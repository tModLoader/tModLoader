using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static tModLoader.SourceGenerators.Constants;

namespace tModLoader.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class NetPacketHandleForAllGenerator : IIncrementalGenerator
{
	private const string Template_Namespace = "{Namespace}";
	private const string Template_DeclarationName = "{DeclarationName}";

	private const string TemplateCodeText = $@"// <auto-generated/>
using System.Runtime.CompilerServices;
using Terraria;
using Terraria.ID;

namespace {Template_Namespace};

partial struct {Template_DeclarationName} {{
	/// <inheritdoc cref=""Terraria.ModLoader.Packets.INetPacket.HandleForAll""/>
	[CompilerGenerated]
	public void HandleForAll() {{
		switch (Main.netMode) {{
			case NetmodeID.MultiplayerClient:
				Send(-1, Main.myPlayer);
				break;
			case NetmodeID.Server:
				Send();
				break;
		}}

		HandlePacket();
	}}
}}
";

	public void Initialize(IncrementalGeneratorInitializationContext ctx)
	{
		var netPackets = ctx.SyntaxProvider.ForAttributeWithMetadataName(NetPacketAttributeFullMetadataName,
			static (n, _) => n is StructDeclarationSyntax,
			static (ctx, _) => {
				var symbol = (INamedTypeSymbol)ctx.TargetSymbol;

				return (
					symbol.ContainingNamespace.ToString(),
					symbol.MetadataName,
					symbol.Name
				);
			});

		ctx.RegisterSourceOutput(netPackets, static (ctx, source) => {
			ctx.AddSource($"{source.Item1}.{source.Item2}.g.cs", MatchBrackets.Replace(TemplateCodeText, match => match.Value switch {
				Template_Namespace => source.Item1,
				Template_DeclarationName => source.Item3,
				_ => match.Value
			}));
		});
	}
}
