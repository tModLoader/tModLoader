using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using tModLoader.SourceGenerators.Helpers;
using static tModLoader.SourceGenerators.Constants;

namespace tModLoader.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed partial class PacketRegistryGenerator : IIncrementalGenerator
{
	internal record struct PacketRegistrySource(
		in ITypeSymbol RegistrySymbol,
		in ImmutableArray<IFieldSymbol> Constants
	);

	private record struct SourceInfo(
		in string Namespace,
		in string DeclarationName,
		in EquatableArray<(string Name, string PacketType)> Constants
	) : IEquatable<SourceInfo>;

	private const string Template_Namespace = "{Namespace}";
	private const string Template_DeclarationName = "{DeclarationName}";
	private const string Template_IdValue = "{IdValue}";
	private const string Template_HandleImplementation = "{HandleImplementation}";

	private const string TemplateCodeText = $@"// <auto-generated/>
using System.IO;
using System.Runtime.CompilerServices;

namespace {Template_Namespace};

partial class {Template_DeclarationName} {{
	[CompilerGenerated]
	public static void Handle(BinaryReader reader, int whoAmI) {{
		byte type = reader.ReadByte();
{Template_HandleImplementation}
	}}
}}
";

	private const string TemplateCodeText2 = $@"// <auto-generated/>
namespace {Template_Namespace};

partial struct {Template_DeclarationName} {{
	public const byte Id = {Template_IdValue};
}}
";

	internal static IncrementalValuesProvider<PacketRegistrySource> CreateRegistrySyntaxProvider(SyntaxValueProvider syntaxValueProvider) => syntaxValueProvider.ForAttributeWithMetadataName(
		PacketRegistryAttributeFullMetadataName,
		static (n, _) => n is ClassDeclarationSyntax,
		static (ctx, _) => {
			var symbol = (ITypeSymbol)ctx.TargetSymbol;

			var constantIds = symbol.GetMembers()
				.Where(x => x is IFieldSymbol)
				.Select(x => (IFieldSymbol)x)
				.Where(x => x.IsConst && x.Type.SpecialType == SpecialType.System_Byte && x.DeclaredAccessibility == Accessibility.Public)
				.Where(x => x.GetAttributes().Any(x => x.AttributeClass.OriginalDefinition.ToDisplayString() == NetPacketIdOfTAttributeFullName))
				.ToImmutableArray();

			return new PacketRegistrySource(symbol, constantIds);
		});

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Commons.AssignDebugger();

		var registrySyntax = CreateRegistrySyntaxProvider(context.SyntaxProvider);
		var registries = registrySyntax.Select((x, _) => {
			var constants = x.Constants
				.Select(x => (
					x.Name,
					((ISymbol)x.GetAttributes().First(x => x.AttributeClass.OriginalDefinition.ToDisplayString() == NetPacketIdOfTAttributeFullName).ConstructorArguments[0].Value).ToDisplayString()
				))
				.ToImmutableArray();

			return new SourceInfo {
				Namespace = x.RegistrySymbol.ContainingNamespace.ToString(),
				DeclarationName = x.RegistrySymbol.Name,
				Constants = new(constants)
			};
		});
		var idsPerPacket = registrySyntax.Select((x, _) => x.Constants.Select(field => (field, x.RegistrySymbol))).SelectMany((x, _) => x).Select((x, _) => {
			var packetIdOfAttribute = x.field.GetAttributes().First(x => x.AttributeClass.OriginalDefinition.ToDisplayString() == NetPacketIdOfTAttributeFullName);

			var packetType = (ITypeSymbol)packetIdOfAttribute.ConstructorArguments[0].Value;

			return (
				packetType.ContainingNamespace.ToString(),
				packetType.MetadataName,
				packetType.Name,
				x.RegistrySymbol.ContainingNamespace.ToString(),
				x.RegistrySymbol.Name,
				x.field.Name
			);
		});

		context.RegisterSourceOutput(registries, (ctx, source) => {
			ctx.AddSource($"{source.Namespace}.{source.DeclarationName}.g.cs", MatchBrackets.Replace(TemplateCodeText, match => match.Value switch {
				Template_Namespace => source.Namespace,
				Template_DeclarationName => source.DeclarationName,
				Template_HandleImplementation => Create_HandleImplementation(),
				_ => match.Value
			}));

			string Create_HandleImplementation()
			{
				var writer = new IndentedStringBuilder();
				writer.Indent += 2;

				writer.WriteLine();
				writer.WriteLine("switch (type) {");
				writer.Indent++;

				foreach (var constant in source.Constants) {
					writer.WriteLine($"case {constant.Name}: {{");
					writer.Indent++;

					writer.WriteLine($"var packet = default({constant.PacketType});");
					writer.WriteLine("packet.Receive(reader, whoAmI);");
					writer.WriteLine("break;");

					writer.Indent--;
					writer.WriteLine('}');
				}

				writer.Indent--;
				writer.Write('}');

				return writer.ToString();
			}
		});

		context.RegisterSourceOutput(idsPerPacket, (ctx, source) => {
			ctx.AddSource($"{source.Item1}.{source.Item2}.g.cs", MatchBrackets.Replace(TemplateCodeText2, match => match.Value switch {
				Template_Namespace => source.Item1,
				Template_DeclarationName => source.Item3,
				Template_IdValue => $"{source.Item4}.{source.Item5}.{source.Item6}",
				_ => match.Value
			}));
		});
	}
}
