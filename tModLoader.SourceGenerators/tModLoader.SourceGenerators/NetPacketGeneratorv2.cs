using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using tModLoader.SourceGenerators.Helpers;
using static tModLoader.SourceGenerators.Constants;

namespace tModLoader.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed partial class NetPacketGeneratorv2 : IIncrementalGenerator
{
	private delegate bool SerializationParameterMatch(IParameterSymbol parameterSymbol);
	private delegate bool SerializationMethodMatch(IMethodSymbol methodSymbol);
	private delegate string WriteSerializationParameterMatch(IParameterSymbol parameterSymbol, int index);
	private record struct SerializationMethods(
		in IMethodSymbol PreSerializationSymbol,
		in IMethodSymbol OnSerializationSymbol,
		in IMethodSymbol PostSerializationSymbol
	)
	{
		private readonly INamedTypeSymbol packetSymbol;

		public SerializationMethods(INamedTypeSymbol packetSymbol) : this(null, null, null)
		{
			this.packetSymbol = packetSymbol;
		}

		private readonly IMethodSymbol FindSerializationMethod(string name, SerializationMethodMatch methodMatch, SerializationParameterMatch parameterMatch)
		{
			var enumerable = packetSymbol.GetMembers(name)
				.Where(x => x is IMethodSymbol)
				.Select(x => (IMethodSymbol)x)
				.Where(x => methodMatch(x));

			if (parameterMatch != null) {
				enumerable = enumerable.Where(x => x.Parameters.All(x => parameterMatch(x)));
			}

			return enumerable.FirstOrDefault();
		}

		public void FindPreSerialization(string name, SerializationMethodMatch methodMatch, SerializationParameterMatch match = null)
			=> PreSerializationSymbol = FindSerializationMethod(name, methodMatch, match);

		public void FindOnSerialization(string name, SerializationMethodMatch methodMatch, SerializationParameterMatch match = null)
			=> OnSerializationSymbol = FindSerializationMethod(name, methodMatch, match);

		public void FindPostSerialization(string name, SerializationMethodMatch methodMatch, SerializationParameterMatch match = null)
			=> PostSerializationSymbol = FindSerializationMethod(name, methodMatch, match);

		public readonly void WriteSerializeMethod(IndentedStringBuilder sb, IMethodSymbol methodSymbol, WriteSerializationParameterMatch parameterNames)
		{
			sb.Write(methodSymbol.Name);
			sb.Write('(');
			sb.Write(String.Join(", ", methodSymbol.Parameters.Select((x, i) => parameterNames(x, i))));
			sb.Write(')');
		}
	}
	private record struct SerializationVector(
		in SerializationMethods Serialization,
		in SerializationMethods Deserialization
	);
	private record struct SerializableProperty(
		in ISymbol PropertySymbol,
		in SerializationVector Serialization
	)
	{
		public readonly ITypeSymbol PropertyType => PropertySymbol is IPropertySymbol
				? ((IPropertySymbol)PropertySymbol).Type
				: ((IFieldSymbol)PropertySymbol).Type;
	}

	private record struct SourceSerialization(
		in bool HasPreSerialization, in bool IsPreSerializationBool,
		in bool HasOnSerialization, in bool HasPostSerialization,
		in bool HasPreDeserialization, in bool IsPreDeserializationBool,
		in bool HasOnDeserialization, in bool HasPostDeserialization
	) : IEquatable<SourceSerialization>;
	private record struct SourceProperty(
		in string PropertyName,
		in string PropertyType,
		in SourceSerialization Serialization
	) : IEquatable<SourceProperty>;
	private record struct SourceInfo(
		in string Namespace,
		in string MetadataName,
		in string DeclarationName,

		in (bool Pre, bool IsPreBool, bool On, bool Post) GlobalSerializations,
		in (bool Pre, bool IsPreBool, bool On, bool Post) GlobalDeserializations,
		in EquatableArray<SourceProperty> SerializableProperties,
		in EquatableArray<(string EncoderType, string EncodedType, bool IsUnsafe)> Encoders
	) : IEquatable<SourceInfo>;

	private const string SerializeMethodName = "Serialize";
	private const string DeserializeMethodName = "Deserialize";

	private const string Template_Namespace = "{Namespace}";
	private const string Template_DeclarationName = "{DeclarationName}";
	private const string Template_SerializationImplementation = "{SerializationImplementation}";
	private const string Template_DeserializationImplementation = "{DeserializationImplementation}";

	private const string TemplateCodeText = $@"// <auto-generated/>
using System.IO;
using System.Runtime.CompilerServices;

namespace {Template_Namespace};

partial struct {Template_DeclarationName} {{
	[CompilerGenerated]
	private void Serialize(global::Terraria.ModLoader.ModPacket writer, int toClient, int ignoreClient) {{
{Template_SerializationImplementation}
	}}

	[CompilerGenerated]
	private void Deserialize(BinaryReader reader, int sender) {{
{Template_DeserializationImplementation}
	}}
}}
";

	public void Initialize(IncrementalGeneratorInitializationContext ctx)
	{
		// Commons.AssignDebugger();

		var netPackets = ctx.SyntaxProvider.ForAttributeWithMetadataName(NetPacketAttributeFullMetadataName,
			static (n, _) => n is StructDeclarationSyntax,
			static (ctx, _) => {
				var symbol = (INamedTypeSymbol)ctx.TargetSymbol;
				var netPacketAttribute = ctx.Attributes[0];

				bool autoSerialization = true;
				if (netPacketAttribute.NamedArguments.Any(x => x.Key == NetPacketAutoSerializePropertyName)) {
					autoSerialization = (bool)netPacketAttribute.NamedArguments.First(x => x.Key == NetPacketAutoSerializePropertyName).Value.Value;
				}

				var globalEncodedAsAttributes = RetriveGlobalEncoders(symbol);

				var globalSerializationVector = RetrieveGlobalSerializationMethods(symbol);
				var serializableProperties = RetrieveSerializableProperties(symbol, autoSerialization);
				var encoders = RetrieveEncoders(serializableProperties, globalEncodedAsAttributes);

				var sourceProperties = serializableProperties.Select(x => new SourceProperty(
					x.PropertySymbol.Name,
					x.PropertyType.ToDisplayString(),
					new SourceSerialization(
						x.Serialization.Serialization.PreSerializationSymbol != null,
						x.Serialization.Serialization.PreSerializationSymbol?.ReturnType?.SpecialType == SpecialType.System_Boolean,
						x.Serialization.Serialization.OnSerializationSymbol != null,
						x.Serialization.Serialization.PostSerializationSymbol != null,

						x.Serialization.Deserialization.PreSerializationSymbol != null,
						x.Serialization.Deserialization.PreSerializationSymbol?.ReturnType?.SpecialType == SpecialType.System_Boolean,
						x.Serialization.Deserialization.OnSerializationSymbol != null,
						x.Serialization.Deserialization.PostSerializationSymbol != null
					)
				)).ToImmutableArray();
				var sourceEncoders = encoders.Select(x => (x.EncoderName, x.TypeFromEncodedAs, x.IsUnsafe)).ToImmutableArray();

				return new SourceInfo(
					Namespace: symbol.ContainingNamespace.ToString(),
					MetadataName: symbol.MetadataName,
					DeclarationName: symbol.Name,

					GlobalSerializations: (
						Pre: globalSerializationVector.Serialization.PreSerializationSymbol != null,
						IsPreBool: globalSerializationVector.Serialization.PreSerializationSymbol?.ReturnType?.SpecialType == SpecialType.System_Boolean,
						On: globalSerializationVector.Serialization.OnSerializationSymbol != null,
						Post: globalSerializationVector.Serialization.PostSerializationSymbol != null),
					GlobalDeserializations: (
						Pre: globalSerializationVector.Deserialization.PreSerializationSymbol != null,
						IsPreBool: globalSerializationVector.Deserialization.PreSerializationSymbol?.ReturnType?.SpecialType == SpecialType.System_Boolean,
						On: globalSerializationVector.Deserialization.OnSerializationSymbol != null,
						Post: globalSerializationVector.Deserialization.PostSerializationSymbol != null),

					SerializableProperties: new EquatableArray<SourceProperty>(sourceProperties),
					Encoders: new EquatableArray<(string EncoderType, string EncodedType, bool IsUnsafe)>(sourceEncoders)
				);
			});

		ctx.RegisterSourceOutput(netPackets, static (ctx, source) => {
			ctx.AddSource($"{source.Namespace}.{source.MetadataName}.g.cs", MatchBrackets.Replace(TemplateCodeText, match => match.Value switch {
				Template_Namespace => source.Namespace,
				Template_DeclarationName => source.DeclarationName,

				Template_SerializationImplementation => Create_SerializationImplementation(),
				Template_DeserializationImplementation => Create_DeserializationImplementation(),

				_ => match.Value
			}));

			string Create_SerializationImplementation()
			{
				const string ParameterName = "writer";

				var sb = new IndentedStringBuilder();
				sb.Indent += 2;

				if (source.SerializableProperties.IsEmpty)
					return string.Empty;

				sb.WriteLine();

				if (source.GlobalSerializations.Pre) {
					if (source.GlobalSerializations.IsPreBool) {
						sb.Write($"if (PreSerialize({ParameterName}, toClient, ignoreClient)) {{");
						sb.WriteLine();
						sb.Indent++;
					}
					else {
						sb.WriteLine($"PreSerialize({ParameterName}, toClient, ignoreClient);");
					}
				}

				if (source.GlobalSerializations.On) {
					sb.WriteLine($"OnSerialize({ParameterName}, toClient, ignoreClient);");
				}

				int i = 0;
				foreach (var property in source.SerializableProperties.AsSpan()) {
					var encoder = source.Encoders[i++];

					if (property.Serialization.HasPreSerialization) {
						if (property.Serialization.IsPreSerializationBool) {
							sb.Write($"if (PreSerialize_{property.PropertyName}({ParameterName}, toClient, ignoreClient)) {{");
							sb.WriteLine();
							sb.Indent++;
						}
						else {
							sb.WriteLine($"PreSerialize_{property.PropertyName}({ParameterName}, toClient, ignoreClient);");
						}
					}

					if (property.Serialization.HasOnSerialization) {
						sb.WriteLine($"OnSerialize_{property.PropertyName}({ParameterName}, toClient, ignoreClient);");
					}

					if (encoder.IsUnsafe) {
						sb.WriteLine("unsafe {");
						sb.Indent++;
					}

					sb.WriteLine($"var encoder_{property.PropertyName} = default({encoder.EncoderType});");
					sb.Write($"encoder_{property.PropertyName}.Write({ParameterName}, ");
					if (encoder.EncodedType != null && encoder.EncodedType != property.PropertyType) {
						sb.Write($"({encoder.EncodedType})");
					}

					sb.Write(property.PropertyName);
					sb.WriteLine(");");

					if (property.Serialization.IsPreSerializationBool) {
						sb.Indent--;
						sb.WriteLine('}');
					}

					if (property.Serialization.HasPostSerialization) {
						sb.WriteLine($"PostSerialize_{property.PropertyName}({ParameterName}, toClient, ignoreClient);");
					}
				}

				if (source.GlobalSerializations.IsPreBool) {
					sb.Indent--;
					sb.WriteLine('}');
				}

				if (source.GlobalSerializations.Post) {
					sb.WriteLine($"PostSerialize({ParameterName}, toClient, ignoreClient);");
				}

				return sb.ToString();
			}

			string Create_DeserializationImplementation()
			{
				const string ParameterName = "reader";

				var sb = new IndentedStringBuilder();
				sb.Indent += 2;

				if (source.SerializableProperties.IsEmpty)
					return string.Empty;

				sb.WriteLine();

				if (source.GlobalSerializations.Pre) {
					if (source.GlobalSerializations.IsPreBool) {
						sb.Write($"if (PreDeserialize({ParameterName}, sender)) {{");
						sb.WriteLine();
						sb.Indent++;
					}
					else {
						sb.WriteLine($"PreDeserialize({ParameterName}, sender);");
					}
				}

				if (source.GlobalSerializations.On) {
					sb.WriteLine($"OnDeserialize({ParameterName}, sender);");
				}

				int i = 0;
				foreach (var property in source.SerializableProperties.AsSpan()) {
					var encoder = source.Encoders[i++];

					if (property.Serialization.HasPreSerialization) {
						if (property.Serialization.IsPreSerializationBool) {
							sb.Write($"if (PreDeserialize_{property.PropertyName}({ParameterName}, sender)) {{");
							sb.WriteLine();
							sb.Indent++;
						}
						else {
							sb.WriteLine($"PreDeserialize_{property.PropertyName}({ParameterName}, sender);");
						}
					}

					if (property.Serialization.HasOnSerialization) {
						sb.WriteLine($"OnDeserialize_{property.PropertyName}({ParameterName}, sender);");
					}

					if (encoder.IsUnsafe) {
						sb.WriteLine("unsafe {");
						sb.Indent++;
					}

					sb.WriteLine($"var encoder_{property.PropertyName} = default({encoder.EncoderType});");
					sb.Write($"{property.PropertyName} = ");
					if (encoder.EncodedType != null && encoder.EncodedType != property.PropertyType) {
						sb.Write($"({property.PropertyType})");
					}

					sb.WriteLine($"encoder_{property.PropertyName}.Read({ParameterName});");

					if (property.Serialization.IsPreSerializationBool) {
						sb.Indent--;
						sb.WriteLine('}');
					}

					if (property.Serialization.HasPostSerialization) {
						sb.WriteLine($"PostDeserialize_{property.PropertyName}({ParameterName}, sender);");
					}
				}

				if (source.GlobalSerializations.IsPreBool) {
					sb.Indent--;
					sb.WriteLine('}');
				}

				if (source.GlobalSerializations.Post) {
					sb.WriteLine($"PostDeserialize({ParameterName}, sender);");
				}

				return sb.ToString();
			}
		});
	}

	private static bool MatchSerializationMethod(IMethodSymbol methodSymbol)
	{
		return !methodSymbol.IsGenericMethod && methodSymbol.Parameters.Length == 3
			&& methodSymbol.Parameters[0].Type.ToDisplayString() is BinaryWriterClassFullName
			&& methodSymbol.Parameters[1].Type.SpecialType == SpecialType.System_Int32
			&& methodSymbol.Parameters[2].Type.SpecialType == SpecialType.System_Int32;
	}

	private static bool MatchDeserializationMethod(IMethodSymbol methodSymbol)
	{
		return !methodSymbol.IsGenericMethod && methodSymbol.Parameters.Length == 2
			&& methodSymbol.Parameters[0].Type.ToDisplayString() is BinaryReaderClassFullName
			&& methodSymbol.Parameters[1].Type.SpecialType == SpecialType.System_Int32;
	}

	private static SerializationVector RetrieveGlobalSerializationMethods(INamedTypeSymbol symbol)
	{
		var serializationMethods = new SerializationMethods(symbol);
		serializationMethods.FindPreSerialization($"Pre{SerializeMethodName}", MatchSerializationMethod);
		serializationMethods.FindOnSerialization($"On{SerializeMethodName}", MatchSerializationMethod);
		serializationMethods.FindPostSerialization($"Post{SerializeMethodName}", MatchSerializationMethod);

		var deserializationMethods = new SerializationMethods(symbol);
		deserializationMethods.FindPreSerialization($"Pre{DeserializeMethodName}", MatchDeserializationMethod);
		deserializationMethods.FindOnSerialization($"On{DeserializeMethodName}", MatchDeserializationMethod);
		deserializationMethods.FindPostSerialization($"Post{DeserializeMethodName}", MatchDeserializationMethod);

		return new SerializationVector(in serializationMethods, in serializationMethods);
	}

	private static ImmutableArray<SerializableProperty> RetrieveSerializableProperties(INamedTypeSymbol symbol, bool autoSerialization) => symbol.GetMembers()
		.Where(x => {
			bool isValidType =
				x is IFieldSymbol fieldSymbol && !fieldSymbol.IsReadOnly && !fieldSymbol.IsConst && !fieldSymbol.IsImplicitlyDeclared
				|| x is IPropertySymbol propertySymbol && (propertySymbol.ReturnsByRef || !propertySymbol.IsWriteOnly && !propertySymbol.IsReadOnly);

			if (!isValidType)
				return false;

			if (autoSerialization) {
				return !x.GetAttributes().Any(x => x.AttributeClass.ToDisplayString() == IgnoreAttributeFullName);
			}
			else {
				return x.GetAttributes().Any(x => x.AttributeClass.ToDisplayString() == SerializeAttributeFullName);
			}
		})
		.Select(x => {
			var serialization = new SerializationMethods(symbol);
			serialization.FindPreSerialization($"Pre{SerializeMethodName}_{x.Name}", MatchSerializationMethod);
			serialization.FindOnSerialization($"On{SerializeMethodName}_{x.Name}", MatchSerializationMethod);
			serialization.FindPostSerialization($"Post{SerializeMethodName}_{x.Name}", MatchSerializationMethod);

			var deserialization = new SerializationMethods(symbol);
			deserialization.FindPreSerialization($"Pre{DeserializeMethodName}_{x.Name}", MatchDeserializationMethod);
			deserialization.FindOnSerialization($"On{DeserializeMethodName}_{x.Name}", MatchDeserializationMethod);
			deserialization.FindPostSerialization($"Post{DeserializeMethodName}_{x.Name}", MatchDeserializationMethod);

			return new SerializableProperty(x, new(serialization, deserialization));
		}).ToImmutableArray();
}
