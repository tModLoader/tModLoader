using System.Linq;
using Microsoft.CodeAnalysis;
using static tModLoader.SourceGenerators.Constants;

namespace tModLoader.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public sealed class NetPacketMainMethodsGenerator : IIncrementalGenerator
{
	private const string Template_Namespace = "{Namespace}";
	private const string Template_DeclarationName = "{DeclarationName}";
	private const string Template_ModName = "{ModName}";
	private const string Template_OptionalSetDefaults = "{OptionalSetDefaults}";

	private const string TemplateCodeText = $@"// <auto-generated/>
using System.IO;
using System.Runtime.CompilerServices;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace {Template_Namespace};

{Template_DeclarationName} {{
#region Internal methods
	private ModPacket _Internal_WriteSerializedData(int toClient, int ignoreClient) {{
		var packet = ModContent.GetInstance<{Template_ModName}>().GetPacket();
		_Internal_TryWriteId(packet);

		Serialize(packet, toClient, ignoreClient);

		return packet;
	}}

	private void _Internal_ReadSerializedData(BinaryReader reader, int sender) {{
		Deserialize(reader, sender);
	}}

	private void _Internal_Handle(int sender) {{
		HandlePacket(sender);
	}}
#endregion

#region INetPacket implementation
	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.Send(int, int)""/>
	[CompilerGenerated]
	public void Send(int toClient = -1, int ignoreClient = -1) {{
		var packet = _Internal_WriteSerializedData(toClient, ignoreClient);

		packet.Send(toClient, ignoreClient);
	}}

	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.Receive(BinaryReader, int)""/>
	[CompilerGenerated]
	public void Receive(BinaryReader reader, int sender) {{
		{Template_OptionalSetDefaults}

		_Internal_ReadSerializedData(reader, sender);

		_Internal_Handle(sender);
	}}
#endregion

#region Send methods
	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.SendToPlayer(int)""/>
	[CompilerGenerated]
	public void SendToPlayer(int player) => Send(toClient: player);

	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.SendToPlayers(int[])""/>
	[CompilerGenerated]
	public void SendToPlayers(params int[] players) {{
		var packet = _Internal_WriteSerializedData(-1, -1);

		foreach (var player in players) {{
			packet.Send(toClient: player);
		}}
	}}

	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.SendToAllPlayers(int)""/>
	[CompilerGenerated]
	public void SendToAllPlayers(int ignoreClient = -1) {{
		if (Main.netMode == NetmodeID.Server) {{
			Send(ignoreClient: ignoreClient);
		}}
	}}

	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.SendToServer()""/>
	[CompilerGenerated]
	public void SendToServer() {{
		if (Main.netMode == NetmodeID.MultiplayerClient) {{
			Send(ignoreClient: Main.myPlayer);
		}}
	}}

	/// <inheritdoc cref=""global::Terraria.ModLoader.Packets.INetPacket.SendToAll()""/>
	[CompilerGenerated]
	public void SendToAll() {{
		if (Main.netMode == NetmodeID.MultiplayerClient) {{
			Send(ignoreClient: Main.myPlayer);
		}}
		else if (Main.netMode == NetmodeID.Server) {{
			Send(ignoreClient: -1);
		}}

		_Internal_Handle(-1);
	}}
#endregion
}}
";

	public void Initialize(IncrementalGeneratorInitializationContext ctx)
	{
		var netPackets = ctx.SyntaxProvider.ForAttributeWithMetadataName(NetPacketAttributeFullMetadataName,
			NetPacketGeneratorv2.MatchStructAndRecordStruct,
			static (ctx, _) => {
				var symbol = (INamedTypeSymbol)ctx.TargetSymbol;
				var netPacketAttribute = ctx.Attributes[0];

				var modType = (ITypeSymbol)netPacketAttribute.ConstructorArguments[0].Value;

				string declarationName = NetPacketGeneratorv2.GenerateDeclarationName(symbol);

				return (
					Namespace: symbol.ContainingNamespace.ToString(),
					symbol.MetadataName,
					Name: symbol.IsRefLikeType ? declarationName : $"{declarationName} : global::Terraria.ModLoader.Packets.INetPacket",
					ModName: modType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
					ImplementsSetDefaults: symbol.GetMembers(NetPacketSetDefaultsMethodName).Any(x => x is IMethodSymbol methodSymbol && !methodSymbol.IsGenericMethod && !methodSymbol.Parameters.Any())
				);
			});

		ctx.RegisterSourceOutput(netPackets, static (ctx, source) => {
			ctx.AddSource($"{source.Namespace}.{source.MetadataName}.g.cs", MatchBrackets.Replace(TemplateCodeText, match => match.Value switch {
				Template_Namespace => source.Namespace,
				Template_DeclarationName => source.Name,

				Template_ModName => source.ModName,
				Template_OptionalSetDefaults => Create_OptionalSetDefaults(),
				_ => match.Value
			}));

			string Create_OptionalSetDefaults()
			{
				if (source.ImplementsSetDefaults)
					return $"{NetPacketSetDefaultsMethodName}();";
				else {
					return $"// {NetPacketSetDefaultsMethodName}();";
				}
			}
		});
	}
}
