--- src/TerrariaNetCore/Terraria/Item.cs
+++ src/tModLoader/Terraria/Item.cs
@@ -1,6 +_,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using Microsoft.Xna.Framework;
 using Terraria.Audio;
 using Terraria.DataStructures;
@@ -13,12 +_,14 @@
 using Terraria.GameContent.UI;
 using Terraria.Graphics.Shaders;
 using Terraria.ID;
+using Terraria.ModLoader;
+using Terraria.ModLoader.IO;
 using Terraria.UI;
 using Terraria.Utilities;
 
 namespace Terraria;
 
-public class Item : Entity
+public partial class Item : Entity
 {
 	private string _nameOverride;
 	public const int luckPotionDuration1 = 18000;
@@ -37,78 +_,455 @@
 	private readonly int eclipsePrice = sellPrice(0, 7, 50);
 	private readonly int eclipsePostPlanteraPrice = sellPrice(0, 10);
 	private readonly int eclipseMothronPrice = sellPrice(0, 12, 50);
+
+	/// <summary>
+	/// The default stack size for stackable items: 9999
+	/// </summary>
 	public static int CommonMaxStack = 9999;
+
+	/// <summary>
+	/// The number of cached item spawns by type.<br/>
+	/// A value of -1 means that an item type is not being cached.<br/>
+	/// See <see cref="StartCachingType"/> and <see cref= "DropCache" /> for more info.<br/>
+	/// Indexed by <see cref="type"/>.Defaults to -1.<br/>
+	/// </summary>
 	public static int[] cachedItemSpawnsByType = ItemID.Sets.Factory.CreateIntSet(-1);
+
+	/// <summary>
+	/// The default cooldown, in ticks, of most healing items.<br/>
+	/// This value is never changed. For creating a Philosopher's Stone-like item, see <see cref="Player.pStone"/> or <see cref="Player.potionDelayTime"/>.<br/>
+	/// </summary>
 	public static int potionDelay = 3600;
+
+	/// <summary>
+	/// The default cooldown, in ticks, of Restoration Potions.<br/>
+	/// This value is never changed. For creating a Philosopher's Stone-like item, see <see cref="Player.pStone"/> or <see cref="Player.restorationDelayTime"/>.<br/>
+	/// </summary>
 	public static int restorationDelay = 2700;
+
+	/// <summary>
+	/// The default cooldown, in ticks, of Mushrooms.<br/>
+	/// This value is never changed. For creating a Philosopher's Stone-like item, see <see cref="Player.pStone"/> or <see cref="Player.mushroomDelayTime"/>.<br/>
+	/// </summary>
 	public static int mushroomDelay = 1800;
+
+	/// <summary>
+	/// If true, categorizes the given item as a quest fish.<br/>
+	/// Quest fish get a special tooltip, their own category in the Research Menu, and cannot be auto-moved to the Void Vault when picked up.<br/>
+	/// If you'd like to make a quest fish, see <see cref="DefaultToQuestFish"/>.<br/>
+	/// If you'd just like to emulate the one-per-inventory behavior of quest fish, see <see cref="uniqueStack"/>.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool questItem;
+
+	/// <summary>
+	/// An array for converting an <see cref="headSlot"/> value into a <see cref="type"/> value.<br/>
+	/// Indexed by <see cref="headSlot"/>. Defaults to 0.<br/>
+	/// </summary>
 	public static int[] headType = new int[ArmorIDs.Head.Count];
+
+	/// <summary>
+	/// An array for converting an <see cref="bodySlot"/> value into a <see cref="type"/> value.<br/>
+	/// Indexed by <see cref="bodySlot"/>. Defaults to 0.<br/>
+	/// </summary>
 	public static int[] bodyType = new int[ArmorIDs.Body.Count];
+
+	/// <summary>
+	/// An array for converting an <see cref="legSlot"/> value into a <see cref="type"/> value.<br/>
+	/// Indexed by <see cref="legSlot"/>. Defaults to 0.<br/>
+	/// </summary>
 	public static int[] legType = new int[ArmorIDs.Legs.Count];
+
+	/// <summary>
+	/// If true, categorizes the given item type as a staff.<br/>
+	/// Staffs are held differently when their <see cref="useStyle"/> is <see cref="ItemUseStyleID.Shoot"/>, but are otherwise no different than any other item.<br/>
+	/// Indexed by <see cref="type"/>. Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public static bool[] staff = new bool[ItemID.Count];
+
+	/// <summary>
+	/// If true, categorizes the given item type as a claw.<br/>
+	/// Claws are held differently when their <see cref="useStyle"/> is <see cref="ItemUseStyleID.Swing"/>, but are otherwise no different than any other item.<br/>
+	/// Used exclusively by the Bladed Glove in vanilla.<br/>
+	/// Indexed by <see cref="type"/>. Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public static bool[] claw = new bool[ItemID.Count];
+
+	/// <summary>
+	/// If true, will cause the corresponding flame texture to be drawn while this item is held. Used for torches, candles, .
+	/// <br/> Modded items should make a texture file postfixed by "_Flame" to autoload the flame texture. For example, ExampleTorch in ExampleMod has both ExampleTorch.png and ExampleTorch_Flame.png.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool flame;
+
+	/// <summary>
+	/// If true, then the given item will show all placed wires and actuators when held.<br/>
+	/// This item will also be grouped with other items with <c>mech</c> set to <see langword="true"/> when the inventory is sorted.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool mech;
+
+	/// <summary>
+	/// The delay, in ticks, before players can pick up this item.<br/>
+	/// Usually set to 100 (approximately 1.666... seconds) whenever an item is dropped.<br/>
+	/// Set to 0 whenever an item drops from a projectile.<br/>
+	/// </summary>
 	public int noGrabDelay;
+
+	/// <summary>
+	/// If true, then this item is currently being grabbed by a player.<br/>
+	/// Items being grabbed by the player cannot combine with nearby items, be picked up by enemies, burn in lava, or despawn.<br/>
+	/// </summary>
 	public bool beingGrabbed;
+
+	/// <summary>
+	/// A value that increases every tick an item is in the world.<br/>
+	/// Defaults to the value in <see cref="ItemID.Sets.OverflowProtectionTimeOffset"/> when an item is created, and increases by <see cref="ItemID.Sets.ItemSpawnDecaySpeed"/> every tick.<br/>
+	/// When creating new items, items with a high <c>timeSinceItemSpawned</c> value will be replaced if no empty item slots are available.<br/>
+	/// </summary>
 	public int timeSinceItemSpawned;
+
+	/// <summary>
+	/// The numerical ID of the item this item consumes when used.<br/>
+	/// If greater than 0, this item cannot be used unless the player has the item type <c>tileWand</c> is set to. The item also gains a counter for said item type.<br/>
+	/// Defaults to -1.<br/>
+	/// </summary>
 	public int tileWand = -1;
+
+	/// <summary>
+	/// If true, then this item is in the local player's armor slots.<br/>
+	/// This causes the item to gain the set bonus tooltip if <see cref="Player.setBonus"/> isn't an empty string.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool wornArmor;
+
+	/// <summary>
+	/// The context in which this item's tooltip is being drawn.<br/>
+	/// See <see cref="ItemSlot.Context"/> for more details.<br/>
+	/// Defaults to -1.<br/>
+	/// </summary>
 	public int tooltipContext = -1;
-	public byte dye;
+
+	/// <summary>
+	/// The numerical ID of the armor shader in <see cref="GameShaders.Armor"/> this item activates when worn in a dye slot.<br/>
+	/// If greater than 0, then this item can be equipped into dye slots.<br/>
+	/// Defaults to 0.<br/>
+	/// </summary>
+	public int dye; //TML: Changed from byte to int.
+
+	/// <summary>
+	/// The numerical value this item adds to a player's fishing skill when held.<br/>
+	/// If greater than 0, categorizes this item as a fishing pole.<br/>
+	/// Fishing poles can be placed into weapon racks, have a counter for the bait the player is carrying, and are held out when a bobber is active.<br/>
+	/// Defaults to 0.<br/>
+	/// </summary>
 	public int fishingPole = 1;
+
+	/// <summary>
+	/// The numerical value this item adds to a player's fishing skill when used as bait.<br/>
+	/// If greater than 0, categorizes this item as bait.<br/>
+	/// Bait can be put into ammo slots and is consumed when fishing.<br/>
+	/// The higher the value of <c>bait</c>, the lower the chance the bait is consumed.<br/>
+	/// Defaults to 0.<br/>
+	/// </summary>
 	public int bait;
+
+	/// <summary>
+	/// The additional distance, in pixels, that coins may be grabbed from if the player has the Gold Ring or its upgrades (<see cref="Player.goldRing"/>).<br/>
+	/// Applies to <see cref="ItemID.CopperCoin"/>, <see cref="ItemID.SilverCoin"/>, <see cref="ItemID.GoldCoin"/>, and <see cref="ItemID.PlatinumCoin"/>.<br/>
+	/// </summary>
 	public static int coinGrabRange = 350;
+
+	/// <summary>
+	/// The additional distance, in pixels, that mana stars may be grabbed from if the player has the Celestial Magnet or its upgrades (<see cref="Player.manaMagnet"/>).<br/>
+	/// Applies to <see cref="ItemID.Star"/>, <see cref="ItemID.SoulCake"/>, and <see cref="ItemID.SugarPlum"/>.<br/>
+	/// </summary>
 	public static int manaGrabRange = 300;
+
+	/// <summary>
+	/// The additional distance, in pixels, that mana stars may be grabbed from if the player has consumed a Heartreach Potion (<see cref="Player.lifeMagnet"/>).<br/>
+	/// Applies to <see cref="ItemID.Heart"/>, <see cref="ItemID.CandyApple"/>, and <see cref="ItemID.CandyCane"/>.<br/>
+	/// </summary>
 	public static int lifeGrabRange = 250;
+
+	/// <summary>
+	/// The additional distance, in pixels, that items may be grabbed from if the player has equipped a Treasure Magnet (<see cref="Player.treasureMagnet"/>).<br/>
+	/// </summary>
 	public static int treasureGrabRange = 150;
-	public short makeNPC;
+
+	/// <summary>
+	/// The numerical ID of the NPC that this item creates when used.<br/>
+	/// Mainly used for caught critters as items so that they can be released into the world.
+	/// </summary>
+	public int makeNPC; //TML: changed to int for convenience and consistency purposes.
+
+	/// <summary>
+	/// If true, then the given item's effects only function in Expert Mode or higher (<see cref="Main.expertMode"/>).<br/>
+	/// Specifically, any equipped, Expert-only accessory will not update, any Expert-only minecart will not be used when riding minecart tracks, and an 'X' will be drawn over the item when equipped.<br/>
+	/// Unused in vanilla.<br/>
+	/// </summary>
 	public bool expertOnly;
+
+	/// <summary>
+	/// If true, then the given item is automatically given the Expert rarity, causing its name to be drawn in rainbow text.<br/>
+	/// It also adds the "Expert" tooltip. To use the Expert rarity without adding this tooltip, see <see cref="ItemRarityID.Expert"/>.<br/>
+	/// </summary>
 	public bool expert;
+
+	/// <summary>
+	/// If true, then the given item's effects only function in Master Mode or higher (<see cref="Main.masterMode"/>).<br/>
+	/// Specifically, any equipped, Master-only accessory will not update, any Master-only minecart will not be used when riding minecart tracks, and an 'X' will be drawn over the item when equipped.<br/>
+	/// Unused in vanilla.<br/>
+	/// </summary>
+	public bool masterOnly;
+
+	/// <summary>
+	/// If true, then the given item is automatically given the Master rarity, causing its name to be drawn in red-orange text.<br/>
+	/// It also adds the "Master" tooltip. To use the Master rarity without adding this tooltip, see <see cref="ItemRarityID.Master"/>.<br/>
+	/// </summary>
+	public bool master;
+
+	/// <summary>
+	/// If true, then the given item is being sold in a shop.<br/>
+	/// Shop items display their price. See <see cref="value"/>.<br/>
+	/// </summary>
 	public bool isAShopItem;
-	public short hairDye = -1;
+	/// <summary>
+	/// The numerical ID of the hair shader in <see cref="GameShaders.Hair"/> this item will apply to the player when used.<br/>
+	/// If greater than -1, then this item is a hair dye.<br/>
+	/// Defaults to -1.<br/>
+	/// </summary>
+	public int hairDye = -1; //TML: Changed from short to int.
+
+	/// <summary>
+	/// The numerical ID of the paint applied by this item when used with a paint brush or paint roller.<br/>
+	/// For conversion into a shader index, see <see cref="Main.ConvertPaintIdToTileShaderIndex"/>.<br/>
+	/// For more details regarding paint, see <see cref="Tile.TileColor"/> and <see cref="Tile.WallColor"/>.<br/>
+	/// Defaults to 0.<br/>
+	/// </summary>
 	public byte paint;
 	public byte paintCoating;
+
+	/// <summary>
+	/// If true, then the given item is instanced per-client.<br/>
+	/// Instanced items only appear on the client they were spawned on and are less likely to be replaced if a new item is spawned.<br/>
+	/// Instanced items do not exist on servers.<br/>
+	/// Vanilla uses this field for treasure bags and Defender Medals. tModLoader automatically handles this for modded treasure bags.<br/>
+	/// If you would like to make an instanced item, see any one of the following for examples:<br/>
+	/// - <see cref="NPC.DropItemInstanced"/><br/>
+	/// - <see cref="GameContent.ItemDropRules.CommonCode.DropItemLocalPerClientAndSetNPCMoneyTo0"/><br/>
+	/// - <see cref="MessageID.InstancedItem"/><br/>
+	/// Defaults to false.<br/>
+	/// </summary>
 	public bool instanced;
 	public int ownIgnore = -1;
 	public int ownTime;
 	public int keepTime;
 	public int timeLeftInWhichTheItemCannotBeTakenByEnemies;
+
+	/// <summary>
+	/// The Item ID of this item. The Item ID is a unique number assigned to each Item loaded into the game. This will be equal to either an <see cref="ItemID"/> entry or <see cref="ModContent.ItemType{T}"/>, for example <see cref="ItemID.IronskinPotion"/> or ModContent.ItemType&lt;MyModItem&gt;(). To check if an Item instance is a specific Item, check <c>Item.type == ItemID.VanillaItemHere</c> or <c>Item.type == ModContent.ItemType&lt;ModdedItemHere&gt;()</c> in an <see langword="if"/> statement. 
+	/// </summary>
 	public int type;
+
+	/// <summary>
+	/// If true, then the given item is favorited.<br/>
+	/// Favorited items cannot be dropped, automatically moved into chests, placed in any kind of item rack, sold, trashed, or sorted.<br/>
+	/// Favorited items can still be dropped if the player has no inventory space and will still drop on death on Mediumcore or higher difficulties.<br/>
+	/// An item becomes unfavorited if removed from the player's inventory, including if the item is move to any equipment slot.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool favorited;
+
+	/// <summary>
+	/// Assign to an <see cref="ItemHoldStyleID"/> value to give this item a specific animation while the player is not using the item, but the item is currently selected. Leave as 0 and use <see cref="ModLoader.ModItem.HoldStyle(Player, Rectangle)"/> hook to implement a custom animation.
+	/// <br/> Defaults to <see cref="ItemHoldStyleID.None"/>.
+	/// </summary>
 	public int holdStyle;
+
+	/// <summary>
+	/// Assign to an <see cref="ItemUseStyleID"/> value to give this item a specific animation while in use. Leave as 0 and use <see cref="ModLoader.ModItem.UseStyle"/> hook to implement a custom animation.
+	/// <br/> Defaults to <see cref="ItemUseStyleID.None"/>.
+	/// </summary>
 	public int useStyle;
+
+	/// <summary>
+	/// Used for items that have special behavior when the attack button is held.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool channel;
+
+	/// <summary>
+	/// Whether the item is an accessory.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool accessory;
+
+	/// <summary>
+	/// The time span of the using animation for the item in ticks. This is independent of the time it takes for the item to actually be used and potentially autoReused again. For weapons it is recommended to be the same as <see cref="useTime"/> as this is only the animation.
+	/// <br/> Blocks use 15. Default value is 100. Terraria runs at 60 frames per second, so 15 is 1/4th of a second.
+	/// </summary>
 	public int useAnimation;
+
+	/// <summary>
+	/// The time span of using the item in ticks. This is independent of the time it takes for the item animation to finish. 
+	/// <br/> Blocks use 10. Default value is 100.
+	/// <br/> Weapons usually have equal <see cref="useAnimation"/> and useTime, unequal values for these two results in multiple attacks per click. See <see href="https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/Weapons/ExampleGun.cs#L105">ExampleGun.cs's Clockwork Assault Rifle example</see> for an example of that.
+	/// </summary>
 	public int useTime;
+
+	/// <summary>
+	/// The current stack of the item. <see cref="maxStack"/> indicates the max possible stack.
+	/// </summary>
 	public int stack;
+
+	/// <summary>
+	/// The maximum number of items that can be contained within a single stack. <see cref="stack"/> indicates the current stack size.
+	/// <br/> Defaults to 1.
+	/// </summary>
 	public int maxStack;
+
+	/// <summary>
+	/// The Pickaxe power of this item. For example, <c>Item.pick = 50;</c> will appear as 50% Pickaxe Power in the tooltip.
+	/// <br/> The <see href="https://terraria.wiki.gg/wiki/Pickaxes">Pickaxes wiki page</see> is a good resource for finding a suitable value.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int pick;
+
+	/// <summary>
+	/// The Axe power of this item. The Axe power percentage shown to the user is five times this value, so adjust accordingly. For example, <c>Item.axe = 9;</c> will appear as 45% Axe Power in the tooltip.
+	/// <br/> The <see href="https://terraria.wiki.gg/wiki/Axes">Axes wiki page</see> is a good resource for finding a suitable value.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int axe;
+
+	/// <summary>
+	/// The Hammer power of this item. For example, <c>Item.hammer = 70;</c> will appear as 70% Hammer Power in the tooltip.
+	/// <br/> The <see href="https://terraria.wiki.gg/wiki/Hammers">Hammers wiki page</see> is a good resource for finding a suitable value.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int hammer;
+
+	/// <summary>
+	/// Additional tile range provided by this tool or tile. Copper Pickaxe has a value of -1, reducing the range. Chain uses 3 to allow the tile to be placed from farther away than normal tiles.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int tileBoost;
+
+	/// <summary>
+	/// The ID of the tile this item places on use. Either a <see cref="TileID"/> entry or <see cref="ModContent.TileType{T}"/>, for example <see cref="TileID.WorkBenches"/> or ModContent.ItemType&lt;ExampleWorkbench&gt;()
+	/// <br/> Defaults to -1.
+	/// </summary>
 	public int createTile = -1;
+
+	/// <summary>
+	/// The ID of the wall this item places on use. Either a <see cref="WallID"/> entry or <see cref="ModContent.WallType{T}"/>, for example <see cref="WallID.TopazGemspark"/> or ModContent.ItemType&lt;ExampleWall&gt;()
+	/// <br/> Defaults to -1.
+	/// </summary>
 	public int createWall = -1;
+
+	/// <summary>
+	/// The style of the tile being placed. Used for tiles that have a different look depending on the item used to place them.
+	/// <br/> The <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Tile#multiple-styles">Basic Tile guide</see> explains more about this concept.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int placeStyle;
+
+	/// <summary>
+	/// The base damage inflicted by this item. The <see href="https://terraria.wiki.gg/wiki/List_of_weapons">List of weapons wiki page</see> can be a useful guide for deciding on a value.
+	/// <br/> Use <see cref="ModItem.ModifyWeaponDamage(Player, ref StatModifier)"/> for dynamic damage values.
+	/// <br/> Defaults to -1.
+	/// </summary>
 	public int damage;
+
+	/// <summary>
+	/// The force of the knock back. Max value is 20. The <see href="https://terraria.wiki.gg/wiki/Knockback">Knockback wiki page</see> has info on existing values. The <see href="https://terraria.wiki.gg/wiki/List_of_weapons">List of weapons wiki page</see> can also be a useful guide for deciding on a value.
+	/// <br/> Use <see cref="ModItem.ModifyWeaponKnockback(Player, ref StatModifier)"/> for dynamic knockback values.
+	/// <br/> Defaults to 0f.
+	/// </summary>
 	public float knockBack;
+
+	/// <summary>
+	/// The amount of health this item restores on use.
+	/// <br/> Use <see cref="ModItem.GetHealLife(Player, bool, ref int)"/> for dynamic health restoring values.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int healLife;
+
+	/// <summary>
+	/// The amount of mana this item restores on use.
+	/// <br/> Use <see cref="ModItem.GetHealMana(Player, bool, ref int)"/> for dynamic mana restoring values.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int healMana;
+
+	/// <summary>
+	/// If true, this item will inflict potion sickness on use. Also determines whether the item cannot be used when the player has potion sickness, and if the item can be used with the Quick Heal key.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool potion;
+
+	/// <summary>
+	/// Whether the item is consumed after use. If consumed, the item stack will decrease by 1. Modders can use the <see cref="ModItem.ConsumeItem(Player)"/> hook to dynamically decide if the item should be consumed. Modders can use <see cref="ModItem.OnConsumeItem(Player)"/> to act on an item being consumed.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool consumable;
+
+	/// <summary>
+	/// Whether the item is in continuous use while the mouse button is held down.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool autoReuse;
+
+	/// <summary>
+	/// Whether the player can turn around while the using animation of this item is happening.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool useTurn;
+
+	/// <summary>
+	/// Draws the item sprite with a colored tint. Gel and Sharkfin use this to spawn different colored items from the same ItemID. <c>NetMessage.SendData(88, ...)</c> needs to be used to sync this if not done in SetDefaults.
+	/// <br/> Defaults to <see cref="Color.Transparent"/>
+	/// </summary>
 	public Color color;
+
+	/// <summary>
+	/// Set to a value from 0 to 255 to control how transparent the item will appear when drawn. Gel uses 175, gemstone items use 50. 0 is opaque, and 255 is transparent. Note that this is the opposite of how alpha is typically expressed in computer graphics. Use <see cref="ModItem.GetAlpha(Color)"/> for more control over the resulting color.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int alpha;
+
+	/// <summary>
+	/// The index in <see cref="TextureAssets.GlowMask"/> of this item's glow mask, or <c>-1</c> if this item doesn't have a glow mask.
+	/// <br/> Currently does not support modded content.
+	/// <br/> Defaults to <c>-1</c>.
+	/// </summary>
 	public short glowMask;
+
+	/// <summary>
+	/// The size multiplier of the item's sprite while the item is being used. Also increases range for melee weapons.
+	/// <br/> Use <see cref="ModItem.ModifyItemScale(Player, ref float)"/> for dynamic scale values.
+	/// <br/> Defaults to 1f.
+	/// </summary>
 	public float scale = 1f;
-	public LegacySoundStyle UseSound;
+
+	/// <summary>
+	/// The sound this item makes when used. Set this to an existing <see cref="SoundID"/> entry or assign to a new <see cref="SoundStyle"/> for a custom sound.
+	/// <br/> The <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Sounds">Basic Sounds Guide</see> teaches how to find existing sounds to use, how to use custom sounds, and how to customize the playback properties of the sounds. 
+	/// <br/> For example <c>Item.UseSound = SoundID.Item1;</c> can be used for the sword swing sound.
+	/// <br/> Defaults to null.
+	/// </summary>
+	public SoundStyle? UseSound; //TML: Changed from LegacySoundStyle.
+
+	/// <summary>
+	/// The amount of defense this item provides when equipped, either as an accessory or armor.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int defense;
 	public int headSlot = -1;
 	public int bodySlot = -1;
 	public int legSlot = -1;
+	/* sbyte -> int
 	public sbyte handOnSlot = -1;
 	public sbyte handOffSlot = -1;
 	public sbyte backSlot = -1;
@@ -121,49 +_,245 @@
 	public sbyte faceSlot = -1;
 	public sbyte balloonSlot = -1;
 	public sbyte beardSlot = -1;
+	*/
+	public int handOnSlot = -1;
+	public int handOffSlot = -1;
+	public int backSlot = -1;
+	public int frontSlot = -1;
+	public int shoeSlot = -1;
+	public int waistSlot = -1;
+	public int wingSlot = -1;
+	public int shieldSlot = -1;
+	public int neckSlot = -1;
+	public int faceSlot = -1;
+	public int balloonSlot = -1;
+	public int beardSlot = -1;
 	public int stringColor;
 	public ItemTooltip ToolTip;
 	public string BestiaryNotes;
 	public int playerIndexTheItemIsReservedFor = 255;
+
+	/// <summary>
+	/// Indicates the rarity of an item. Assign to a <see cref="ItemRarityID"/> value. Vanilla values range from -1 to 13.
+	/// <br/> Items with <see cref="ItemRarityID.White"/> rarity will burn in lava unless <see cref="ItemID.Sets.IsLavaImmuneRegardlessOfRarity"/> is used.
+	/// <br/> Modded rarities can be assigned by: <c>Item.rare = ModContent.RarityType&lt;ExampleModRarity&gt;();</c>
+	/// <br/> The <see href="https://terraria.wiki.gg/wiki/Rarity">Rarity wiki page</see> has guidelines for deciding on a suitable rarity.
+	/// <br/> Defaults to <see cref="ItemRarityID.White"/>
+	/// </summary>
 	public int rare;
+
+	/// <summary>
+	/// The ID of the projectile that is fired by this item on use. Either a <see cref="ProjectileID"/> entry or <see cref="ModContent.ProjectileType{T}"/>, for example <see cref="ProjectileID.FireArrow"/> or ModContent.ProjectileType&lt;MyModProjectile&gt;()
+	/// <br/> If this weapon uses <see cref="useAmmo"/>, then this value is ignored as the projectile will be decided by the ammo item, but shoot should still be 10 by convention.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int shoot;
+
+	/// <summary>
+	/// The velocity in pixels the projectile fired by this item will have. Actual velocity depends on the projectile being fired. If your weapon is shooting projectiles and they are stationary, change this to something like 10f. Throwing Knife uses 10f. Held projectiles like Vortex Beater use shootSpeed to determine how far away from the player to hold the projectile.
+	/// <br/> Defaults to 0f.
+	/// </summary>
 	public float shootSpeed;
+
+	/// <summary>
+	/// The Ammo ID this item belongs to. Weapons with <see cref="useAmmo"/> set to the same AmmoID will consume this item as ammo. See the <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Ammo">Ammo Guide</see> for more information.
+	/// <br/> Defaults to <see cref="AmmoID.None"/>.
+	/// </summary>
 	public int ammo = AmmoID.None;
+
+	/// <summary>
+	/// If true and the item is ammo (sets <see cref="ammo"/> to something), the item will not count as ammo for certain ammo-specific behavior, such as the tooltip mentioning the item is ammo, or ammo items going into ammo slots first when picked up. Used for the Coin items, Ale, and Sand Blocks.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool notAmmo;
+
+	/// <summary>
+	/// The Ammo ID this weapon will consume. Ammo items with <see cref="ammo"/> set to this same AmmoID will be consumed as ammo for this weapon to be used. See the <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Ammo">Ammo Guide</see> for more information.
+	/// <br/> Defaults to <see cref="AmmoID.None"/>.
+	/// </summary>
 	public int useAmmo = AmmoID.None;
+
+	/// <summary>
+	/// The value to add to <see cref="Player.lifeRegen"/> of the equipping player.
+	/// <br/> Defaults to <c>0</c>.
+	/// </summary>
 	public int lifeRegen;
 	public int manaIncrease;
+	/// <summary>
+	/// Indicates that an item in a shop can only be bought once, meaning it is an item that has been sold to the NPC shop by the player.
+	/// </summary>
 	public bool buyOnce;
+
+	/// <summary>
+	/// The amount of mana this item consumes on use.
+	/// <br/> Use <see cref="ModItem.ModifyManaCost(Player, ref float, ref float)"/> for dynamic mana costs.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int mana;
+
+	/// <summary>
+	/// If true, the item's sprite will not be visible while the item is in use.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool noUseGraphic;
+
+	/// <summary>
+	/// If true, the item's using animation will not deal damage. Set to true on most weapons that aren't swords.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool noMelee;
 	public int timeSinceTheItemHasBeenReservedForSomeone;
+
+	/// <summary>
+	/// The number of copper coins this item is worth (aka, cost to buy from a merchant). Setting it to <c>10462</c> would mean the item cost 1 gold, 4 silver, and 62 copper. The sell price of an item is one fifth of its value. Value also influences reforge costs with the goblin tinkerer.
+	/// <br/> For convenience, you can also use the <see cref="Item.buyPrice(int, int, int, int)"/> method for setting values: <c>Item.value = Item.buyPrice(0, 1, 4, 62);</c> You can also use the <see cref="Item.sellPrice(int, int, int, int)"/> method if you would rather think about an item's value the other way. Both <c>Item.buyPrice(0, 0, 10, 55)</c> and <c>Item.sellPrice(0, 0, 2, 11)</c> would set the value to <c>1055</c>.
+	/// </summary>
 	public int value;
 	public bool buy;
 	public bool social;
+
+	/// <summary>
+	/// If <see langword="true"/>, this item is a vanity item.
+	/// <br/> Vanity items can't receive prefixes and have a special vanity tooltip.
+	/// </summary>
 	public bool vanity;
+
+	/// <summary>
+	/// Indicates that an item should show the material tooltip. Typically this means that the item is used in at least 1 recipe. Automatically assigned.
+	/// </summary>
 	public bool material;
+
+	/// <summary>
+	/// If true, the item won't be drawn while the holding player is wet. The player will also not be in the animation frame corresponding to the item's holdStyle
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool noWet;
+
+	/// <summary>
+	/// The Buff ID of the buff given by this item on use. To have a potion give multiple buffs, assign one buff here and in <see cref="ModItem.UseItem(Player)"/>, call <see cref="Player.AddBuff(int, int, bool, bool)"/> for the remaining buffs you wish to give.
+	/// <br/> Make sure to set <see cref="buffTime"/> as well or the buff will instantly disappear.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int buffType;
+
+	/// <summary>
+	/// The duration in ticks of the buff given by this item on use. There are 60 ticks per second, multiply the number of seconds by 60. For example, a buff lasting 8 minutes would use a value of either <c>28800</c> or <c>8*60*60</c>. 
+	/// <br/> Make sure to set <see cref="buffType"/> as well. 
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int buffTime;
+
+	/// <summary>
+	/// Specifies which mount to equip when the item is used. Assign to <c>ModContent.MountType&lt;ModdedMountHere&gt;()</c>. See <see href="https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Content/Items/ExampleMountItem.cs">ExampleMountItem.cs</see> for an example.
+	/// <br/> Defaults to -1.
+	/// </summary>
 	public int mountType = -1;
 	public bool cartTrack;
+
+	/// <summary>
+	/// Players cannot pick up a <c>uniqueStack</c> item if they have an item with the same <see cref="type"/> in their inventory.<br/>
+	/// This does not apply to equipped items, nor does it apply to items held with the mouse (<see cref="Main.mouseItem"/>).<br/>
+	/// This field only prevents picking items up: Multiple <c>uniqueStack</c> items may still be transferred into the player's inventory from chests.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool uniqueStack;
+
+	/// <summary>
+	/// The numerical ID of the special currency this item is bought using.<br/>
+	/// To make an item bought using Defender Medals, set this to <see cref="CustomCurrencyID.DefenderMedals"/>.<br/>
+	/// See <see href="https://github.com/tModLoader/tModLoader/search?q=ExampleCustomCurrencyId">ExampleCustomCurrencyId</see> for an example of creating and using a custom currency.<br/>
+	/// Must be used with <see cref="shopCustomPrice"/> assigning the price in terms of this custom currency.<br/>
+	/// Defaults to -1, which means an item is bought using coins.<br/>
+	/// </summary>
 	public int shopSpecialCurrency = -1;
+
+	/// <summary>
+	/// If not <see langword="null"/>, the custom value of the given item when being bought from a shop.<br/>
+	/// Used for assigning a non-default price to an item in shops.<br/>
+	/// Can be used with <see cref="shopSpecialCurrency"/> to assign a price in terms of a custom currency instead of coins.<br/>
+	/// To get the raw price of an item, use <see cref="GetStoreValue"/>.<br/>
+	/// To get the price of an item after discounts, use <see cref="Player.GetItemExpectedPrice"/>.<br/>
+	/// Defaults to <see langword="null"/>.<br/>
+	/// </summary>
 	public int? shopCustomPrice;
 	public bool shootsEveryUse;
 	public bool chlorophyteExtractinatorConsumable;
+
+	/// <summary>
+	/// If true, the given item is categorized as a Dungeon Defenders 2 summon item.<br/>
+	/// DD2 summon items get a counter for how much Etherian Mana is in the player's inventory.<br/>
+	/// <b>This field being set does not make the item consume Etherian Mana.</b> Etherian Mana consumption is handled manually per-type.<br/>
+	/// Defaults to <see langword="false"/>.<br/>
+	/// </summary>
 	public bool DD2Summon;
 	public int netID;
+
+	/// <summary>
+	/// The base critical chance for this item. Remember that the player has a base crit chance of 4.
+	/// <br/> Use <see cref="ModItem.ModifyWeaponCrit(Player, ref float)"/> for dynamic crit values.
+	/// <br/> Defaults to 0
+	/// </summary>
 	public int crit;
-	public byte prefix;
-	public bool melee;
-	public bool magic;
-	public bool ranged;
-	public bool summon;
+
+	/// <summary>
+	/// The current prefix applied to this item. Either a <see cref="PrefixID"/> entry or <see cref="ModContent.PrefixType{T}"/>. Prefixes are assigned by calling the <see cref="Item.Prefix(int)"/> method.
+	/// <br/> Defaults to 0.
+	/// </summary>
+	public int prefix; //TML: Changed from byte to int.
+
+	internal bool melee {
+		get => CountsAsClass(DamageClass.Melee);
+		set {
+			if (value)
+				DamageType = DamageClass.Melee;
+			else if (DamageType == DamageClass.Melee)
+				DamageType = DamageClass.Default;
+		}
+	}
+
+	internal bool magic {
+		get => CountsAsClass(DamageClass.Magic);
+		set {
+			if (value)
+				DamageType = DamageClass.Magic;
+			else if (DamageType == DamageClass.Magic)
+				DamageType = DamageClass.Default;
+		}
+	}
+
+	internal bool ranged {
+		get => CountsAsClass(DamageClass.Ranged);
+		set {
+			if (value)
+				DamageType = DamageClass.Ranged;
+			else if (DamageType == DamageClass.Ranged)
+				DamageType = DamageClass.Default;
+		}
+	}
+
+	internal bool summon {
+		get => CountsAsClass(DamageClass.Summon);
+		set {
+			if (value)
+				DamageType = DamageClass.Summon;
+			else if (DamageType == DamageClass.Summon)
+				DamageType = DamageClass.Default;
+		}
+	}
+
 	public bool sentry;
+
+	/// <summary>
+	/// A delay in frames added at the end of the using animation for the item, during which the player wont be able to use any items.
+	/// <br/> Defaults to 0.
+	/// </summary>
 	public int reuseDelay;
 	public bool newAndShiny;
+
+	/// <summary>
+	/// If <see langword="true"/>, this item has vanity effects even though it doesn't use equipment slots.
+	/// <br/> Unused in vanilla, as the system it was used for was removed in 1.4.4.
+	/// </summary>
 	[Old("This is used to allow items to be discerned as vanity even if they didn't have visual slots to poll against")]
 	public bool hasVanityEffects;
 	private const int foodWidth = 22;
@@ -173,8 +_,30 @@
 	public bool shimmered;
 	public float shimmerTime;
 
+	// EntryFilter complains if item doesn't have a parameterless constructor (even when the parameter is optional).
+	public Item() { }
+
+	// Added by TML.
+	public Item(int setDefaultsToType, int stack = 1, int prefix = 0)
+	{
+		SetDefaults(setDefaultsToType);
+
+		if (setDefaultsToType > 0)
+			this.stack = stack;
+
+		if (prefix != 0)
+			Prefix(prefix);
+	}
+
+	/// <summary>
+	/// The localized name of this item without stack size or prefixes.
+	/// <br/> Can be overridden using <see cref="SetNameOverride(string)"/>.
+	/// </summary>
 	public string Name => _nameOverride ?? Lang.GetItemNameValue(type);
 
+	/// <summary>
+	/// The name of this item including stack size and prefix.
+	/// </summary>
 	public string HoverName {
 		get {
 			string text = AffixName();
@@ -185,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// <see langword="true"/> if <c><see cref="paint"/> &gt; 0 || <see cref="paintCoating"/> &gt; 0</c> and <see langword="false"/> otherwise.
+	/// </summary>
 	public bool PaintOrCoating {
 		get {
 			if (paint <= 0)
@@ -196,11 +_,19 @@
 
 	public bool FitsAccessoryVanitySlot => true;
 
+	/*
 	public int OriginalRarity => ContentSamples.ItemsByType[type].rare;
 
 	public int OriginalDamage => ContentSamples.ItemsByType[type].damage;
 
 	public int OriginalDefense => ContentSamples.ItemsByType[type].defense;
+	*/
+
+	public int OriginalRarity => ContentSamples.ItemsByType.TryGetValue(type, out Item item) ? item.rare : 0;
+
+	public int OriginalDamage => ContentSamples.ItemsByType.TryGetValue(type, out Item item) ? item.damage : 0;
+
+	public int OriginalDefense => ContentSamples.ItemsByType.TryGetValue(type, out Item item) ? item.defense : 0;
 
 	public ItemVariant Variant { get; private set; }
 
@@ -254,12 +_,27 @@
 		}
 	}
 
+	/// <summary>
+	/// Begins caching items spawns for a given item type (<see cref="Item.type"/>).
+	/// <br/> Cached item types will not be spawned into the world when created with Item.NewItem().
+	/// <br/> Cache sizes can be checked by indexing <see cref="cachedItemSpawnsByType"/> and dropped using <see cref="DropCache(IEntitySource, Vector2, Vector2, int, bool)"/>.
+	/// </summary>
+	/// <param name="t">The item type to start caching.</param>
 	public static void StartCachingType(int t)
 	{
 		if (cachedItemSpawnsByType[t] == -1)
 			cachedItemSpawnsByType[t] = 0;
 	}
 
+	/// <summary>
+	/// Drops a cache previously created using <see cref="StartCachingType(int)"/>.
+	/// <br/> If no cache of <paramref name="t"/> exists, nothing happens.
+	/// </summary>
+	/// <param name="reason">The source of the dropped cache.</param>
+	/// <param name="pos">The position to drop the cache in world coordinates.</param>
+	/// <param name="spread">The random spread of the dropped items in world coordinates.</param>
+	/// <param name="t">The item type (<see cref="Item.type"/>) to drop.</param>
+	/// <param name="stopCaching">If <see langword="true"/>, then <paramref name="t"/> will no longer be cached, allowing future drops to spawn as normal.</param>
 	public static void DropCache(IEntitySource reason, Vector2 pos, Vector2 spread, int t, bool stopCaching = true)
 	{
 		if (cachedItemSpawnsByType[t] == -1)
@@ -279,12 +_,26 @@
 		}
 	}
 
+	// Internal, modders should use GetSource_FromThis
-	public IEntitySource GetNPCSource_FromThis() => new EntitySource_Parent(this);
+	internal IEntitySource GetNPCSource_FromThis() => new EntitySource_Parent(this);
+
+	// Internal redirect
+	/*
 	public IEntitySource GetItemSource_Misc(int itemSourceId) => new EntitySource_ByItemSourceId(this, itemSourceId);
+	*/
+	internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+
 	public override string ToString() => $"{{Name: \"{Name}\" NetID: {netID} Stack: {stack}";
 
+	/// <summary>
+	/// Determines if this <see cref="Item"/> can receive prefixes.
+	/// </summary>
+	/// <returns>
+	/// <see langword="true"/> if this <see cref="Item"/> is allowed to receive prefixes, <see langword="false"/> otherwise.
+	/// </returns>
-	private bool CanHavePrefixes()
+	public bool CanHavePrefixes()
 	{
+		/*
 		if (type != 0 && maxStack == 1) {
 			if (damage <= 0)
 				return accessory;
@@ -293,8 +_,36 @@
 		}
 
 		return false;
+		*/
+
+		return type != 0
+			&& ItemID.Sets.CanGetPrefixes[type]
+			&& (maxStack == 1 || AllowReforgeForStackableItem)
+			&& ammo == 0
+			&& (damage > 0 || IsAPrefixableAccessory());
 	}
 
+	/// <summary>
+	/// Attempts to apply a prefix to this <see cref="Item"/>.
+	/// </summary>
+	/// <param name="prefixWeWant">
+	/// <br/> If <c><paramref name="prefixWeWant"/> == 0</c>, do nothing.
+	///	<br/> If <c><paramref name="prefixWeWant"/> == -1</c>, then a random prefix is rolled, with a 25% chance to not roll a prefix and an additional 66% chance to void any prefixes in the <see cref="PrefixID.Sets.ReducedNaturalChance"/> set. This is used for chest loot, starting equipment, etc.
+	///	<br/> If <c><paramref name="prefixWeWant"/> == -2</c>, then a random prefix is rolled, with no chance to not roll a prefix. This is used for the Goblin Tinkerer.
+	///	<br/> If <c><paramref name="prefixWeWant"/> == -3</c>, then this method simple checks if this item <em>can</em> receive prefixes.
+	///	<br/> Otherwise, attempt to apply the given <see cref="PrefixID"/> to this item.
+	/// </param>
+	/// <returns>
+	/// <see langword="false"/> if:<list type="bullet">
+	/// <item><paramref name="prefixWeWant"/> is <c>0</c></item>
+	/// <item><see cref="CanHavePrefixes"/> returns <see langword="false"/></item>
+	/// <item><see cref="CanApplyPrefix(int)"/> returns <see langword="false"/></item>
+	/// <item><c><paramref name="prefixWeWant"/> == -1</c> and <c><see cref="maxStack"/> &gt; 1</c></item>
+	/// <item><see cref="ItemLoader.PrefixChance(Item, int, UnifiedRandom)"/> returns <see langword="false"/></item>
+	/// <item><c><paramref name="prefixWeWant"/> == -1 or -2 or -3</c> and <see cref="PrefixLoader.Roll(Item, UnifiedRandom, out int, bool)"/> returns <see langword="false"/>.</item>
+	/// </list>
+	/// Otherwise, return <see langword="true"/>.
+	/// </returns>
 	public bool Prefix(int prefixWeWant)
 	{
 		if (!WorldGen.gen && Main.rand == null)
@@ -306,7 +_,19 @@
 		if (!CanHavePrefixes())
 			return false;
 
+		if (prefixWeWant > 0 && !CanApplyPrefix(prefixWeWant))
+			return false;
+
+		//#StackablePrefixWeapons: Stackable items will not spawn with a prefix on craft/generate. Only when deliberately reforged.
+		if (prefixWeWant == -1 && maxStack > 1)
+			return false;
+
 		UnifiedRandom unifiedRandom = (WorldGen.gen ? WorldGen.genRand : Main.rand);
+
+		bool? applyPrefixOverride = ItemLoader.PrefixChance(this, prefixWeWant, unifiedRandom);
+		if (applyPrefixOverride is false)
+			return false;
+
 		int rolledPrefix = prefixWeWant;
 		float dmg = 1f;
 		float kb = 1f;
@@ -318,12 +_,18 @@
 		bool flag = true;
 		while (flag) {
 			flag = false;
+
+			if (applyPrefixOverride is true) { } else
 			if (rolledPrefix == -1 && unifiedRandom.Next(4) == 0)
-				rolledPrefix = 0;
+				return true; //rolledPrefix = 0;
 
 			if (prefixWeWant < -1)
 				rolledPrefix = -1;
 
+			// Faster check implementation than actually rolling.
+			if (prefixWeWant == -3)
+				return PrefixLoader.Roll(this, unifiedRandom, out _, justCheck: true);
+
 			if ((rolledPrefix == -1 || rolledPrefix == -2 || rolledPrefix == -3) && !RollAPrefix(unifiedRandom, ref rolledPrefix))
 				return false;
 
@@ -331,8 +_,9 @@
 				case -3:
 					return true;
 				case -1:
+					if (applyPrefixOverride is true) { } else
 					if (PrefixID.Sets.ReducedNaturalChance[rolledPrefix] && unifiedRandom.Next(3) != 0)
-						rolledPrefix = 0;
+						return true; //rolledPrefix = 0;
 					break;
 			}
 
@@ -347,6 +_,8 @@
 			}
 		}
 
+		UndoItemAnimationCompensations();
+
 		damage = (int)Math.Round((float)damage * dmg);
 		useAnimation = (int)Math.Round((float)useAnimation * spd);
 		useTime = (int)Math.Round((float)useTime * spd);
@@ -356,6 +_,12 @@
 		scale *= size;
 		shootSpeed *= shtspd;
 		crit += crt;
+
+		if (rolledPrefix >= PrefixID.Count)
+			PrefixLoader.GetPrefix(rolledPrefix)?.Apply(this);
+
+		ApplyItemAnimationCompensationsToVanillaItems();
+
 		float num = 1f * dmg * (2f - spd) * (2f - mcst) * size * kb * shtspd * (1f + (float)crt * 0.02f);
 		if (rolledPrefix == 62 || rolledPrefix == 69 || rolledPrefix == 73 || rolledPrefix == 77)
 			num *= 1.05f;
@@ -369,6 +_,11 @@
 		if (rolledPrefix == 65 || rolledPrefix == 72 || rolledPrefix == 76 || rolledPrefix == 80 || rolledPrefix == 68)
 			num *= 1.2f;
 
+		if (rolledPrefix >= PrefixID.Count)
+			PrefixLoader.GetPrefix(rolledPrefix)?.ModifyValue(ref num);
+
+		int baseRarity = rare;
+
 		if ((double)num >= 1.2)
 			rare += 2;
 		else if ((double)num >= 1.05)
@@ -378,25 +_,37 @@
 		else if ((double)num <= 0.95)
 			rare--;
 
+		if (baseRarity >= ItemRarityID.Count)
+			rare = RarityLoader.GetRarity(baseRarity).GetPrefixedRarity(rare - baseRarity, num);
+		else if (rare > ItemRarityID.Purple)
+			rare = ItemRarityID.Purple;
+
 		if (rare > -11) {
 			if (rare < -1)
 				rare = -1;
 
-			if (rare > 11)
-				rare = 11;
+			if (rare > RarityLoader.RarityCount - 1)
+				rare = RarityLoader.RarityCount - 1;
 		}
 
 		num *= num;
 		value = (int)((float)value * num);
-		prefix = (byte)rolledPrefix;
+		prefix = rolledPrefix;
 		return true;
 	}
 
+	/// <summary>
+	/// Determines if this <see cref="Item"/> can roll the given prefix.
+	/// </summary>
+	/// <param name="prefix">The <see cref="PrefixID"/> to check.</param>
+	/// <returns><see langword="true"/> if this <see cref="Item"/> can receive prefixes (<see cref="CanHavePrefixes"/>) and if <see cref="PrefixLoader.CanRoll(Item, int)"/> returns <see langword="true"/>, <see langword="false"/> otherwise.</returns>
+	/// <remarks>Just because a prefix can be rolled does not mean it can be applied -- use <see cref="CanApplyPrefix(int)"/> to check for that.</remarks>
 	public bool CanRollPrefix(int prefix)
 	{
 		if (!CanHavePrefixes())
 			return false;
 
+		/*
 		int[] rollablePrefixes = GetRollablePrefixes();
 		if (rollablePrefixes == null)
 			return false;
@@ -407,8 +_,16 @@
 		}
 
 		return false;
+		*/
+
+		return PrefixLoader.CanRoll(this, prefix);
 	}
 
+	/// <summary>
+	/// Determines if this <see cref="Item"/> can receive the given prefix.
+	/// </summary>
+	/// <param name="prefix">The <see cref="PrefixID"/> to check.</param>
+	/// <returns><see langword="true"/> if this <see cref="Item"/> can roll the given prefix (<see cref="CanRollPrefix(int)"/>) and if the applied prefix does not fail to modify any stat values.</returns>
 	public bool CanApplyPrefix(int prefix)
 	{
 		if (!CanRollPrefix(prefix))
@@ -706,6 +_,13 @@
 				dmg = 1.05f;
 				crt = 2;
 				break;
+			// Handle mod prefixes.
+			case int pre when PrefixLoader.GetPrefix(pre) is ModPrefix modPrefix:
+				if (!modPrefix.AllStatChangesHaveEffectOn(this))
+					return false;
+
+				modPrefix.SetStats(ref dmg, ref kb, ref spd, ref size, ref shtspd, ref mcst, ref crt);
+				break;
 		}
 
 		if (dmg != 1f && Math.Round((float)damage * dmg) == (double)damage)
@@ -723,7 +_,8 @@
 		return true;
 	}
 
+	//TML: Made internal.
-	public int[] GetRollablePrefixes()
+	internal int[] GetRollablePrefixes()
 	{
 		_ = type;
 		if (PrefixLegacy.ItemSets.SwordsHammersAxesPicks[type])
@@ -750,16 +_,65 @@
 		return null;
 	}
 
+	// Added by TML.
+	/// <summary>
+	/// Determines the <see cref="PrefixCategory"/> of this <see cref="Item"/>.
+	/// </summary>
+	/// <returns>The <see cref="PrefixCategory"/> of this <see cref="Item"/> or <see langword="null"/> if this <see cref="Item"/> doesn't have a category.</returns>
+	public PrefixCategory? GetPrefixCategory()
+	{
+		if (PrefixLegacy.ItemSets.SwordsHammersAxesPicks[type] || ItemLoader.MeleePrefix(this))
+			return PrefixCategory.Melee;
+		
+		if (PrefixLegacy.ItemSets.GunsBows[type] || ItemLoader.RangedPrefix(this))
+			return PrefixCategory.Ranged;
+
+		if (PrefixLegacy.ItemSets.MagicAndSummon[type] || ItemLoader.MagicPrefix(this))
+			return PrefixCategory.Magic;
+
+		if (PrefixLegacy.ItemSets.SpearsMacesChainsawsDrillsPunchCannon[type] || PrefixLegacy.ItemSets.BoomerangsChakrams[type] || PrefixLegacy.ItemSets.ItemsThatCanHaveLegendary2[type] || ItemLoader.WeaponPrefix(this))
+			return PrefixCategory.AnyWeapon;
+
+		if (IsAPrefixableAccessory())
+			return PrefixCategory.Accessory;
+
+		return null;
+	}
+
+	// Added by TML.
+	/// <summary>
+	/// Gets the vanilla prefixes for the given <see cref="PrefixCategory"/>.
+	/// </summary>
+	/// <param name="category">The <see cref="PrefixCategory"/> to check.</param>
+	/// <returns>An array of vanilla <see cref="PrefixID"/>s for the given category, or an empty array for <see cref="PrefixCategory.Custom"/>.</returns>
+	public static int[] GetVanillaPrefixes(PrefixCategory category) => category switch {
+		PrefixCategory.Melee => PrefixLegacy.Prefixes.PrefixesForSwords,
+		PrefixCategory.Ranged => PrefixLegacy.Prefixes.PrefixesForGunsBows,
+		PrefixCategory.Magic => PrefixLegacy.Prefixes.PrefixesForMagicAndSummons,
+		PrefixCategory.AnyWeapon => PrefixLegacy.Prefixes.PrefixesForSpears,
+		PrefixCategory.Accessory => PrefixLegacy.Prefixes.PrefixesForAccessories,
+		_ => Array.Empty<int>(),
+	};
+
 	private bool RollAPrefix(UnifiedRandom random, ref int rolledPrefix)
 	{
+		/*
 		int[] rollablePrefixes = GetRollablePrefixes();
 		if (rollablePrefixes == null)
 			return false;
 
 		rolledPrefix = rollablePrefixes[random.Next(rollablePrefixes.Length)];
+		
 		return true;
+		*/
+
+		return PrefixLoader.Roll(this, random, out rolledPrefix, justCheck: false);
 	}
 
+	/// <summary>
+	/// Determines if this <see cref="Item"/> is an accessory that can receive prefixes.
+	/// </summary>
+	/// <returns><see langword="true"/> if this <see cref="Item"/> is an accessory, is not a vanity item, and is not blacklisted from receiving prefixes (<see cref="ItemID.Sets.CanGetPrefixes"/>).</returns>
 	public bool IsAPrefixableAccessory()
 	{
 		if (accessory && !vanity)
@@ -768,6 +_,10 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Gets the localized name of this <see cref="Item"/> including its prefix.
+	/// </summary>
+	/// <returns>The localized name of this <see cref="Item"/> including its prefix, or simply <see cref="Name"/> if the prefix doesn't exist or is an empty string.</returns>
 	public string AffixName()
 	{
 		if (prefix < 0 || prefix >= Lang.prefix.Length)
@@ -789,8 +_,14 @@
 			ToolTip = Lang.GetTooltip(netID);
 	}
 
+	/// <summary>
+	/// Gets this <see cref="Item"/>'s hitbox in the world. Equivalent to <see cref="Entity.Hitbox"/>.
+	/// </summary>
+	/// <returns>This <see cref="Item"/>'s hitbox in the world.</returns>
 	public Rectangle getRect() => new Rectangle((int)position.X, (int)position.Y, width, height);
 
+	// Removed in favor of UpdateWhichItemsAreMaterials logic
+	/*
 	public bool checkMat()
 	{
 		if (type >= 71 && type <= 74) {
@@ -839,9 +_,11 @@
 
 				material = false;
 				return false;
+				// Extra patch context.
 			}
 		}
 	}
+	*/
 
 	public void netDefaults(int type)
 	{
@@ -998,8 +_,20 @@
 		}
 	}
 
+	/// <summary>
+	/// Converts a banner ID into the equivalent item type (<see cref="Item.type"/>).
+	/// </summary>
+	/// <param name="banner">The banner ID to convert.</param>
+	/// <returns>
+	/// The item type associated with the given banner ID.
+	/// <br/> <strong>This method will return the wrong item type if <paramref name="banner"/> is not a valid banner ID.</strong>
+	/// </returns>
+	/// <remarks>You can get the banner ID of an NPC using <see cref="NPCtoBanner(int)"/>.</remarks>
 	public static int BannerToItem(int banner)
 	{
+		if (NPCLoader.bannerToItem.TryGetValue(banner, out int result))
+			return result;
+
 		int num = 0;
 		if (banner == 289)
 			return 5352;
@@ -1037,6 +_,11 @@
 		return 1615 + banner - 1;
 	}
 
+	/// <summary>
+	/// Converts an NPC type (<see cref="NPC.type"/>) into the equivalent banner ID.
+	/// </summary>
+	/// <param name="i">The NPC type to convert.</param>
+	/// <returns>The banner ID associated with the given NPC type, or <c>0</c> if the NPC type has no associated banner.</returns>
 	public static int NPCtoBanner(int i)
 	{
 		switch (i) {
@@ -1771,15 +_,24 @@
 				return 286;
 			case 176:
 				return 287;
+			// Extra patch context.
 			case 133:
 				return 288;
 			case 676:
 				return 289;
 			default:
+				if (i >= NPCID.Count) // in NPCtoBanner method
+					return NPCLoader.GetNPC(i).Banner;
+
 				return 0;
 		}
 	}
 
+	/// <summary>
+	/// Converts a banner ID into the equivalent NPC type (<see cref="NPC.type"/>).
+	/// </summary>
+	/// <param name="i">The banner ID to convert.</param>
+	/// <returns>The NPC type associated with the given banner ID, or <see cref="NPCID.None"/> for an invalid banner ID.</returns>
 	public static int BannerToNPC(int i)
 	{
 		switch (i) {
@@ -2347,11 +_,15 @@
 				return 475;
 			case 287:
 				return 176;
+			// Extra patch context.
 			case 288:
 				return 133;
 			case 289:
 				return 676;
 			default:
+				if (i >= NPCID.Count) // in BannerToNPC method
+					return i;
+
 				return 0;
 		}
 	}
@@ -7679,6 +_,8 @@
 				value = 300;
 				break;
 			case 434:
+				consumeAmmoOnLastShotOnly = true; // Added by TML.
+
 				autoReuse = true;
 				useStyle = 5;
 				useAnimation = 12;
@@ -8651,6 +_,8 @@
 				rare = 2;
 				break;
 			case 506:
+				consumeAmmoOnFirstShotOnly = true; // Added by TML.
+
 				useStyle = 5;
 				autoReuse = true;
 				useAnimation = 30;
@@ -11396,6 +_,7 @@
 				knockBack = 6.5f;
 				melee = true;
 				value = sellPrice(0, 3);
+				ChangePlayerDirectionOnShoot = false;// Added by tML
 				break;
 			case 724:
 				autoReuse = true;
@@ -12077,6 +_,8 @@
 				scale = 1f;
 				break;
 			case 779:
+				consumeAmmoOnLastShotOnly = true; // Added by TML
+
 				useStyle = 5;
 				autoReuse = true;
 				useAnimation = 30;
@@ -22766,6 +_,8 @@
 				melee = true;
 				return;
 			case 1910:
+				consumeAmmoOnFirstShotOnly = true; // Added by TML.
+
 				useStyle = 5;
 				autoReuse = true;
 				useAnimation = 30;
@@ -30150,6 +_,17 @@
 			value = buyPrice(0, 2, 70);
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to quest fish items.<br/>
+	/// Specifically:<code>
+	/// questItem = true;
+	///	maxStack = 1;
+	///	width = 26;
+	///	height = 26;
+	///	uniqueStack = true;
+	///	rare = <see cref="ItemRarityID.Quest"/>;
+	/// </code>
+	/// </summary>
 	public void DefaultToQuestFish()
 	{
 		questItem = true;
@@ -35265,6 +_,7 @@
 				rare = 2;
 				UseSound = SoundID.Item64;
 				mech = true;
+				ChangePlayerDirectionOnShoot = false;// Added by tML
 				return;
 			case 3612:
 				useStyle = 1;
@@ -36886,6 +_,8 @@
 				shootSpeed = 17f;
 				return;
 			case 3852:
+				useLimitPerAnimation = 4; // Added by TML.
+
 				useStyle = 5;
 				useAnimation = 25;
 				useTime = 3;
@@ -38322,6 +_,26 @@
 		}
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to golf ball items.<br/>
+	/// Specifically:<code>
+	///	shoot = <paramref name="projid"/>;
+	///	useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	shootSpeed = 12f;
+	///	width = 18;
+	///	height = 20;
+	///	maxStack = 1;
+	///	UseSound = <see cref="SoundID.Item1"/>;
+	///	useAnimation = 15;
+	///	useTime = 15;
+	///	noUseGraphic = true;
+	///	noMelee = true;
+	///	accessory = true;
+	///	SetShopValues(ItemRarityColor.Green2, buyPrice(0, 1));
+	///	hasVanityEffects = true;
+	/// </code>
+	/// </summary>
+	/// <param name="projid"></param>
 	public void DefaultToGolfBall(int projid)
 	{
 		shoot = projid;
@@ -43082,6 +_,8 @@
 				expert = true;
 				break;
 			case 4952:
+				useLimitPerAnimation = 4; // Added by TML.
+
 				autoReuse = true;
 				useStyle = 14;
 				holdStyle = 6;
@@ -43103,6 +_,9 @@
 				flame = true;
 				break;
 			case 4953:
+				useLimitPerAnimation = 5; // Added by TML.
+				consumeAmmoOnLastShotOnly = true; // Added by TML.
+
 				useStyle = 5;
 				autoReuse = true;
 				useAnimation = 30;
@@ -46345,6 +_,20 @@
 		}
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to Clentaminator ammo solution items.<br/>
+	/// Specifically:<code>
+	///	shoot = projectileId - 145;
+	/// ammo = AmmoID.Solution;
+	/// width = 10;
+	///	height = 12;
+	/// value = buyPrice(0, 0, 15);
+	/// rare = 3;
+	///	maxStack = <see cref="CommonMaxStack"/>;
+	///	consumable = true;
+	/// </code>
+	/// </summary>
+	/// <param name="projectileId"></param>
 	public void DefaultToSolution(int projectileId)
 	{
 		shoot = projectileId - 145;
@@ -46357,6 +_,30 @@
 		consumable = true;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to whip weapons.<br/>
+	/// Specifically:<code>
+	/// autoReuse = false;
+	///	useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	useAnimation = animationTotalTime;
+	///	useTime = animationTotalTime;
+	///	width = 18;
+	///	height = 18;
+	///	shoot = projectileId;
+	///	UseSound = <see cref="SoundID.Item152"/>;
+	///	noMelee = true;
+	///	DamageType = <see cref="DamageClass.SummonMeleeSpeed"/>;
+	///	noUseGraphic = true;
+	///	damage = dmg;
+	///	knockBack = kb;
+	///	shootSpeed = <paramref name="shootspeed"/>;
+	/// </code>
+	/// </summary>
+	/// <param name="projectileId"></param>
+	/// <param name="dmg"></param>
+	/// <param name="kb"></param>
+	/// <param name="shootspeed"></param>
+	/// <param name="animationTotalTime"></param>
 	public void DefaultToWhip(int projectileId, int dmg, float kb, float shootspeed, int animationTotalTime = 30)
 	{
 		autoReuse = false;
@@ -46368,7 +_,10 @@
 		shoot = projectileId;
 		UseSound = SoundID.Item152;
 		noMelee = true;
+		/*
 		summon = true;
+		*/
+		DamageType = DamageClass.SummonMeleeSpeed;
 		noUseGraphic = true;
 		damage = dmg;
 		knockBack = kb;
@@ -46422,7 +_,7 @@
 		return false;
 	}
 
-	private void DefaultToSeaShell()
+	public void DefaultToSeaShell()
 	{
 		useStyle = 1;
 		autoReuse = true;
@@ -46456,7 +_,8 @@
 		}
 	}
 
+	//TML: Changed to take an int instead of a short for convenience and consistency purposes
-	public void DefaultToCapturedCritter(short npcIdToSpawnOnUse)
+	public void DefaultToCapturedCritter(int npcIdToSpawnOnUse)
 	{
 		useStyle = 1;
 		autoReuse = true;
@@ -46471,6 +_,21 @@
 		makeNPC = npcIdToSpawnOnUse;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to staff magic weapons.<br/>
+	/// Specifically:<code>
+	/// DefaultToMagicWeapon(projType, singleShotTime, pushForwardSpeed, hasAutoReuse: true);
+	/// mana = manaPerShot;
+	///	width = 40;
+	///	height = 40;
+	///	UseSound = <see cref="SoundID.Item43"/>;
+	/// </code>
+	/// Additionally: <br/><inheritdoc cref="DefaultToMagicWeapon" />
+	/// </summary>
+	/// <param name="projType"></param>
+	/// <param name="pushForwardSpeed">Passed into DefaultToMagicWeapon as the shotVelocity parameter</param>
+	/// <param name="singleShotTime"></param>
+	/// <param name="manaPerShot"></param>
 	public void DefaultToStaff(int projType, float pushForwardSpeed, int singleShotTime, int manaPerShot)
 	{
 		DefaultToMagicWeapon(projType, singleShotTime, pushForwardSpeed, hasAutoReuse: true);
@@ -46480,6 +_,25 @@
 		UseSound = SoundID.Item43;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to spear weapons.<br/>
+	/// Specifically:<code>
+	/// useStyle = <see cref="ItemUseStyleID.Shoot"/>;
+	/// useAnimation = animationTime;
+	/// useTime = animationTime;
+	/// shootSpeed = pushForwardSpeed;
+	/// width = 32;
+	/// height = 32;
+	/// UseSound = SoundID.Item1;
+	/// shoot = projType;
+	/// noMelee = true;
+	/// noUseGraphic = true;
+	/// DamageType = DamageClass.Melee;
+	/// </code>
+	/// </summary>
+	/// <param name="projType"></param>
+	/// <param name="pushForwardSpeed"></param>
+	/// <param name="animationTime"></param>
 	public void DefaultToSpear(int projType, float pushForwardSpeed, int animationTime)
 	{
 		useStyle = 5;
@@ -46852,7 +_,24 @@
 		mountType = mount;
 	}
 
+	// tML: changed to take an int instead of a ushort for convenience and consistency purposes
+	/// <summary>
+	/// This method sets a variety of Item values common to placeable walls.<br/>
+	/// Specifically:<code>
+	///	useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	useTurn = true;
+	///	useAnimation = 15;
+	///	useTime = 7;
+	///	autoReuse = true;
+	///	maxStack = <see cref="CommonMaxStack"/>;
+	///	consumable = true;
+	///	createWall = wallToPlace;
+	///	width = 12;
+	///	height = 12;
+	///	</code>
+	/// </summary>
+	/// <param name="wallToPlace"></param>
-	public void DefaultToPlaceableWall(ushort wallToPlace)
+	public void DefaultToPlaceableWall(int wallToPlace)
 	{
 		useStyle = 1;
 		useTurn = true;
@@ -46866,6 +_,12 @@
 		height = 12;
 	}
 
+	/// <summary>
+	/// This method conveniently sets <see cref="Item.damage"/>, <see cref="Item.knockBack"/>, and <see cref="Item.crit"/>.
+	/// </summary>
+	/// <param name="dmg"></param>
+	/// <param name="knockback"></param>
+	/// <param name="bonusCritChance"></param>
 	public void SetWeaponValues(int dmg, float knockback, int bonusCritChance = 0)
 	{
 		damage = dmg;
@@ -46873,6 +_,14 @@
 		crit = bonusCritChance;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to bow weapons.<br/>
+	/// Specifically: <code>width = 14;<br/>height = 30;<br/>UseSound = SoundID.Item5;</code><br/>
+	/// Additionally: <br/><inheritdoc cref="DefaultToRangedWeapon(int,int,int,float,bool)" />
+	/// </summary>
+	/// <param name="singleShotTime"></param>
+	/// <param name="shotVelocity"></param>
+	/// <param name="hasAutoReuse"></param>
 	public void DefaultToBow(int singleShotTime, float shotVelocity, bool hasAutoReuse = false)
 	{
 		DefaultToRangedWeapon(1, AmmoID.Arrow, singleShotTime, shotVelocity, hasAutoReuse);
@@ -46881,6 +_,23 @@
 		UseSound = SoundID.Item5;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to magic weapons.<br/>
+	/// Specifically:<code>
+	/// autoReuse = hasAutoReuse;
+	/// useStyle = <see cref="ItemUseStyleID.Shoot"/>;
+	/// useAnimation = singleShotTime;
+	/// useTime = singleShotTime;
+	/// shoot = projType;
+	/// shootSpeed = shotVelocity;
+	/// noMelee = true;
+	/// DamageType = DamageClass.Magic;
+	/// </code>
+	/// </summary>
+	/// <param name="projType"></param>
+	/// <param name="singleShotTime"></param>
+	/// <param name="shotVelocity"></param>
+	/// <param name="hasAutoReuse"></param>
 	public void DefaultToMagicWeapon(int projType, int singleShotTime, float shotVelocity, bool hasAutoReuse = false)
 	{
 		autoReuse = hasAutoReuse;
@@ -46893,6 +_,25 @@
 		magic = true;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to ranged weapons.<br/>
+	/// Specifically:<code>
+	/// autoReuse = hasAutoReuse;
+	/// useStyle = <see cref="ItemUseStyleID.Shoot"/>;
+	/// useAnimation = singleShotTime;
+	/// useTime = singleShotTime;
+	/// shoot = baseProjType;
+	/// useAmmo = ammoID;
+	/// shootSpeed = shotVelocity;
+	/// noMelee = true;
+	/// DamageType = DamageClass.Ranged;
+	/// </code>
+	/// </summary>
+	/// <param name="baseProjType"></param>
+	/// <param name="ammoID">The Ammo ID this weapon will consume. See the <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Ammo">Ammo Guide</see> for more information</param>
+	/// <param name="singleShotTime"></param>
+	/// <param name="shotVelocity"></param>
+	/// <param name="hasAutoReuse"></param>
 	public void DefaultToRangedWeapon(int baseProjType, int ammoID, int singleShotTime, float shotVelocity, bool hasAutoReuse = false)
 	{
 		autoReuse = hasAutoReuse;
@@ -46906,6 +_,25 @@
 		ranged = true;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to thrown weapons.<br/>
+	/// Specifically:<code>
+	/// autoReuse = hasAutoReuse;
+	///	useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	useAnimation = singleShotTime;
+	///	useTime = singleShotTime;
+	///	shoot = baseProjType;
+	///	shootSpeed = shotVelocity;
+	///	noMelee = true;
+	///	DamageType = DamageClass.Ranged;
+	///	consumable = true;
+	///	maxStack = <see cref="CommonMaxStack"/>;
+	/// </code>
+	/// </summary>
+	/// <param name="baseProjType"></param>
+	/// <param name="singleShotTime"></param>
+	/// <param name="shotVelocity"></param>
+	/// <param name="hasAutoReuse"></param>
 	public void DefaultToThrownWeapon(int baseProjType, int singleShotTime, float shotVelocity, bool hasAutoReuse = false)
 	{
 		autoReuse = hasAutoReuse;
@@ -46920,7 +_,36 @@
 		maxStack = CommonMaxStack;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to items that place music boxes.<br/>
+	/// Specifically:<code>
+	/// flame = true;
+	/// noWet = !allowWaterPlacement;
+	///	holdStyle = <see cref="ItemHoldStyleID.HoldFront"/>;
+	///	autoReuse = true;
+	///	maxStack = <see cref="CommonMaxStack"/>;
+	///	consumable = true;
+	///	createTile = tileIDToPlace;
+	///	placeStyle = tileStyleToPlace;
+	///	width = 10;
+	///	height = 12;
+	///	value = 60;
+	///	useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	useTurn = true;
+	///	useAnimation = 15;
+	///	useTime = 10;
+	/// </code>
+	/// </summary>
+	/// <param name="tileIDToPlace"></param>
+	/// <param name="tileStyleToPlace"></param>
+	/// <param name="allowWaterPlacement"></param>
+	public void DefaultToTorch(int tileIDToPlace, int tileStyleToPlace, bool allowWaterPlacement = false)
+	{
+		DefaultToTorch(tileStyleToPlace, allowWaterPlacement);
+		createTile = tileIDToPlace;
+	}
+
-	private void DefaultToTorch(int tileStyleToPlace, bool allowWaterPlacement = false)
+	internal void DefaultToTorch(int tileStyleToPlace, bool allowWaterPlacement = false)
 	{
 		flame = true;
 		noWet = !allowWaterPlacement;
@@ -46939,11 +_,30 @@
 		useTime = 10;
 	}
 
+	/// <inheritdoc cref="DefaultToPlaceableTile(ushort, int)"/>
 	public void DefaultToPlaceableTile(int tileIDToPlace, int tileStyleToPlace = 0)
 	{
 		DefaultToPlaceableTile((ushort)tileIDToPlace, tileStyleToPlace);
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to items that place tiles.<br/>
+	/// Specifically:<code>
+	/// createTile = tileIDToPlace;
+	/// placeStyle = tileStyleToPlace;
+	/// width = 14;
+	/// height = 14;
+	/// useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	/// useAnimation = 15;
+	/// useTime = 10;
+	/// maxStack = <see cref="CommonMaxStack"/>;
+	/// useTurn = true;
+	/// autoReuse = true;
+	/// consumable = true;
+	/// </code>
+	/// </summary>
+	/// <param name="tileIDToPlace"></param>
+	/// <param name="tileStyleToPlace"></param>
 	public void DefaultToPlaceableTile(ushort tileIDToPlace, int tileStyleToPlace = 0)
 	{
 		createTile = tileIDToPlace;
@@ -46995,6 +_,27 @@
 		autoReuse = true;
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to food items.<br/>
+	/// Specifically: <code>
+	/// UseSound = useGulpSound ? Item3 : Item2;
+	/// useStyle = useGulpSound ? <see cref="ItemUseStyleID.DrinkLiquid"/> : <see cref="ItemUseStyleID.EatFood"/>;
+	/// useTurn = true;
+	/// useAnimation = useTime = animationTime;
+	/// maxStack = <see cref="CommonMaxStack"/>;
+	/// consumable = true;
+	/// buffType = <paramref name="foodbuff"/>;
+	/// buffTime = <paramref name="foodbuffduration"/>;
+	/// rare = <see cref="ItemRarityID.Blue"/>;
+	/// value = 20 silver;
+	/// </code>
+	/// </summary>
+	/// <param name="newwidth"></param>
+	/// <param name="newheight"></param>
+	/// <param name="foodbuff"></param>
+	/// <param name="foodbuffduration"></param>
+	/// <param name="useGulpSound">If true, the gulp sound is set, otherwise the crunch sound is set</param>
+	/// <param name="animationTime"></param>
 	public void DefaultToFood(int newwidth, int newheight, int foodbuff, int foodbuffduration, bool useGulpSound = false, int animationTime = 17)
 	{
 		if (useGulpSound)
@@ -47035,12 +_,18 @@
 		healLife = healingAmount;
 	}
 
+	/// <summary>
+	/// A helper method that sets item rarity (<see cref="Item.rare"/>) and item value (<see cref="Item.value"/>). 
+	/// </summary>
+	/// <param name="rarity"></param>
+	/// <param name="coinValue"></param>
 	public void SetShopValues(ItemRarityColor rarity, int coinValue)
 	{
 		rare = (int)rarity;
 		value = coinValue;
 	}
 
+	/// <summary>Modders should not use this.</summary>
 	public void DefaultToHeadgear(int newwidth, int newheight, int helmetArtID)
 	{
 		width = newwidth;
@@ -47065,7 +_,34 @@
 		useAnimation = (useTime = 12);
 	}
 
+	/// <summary>
+	/// This method sets a variety of Item values common to items that place music boxes.<br/>
+	/// Specifically:<code>
+	/// useStyle = <see cref="ItemUseStyleID.Swing"/>;
+	///	useTurn = true;
+	///	useAnimation = 15;
+	///	useTime = 10;
+	///	autoReuse = true;
+	///	consumable = true;
+	///	createTile = tileIDToPlace;
+	///	placeStyle = style;
+	///	width = 24;
+	///	height = 24;
+	///	rare = <see cref="ItemRarityID.LightRed"/>;
+	///	value = 100000;
+	///	accessory = true;
+	///	hasVanityEffects = true;
+	/// </code>
+	/// </summary>
+	/// <param name="tileIDToPlace"></param>
+	/// <param name="style"></param>
+	public void DefaultToMusicBox(int tileIDToPlace, int style = 0)
+	{
+		DefaultToMusicBox(style);
+		createTile = tileIDToPlace;
+	}
+
-	public void DefaultToMusicBox(int style)
+	internal void DefaultToMusicBox(int style)
 	{
 		useStyle = 1;
 		useTurn = true;
@@ -47088,6 +_,22 @@
 		SetDefaults(Type, noMatCheck: false, null);
 	}
 
+	// Added by TML.
+	public void CloneDefaults(int TypeToClone)
+	{
+		int originalType = type;
+		int originalNetID = netID;
+		var originalModItem = ModItem;
+		var originalGlobals = _globals;
+
+		SetDefaults(TypeToClone);
+
+		type = originalType;
+		netID = originalNetID;
+		ModItem = originalModItem;
+		_globals = originalGlobals;
+	}
+
 	public void SetDefaults(int Type, bool noMatCheck = false, ItemVariant variant = null)
 	{
 		if (Type < 0) {
@@ -47101,8 +_,11 @@
 			playerIndexTheItemIsReservedFor = Main.myPlayer;
 
 		ResetStats(Type);
+
+		/*
 		if (type >= ItemID.Count)
 			type = 0;
+		*/
 
 		if (variant == null)
 			variant = ItemVariants.SelectVariant(Type);
@@ -47133,7 +_,18 @@
 			SetDefaults5(type);
 		}
 
+		// Compensate for the change of itemAnimation getting reset at 0 instead of vanilla's 1.
+		ApplyItemAnimationCompensationsToVanillaItems();
+
+		// tML: make sure some vanilla balance doesn't get obliterated by attack speed changes
+		RestoreMeleeSpeedBehaviorOnVanillaItems();
+
+		// Set 'master' bool for vanilla items with master rarity.
+		if (type < ItemID.Count && rare == ItemRarityID.Master) {
+			master = true;
+		}
+
-		dye = (byte)GameShaders.Armor.GetShaderIdFromItemId(type);
+		dye = GameShaders.Armor.GetShaderIdFromItemId(type);
 		if (hairDye != 0)
 			hairDye = GameShaders.Hair.GetShaderIdFromItemId(type);
 
@@ -47297,19 +_,27 @@
 			maxStack = CommonMaxStack;
 
 		netID = type;
+
+		ItemLoader.SetDefaults(this);
+
 		if (!noMatCheck)
 			material = ItemID.Sets.IsAMaterial[type];
 
 		RebuildTooltip();
-		if (type > 0 && type < ItemID.Count && ItemID.Sets.Deprecated[type]) {
+		if (type > 0 && ItemID.Sets.Deprecated[type]) {
+			/*
 			netID = 0;
 			type = 0;
 			stack = 0;
+			*/
+			TurnToAir();
 		}
 	}
 
 	public void OnCreated(ItemCreationContext context)
 	{
+		ItemLoader.OnCreated(this, context);
+
 		if (type == 5437)
 			SetDefaults(5358);
 	}
@@ -47318,14 +_,32 @@
 	{
 		tooltipContext = -1;
 		BestiaryNotes = null;
+
+		// TML field initialization:
+		ModItem = null;
+		_globals = null;
+		StatsModifiedBy = new();
+		AllowReforgeForStackableItem = false;
+		useTurnOnAnimationStart = false;
+		attackSpeedOnlyAffectsWeaponAnimation = false;
+		useLimitPerAnimation = null;
+		consumeAmmoOnFirstShotOnly = false;
+		consumeAmmoOnLastShotOnly = false;
+		InterruptChannelOnHurt = false;
+		StopAnimationOnHurt = false;
+		DamageType = DamageClass.Default;
+		ChangePlayerDirectionOnShoot = true;
+
 		sentry = false;
 		hasVanityEffects = false;
 		DD2Summon = false;
 		shopSpecialCurrency = -1;
 		shopCustomPrice = null;
 		expert = false;
+		master = false; // Added by TML.
 		isAShopItem = false;
 		expertOnly = false;
+		masterOnly = false; // Added by TML.
 		instanced = false;
 		questItem = false;
 		fishingPole = 0;
@@ -47343,10 +_,14 @@
 		mech = false;
 		flame = false;
 		reuseDelay = 0;
+
+		/*
 		melee = false;
 		magic = false;
 		ranged = false;
 		summon = false;
+		*/
+
 		placeStyle = 0;
 		buffTime = 0;
 		buffType = 0;
@@ -47366,7 +_,7 @@
 		noUseGraphic = false;
 		lifeRegen = 0;
 		shootSpeed = 0f;
-		active = true;
+		active = Type != 0;
 		alpha = 0;
 		ammo = AmmoID.None;
 		useAmmo = AmmoID.None;
@@ -47426,6 +_,9 @@
 
 	public Color GetAlpha(Color newColor)
 	{
+		if (ItemLoader.GetAlpha(this, newColor) is Color modColor)
+			return modColor;
+
 		if (ItemID.Sets.BossBag[type])
 			return Color.Lerp(newColor, Color.White, 0.4f);
 
@@ -47623,6 +_,9 @@
 		return new Color(num, num2, num3, num4);
 	}
 
+	/// <summary>
+	/// Use to check if a mechanism is allowed to spawn an Item of the provided type at the provided world coordinates. Checks nearby area to see if the <see href="https://terraria.wiki.gg/wiki/Statues#Spawn_limits">Spawn Limits</see> have been reached.
+	/// </summary>
 	public static bool MechSpawn(float x, float y, int type)
 	{
 		int num = 0;
@@ -47649,7 +_,18 @@
 		return true;
 	}
 
+	/// <summary>
+	/// Converts the provided buy price into copper coins.
+	/// <br/> If assigned to <see cref="Item.value"/>, that item will be bought for the provided value.
+	/// </summary>
+	/// <returns>The converted value.</returns>
 	public static int buyPrice(int platinum = 0, int gold = 0, int silver = 0, int copper = 0) => copper + silver * 100 + gold * 100 * 100 + platinum * 100 * 100 * 100;
+
+	/// <summary>
+	/// Converts the provided sell value into copper coins. This value is five times larger than <see cref="buyPrice"/>.
+	/// <br/> If assigned to <see cref="Item.value"/>, that item will be sold for the provided value.
+	/// </summary>
+	/// <returns>The converted value.</returns>
 	public static int sellPrice(int platinum = 0, int gold = 0, int silver = 0, int copper = 0) => (copper + silver * 100 + gold * 100 * 100 + platinum * 100 * 100 * 100) * 5;
 
 	public bool CanShimmer()
@@ -47668,7 +_,7 @@
 		if (type == 3461 || createTile == 139)
 			flag = true;
 
-		if (!flag && ItemID.Sets.ShimmerTransformToItem[shimmerEquivalentType] <= 0 && FindDecraftAmount() <= 0 && !ItemID.Sets.CommonCoin[type])
+		if (!flag && ItemID.Sets.ShimmerTransformToItem[shimmerEquivalentType] <= 0 && FindDecraftAmount() <= 0 && ItemID.Sets.CoinLuckValue[type] <= 0)
 			return makeNPC > 0;
 
 		return true;
@@ -47723,7 +_,9 @@
 	{
 		int shimmerEquivalentType = GetShimmerEquivalentType();
 		int decraftingRecipeIndex = ShimmerTransforms.GetDecraftingRecipeIndex(shimmerEquivalentType);
-		if (ItemID.Sets.CommonCoin[shimmerEquivalentType]) {
+		if (ItemID.Sets.CoinLuckValue[shimmerEquivalentType] > 0) {
+			stack *= ItemID.Sets.CoinLuckValue[shimmerEquivalentType];
+			/*
 			switch (shimmerEquivalentType) {
 				case 72:
 					stack *= 100;
@@ -47737,6 +_,8 @@
 					stack *= 1000000;
 					break;
 			}
+			*/
+			// patch context for CoinLuckValue
 
 			Main.player[Main.myPlayer].AddCoinLuck(base.Center, stack);
 			NetMessage.SendData(146, -1, -1, null, 1, (int)base.Center.X, (int)base.Center.Y, stack);
@@ -47857,7 +_,7 @@
 			int num13 = FindDecraftAmount();
 			Recipe recipe = Main.recipe[decraftingRecipeIndex];
 			int num14 = 0;
-			bool flag = recipe.requiredItem[1].stack > 0;
+			bool flag = recipe.requiredItem.Count > 1;
 			IEnumerable<Item> enumerable = recipe.requiredItem;
 			if (recipe.customShimmerResults != null)
 				enumerable = recipe.customShimmerResults;
@@ -48004,7 +_,7 @@
 		if (Main.netMode == 1) {
 			int num = (int)(position.X + (float)(width / 2)) / 16;
 			int num2 = (int)(position.Y + (float)(height / 2)) / 16;
-			if (num >= 0 && num2 >= 0 && num < Main.maxTilesX && num2 < Main.maxTilesY && Main.tile[num, num2] == null) {
+			if (num >= 0 && num2 >= 0 && num < Main.maxTilesX && num2 < Main.maxTilesY && !Main.sectionManager.TileLoaded(num, num2)) {
 				gravity = 0f;
 				velocity.X = 0f;
 				velocity.Y = 0f;
@@ -48124,6 +_,8 @@
 			timeSinceItemSpawned += num7;
 		}
 
+		ItemLoader.PostUpdate(this);
+
 		if (Main.netMode == 2 && playerIndexTheItemIsReservedFor != Main.myPlayer) {
 			timeSinceTheItemHasBeenReservedForSomeone++;
 			if (timeSinceTheItemHasBeenReservedForSomeone >= 300) {
@@ -48274,7 +_,7 @@
 
 			NetMessage.SendData(21, -1, -1, null, i);
 		}
-		else if (playerIndexTheItemIsReservedFor == Main.myPlayer && rare == 0 && type >= 0 && type < ItemID.Count && !ItemID.Sets.IsLavaImmuneRegardlessOfRarity[type]) {
+		else if (playerIndexTheItemIsReservedFor == Main.myPlayer && rare == 0 && type >= 0 && !ItemID.Sets.IsLavaImmuneRegardlessOfRarity[type]) {
 			active = false;
 			type = 0;
 			stack = 0;
@@ -48285,6 +_,8 @@
 
 	private void MoveInWorld(float gravity, float maxFallSpeed, ref Vector2 wetVelocity, int i)
 	{
+		ItemLoader.Update(this, ref gravity, ref maxFallSpeed);
+
 		if (!shimmered && ItemID.Sets.ItemNoGravity[type]) {
 			velocity.X *= 0.95f;
 			if ((double)velocity.X < 0.1 && (double)velocity.X > -0.1)
@@ -48553,7 +_,7 @@
 		Rectangle hitbox = base.Hitbox;
 		for (int j = 0; j < 200; j++) {
 			NPC nPC = Main.npc[j];
-			if (nPC.active && flag && nPC.type >= 0 && nPC.type < NPCID.Count && NPCID.Sets.CanConvertIntoCopperSlimeTownNPC[nPC.type] && hitbox.Intersects(nPC.Hitbox)) {
+			if (nPC.active && flag && nPC.type >= 0 && NPCID.Sets.CanConvertIntoCopperSlimeTownNPC[nPC.type] && hitbox.Intersects(nPC.Hitbox)) {
 				flag3 = true;
 				NPC.TransformCopperSlime(j);
 				break;
@@ -48669,14 +_,26 @@
 				num2 *= 2;
 
 			if (num < (float)num2) {
+				if (!ItemLoader.CanStack(this, item))
+					continue;
+
+				if (!ItemLoader.CanStackInWorld(this, item))
+					continue;
+
 				position = (position + item.position) / 2f;
 				velocity = (velocity + item.velocity) / 2f;
+
+				ItemLoader.StackItems(this, item, out _);
+
+				/* #OnStackHook
 				int num3 = item.stack;
 				if (num3 > maxStack - stack)
 					num3 = maxStack - stack;
 
 				item.stack -= num3;
 				stack += num3;
+				*/
+
 				if (item.stack <= 0) {
 					item.SetDefaults();
 					item.active = false;
@@ -49077,21 +_,68 @@
 			case 4070:
 				return TextureAssets.Item[type].Frame(1, 4);
 			default:
+				/*
 				return TextureAssets.Item[type].Frame();
+				*/
+
+				// Notes:
+				//   If the item doesn't have an animation, "Main.itemAnimations[type]" is just null, so the code will default to Asset<Texture2D>.Frame(), which will just be what vanilla does.
+				//   However, if it does have an animation, then the source rect will be obtained from the animation instance, which is also what's used for displaying the animation
+				//   source rect for items in the inventory and dropped items in the world.  This source rect will then be the basis for the use item's hitbox, rather than the entire
+				//   spritesheet's size.
+				//     - absoluteAquarian
+				return Main.itemAnimations[type]?.GetFrame(TextureAssets.Item[type].Value) ?? TextureAssets.Item[type].Frame();
 		}
 	}
 
+	/// <summary>
+	/// <inheritdoc cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/>
+	/// <br/><br/>This particular overload uses two Vector2 to determine the actual spawn position.
+	/// </summary>
+	/// <returns><inheritdoc cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/></returns>
 	public static int NewItem(IEntitySource source, Vector2 pos, Vector2 randomBox, int Type, int Stack = 1, bool noBroadcast = false, int prefixGiven = 0, bool noGrabDelay = false, bool reverseLookup = false) => NewItem(source, (int)pos.X, (int)pos.Y, (int)randomBox.X, (int)randomBox.Y, Type, Stack, noBroadcast, prefixGiven, noGrabDelay, reverseLookup);
+
+	/// <summary>
+	/// <inheritdoc cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/>
+	/// <br/><br/>This particular overload uses a Vector2 instead of X and Y to determine the actual spawn position.
+	/// </summary>
+	/// <returns><inheritdoc cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/></returns>
 	public static int NewItem(IEntitySource source, Vector2 pos, int Width, int Height, int Type, int Stack = 1, bool noBroadcast = false, int prefixGiven = 0, bool noGrabDelay = false, bool reverseLookup = false) => NewItem(source, (int)pos.X, (int)pos.Y, Width, Height, Type, Stack, noBroadcast, prefixGiven, noGrabDelay, reverseLookup);
 
+	/// <summary>
+	/// Spawns an item into the game world with the given type and stack size. The X, Y, Width, and Height parameters dictate a rectangle, the item will be spawned centered within that rectangle. Other overloads support passing in a position directly, or just use 0 for Width and Height if the center is passed in a X and Y.
+	/// <br/> This method should not be called on multiplayer clients. If you need to spawn items from client code, use <see cref="Player.QuickSpawnItem(IEntitySource, int, int)"/> instead, it handles the multiplayer syncing code needed.
+	/// <br/> See the <paramref name="noBroadcast"/> documentation if you need to customize attached ModItem or GlobalItem data prior to syncing.
+	/// <br/> The source represents the entity causing this item to spawn. The return value is the index of the spawned Item within the <see cref="Main.item"/> array. 
+	/// </summary>
+	/// <param name="source"></param>
+	/// <param name="X"></param>
+	/// <param name="Y"></param>
+	/// <param name="Width"></param>
+	/// <param name="Height"></param>
+	/// <param name="Type">Either an <see cref="ItemID"/> entry or <see cref="ModContent.ItemType{T}"/>, for example <see cref="ItemID.IronskinPotion"/> or ModContent.ItemType&lt;MyModItem&gt;()</param>
+	/// <param name="Stack">Item stack</param>
+	/// <param name="noBroadcast">Controls whether an item spawned on a server is synced using <see cref="NetMessage.SendData"/> and <see cref="MessageID.SyncItem"/>. If false, the item will be synced. If true, the calling code can modify the item instance and then sync the item with <see cref="MessageID.SyncItem"/>. Has no effect except on server. NewItem running on multiplayer clients always needs to manually sync, see <see cref="Player.QuickSpawnItem(IEntitySource, int, int)"/> source code for an example.</param>
+	/// <param name="pfix"></param>
+	/// <param name="noGrabDelay"></param>
+	/// <param name="reverseLookup"></param>
+	/// <returns>The index of the item within <see cref="Main.item"/></returns>
 	public static int NewItem(IEntitySource source, int X, int Y, int Width, int Height, int Type, int Stack = 1, bool noBroadcast = false, int pfix = 0, bool noGrabDelay = false, bool reverseLookup = false)
 	{
+		return Item.NewItem_Inner(source, X, Y, Width, Height, null, Type, Stack, noBroadcast, pfix, noGrabDelay, reverseLookup);
+	}
+
+	private static int NewItem_Inner(IEntitySource source, int X, int Y, int Width, int Height, Item itemToClone, int Type, int Stack = 1, bool noBroadcast = false, int pfix = 0, bool noGrabDelay = false, bool reverseLookup = false)
+	{
 		if (WorldGen.gen)
 			return 0;
 
 		if (Main.rand == null)
 			Main.rand = new UnifiedRandom();
 
+		if (NPCLoader.blockLoot.Contains(Type) || newItemDisabled)
+			return Main.maxItems;
+
 		if (Main.tenthAnniversaryWorld) {
 			if (Type == 58) {
 				Type = Main.rand.NextFromList(new short[3] {
@@ -49126,7 +_,7 @@
 				Type = 1868;
 		}
 
-		if (Type > 0 && cachedItemSpawnsByType[Type] != -1) {
+		if (itemToClone == null && Type > 0 && cachedItemSpawnsByType[Type] != -1) {
 			cachedItemSpawnsByType[Type] += Stack;
 			return 400;
 		}
@@ -49139,9 +_,19 @@
 		Main.timeItemSlotCannotBeReusedFor[num] = 0;
 		Main.item[num] = new Item();
 		Item item = Main.item[num];
+
+		if (itemToClone != null) {
+			Main.item[num] = itemToClone.Clone();
+			item = Main.item[num];
+			Type = itemToClone.type; // just to be safe if IL edits change type swaps and velocity tweaks.
+			goto skipItemCreation;
+		}
+
 		item.SetDefaults(Type);
 		item.Prefix(pfix);
 		item.stack = Stack;
+		skipItemCreation:
+
 		item.position.X = X + Width / 2 - item.width / 2;
 		item.position.Y = Y + Height / 2 - item.height / 2;
 		item.wet = Collision.WetCollision(item.position, item.width, item.height);
@@ -49161,6 +_,8 @@
 		if (ItemSlot.Options.HighlightNewItems && item.type >= 0 && !ItemID.Sets.NeverAppearsAsNewInInventory[item.type])
 			item.newAndShiny = true;
 
+		ItemLoader.OnSpawn(item, source);
+
 		if (Main.netMode == 2 && !noBroadcast)
 			NetMessage.SendData(21, -1, -1, null, num, noGrabDelay.ToInt());
 		else if (Main.netMode == 0)
@@ -49240,8 +_,9 @@
 					continue;
 
 				Player.ItemSpaceStatus status = player.ItemSpace(Main.item[whoAmI]);
-				if (player.CanPullItem(Main.item[whoAmI], status)) {
+				if (ItemLoader.CanPickup(Main.item[whoAmI], player) && player.CanPullItem(Main.item[whoAmI], status)) {
 					float num3 = Math.Abs(player.position.X + (float)(player.width / 2) - position.X - (float)(width / 2)) + Math.Abs(player.position.Y + (float)(player.height / 2) - position.Y - (float)height);
+					/*
 					if (player.manaMagnet && (type == 184 || type == 1735 || type == 1868))
 						num3 -= (float)manaGrabRange;
 
@@ -49250,6 +_,9 @@
 
 					if (type == 4143)
 						num3 -= (float)manaGrabRange;
+					*/
+					// This will have grab range discrepancies with the above code due to this method having additional checks - Mutant
+					num3 -= player.GetItemGrabRange(Main.item[whoAmI]);
 
 					if (num2 > num3) {
 						num2 = num3;
@@ -49266,10 +_,30 @@
 		}
 	}
 
+
+	/*
 	public Item Clone() => (Item)MemberwiseClone();
+	*/
+	public Item Clone()
+	{
+		if (cloningDisabled != null)
+			throw new Exception(cloningDisabled);
+
+		Item newItem = (Item)MemberwiseClone();
+
+		newItem.ModItem = ModItem?.Clone(newItem);
+		newItem._globals = _globals?.Select(g => g?.Clone(this, newItem)).ToArray();
+
+		return newItem;
+	}
+
+	/*
 	public Item DeepClone() => (Item)MemberwiseClone();
+	*/
+	internal Item DeepClone() => Clone();
 
+	// TML: Made internal so that modders will have to replace it with a more straightforward item.type == compareItem.type
-	public bool IsTheSameAs(Item compareItem)
+	internal bool IsTheSameAs(Item compareItem)
 	{
 		if (netID == compareItem.netID)
 			return type == compareItem.type;
@@ -49277,7 +_,9 @@
 		return false;
 	}
 
+	// TML: Made internal + renamed in Item.TML.cs with more descriptive name (IsNotSameTypePrefixAndStack)
+	// Many usages replaced with !IsNetStateEquivalent
-	public bool IsNotTheSameAs(Item compareItem)
+	internal bool IsNotTheSameAs(Item compareItem)
 	{
 		if (netID == compareItem.netID && stack == compareItem.stack)
 			return prefix != compareItem.prefix;
@@ -49285,11 +_,18 @@
 		return true;
 	}
 
+	/// <summary>
+	/// Overrides the value of <see cref="Name"/>.
+	/// </summary>
+	/// <param name="name">The new name of this <see cref="Item"/>.</param>
 	public void SetNameOverride(string name)
 	{
 		_nameOverride = name;
 	}
 
+	/// <summary>
+	/// Clears the overridden value of <see cref="Name"/>.
+	/// </summary>
 	public void ClearNameOverride()
 	{
 		_nameOverride = null;
@@ -49309,6 +_,10 @@
 		dye = 0;
 		shoot = 0;
 		mountType = -1;
+		active = false;
+
+		ModItem = null;
+		_globals = null;
 	}
 
 	public void OnPurchase(Item item)
@@ -49330,9 +_,9 @@
 	public void Serialize(BinaryWriter writer, ItemSerializationContext context)
 	{
 		if (context == ItemSerializationContext.SavingAndLoading) {
-			writer.Write(netID);
+			writer.Write(netID >= ItemID.Count ? 0 : netID);
 			writer.Write(stack);
-			writer.Write(prefix);
+			ItemIO.WriteByteVanillaPrefix(this, writer);
 		}
 	}
 
@@ -49344,7 +_,7 @@
 			Prefix(reader.ReadByte());
 		}
 
-		if (type >= ItemID.Count)
+		if (type >= ItemLoader.ItemCount)
 			TurnToAir();
 	}
 
@@ -49359,6 +_,7 @@
 	public void Refresh(bool onlyIfVariantChanged = true)
 	{
 		if (!IsAir && (!onlyIfVariantChanged || ItemVariants.SelectVariant(type) != Variant)) {
+			/*
 			bool flag = favorited;
 			int num = stack;
 			int num2 = netID;
@@ -49367,6 +_,13 @@
 			Prefix(prefixWeWant);
 			stack = num;
 			favorited = flag;
+			*/
+
+			//TODO: Could speed this up by reusing the memory stream, reader and writer, perhaps with a `ThreadLocalCache`?
+			using var ms = new MemoryStream(64);
+			ItemIO.Send(this, new BinaryWriter(ms), writeStack: true, writeFavorite: true);
+			ms.Position = 0;
+			ItemIO.Receive(this, new BinaryReader(ms), readStack: true, readFavorite: true);
 		}
 	}
 }
