--- src/TerrariaNetCore/Terraria/Localization/LocalizedText.cs
+++ src/tModLoader/Terraria/Localization/LocalizedText.cs
@@ -1,15 +_,27 @@
+using System;
+using System.Collections.Generic;
 using System.ComponentModel;
 using System.Text.RegularExpressions;
 
 namespace Terraria.Localization;
 
-public class LocalizedText
+public partial class LocalizedText
 {
 	public static readonly LocalizedText Empty = new LocalizedText("", "");
 	private static Regex _substitutionRegex = new Regex("{(\\?(?:!)?)?([a-zA-Z][\\w\\.]*)}", RegexOptions.Compiled);
 	public readonly string Key;
-
+	
+	/*
 	public string Value { get; private set; }
+	*/
+	private string _value;
+	public string Value {
+		get => _value;
+		private set {
+			_value = value;
+			_hasPlurals = null;
+		}
+	}
 
 	internal LocalizedText(string key, string text)
 	{
@@ -22,6 +_,15 @@
 		Value = text;
 	}
 
+	/// <summary>
+	/// Formats this <see cref="LocalizedText"/> using an anonymous type or dictionary.
+	/// <br/> If <paramref name="obj"/> is an <see cref="IDictionary{TKey, TValue}">IDictionary&lt;string, object&gt;</see>, then formatting placeholders will be keys to this dictionary.
+	/// <br/> Otherwise, formatting placeholders will be property names on <paramref name="obj"/>.
+	/// <br/> For each key <c>K</c> with value <c>V</c>, any substring in the localized text of form <c>{P}</c> will be replaced with <c>(V ?? "").ToString()</c>.
+	/// <br/> <b>All key names must start with a letter a-z</b>, followed by any combination of letters, numbers, underscores, and periods.
+	/// </summary>
+	/// <param name="obj">The set of substitutions.</param>
+	/// <returns>The formatted string.</returns>
 	public string FormatWith(object obj)
 	{
 		string value = Value;
@@ -31,16 +_,33 @@
 				return "";
 
 			string name = match.Groups[2].ToString();
+			/*
 			PropertyDescriptor propertyDescriptor = properties.Find(name, ignoreCase: false);
 			return (propertyDescriptor == null) ? "" : (propertyDescriptor.GetValue(obj) ?? "").ToString();
+			*/
+			return !GetValueFromSubstitution(properties, obj, name, out object value) ? "" : (value ?? "").ToString(); // #ModdedDialogueSubstitutions: Added support for Dictionary<string, object>.
 		});
 	}
 
+	/// <summary>
+	/// Determines if this <see cref="LocalizedText"/> can be formatted using an anonymous type or a dictionary.
+	/// <br/> If <paramref name="obj"/> is an <see cref="IDictionary{TKey, TValue}">IDictionary&lt;string, object&gt;</see>, then formatting placeholders will be keys to this dictionary.
+	/// <br/> Otherwise, formatting placeholders will be property names on <paramref name="obj"/>.
+	/// <br/> A <see cref="LocalizedText"/> can be formatted if:
+	/// <list type="bullet">
+	/// <item>Every substring of the text in form <c>{?Name}</c> has a property <c>Name</c> in <paramref name="obj"/> which is a <see cref="bool"/> with the value <see langword="true"/>.</item>
+	/// <item>Every substring of the text in form <c>{?!Name}</c> has a property <c>Name</c> in <paramref name="obj"/> which is a <see cref="bool"/> with the value <see langword="false"/>.</item>
+	/// <item>Every substring of the text in form <c>{Name}</c> has a property <c>Name</c> in <paramref name="obj"/> which is not <see langword="null"/>.</item>
+	/// </list>
+	/// </summary>
+	/// <param name="obj">The set of substitutions.</param>
+	/// <returns><see langword="true"/> if all conditions pass, <see langword="false"/> otherwise.</returns>
 	public bool CanFormatWith(object obj)
 	{
 		PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(obj);
 		foreach (Match item in _substitutionRegex.Matches(Value)) {
 			string name = item.Groups[2].ToString();
+			/*
 			PropertyDescriptor propertyDescriptor = properties.Find(name, ignoreCase: false);
 			if (propertyDescriptor == null)
 				return false;
@@ -48,6 +_,9 @@
 			object value = propertyDescriptor.GetValue(obj);
 			if (value == null)
 				return false;
+			*/
+			if (!GetValueFromSubstitution(properties, obj, name, out object value)) // #ModdedDialogueSubstitutions: Added support for Dictionary<string, object>.
+				return false;
 
 			if (item.Groups[1].Length != 0 && (((value as bool?) ?? false) ^ (item.Groups[1].Length == 1)))
 				return false;
@@ -64,9 +_,12 @@
 		return text.Value;
 	}
 
+	/*
 	public string Format(object arg0) => string.Format(Value, arg0);
 	public string Format(object arg0, object arg1) => string.Format(Value, arg0, arg1);
 	public string Format(object arg0, object arg1, object arg2) => string.Format(Value, arg0, arg1, arg2);
 	public string Format(params object[] args) => string.Format(Value, args);
+	*/
+
 	public override string ToString() => Value;
 }
