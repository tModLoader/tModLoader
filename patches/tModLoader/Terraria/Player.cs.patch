--- src/TerrariaNetCore/Terraria/Player.cs
+++ src/tModLoader/Terraria/Player.cs
@@ -1,6 +_,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Security.Cryptography;
 using System.Text;
 using Microsoft.Xna.Framework;
@@ -28,6 +_,10 @@
 using Terraria.ID;
 using Terraria.IO;
 using Terraria.Localization;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Exceptions;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
 using Terraria.ObjectData;
 using Terraria.Social;
 using Terraria.UI;
@@ -35,10 +_,11 @@
 using Terraria.UI.Gamepad;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using LegacySoundStyle = Terraria.Audio.SoundStyle;
 
 namespace Terraria;
 
-public class Player : Entity, IFixLoadedData
+public partial class Player : Entity, IFixLoadedData
 {
 	public static class BuilderAccToggleIDs
 	{
@@ -252,20 +_,33 @@
 		public static void PlayerConnect(int playerIndex)
 		{
 			PressurePlateHelper.ResetPlayer(playerIndex);
+
+			PlayerLoader.PlayerConnect(playerIndex);
 		}
 
 		public static void PlayerDisconnect(int playerIndex)
 		{
 			PressurePlateHelper.ResetPlayer(playerIndex);
+
+			PlayerLoader.PlayerDisconnect(playerIndex);
 		}
 
 		public static void EnterWorld(int playerIndex)
 		{
+			Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", Main.ActivePlayerFileData.Name, Main.ActivePlayerFileData.IsCloudSave, Main.maxTilesX, Main.maxTilesY, WorldGen.crimson.ToInt(), Main.GameMode);
+			Interface.ResetData();
+
 			if (Hooks.OnEnterWorld != null)
 				Hooks.OnEnterWorld(Main.player[playerIndex]);
 
+			PlayerLoader.OnEnterWorld(playerIndex);
+
-			if (playerIndex == Main.myPlayer)
+			if (playerIndex == Main.myPlayer) {
 				Main.ToggleGameplayUpdates(state: true);
+
+				// Added by TML.
+				Social.Steam.SteamedWraps.BeginPlaytimeTracking();
+			}
 		}
 	}
 
@@ -475,7 +_,7 @@
 
 	public int emoteTime;
 	public CreativeUnlocksTracker creativeTracker;
-	private static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
+	internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
 	public OverheadMessage chatOverhead;
 	public SelectionRadial DpadRadial = new SelectionRadial();
 	public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);
@@ -484,7 +_,7 @@
 	public int HotbarOffset;
 	public bool GoingDownWithGrapple;
 	public byte spelunkerTimer;
-	public bool[] hideInfo = new bool[13];
+	public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];
 	public int[] builderAccStatus = new int[BuilderAccToggleIDs.Count];
 	public long lostCoins;
 	public string lostCoinString = "";
@@ -496,10 +_,18 @@
 	private static float _blizzardSoundVolume;
 	private static SlotId _strongBlizzardSound = SlotId.Invalid;
 	private static SlotId _insideBlizzardSound = SlotId.Invalid;
+
+	/// <summary>
+	/// This player's displayed name.
+	/// <br/> Usually capped at 20 characters.
+	/// </summary>
 	public string name = "";
 	public int taxMoney;
+
+	//TML: Both fields turned from int to double.
-	public int taxTimer;
+	public double taxTimer;
-	public static int taxRate = 3600;
+	public static double taxRate = 3600;
+
 	public int numberOfDeathsPVE;
 	public int numberOfDeathsPVP;
 	public static int crystalLeafDamage = 100;
@@ -589,10 +_,40 @@
 	public int ropeCount;
 	public int manaRegenBonus;
 	public float manaRegenDelayBonus;
+
+	/// <summary>
+	/// The current vanilla dash that the player is using.<br/>
+	/// The following values correspond to vanilla dashes:<br/>
+	/// 1 => Tabi / Master Ninja Gear<br/>
+	/// 2 => Shield of Cthulhu<br/>
+	/// 3 => Solar Flare armor set bonus<br/>
+	/// 4 => Unused, though a dash for this value DOES exist<br/>
+	/// 5 => Crystal Assassin set bonus<br/>
+	/// </summary>
 	public int dashType;
+
+	/// <summary>
+	/// The current vanilla dash that the player is VISIBLY using.<br/>
+	/// Unlike <see cref="dashType"/>, this does not update if a dash cannot currently be input.<br/>
+	/// </summary>
 	public int dash;
+
+	/// <summary>
+	/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br/>
+	/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br/>
+	/// </summary>
 	public int dashTime;
+
+	/// <summary>
+	/// The amount of time that has passed, in ticks, since this player last performed a dash.
+	/// </summary>
 	public int timeSinceLastDashStarted;
+
+	/// <summary>
+	/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br/>
+	/// For the first frame of any given dash, this is set to -1. After that frame has passsed, it is set to 20 ticks, or 1/3 of a second.<br/>
+	/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br/>
+	/// </summary>
 	public int dashDelay;
 	public int eocDash;
 	public int eocHit;
@@ -601,6 +_,24 @@
 	public int gem = -1;
 	public int gemCount;
 	public BitsByte ownedLargeGems;
+
+	/// <summary>
+	/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br/>
+	/// Defaults to 0, which denotes that the player does not currently have a flask active.<br/>
+	/// The following values correspond to vanilla flasks:<br/>
+	/// 1 => Flask of Venom (affected weapons proc Acid Venom on hit)<br/>
+	/// 2 => Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br/>
+	/// 3 => Flask of Fire (affected weapons proc On Fire! on hit)<br/>
+	/// 4 => Flask of Gold (affected weapons proc Midas on hit)<br/>
+	/// 5 => Flask of Ichor (affected weapons proc Ichor on hit)<br/>
+	/// 6 => Flask of Nanites (affected weapons proc Confused on hit)<br/>
+	/// 7 => Flask of Party (affected weapons sometimes release confetti explosions on hit)<br/>
+	/// 8 => Flask of Poison (affected weapons proc Poisoned on hit)<br/>
+	/// </summary>
+	// TODO:
+	// Transform to int later, make proper flask effect system maybe?
+	// Concrete use cases exist. Just gotta find a way to make a system for them intuitive.
+	// - Thomas
 	public byte meleeEnchant;
 	public byte pulleyDir;
 	public bool pulley;
@@ -612,6 +_,13 @@
 	public int snowBallLauncherInteractionCooldown;
 	public bool iceSkate;
 	public bool carpet;
+
+	/// <summary>
+	/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br/>
+	/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br/>
+	/// A value of 1 causes the player to slowly slide down them while holding onto them.<br/>
+	/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
+	/// </summary>
 	public int spikedBoots;
 	public int carpetFrame = -1;
 	public float carpetFrameCounter;
@@ -635,11 +_,22 @@
 	public bool dangerSense;
 	public byte luckPotion;
 	public byte oldLuckPotion;
+
+	/// <summary>
+	/// The percent of damage this player should resist.
+	/// <br/> Has a soft cap of <c>1f</c>. Cannot reduce taken damage below <c>1</c>.
+	/// </summary>
 	public float endurance;
 	public float whipRangeMultiplier;
+	/*
 	public float whipUseTimeMultiplier;
+	*/
 	public bool loveStruck;
 	public bool stinky;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player will take 30% less damage from any NPC with <see cref="NPC.coldDamage"/> set and any projectile with <see cref="Projectile.coldDamage"/> set.
+	/// </summary>
 	public bool resistCold;
 	public bool electrified;
 	public bool dryadWard;
@@ -664,10 +_,19 @@
 	public int fishingSkill;
 	public bool cratePotion;
 	public bool sonarPotion;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player's fishing line will never break.
+	/// </summary>
 	public bool accFishingLine;
 	public bool accFishingBobber;
 	public bool accTackleBox;
 	public bool accLavaFishing;
+
+	/// <summary>
+	/// The maximum value of minions this player can have summoned at once.
+	/// <br/> A minion's value is stored as <see cref="Projectile.minionSlots"/>.
+	/// </summary>
 	public int maxMinions = 1;
 	public int numMinions;
 	public float slotsMinions;
@@ -731,6 +_,11 @@
 	public bool defendedByPaladin;
 	public bool hasPaladinShield;
 	public float[] speedSlice = new float[60];
+
+	/// <summary>
+	/// The sum of the <see cref="NPC.npcSlots"/> of all town NPCs near this player.
+	/// <br/> If <c><see cref="townNPCs"/> &gt; 2f</c>, then this player is in a town.
+	/// </summary>
 	public float townNPCs;
 	public double headFrameCounter;
 	public double bodyFrameCounter;
@@ -781,9 +_,34 @@
 	public bool poundRelease;
 	public float ghostFade;
 	public float ghostDir = 1f;
+
+	/*
 	public static readonly int maxBuffs = 44;
+	*/
+	internal static int maxBuffs => 44 + BuffLoader.extraPlayerBuffCount;
+	public static int MaxBuffs => maxBuffs;
+
+	/// <summary>
+	/// The <see cref="BuffID"/>s of all buffs this player has active.
+	/// <br/> A value of <c>0</c> means that buff slot is empty.
+	/// <br/> Buff times are stored with the same index in <see cref="buffTime"/>.
+	/// <br/> <see cref="AddBuff(int, int, bool, bool)"/>, <see cref="ClearBuff(int)"/>, and <see cref="DelBuff(int)"/> should be used to manipulate player buffs.
+	/// </summary>
 	public int[] buffType = new int[maxBuffs];
+
+	/// <summary>
+	/// The remaining durations in ticks of all buffs this player has active.
+	/// <br/> A value of <c>0</c> means that buff slot is empty.
+	/// <br/> Buff types are stored with the same index in <see cref="buffType"/>.
+	/// <br/> <see cref="AddBuff(int, int, bool, bool)"/>, <see cref="ClearBuff(int)"/>, and <see cref="DelBuff(int)"/> should be used to manipulate player buffs.
+	/// </summary>
 	public int[] buffTime = new int[maxBuffs];
+
+	/// <summary>
+	/// Indexed by <see cref="BuffID"/>. If <see langword="true"/> for a given <see cref="BuffID"/>, then this player cannot be inflicted with that buff.
+	/// <br/> Additionally, if the player is inflicted with that buff and becomes immune to it, the buff will be cleared.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool[] buffImmune = new bool[BuffID.Count];
 	public int heldProj = -1;
 	public int breathCD;
@@ -813,6 +_,10 @@
 	public bool isHatRackDoll;
 	public bool isFirstFractalAfterImage;
 	public float firstFractalAfterImageOpacity;
+
+	/// <summary>
+	/// The text that is shown on armor (<see cref="Item.wornArmor"/>) with an active set bonus.
+	/// </summary>
 	public string setBonus = "";
 	public Item[] inventory = new Item[59];
 	public bool[] inventoryChestStack = new bool[59];
@@ -853,6 +_,7 @@
 	public int head = -1;
 	public int body = -1;
 	public int legs = -1;
+	/* sbyte -> int
 	public sbyte handon = -1;
 	public sbyte handoff = -1;
 	public sbyte back = -1;
@@ -869,6 +_,23 @@
 	public sbyte faceFlower = -1;
 	public sbyte balloonFront = -1;
 	public sbyte beard = -1;
+	*/
+	public int handon = -1;
+	public int handoff = -1;
+	public int back = -1;
+	public int front = -1;
+	public int shoe = -1;
+	public int waist = -1;
+	public int shield = -1;
+	public int neck = -1;
+	public int face = -1;
+	public int balloon = -1;
+	public int backpack = -1;
+	public int tail = -1;
+	public int faceHead = -1;
+	public int faceFlower = -1;
+	public int balloonFront = -1;
+	public int beard = -1;
 	public bool[] hideVisibleAccessory = new bool[10];
 	public BitsByte hideMisc = (byte)0;
 	public Rectangle headFrame;
@@ -943,6 +_,11 @@
 	public Vector2[] shadowOrigin = new Vector2[3];
 	public int[] shadowDirection = new int[3];
 	public int shadowCount;
+
+	/// <summary>
+	/// The percent of mana actually used when mana is consumed.
+	/// <br/> Cannot reduce an item's mana cost below <c>0</c>.
+	/// </summary>
 	public float manaCost = 1f;
 	public bool fireWalk;
 	public bool channel;
@@ -961,16 +_,78 @@
 	public int golferScoreAccumulated;
 	public int bartenderQuestLog;
 	public bool downedDD2EventAnyDifficulty;
+
+	/*
 	public int armorPenetration;
-	public int statDefense;
+	*/
+	internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);
+
+	public DefenseStat statDefense; // changed from int
+	public MultipliableFloat DefenseEffectiveness; // added by TML
+
+	/// <summary>
+	/// The maximum health this player can have without adjustment.
+	/// <br/> You should <strong>not</strong> modify this value. If you need to increase max health for equipment, modify <see cref="statLifeMax2"/>. If you need to increase max health for a permanent stat boost, use <see cref="ModPlayer.ModifyMaxStats(out StatModifier, out StatModifier)"/>.
+	/// </summary>
 	public int statLifeMax = 100;
+
+	/// <summary>
+	/// The maximum health this player can have, adjusted by buffs and equipment.
+	/// </summary>
 	public int statLifeMax2 = 100;
+
+	/// <summary>
+	/// The current health of this player. Capped at <see cref="statLifeMax2"/>.
+	/// <br/> If you increase this value, be sure to respect the cap.
+	/// </summary>
+	/// <remarks>
+	/// If you want to heal the player with the green text effect, use <see cref="Player.Heal(int)"/>.
+	/// <br/> If you want to hurt the player, use <see cref="Hurt"/>.
+	/// </remarks>
 	public int statLife = 100;
+
+	/// <summary>
+	/// The current mana of this player. Capped at <see cref="statManaMax2"/>.
+	/// <br/> If you increase this value, be sure to respect the cap.
+	/// </summary>
+	/// <remarks>
+	/// If you want to use mana, use <see cref="Player.CheckMana(Item, int, bool, bool)"/> or its overload.
+	/// </remarks>
 	public int statMana;
+
+	/// <summary>
+	/// The maximum mana this player can have without adjustment.
+	/// <br/> You should <strong>not</strong> modify this value. If you need to increase max mana for equipment, modify <see cref="statManaMax2"/>. If you need to increase max mana for a permanent stat boost, use <see cref="ModPlayer.ModifyMaxStats(out StatModifier, out StatModifier)"/>.
+	/// </summary>
 	public int statManaMax;
+
+	/// <summary>
+	/// The maximum mana this player can have, adjusted by buffs and equipment.
+	/// </summary>
 	public int statManaMax2;
+
+	/// <summary>
+	/// The rate of this player's life regeneration in health/ticks, divided by <c>120</c>.
+	/// <br/> For example, adding <c>10</c> to this value regenerates <c>10 / 120</c> = <c>1/6</c> health per tick, or 5 health per second.
+	/// <br/> Life regeneration is accumulated every tick in <see cref="lifeRegenCount"/>.
+	/// <br/> This value should be subtracted from in <see cref="ModPlayer.UpdateBadLifeRegen"/> and added to in <see cref="ModPlayer.UpdateLifeRegen"/>.
+	/// </summary>
 	public int lifeRegen;
+
+	/// <summary>
+	/// This player's accumulated life regeneration.
+	/// <br/> If this value reaches or exceeds <c>120</c>, the player gains <c><see cref="lifeRegenCount"/> / 120</c> health and this value decreases until it no longer exceeds <c>120</c>.
+	/// <br/> If this value reaches or exceeds <c>-120</c>, the player loses health in the same way.
+	/// </summary>
 	public int lifeRegenCount;
+
+	/// <summary>
+	/// How effective this player's natural life regeneration should be. Resets whenever the player is hurt, increases over time.
+	/// <br/> Certain effects increase this value to increase
+	/// </summary>
+	/// <remarks>
+	/// Use <see cref="ModPlayer.NaturalLifeRegen(ref float)"/> to directly modify natural life regeneration.
+	/// </remarks>
 	public float lifeRegenTime;
 	public int manaRegen;
 	public int manaRegenCount;
@@ -993,6 +_,10 @@
 	public bool ammoBox;
 	public bool ammoPotion;
 	public bool chaosState;
+
+	/// <summary>
+	/// If <see langword="true"/>, then the bees created by <see cref="honeyCombItem"/> have a chance to be stronger.
+	/// </summary>
 	public bool strongBees;
 	public bool sporeSac;
 	public bool shinyStone;
@@ -1019,7 +_,15 @@
 	public int overrideFishingBobber = -1;
 	public bool unlockedBiomeTorches;
 	public bool ateArtisanBread;
+
+	/// <summary>
+	/// If <see langword="true"/>, then this player has permanently buffed their minecarts. See <see cref="UsingSuperCart"/> for more info.
+	/// </summary>
 	public bool unlockedSuperCart;
+
+	/// <summary>
+	/// If <see langword="true"/>, then this player has the effects of the Super Cart enabled. See <see cref="UsingSuperCart"/> for more info.
+	/// </summary>
 	public bool enabledSuperCart = true;
 	public bool suspiciouslookingTentacle;
 	public bool crimsonHeart;
@@ -1053,6 +_,11 @@
 	public bool cartFlip;
 	public float trackBoost;
 	public Vector2 lastBoost = Vector2.Zero;
+
+	/// <summary>
+	/// This player's <see cref="Mount"/>.
+	/// <br/> <strong>Do not overwrite this value.</strong> Instead, call <see cref="Mount.SetMount(int, Player, bool)"/> or <see cref="Mount.Dismount(Player)"/> on it.
+	/// </summary>
 	public Mount mount;
 	public bool blackCat;
 	public bool spider;
@@ -1194,21 +_,63 @@
 	public bool parryDamageBuff;
 	public bool ballistaPanic;
 	public bool JustDroppedAnItem;
+	/*
 	public int meleeCrit = 4;
 	public int magicCrit = 4;
 	public int rangedCrit = 4;
+	*/
+	internal ref float allCrit => ref GetCritChance(DamageClass.Generic); //TML: New.
+	internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);
+	internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);
+	internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);
+
+	/*
 	public float meleeDamage = 1f;
 	public float magicDamage = 1f;
 	public float rangedDamage = 1f;
 	public float rangedMultDamage = 1f;
+	*/
+	internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic); //TML: New.
+	internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);
+	internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);
+	internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);
+
+	/*
 	public float arrowDamageAdditiveStack;
+	*/
+	private ref StatModifier arrowDamageAdditiveStack => ref arrowDamage;
+
+	/*
 	public float arrowDamage = 1f;
 	public float bulletDamage = 1f;
 	public float rocketDamage = 1f;
 	public float minionDamage = 1f;
+	*/
+	public StatModifier arrowDamage = StatModifier.Default;
+	public StatModifier bulletDamage = StatModifier.Default;
+	public StatModifier rocketDamage = StatModifier.Default;
+	internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);
+
+	/*
 	public float minionKB;
 	public float meleeSpeed = 1f;
+	*/
+	internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic); //TML: New.
+	internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;
+	internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);
+	// TML: meleeSpeed is now a damage multiplier, so inverseMeleeSpeed is the useTime multiplier.
+	// By using GetTotalAttackSpeed we also incorporate anyone that adds attackSpeed to the Generic damage class.
+	internal float inverseMeleeSpeed => 1 / GetTotalAttackSpeed(DamageClass.Melee);
+
+	/*
 	public float summonerWeaponSpeedBonus;
+	*/
+	internal ref float summonerWeaponSpeedBonus => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);
+
+	// TML: Should these be StatModifiers?
+	/// <summary>
+	/// The multiplier on this player's <see cref="maxRunSpeed"/> and <see cref="runAcceleration"/>.
+	/// </summary>
 	public float moveSpeed = 1f;
 	public float pickSpeed = 1f;
 	public float wallSpeed = 1f;
@@ -1231,24 +_,61 @@
 	public static int tileTargetY;
 	public static float defaultGravity = 0.4f;
 	public static int jumpHeight = 15;
+
+	/// <summary>
+	/// The speed, in pixels/tick, that this players jumps at.
+	/// </summary>
 	public static float jumpSpeed = 5.01f;
 	public float gravity = defaultGravity;
 	public float maxFallSpeed = 10f;
+
+	/// <summary>
+	/// The maximum speed, in pixels/tick, that this player can reach by just running.
+	/// </summary>
+	/// <remarks>To apply a global run speed modifier, use <see cref="moveSpeed"/>.</remarks>
 	public float maxRunSpeed = 3f;
+
+	/// <summary>
+	/// The acceleration, in pixels/ticks^2, that this player experiences while running.
+	/// </summary>
+	/// <remarks>To apply a global run speed modifier, use <see cref="moveSpeed"/>.</remarks>
 	public float runAcceleration = 0.08f;
 	public float runSlowdown = 0.2f;
 	public bool adjWater;
 	public bool adjHoney;
+	public bool adjShimmer;
 	public bool adjLava;
 	public bool oldAdjWater;
 	public bool oldAdjHoney;
 	public bool oldAdjLava;
-	public bool[] adjTile = new bool[TileID.Count];
-	public bool[] oldAdjTile = new bool[TileID.Count];
+	public bool oldAdjShimmer;
+
+	private bool[] _adjTile = new bool[TileLoader.TileCount];
+	public bool[] adjTile {
+		get {
+			if (_adjTile.Length != TileLoader.TileCount)
+				Array.Resize(ref _adjTile, TileLoader.TileCount);
+
+			return _adjTile;
+		}
+		set => _adjTile = value;
+	}
+
+	private bool[] _oldAdjTile = new bool[TileLoader.TileCount];
+	public bool[] oldAdjTile {
+		get {
+			if (_oldAdjTile.Length != TileLoader.TileCount)
+				Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
+
+			return _oldAdjTile;
+		}
+		set => _oldAdjTile = value;
+	}
+
 	public static int defaultItemGrabRange = 42;
 	private static float itemGrabSpeed = 0.45f;
 	private static float itemGrabSpeedMax = 4f;
-	public byte hairDye;
+	public int hairDye; //TML: Changed from byte to int.
 	public Color hairDyeColor = Color.Transparent;
 	public float hairDyeVar;
 	public int skinDyePacked;
@@ -1330,7 +_,18 @@
 	public bool isPerformingPogostickTricks;
 	public bool autoJump;
 	public bool justJumped;
+
+	/// <summary>
+	/// How much to directly increase <see cref="jumpSpeed"/>, in pixels/tick.
+	/// </summary>
 	public float jumpSpeedBoost;
+
+	/// <summary>
+	/// The number of extra tiles this player can fall before they start taking fall damage.
+	/// </summary>
+	/// <remarks>
+	/// If you want to prevent fall damage entirely, use <see cref="noFallDmg"/>.
+	/// </remarks>
 	public int extraFall;
 	public bool canFloatInWater;
 	public bool hasFloatingTube;
@@ -1351,6 +_,10 @@
 	public int vanityRocketBoots;
 	public bool canRocket;
 	public bool jumpBoost;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player will take no fall damage.
+	/// </summary>
 	public bool noFallDmg;
 	public int swimTime;
 	public bool killGuide;
@@ -1397,6 +_,10 @@
 	public int forcedGravity;
 	public bool gravControl;
 	public bool gravControl2;
+
+	/// <summary>
+	/// If not <see langword="null"/>, this player will create damaging bee projectiles when taking damage.
+	/// </summary>
 	public Item honeyCombItem;
 	public int wireOperationsCooldown;
 	public int lastChest;
@@ -1507,7 +_,7 @@
 	private int[] unlitTorchY = new int[maxTorchAttacks];
 	private static int[] _torchAttackPosX = new int[400];
 	private static int[] _torchAttackPosY = new int[400];
-	public int ladyBugLuckTimeLeft;
+	public double ladyBugLuckTimeLeft; //TML: Changed from int to double.
 	public float luck;
 	public float luckMinimumCap = -0.7f;
 	public float luckMaximumCap = 1f;
@@ -1558,7 +_,7 @@
 	private const int SaveSlotIndex_GuideItem = 2;
 	private const int SaveSlotIndex_TinkererItem = 3;
 	private const int SaveSlotIndexCount = 4;
-	private Item[] _temporaryItemSlots = new Item[4];
+	internal Item[] _temporaryItemSlots = new Item[4];
 	private static readonly PlayerFileData _visualCloneDummyData = new PlayerFileData();
 	private static readonly MemoryStream _visualCloneStream = new MemoryStream();
 	private static readonly BinaryWriter _visualCloneWriter = new BinaryWriter(_visualCloneStream);
@@ -1640,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// Returns the player's center adjusted for mount and step stool usage. Typically used in conjuction with <see cref="RotatedRelativePoint(Vector2, bool, bool)"/> to retrieve a suitable position for positioning items and effects originating from the player.
+	/// </summary>
 	public Vector2 MountedCenter {
 		get {
 			return new Vector2(position.X + (float)(width / 2), position.Y + 21f + HeightOffsetHitboxCenter);
@@ -1823,6 +_,10 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is the top 35% of the world.
+	/// <br/> <strong>NOTE:</strong> Vanilla uses a lot of different conditions for what counts as space. This flag is never used in vanilla, but the logc behind it is used for NPC shops and enemy spawns.
+	/// </summary>
 	public bool ZoneSkyHeight {
 		get {
 			return zone3[0];
@@ -1832,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is above ground (<see cref="Main.worldSurface"/>) but not in space (<see cref="ZoneSkyHeight"/>).
+	/// </summary>
 	public bool ZoneOverworldHeight {
 		get {
 			return zone3[1];
@@ -1841,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is underground (<see cref="Main.worldSurface"/>) but above the Caverns layer (<see cref="Main.rockLayer"/>).
+	/// </summary>
 	public bool ZoneDirtLayerHeight {
 		get {
 			return zone3[2];
@@ -1850,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is in the Caverns layer (<see cref="Main.rockLayer"/>) but not in the Underworld (<see cref="Main.UnderworldLayer"/>).
+	/// </summary>
 	public bool ZoneRockLayerHeight {
 		get {
 			return zone3[3];
@@ -1859,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is in the Underworld (<see cref="Main.UnderworldLayer"/>).
+	/// </summary>
 	public bool ZoneUnderworldHeight {
 		get {
 			return zone3[4];
@@ -2085,6 +_,10 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then any minecart (<see cref="MountID.Sets.Cart"/>) this player rides in will be significantly faster and fire lasers.
+	/// <br/> Cannot be <see langword="true"/> if <see cref="unlockedSuperCart"/> is <see langword="false"/>.
+	/// </summary>
 	public bool UsingSuperCart {
 		get {
 			if (!unlockedSuperCart)
@@ -2097,11 +_,13 @@
 		}
 	}
 
+	/*
 	public float bowEffectiveDamage => (rangedDamage / rangedMultDamage + arrowDamageAdditiveStack) * rangedMultDamage * arrowDamage;
 
 	public float gunEffectiveDamage => rangedDamage * bulletDamage;
 
 	public float specialistEffectiveDamage => rangedDamage * rocketDamage;
+	*/
 
 	public bool ShouldNotDraw {
 		get {
@@ -2118,6 +_,11 @@
 
 	public int talkNPC { get; private set; }
 
+	/// <summary>
+	/// The NPC instance the player is talking to, or null if <see cref="talkNPC"/> is -1
+	/// </summary>
+	public NPC TalkNPC => talkNPC >= 0 ? Main.npc[talkNPC] : null;
+
 	public bool isLockedToATile {
 		get {
 			if (!sitting.isSitting)
@@ -2155,7 +_,10 @@
 
 	public bool ItemTimeIsZero => itemTime == 0;
 
-	public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax - 1;
+	/// <summary>
+	/// Returns true if the item animation is in its first frame.
+	/// </summary>
+	public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax/* - 1*/ && itemAnimation > 0; //#2351 & #3139
 
 	public float NormalizedLuck {
 		get {
@@ -2228,6 +_,13 @@
 		return pos + vector;
 	}
 
+	/// <summary>
+	/// Takes an input position and returns the position adjusted to the players visual rotation and offset. This accounts for the player being shifted up or down and rotated while riding a mount, sitting in a chair, and sleeping. <br/>
+	/// </summary>
+	/// <param name="pos"></param>
+	/// <param name="reverseRotation"></param>
+	/// <param name="addGfxOffY"></param>
+	/// <returns></returns>
 	public Vector2 RotatedRelativePoint(Vector2 pos, bool reverseRotation = false, bool addGfxOffY = true)
 	{
 		float num = (reverseRotation ? (0f - fullRotation) : fullRotation);
@@ -2328,6 +_,7 @@
 	{
 		talkNPC = npcIndex;
 		if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
+			// Gut feeling there is a to do on the above conditional
 			Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
 
 		if (talkNPC == -1)
@@ -2345,6 +_,7 @@
 		itemTimeMax = frames;
 	}
 
+	/*
 	public void ApplyItemTime(Item sItem)
 	{
 		SetItemTime(sItem.useTime);
@@ -2354,6 +_,17 @@
 	{
 		SetItemTime((int)((float)sItem.useTime * multiplier));
 	}
+	*/
+
+	//TML: Full remake of the above methods.
+	public void ApplyItemTime(Item sItem, float multiplier = 1, bool? callUseItem = null)
+	{
+		if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+			return;
+
+		SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime * multiplier, this, sItem));
+		ItemUsesThisAnimation++;
+	}
 
 	public void SetDummyItemTime(int frames)
 	{
@@ -2362,14 +_,15 @@
 		itemTimeMax = frames + 1;
 	}
 
-	private void SetItemAnimation(int frames)
+	public void SetItemAnimation(int frames)
 	{
 		itemAnimation = frames;
 		itemAnimationMax = frames;
 	}
 
-	private void ApplyItemAnimation(Item sItem)
+	public void ApplyItemAnimation(Item sItem)
 	{
+		/*
 		int num = 0;
 		if (sItem.autoReuse && sItem.reuseDelay == 0 && sItem.useTime <= sItem.useAnimation && sItem.shoot > 0 && sItem.useStyle == 5)
 			num = 1;
@@ -2386,6 +_,26 @@
 			SetItemAnimation(sItem.useAnimation + num);
 
 		reuseDelay = sItem.reuseDelay;
+		*/
+
+		//TODO: Just merge the tile/wall speed into TotalUseSpeedMultiplier?
+		if (sItem.createTile >= 0)
+			ApplyItemAnimation(sItem, tileSpeed);
+		else if (sItem.createWall >= 0)
+			ApplyItemAnimation(sItem, wallSpeed);
+		else
+			ApplyItemAnimation(sItem, 1);
+	}
+
+	// Overload added by TML.
+	public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null)
+	{
+		ItemLoader.UseAnimation(sItem, this);
+
+		SetItemAnimation(CombinedHooks.TotalAnimationTime(sItem.useAnimation * multiplier, this, sItem));
+
+		reuseDelay = (int)((itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
+		ItemUsesThisAnimation = 0;
 	}
 
 	public void MatchItemTimeToItemAnimation()
@@ -2407,6 +_,10 @@
 
 	public bool TeamChangeAllowed() => true;
 
+	/// <summary>
+	/// Spawns a <see cref="CombatText"/> indicating the player healed <paramref name="healAmount"/> life and syncs it if <paramref name="broadcast"/> is true. <br/>
+	/// Note that this doesn't actually heal the player, it only spawns the floating text. The <see cref="Heal(int)"/> method heals the player and calls this method and is more commonly used.
+	/// </summary>
 	public void HealEffect(int healAmount, bool broadcast = true)
 	{
 		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealLife, healAmount);
@@ -2753,7 +_,9 @@
 			Main.guideItem.position = base.Center;
 			Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
 			if (item.stack > 0) {
+				//TODO: Replace with Item.DropItem?
 				int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+				Main.item[num] = item.Clone(); // Added by TML.
 				Main.item[num].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num, 1f);
@@ -2766,7 +_,9 @@
 			Main.reforgeItem.position = base.Center;
 			Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
 			if (item2.stack > 0) {
+				//TODO: Replace with Item.DropItem?
 				int num2 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+				Main.item[num2] = item2.Clone(); // Added by TML.
 				Main.item[num2].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num2, 1f);
@@ -2801,7 +_,9 @@
 			Main.mouseItem.position = base.Center;
 			Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
 			if (item3.stack > 0) {
+				//TODO: Replace with Item.DropItem?
 				int num3 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+				Main.item[num3] = item3.Clone(); // Added by TML.
 				Main.item[num3].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num3, 1f);
@@ -2923,6 +_,14 @@
 		return -1;
 	}
 
+	/// <summary>
+	/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="BuffID"/> and modded buffs are typically retrieved using <see cref="ModContent.BuffType{T}"/>. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
+	/// <br/> If applying a buff to a player other than the local player in pvp, quiet should be false and the buff must be true in <see cref="Main.pvpBuff"/> to properly sync.
+	/// </summary>
+	/// <param name="type">The buff type</param>
+	/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
+	/// <param name="quiet">If true, the network sync message is skipped.</param>
+	/// <param name="foodHack">unused</param>
 	public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false)
 	{
 		if (buffImmune[type])
@@ -3020,6 +_,7 @@
 			if (buffType[i] != type)
 				continue;
 
+			if (BuffLoader.ReApply(type, this, time, i)) { } else
 			if (type == 94) {
 				buffTime[i] += time;
 				if (buffTime[i] > manaSickTimeMax)
@@ -3039,7 +_,10 @@
 	private int AddBuff_DetermineBuffTimeToAdd(int type, int time1)
 	{
 		int num = time1;
+		/*
 		if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80)) {
+		*/
+		if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type]) {
 			float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
 			if (Main.GameModeInfo.IsJourneyMode) {
 				if (Main.masterMode)
@@ -3054,6 +_,10 @@
 		return num;
 	}
 
+	/// <summary>
+	/// Removes the buff at the provided index in <see cref="buffType"/> and <see cref="buffTime"/> and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.ClearBuff(int)"/> if you only know the <see cref="BuffID"/>.
+	/// </summary>
+	/// <param name="b">The index in <see cref="buffType"/> of the buff to remove.</param>
 	public void DelBuff(int b)
 	{
 		buffTime[b] = 0;
@@ -3073,8 +_,16 @@
 		}
 	}
 
+	/// <summary>
+	/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.DelBuff(int)"/> if you only know the buff index
+	/// </summary>
+	/// <param name="type">The buff type</param>
 	public void ClearBuff(int type)
 	{
+		//TML: Small optimization.
+		if (type == 0)
+			return;
+
 		for (int i = 0; i < maxBuffs; i++) {
 			if (buffType[i] == type)
 				DelBuff(i);
@@ -3117,6 +_,7 @@
 			AddBuff(item.buffType, num);
 		}
 
+		if (item.consumable && ItemLoader.ConsumeItem(item, this))
 		item.stack--;
 		if (item.stack <= 0)
 			item.TurnToAir();
@@ -3141,7 +_,13 @@
 			if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0)
 				continue;
 
+			if (!CombinedHooks.CanUseItem(this, item))
+				continue;
+
+			/*
 			int num4 = item.healLife - num;
+			*/
+			int num4 = GetHealLife(item, true) - num;
 			if (item.type == 227 && num4 < 0) {
 				num4 += 30;
 				if (num4 > 0)
@@ -3175,6 +_,8 @@
 				ApplyPotionDelay(item);
 
 			ApplyLifeAndOrMana(item);
+
+			if (item.consumable && ItemLoader.ConsumeItem(item, this))
 			item.stack--;
 			if (item.stack <= 0)
 				item.TurnToAir();
@@ -3226,7 +_,7 @@
 		if (cursed || CCed || dead)
 			return;
 
-		LegacySoundStyle legacySoundStyle = null;
+		SoundStyle? legacySoundStyle = null;
 		if (CountBuffs() == maxBuffs)
 			return;
 
@@ -3237,8 +_,10 @@
 			if (num == 0)
 				num = 3600;
 
+			ItemLoader.UseItem(item, this);
+
 			AddBuff(item.buffType, num);
-			if (item.consumable) {
+			if (item.consumable && ItemLoader.ConsumeItem(item, this)) {
 				item.stack--;
 				if (item.stack <= 0)
 					item.TurnToAir();
@@ -3256,8 +_,9 @@
 					continue;
 
 				int num3 = item2.buffType;
-				bool flag = QuickBuff_ShouldBotherUsingThisBuff(num3);
+				bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num3);
 				if (item2.mana > 0 && flag) {
+					/*
 					if (statMana >= (int)((float)item2.mana * manaCost)) {
 						manaRegenDelay = (int)maxRegenDelay;
 						statMana -= (int)((float)item2.mana * manaCost);
@@ -3265,6 +_,11 @@
 					else {
 						flag = false;
 					}
+					*/
+					if (CheckMana(item2, -1, true, true))
+						manaRegenDelay = (int)maxRegenDelay;
+					else
+						flag = false;
 				}
 
 				if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
@@ -3285,14 +_,17 @@
 				if (!flag)
 					continue;
 
+				ItemLoader.UseItem(item2, this);
+
 				legacySoundStyle = item2.UseSound;
 				int num4 = item2.buffTime;
 				if (num4 == 0)
 					num4 = 3600;
 
 				AddBuff(num3, num4);
-				if (item2.consumable) {
+				if (item2.consumable && ItemLoader.ConsumeItem(item2, this)) {
 					item2.stack--;
+
 					if (item2.stack <= 0)
 						item2.TurnToAir();
 				}
@@ -3412,6 +_,9 @@
 			if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this) && ItemCheck_CheckCanUse(item)) {
 				if (!QuickMinecartSnap()) {
 					mount.SetMount(item.mountType, this);
+
+					ItemLoader.UseItem(item, this);
+
 					if (item.UseSound != null)
 						SoundEngine.PlaySound(item.UseSound, base.Center);
 				}
@@ -3487,12 +_,20 @@
 	public Item QuickMount_GetItemToUse()
 	{
 		Item item = null;
+		bool equippedMountSufficient = false;
 		if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
+			equippedMountSufficient = true;
+
+		if (equippedMountSufficient && CombinedHooks.CanUseItem(this, miscEquips[3]))
 			item = miscEquips[3];
 
 		if (item == null) {
 			for (int i = 0; i < 58; i++) {
 				if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType]) {
+					if (!CombinedHooks.CanUseItem(this, inventory[i])) {
+						continue;
+					}
+
 					item = inventory[i];
 					break;
 				}
@@ -3555,6 +_,11 @@
 		if (item == null || !ItemCheck_CheckCanUse(item))
 			return;
 
+		if (ProjectileLoader.CanUseGrapple(item.shoot, this) is bool modCanGrapple) {
+			if (!modCanGrapple)
+				item = null;
+		}
+		else // Skip vanilla grapple checks
 		if (item.shoot == 73) {
 			int num2 = 0;
 			for (int i = 0; i < 1000; i++) {
@@ -3630,11 +_,13 @@
 		float shootSpeed = item.shootSpeed;
 		int damage = item.damage;
 		float knockBack = item.knockBack;
-		if (num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935) {
+
+		if (ProjectileID.Sets.SingleGrappleHook[num7]) {
 			grappling[0] = -1;
 			grapCount = 0;
 			for (int num8 = 0; num8 < 1000; num8++) {
 				if (Main.projectile[num8].active && Main.projectile[num8].owner == whoAmI) {
+					/*
 					switch (Main.projectile[num8].type) {
 						case 13:
 						case 230:
@@ -3651,6 +_,11 @@
 							Main.projectile[num8].Kill();
 							break;
 					}
+					*/
+					if (!ProjectileID.Sets.SingleGrappleHook[num8])
+						continue;
+
+					Main.projectile[num8].Kill();
 				}
 			}
 		}
@@ -3721,11 +_,14 @@
 					break;
 				case -1:
 				case 649:
+					// Extra patch context.
 					num7 = 646;
 					break;
 			}
 		}
 
+		ProjectileLoader.UseGrapple(this, ref num7);
+
 		Vector2 vector = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 		float num21 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
 		float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
@@ -4055,6 +_,12 @@
 		if (Main.myPlayer != whoAmI)
 			return;
 
+		OnHit_Inner(x, y, victim);
+		PlayerLoader.OnHitAnything(this, x, y, victim);
+	}
+
+	private void OnHit_Inner(float x, float y, Entity victim)
+	{
 		bool flag = victim is NPC && (((NPC)victim).type == 488 || ((NPC)victim).SpawnedFromStatue);
 		if (titaniumStormCooldown > 0)
 			flag = true;
@@ -4148,6 +_,9 @@
 
 	public void OpenPresent(int itemType)
 	{
+		DropFromItem(itemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		if (Main.rand.Next(15) == 0 && Main.hardMode) {
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 602);
@@ -4372,10 +_,13 @@
 				break;
 			}
 		}
+		*/
 	}
 
 	public void OpenLegacyPresent(int itemType)
 	{
+		DropFromItem(itemType);
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		int num = Main.rand.Next(14);
 		if (num == 0 && Main.hardMode) {
@@ -4390,20 +_,41 @@
 		}
 		else {
 			int number3 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 591, Main.rand.Next(20, 50));
+			// Extra patch context for the below.
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number3, 1f);
 		}
+		*/
 	}
 
+	// Return value added by TML.
+	/// <summary>
+	/// Spawns an item into the world at this players position. This is a simpler alternative to <see cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/>. This method can be called from multiplayer client code without necessitating manually syncing the item.
+	/// <br/> Use <see cref="QuickSpawnItem(IEntitySource, Item, int)"/> if a specific instance of an Item needs to be spawned into the world to preserve modded data.
+	/// </summary>
+	/// <param name="source"></param>
+	/// <param name="item"></param>
+	/// <param name="stack"></param>
+	/// <returns>The index of the item within <see cref="Main.item"/></returns>
-	public void QuickSpawnItem(IEntitySource source, int item, int stack = 1)
+	public int QuickSpawnItem(IEntitySource source, int item, int stack = 1)
 	{
 		int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
+
 		if (Main.netMode == 1)
 			NetMessage.SendData(21, -1, -1, null, number, 1f);
+
+		return number;
 	}
 
 	public void OpenBossBag(int type)
 	{
+		DropFromItem(type);
+
+		if ((!ItemID.Sets.PreHardmodeLikeBossBag[type] || Main.tenthAnniversaryWorld)) {
+			TryGettingDevArmor(GetItemSource_OpenItem(type));
+		}
+
+		/*
 		GameModeData gameModeInfo = Main.GameModeInfo;
 		float strength = 1f;
 		if (gameModeInfo.IsJourneyMode) {
@@ -4975,16 +_,20 @@
 			}
 
 			int num15 = (int)value;
+			// Extra patch context for the below.
 			if (num15 < 1)
 				num15 = 1;
 
 			value -= (float)num15;
 			QuickSpawnItem(itemSource_OpenItem, 71, num15);
 		}
+		*/
 	}
 
-	private void TryGettingDevArmor(IEntitySource source)
+	public void TryGettingDevArmor(IEntitySource source)
 	{
+		ModLoader.Default.ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
+
 		if (Main.rand.Next(Main.tenthAnniversaryWorld ? 8 : 16) == 0) {
 			switch (Main.rand.Next(18)) {
 				case 0:
@@ -5106,6 +_,9 @@
 
 	public void OpenFishingCrate(int crateItemID)
 	{
+		DropFromItem(crateItemID);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(crateItemID);
 		bool flag = ItemID.Sets.IsFishingCrateHardmode[crateItemID];
 		switch (crateItemID) {
@@ -6465,12 +_,22 @@
 					break;
 			}
 
+			// Extra patch context for the below.
 			int number72 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, type49, stack42);
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number72, 1f);
 		}
+		*/
 	}
 
+	/// <summary>
+	/// Counts the total stack of the specified item type in this players <see cref="inventory"/>. <br/>
+	/// Does not check Void Bag. <br/>
+	/// Use <see cref="Player.HasItem(int)"/> to check if the player has the item at all. <br/>
+	/// </summary>
+	/// <param name="type">The item type to count</param>
+	/// <param name="stopCountingAt">When to stop counting, useful to avoid unneccessary calculations</param>
+	/// <returns>The total amount counted</returns>
 	public int CountItem(int type, int stopCountingAt = 0)
 	{
 		int num = 0;
@@ -6485,6 +_,16 @@
 		return num;
 	}
 
+	/// <summary>
+	/// Use to consume a single item. The item does not have to be <see cref="Item.consumable"/>. <br/>
+	/// Attempts to reduce the <see cref="Item.stack"/> of the first <see cref="Item"/> found in the <see cref="inventory"/> by 1. <br/>
+	/// Respects <see cref="ItemLoader.ConsumeItem(Item, Player)"/>, so the item won't necessarily be consumed. <br/>
+	/// To consume multiple of the item, first check <see cref="Player.CountItem"/> to ensure that there are enough of the item, then use a for loop to call this method many times. <br/>
+	/// </summary>
+	/// <param name="type">The item type to consume</param>
+	/// <param name="reverseOrder">If true, the search for the item will start at the end of the player inventory</param>
+	/// <param name="includeVoidBag">If true, the void bag, if open, will also be considered for finding an item to consume</param>
+	/// <returns>True if the item was found and attempted to be consumed</returns>
 	public bool ConsumeItem(int type, bool reverseOrder = false, bool includeVoidBag = false)
 	{
 		int num = 0;
@@ -6498,7 +_,9 @@
 
 		for (int i = num; i != num2; i += num3) {
 			if (inventory[i].stack > 0 && inventory[i].type == type) {
+				if (ItemLoader.ConsumeItem(inventory[i], this))
-				inventory[i].stack--;
+					inventory[i].stack--;
+
 				if (inventory[i].stack <= 0)
 					inventory[i].SetDefaults();
 
@@ -6524,6 +_,9 @@
 
 	public void OpenShadowLockbox(int boxType)
 	{
+		DropFromItem(boxType);
+
+		/*
 		bool flag = true;
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(boxType);
 		while (flag) {
@@ -6551,15 +_,20 @@
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 
 			if (Main.rand.Next(5) == 0) {
+				// Extra patch context for the below.
 				number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 5010, 1, noBroadcast: false, -1);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
 		}
+		*/
 	}
 
 	public void OpenLockBox(int lockboxItemType)
 	{
+		DropFromItem(lockboxItemType);
+
+		/*
 		bool flag = true;
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(lockboxItemType);
 		while (flag) {
@@ -6593,16 +_,21 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 
+			// Extra patch context for the below.
 			if (Main.rand.Next(3) == 0) {
 				int number2 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 329, 1, noBroadcast: false, -1);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number2, 1f);
 			}
 		}
+		*/
 	}
 
 	public void OpenHerbBag(int bagType)
 	{
+		DropFromItem(bagType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(bagType);
 		int num = Main.rand.Next(2, 5);
 		if (Main.rand.Next(3) == 0)
@@ -6656,25 +_,35 @@
 			if (Main.rand.Next(3) == 0)
 				num3 += Main.rand.Next(1, 5);
 
+			// Extra patch context for the below.
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, num2, num3);
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
 	public void OpenCanofWorms(int sourceItemType)
 	{
+		DropFromItem(sourceItemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 		QuickSpawnItem(itemSource_OpenItem, 2002, Main.rand.Next(5, 9));
 		if (Main.rand.Next(10) < 3)
 			QuickSpawnItem(itemSource_OpenItem, 3191, Main.rand.Next(1, 3));
 
+		// Extra patch context.
 		if (Main.rand.Next(20) == 0)
 			QuickSpawnItem(itemSource_OpenItem, 2895);
+		*/
 	}
 
 	public void OpenOyster(int sourceItemType)
 	{
+		DropFromItem(sourceItemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 		if (Main.rand.Next(5) == 0) {
 			if (Main.rand.Next(15) == 0)
@@ -6683,13 +_,18 @@
 				QuickSpawnItem(itemSource_OpenItem, 4413);
 			else
 				QuickSpawnItem(itemSource_OpenItem, 4412);
+			// Extra patch context for the below.
 		}
 
 		QuickSpawnItem(itemSource_OpenItem, 4411);
+		*/
 	}
 
 	public void OpenGoodieBag(int itemType)
 	{
+		DropFromItem(itemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		if (Main.rand.Next(150) == 0) {
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1810);
@@ -6970,14 +_,17 @@
 				int number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1851);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
+				// Extra patch context for the below.
 
 				number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1852);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
 
+				// Extra patch context for the below.
 				break;
 			}
 		}
+		*/
 	}
 
 	public void UpdateDyes()
@@ -7002,12 +_,15 @@
 				int num = i % 10;
 				UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
 			}
+			// Extra patch context.
 		}
+
+		PlayerLoader.UpdateDyes(this);
 
 		cYorai = cPet;
 	}
 
-	private void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
+	internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
 	{
 		if (armorItem.IsAir)
 			return;
@@ -7020,13 +_,13 @@
 		if (!num && flag)
 			return;
 
-		if (armorItem.handOnSlot > 0 && armorItem.handOnSlot < ArmorIDs.HandOn.Count)
+		if (armorItem.handOnSlot > 0)
 			cHandOn = dyeItem.dye;
 
-		if (armorItem.handOffSlot > 0 && armorItem.handOffSlot < ArmorIDs.HandOff.Count)
+		if (armorItem.handOffSlot > 0)
 			cHandOff = dyeItem.dye;
 
-		if (armorItem.backSlot > 0 && armorItem.backSlot < ArmorIDs.Back.Count) {
+		if (armorItem.backSlot > 0) {
 			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
 				cBackpack = dyeItem.dye;
 			else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
@@ -7035,26 +_,26 @@
 				cBack = dyeItem.dye;
 		}
 
-		if (armorItem.frontSlot > 0 && armorItem.frontSlot < ArmorIDs.Front.Count)
+		if (armorItem.frontSlot > 0)
 			cFront = dyeItem.dye;
 
-		if (armorItem.shoeSlot > 0 && armorItem.shoeSlot < ArmorIDs.Shoe.Count) {
+		if (armorItem.shoeSlot > 0) {
 			if (armorItem.type == 4822 || armorItem.type == 4874)
 				cFlameWaker = dyeItem.dye;
 			else
 				cShoe = dyeItem.dye;
 		}
 
-		if (armorItem.waistSlot > 0 && armorItem.waistSlot < ArmorIDs.Waist.Count)
+		if (armorItem.waistSlot > 0)
 			cWaist = dyeItem.dye;
 
-		if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < ArmorIDs.Shield.Count)
+		if (armorItem.shieldSlot > 0)
 			cShield = dyeItem.dye;
 
-		if (armorItem.neckSlot > 0 && armorItem.neckSlot < ArmorIDs.Neck.Count)
+		if (armorItem.neckSlot > 0)
 			cNeck = dyeItem.dye;
 
-		if (armorItem.faceSlot > 0 && armorItem.faceSlot < ArmorIDs.Face.Count) {
+		if (armorItem.faceSlot > 0) {
 			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
 				cFaceHead = dyeItem.dye;
 			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
@@ -7063,17 +_,17 @@
 				cFace = dyeItem.dye;
 		}
 
-		if (armorItem.beardSlot > 0 && armorItem.beardSlot < ArmorIDs.Beard.Count)
+		if (armorItem.beardSlot > 0)
 			cBeard = dyeItem.dye;
 
-		if (armorItem.balloonSlot > 0 && armorItem.balloonSlot < ArmorIDs.Balloon.Count) {
+		if (armorItem.balloonSlot > 0) {
 			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
 				cBalloonFront = dyeItem.dye;
 			else
 				cBalloon = dyeItem.dye;
 		}
 
-		if (armorItem.wingSlot > 0 && armorItem.wingSlot < ArmorIDs.Wing.Count)
+		if (armorItem.wingSlot > 0)
 			cWings = dyeItem.dye;
 
 		if (armorItem.type == 934)
@@ -7112,6 +_,8 @@
 		}
 	}
 
+	// Original vanilla methods:
+	/*
 	public IEntitySource GetProjectileSource_Buff(int buffIndex)
 	{
 		int buffId = buffType[buffIndex];
@@ -7132,9 +_,36 @@
 	public IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 	public IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 	public IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => new EntitySource_OnHit_ByItemSourceID(this, victim, itemSourceId);
+	*/
+
+	// Internal redirects:
+	internal IEntitySource GetProjectileSource_Buff(int buffIndex) => GetSource_Buff(buffIndex);
+	internal IEntitySource GetProjectileSource_Item(Item item) => GetSource_ItemUse(item);
+	internal IEntitySource GetItemSource_OpenItem(int itemType) => GetSource_OpenItem(itemType);
+	internal IEntitySource GetItemSource_Death() => GetSource_Death();
+	internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+	internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId) => GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
+	internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => GetSource_OnHit(victim, context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId) => GetSource_OnHurt(attacker, context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_Accessory(Item item) => GetSource_Accessory(item);
+	internal IEntitySource GetProjectileSource_Misc(int projectileSourceId) => GetSource_Misc(context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => GetSource_OnHit(victim, context: ItemSourceID.ToContextString(itemSourceId));
+	internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId) => GetSource_FromThis(context: ProjectileSourceID.ToContextString(projectileSourceId));
+
+	// Public API methods can be found in:
+	//   Entity.TML.Sources.cs;
+	//   Player.TML.Sources.cs (if exists);
 
 	public void UpdateBuffs(int i)
 	{
+		// TML:
+		// All accessories that previously used each class-specific crit field individually now use 'allCrit' instead where appropriate.
+		// This allows them to automagically account for new classes, preventing modders from having to do extra work for no reason.
+		// - Thomas
+
 		if (soulDrain > 0 && whoAmI == Main.myPlayer)
 			AddBuff(151, 2);
 
@@ -7148,6 +_,9 @@
 			if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
 				buffTime[j]--;
 
+			//TML: This will be used at the very end of this scope.
+			int originalIndex = j;
+
 			if (buffType[j] == 1) {
 				lavaImmune = true;
 				fireWalk = true;
@@ -7162,8 +_,18 @@
 				manaRegenDelayBonus += 0.5f;
 				manaRegenBonus += 10;
 			}
+			// TML:
+			// The changes to this block exist to fix the Sharpening Station's armor penetration bonus
+			// being able to be applied to non-melee weapons (most notably summons) by holding a melee weapon.
+			// - Thomas
+			/*
 			else if (buffType[j] == 159 && inventory[selectedItem].melee) {
+			*/
+			else if (buffType[j] == 159) {
+				/*
 				armorPenetration += 12;
+				*/
+				GetArmorPenetration(DamageClass.Melee) += 12;
 			}
 			else if (buffType[j] == 192) {
 				pickSpeed -= 0.2f;
@@ -7171,9 +_,12 @@
 			}
 			else if (buffType[j] == 321) {
 				int num = 10;
+				allCrit += num;
+				/*
 				meleeCrit += num;
 				rangedCrit += num;
 				magicCrit += num;
+				*/
 				minionDamage += (float)num / 100f;
 			}
 			else if (buffType[j] == 2) {
@@ -7224,6 +_,9 @@
 			}
 			else if (buffType[j] == 16) {
 				archery = true;
+
+				//TML: Moved from PickAmmo, as StatModifier allows multiplicative buffs to be 'registered' alongside additive ones.
+				arrowDamage *= 1.1f;
 			}
 			else if (buffType[j] == 17) {
 				detectCreature = true;
@@ -7351,9 +_,12 @@
 				endurance += 0.1f;
 			}
 			else if (buffType[j] == 115) {
+				allCrit += 10;
+				/*
 				meleeCrit += 10;
 				rangedCrit += 10;
 				magicCrit += 10;
+				*/
 			}
 			else if (buffType[j] == 116) {
 				inferno = true;
@@ -7388,19 +_,22 @@
 						player.AddBuff(num2, 120);
 
 					if (flag) {
+						PlayerDeathReason reason = PlayerDeathReason.ByOther(16, whoAmI);
-						player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0, pvp: true);
+						player.Hurt(reason, damage, 0, pvp: true);
 						if (Main.netMode != 0) {
-							PlayerDeathReason reason = PlayerDeathReason.ByOther(16);
 							NetMessage.SendPlayerHurt(l, reason, damage, 0, critical: false, pvp: true, -1);
 						}
 					}
 				}
 			}
 			else if (buffType[j] == 117) {
+				allDamage += 0.1f;
+				/*
 				meleeDamage += 0.1f;
 				rangedDamage += 0.1f;
 				magicDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 			else if (buffType[j] == 119) {
 				loveStruck = true;
@@ -7596,10 +_,13 @@
 				}
 
 				float num17 = 0.15f * (float)nebulaLevelDamage;
+				allDamage += num17;
+				/*
 				meleeDamage += num17;
 				rangedDamage += num17;
 				magicDamage += num17;
 				minionDamage += num17;
+				*/
 			}
 			else if (buffType[j] == 62) {
 				if ((double)statLife <= (double)statLifeMax2 * 0.5) {
@@ -8287,10 +_,13 @@
 					}
 				}
 
+				allDamage += 0.2f;
+				/*
 				meleeDamage += 0.2f;
 				magicDamage += 0.2f;
 				rangedDamage += 0.2f;
 				minionDamage += 0.2f;
+				*/
 			}
 			else if (buffType[j] == 41) {
 				buffTime[j] = 18000;
@@ -8708,14 +_,20 @@
 			else if (buffType[j] == 26) {
 				wellFed = true;
 				statDefense += 2;
+				allCrit += 2;
+				allDamage += 0.05f;
+				/*
 				meleeCrit += 2;
 				meleeDamage += 0.05f;
+				*/
 				meleeSpeed += 0.05f;
+				/*
 				magicCrit += 2;
 				magicDamage += 0.05f;
 				rangedCrit += 2;
 				rangedDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 				minionKB += 0.5f;
 				moveSpeed += 0.2f;
 				pickSpeed -= 0.05f;
@@ -8723,14 +_,20 @@
 			else if (buffType[j] == 206) {
 				wellFed = true;
 				statDefense += 3;
+				allCrit += 3;
+				allDamage += 0.075f;
+				/*
 				meleeCrit += 3;
 				meleeDamage += 0.075f;
+				*/
 				meleeSpeed += 0.075f;
+				/*
 				magicCrit += 3;
 				magicDamage += 0.075f;
 				rangedCrit += 3;
 				rangedDamage += 0.075f;
 				minionDamage += 0.075f;
+				*/
 				minionKB += 0.75f;
 				moveSpeed += 0.3f;
 				pickSpeed -= 0.1f;
@@ -8738,14 +_,20 @@
 			else if (buffType[j] == 207) {
 				wellFed = true;
 				statDefense += 4;
+				allCrit += 4;
+				allDamage += 0.1f;
+				/*
 				meleeCrit += 4;
 				meleeDamage += 0.1f;
+				*/
 				meleeSpeed += 0.1f;
+				/*
 				magicCrit += 4;
 				magicDamage += 0.1f;
 				rangedCrit += 4;
 				rangedDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 				minionKB += 1f;
 				moveSpeed += 0.4f;
 				pickSpeed -= 0.15f;
@@ -8753,28 +_,40 @@
 			else if (buffType[j] == 333) {
 				hungry = true;
 				statDefense -= 2;
+				allCrit -= 2;
+				allDamage -= 0.05f;
+				/*
 				meleeCrit -= 2;
 				meleeDamage -= 0.05f;
+				*/
 				meleeSpeed -= 0.05f;
+				/*
 				magicCrit -= 2;
 				magicDamage -= 0.05f;
 				rangedCrit -= 2;
 				rangedDamage -= 0.05f;
 				minionDamage -= 0.05f;
+				*/
 				minionKB -= 0.5f;
 				pickSpeed += 0.05f;
 			}
 			else if (buffType[j] == 334) {
 				starving = true;
 				statDefense -= 4;
+				allCrit -= 4;
+				allDamage -= 0.1f;
+				/*
 				meleeCrit -= 4;
 				meleeDamage -= 0.1f;
+				*/
 				meleeSpeed -= 0.1f;
+				/*
 				magicCrit -= 4;
 				magicDamage -= 0.1f;
 				rangedCrit -= 4;
 				rangedDamage -= 0.1f;
 				minionDamage -= 0.1f;
+				*/
 				minionKB -= 1f;
 				pickSpeed += 0.15f;
 			}
@@ -8805,6 +_,9 @@
 			else if (buffType[j] == 79) {
 				meleeEnchant = 8;
 			}
+
+			if (j == originalIndex)
+				BuffLoader.Update(buffType[j], this, ref j);
 		}
 
 		UpdateHungerBuffs();
@@ -9226,23 +_,26 @@
 		accStopwatch = false;
 		accOreFinder = false;
 		accDreamCatcher = false;
+
+		PlayerLoader.ResetInfoAccessories(this);
+
 		for (int i = 0; i < 58; i++) {
 			int type = inventory[i].type;
-			RefreshInfoAccsFromItemType(type);
+			RefreshInfoAccsFromItemType(inventory[i]);
 			if (type == 4131)
 				flag = true;
 		}
 
 		for (int j = 0; j < 10; j++) {
 			int type2 = armor[j].type;
-			RefreshInfoAccsFromItemType(type2);
+			RefreshInfoAccsFromItemType(armor[j]);
 		}
 
 		if (flag) {
 			for (int k = 0; k < 40; k++) {
 				int type3 = bank4.item[k].type;
-				if (type3 < 0 || type3 > ItemID.Count || ItemID.Sets.WorksInVoidBag[type3])
-					RefreshInfoAccsFromItemType(type3);
+				if (type3 < 0 || ItemID.Sets.WorksInVoidBag[type3])
+					RefreshInfoAccsFromItemType(bank4.item[k]);
 			}
 		}
 
@@ -9301,11 +_,20 @@
 
 				if (Main.player[i].hasLuck_LuckyCoin)
 					hasLuck_LuckyCoin = true;
+
+				PlayerLoader.RefreshInfoAccessoriesFromTeamPlayers(this, Main.player[i]);
 			}
 		}
 	}
 
+	// Added by tML.
+	public void RefreshInfoAccsFromItemType(Item item)
+	{
+		RefreshInfoAccsFromItemType(item.type);
+		ItemLoader.UpdateInfoAccessory(item, this);
+	}
+
-	public void RefreshInfoAccsFromItemType(int accType)
+	private void RefreshInfoAccsFromItemType(int accType)
 	{
 		if ((accType == 15 || accType == 707) && accWatch < 1)
 			accWatch = 1;
@@ -9431,7 +_,10 @@
 		bool flag = false;
 		for (int j = 0; j < 58; j++) {
 			int type = inventory[j].type;
-			RefreshInfoAccsFromItemType(type);
+
+			ItemLoader.UpdateInventory(inventory[j], this);
+
+			RefreshInfoAccsFromItemType(inventory[j]);
 			RefreshMechanicalAccsFromItemType(type);
 			if (type == 4743)
 				hasFootball = true;
@@ -9456,8 +_,10 @@
 		if (flag) {
 			for (int l = 0; l < 40; l++) {
 				int type2 = bank4.item[l].type;
-				if (type2 < 0 || type2 > ItemID.Count || ItemID.Sets.WorksInVoidBag[type2]) {
-					RefreshInfoAccsFromItemType(type2);
+				if (ItemID.Sets.WorksInVoidBag[type2]) {
+					ItemLoader.UpdateInventory(bank4.item[l], this);
+
+					RefreshInfoAccsFromItemType(bank4.item[l]);
 					RefreshMechanicalAccsFromItemType(type2);
 				}
 			}
@@ -9471,8 +_,14 @@
 
 		for (int m = 3; m < 10; m++) {
 			if (IsItemSlotUnlockedAndUsable(m))
-				ApplyEquipFunctional(m, armor[m]);
+				ApplyEquipFunctional(armor[m], hideVisibleAccessory[m]);
 		}
+
+		PlayerLoader.UpdateEquips(this);
+
+		// Apply knockback glove here, rather than on hit. Moved from ItemCheck_OwnerOnlyCode/DashMovement/GetWeaponKnockback
+		if (kbGlove)
+			GetKnockback(DamageClass.Melee) *= 2f;
 
 		if (accFishingBobber)
 			fishingSkill += 10;
@@ -9481,14 +_,20 @@
 			lifeRegen += 2;
 			statDefense += 4;
 			meleeSpeed += 0.1f;
+			allDamage += 0.1f;
+			allCrit += 2;
+			/*
 			meleeDamage += 0.1f;
 			meleeCrit += 2;
 			rangedDamage += 0.1f;
 			rangedCrit += 2;
 			magicDamage += 0.1f;
 			magicCrit += 2;
+			*/
 			pickSpeed -= 0.15f;
+			/*
 			minionDamage += 0.1f;
+			*/
 			minionKB += 0.5f;
 		}
 
@@ -9497,6 +_,8 @@
 			maxTurrets++;
 		}
 
+		//TML: Wing loop is merged into ApplyEquipFunctional
+		/*
 		for (int n = 3; n < 10; n++) {
 			if (armor[n].wingSlot > 0 && IsItemSlotUnlockedAndUsable(n)) {
 				if (!hideVisibleAccessory[n] || (velocity.Y != 0f && !mount.Active))
@@ -9505,6 +_,7 @@
 				wingsLogic = armor[n].wingSlot;
 			}
 		}
+		*/
 
 		for (int num = 13; num < 20; num++) {
 			if (IsItemSlotUnlockedAndUsable(num))
@@ -9562,10 +_,10 @@
 		}
 	}
 
-	private void GrantArmorBenefits(Item armorPiece)
+	public void GrantArmorBenefits(Item armorPiece)
 	{
 		int type = armorPiece.type;
-		RefreshInfoAccsFromItemType(type);
+		RefreshInfoAccsFromItemType(armorPiece);
 		RefreshMechanicalAccsFromItemType(type);
 		if (armorPiece.type == 3017 || armorPiece.type == 3993) {
 			flowerBoots = true;
@@ -9737,6 +_,9 @@
 			armorPenetration += 5;
 
 		if (armorPiece.type == 2277) {
+			allDamage += 0.05f;
+			allCrit += 5;
+			/*
 			magicDamage += 0.05f;
 			meleeDamage += 0.05f;
 			rangedDamage += 0.05f;
@@ -9744,6 +_,7 @@
 			magicCrit += 5;
 			rangedCrit += 5;
 			meleeCrit += 5;
+			*/
 			meleeSpeed += 0.1f;
 			moveSpeed += 0.1f;
 		}
@@ -9758,9 +_,12 @@
 			nightVision = true;
 
 		if (armorPiece.type == 256 || armorPiece.type == 257 || armorPiece.type == 258) {
+			allCrit += 3;
+			/*
 			rangedCrit += 3;
 			meleeCrit += 3;
 			magicCrit += 3;
+			*/
 		}
 
 		if (armorPiece.type == 3374)
@@ -9811,10 +_,13 @@
 		}
 
 		if (armorPiece.type == 792 || armorPiece.type == 793 || armorPiece.type == 794) {
+			allDamage += 0.02f;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 		}
 
 		if (armorPiece.type == 231)
@@ -9843,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 374) {
+			allCrit += 5;
+			/*
 			magicCrit += 5;
 			meleeCrit += 5;
 			rangedCrit += 5;
+			*/
 		}
 
 		if (armorPiece.type == 375) {
+			allDamage += 0.03f;
+			/*
 			rangedDamage += 0.03f;
 			meleeDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 			moveSpeed += 0.1f;
 		}
 
@@ -9872,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 379) {
+			allDamage += 0.07f;
+			/*
 			rangedDamage += 0.07f;
 			meleeDamage += 0.07f;
 			magicDamage += 0.07f;
 			minionDamage += 0.07f;
+			*/
 		}
 
 		if (armorPiece.type == 380) {
+			allCrit += 10;
+			/*
 			magicCrit += 10;
 			meleeCrit += 10;
 			rangedCrit += 10;
+			*/
 		}
 
 		if (armorPiece.type >= 2367 && armorPiece.type <= 2369)
@@ -9904,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 403) {
+			allDamage += 0.08f;
+			/*
 			rangedDamage += 0.08f;
 			meleeDamage += 0.08f;
 			magicDamage += 0.08f;
 			minionDamage += 0.08f;
+			*/
 		}
 
 		if (armorPiece.type == 404) {
+			allCrit += 7;
+			/*
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 			moveSpeed += 0.05f;
 		}
 
@@ -9934,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1208) {
+			allDamage += 0.03f;
+			allCrit += 2;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
@@ -9941,9 +_,13 @@
 			magicCrit += 2;
 			meleeCrit += 2;
 			rangedCrit += 2;
+			*/
 		}
 
 		if (armorPiece.type == 1209) {
+			allDamage += 0.02f;
+			allCrit += 1;
+			/*
 			meleeDamage += 0.02f;
 			rangedDamage += 0.02f;
 			magicDamage += 0.02f;
@@ -9951,6 +_,7 @@
 			magicCrit++;
 			meleeCrit++;
 			rangedCrit++;
+			*/
 		}
 
 		if (armorPiece.type == 1210) {
@@ -9970,9 +_,12 @@
 		}
 
 		if (armorPiece.type == 1213) {
+			allCrit += 6;
+			/*
 			magicCrit += 6;
 			meleeCrit += 6;
 			rangedCrit += 6;
+			*/
 		}
 
 		if (armorPiece.type == 1214) {
@@ -10001,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1218) {
+			allDamage += 0.04f;
+			allCrit += 3;
+			/*
 			meleeDamage += 0.04f;
 			rangedDamage += 0.04f;
 			magicDamage += 0.04f;
@@ -10008,9 +_,13 @@
 			magicCrit += 3;
 			meleeCrit += 3;
 			rangedCrit += 3;
+			*/
 		}
 
 		if (armorPiece.type == 1219) {
+			allDamage += 0.03f;
+			allCrit += 3;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
@@ -10018,6 +_,7 @@
 			magicCrit += 3;
 			meleeCrit += 3;
 			rangedCrit += 3;
+			*/
 			moveSpeed += 0.06f;
 		}
 
@@ -10044,31 +_,43 @@
 		}
 
 		if (armorPiece.type == 551 || armorPiece.type == 4900) {
+			allCrit += 7;
+			/*
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 		}
 
 		if (armorPiece.type == 552 || armorPiece.type == 4901) {
+			allDamage += 0.07f;
+			/*
 			rangedDamage += 0.07f;
 			meleeDamage += 0.07f;
 			magicDamage += 0.07f;
 			minionDamage += 0.07f;
+			*/
 			moveSpeed += 0.08f;
 		}
 
 		if (armorPiece.type == 4982) {
+			allCrit += 5;
+			/*
 			rangedCrit += 5;
 			meleeCrit += 5;
 			magicCrit += 5;
+			*/
 			manaCost -= 0.1f;
 		}
 
 		if (armorPiece.type == 4983) {
+			allDamage += 0.05f;
+			/*
 			rangedDamage += 0.05f;
 			meleeDamage += 0.05f;
 			magicDamage += 0.05f;
 			minionDamage += 0.05f;
+			*/
 			huntressAmmoCost90 = true;
 		}
 
@@ -10094,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1004) {
+			allDamage += 0.05f;
+			allCrit += 7;
+			/*
 			meleeDamage += 0.05f;
 			magicDamage += 0.05f;
 			rangedDamage += 0.05f;
@@ -10101,12 +_,16 @@
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 		}
 
 		if (armorPiece.type == 1005) {
+			allCrit += 8;
+			/*
 			magicCrit += 8;
 			meleeCrit += 8;
 			rangedCrit += 8;
+			*/
 			moveSpeed += 0.05f;
 		}
 
@@ -10365,14 +_,17 @@
 			minionDamage += 0.11f;
 		}
 
+		// Extra patch context.
 		if (armorPiece.type == 1834) {
 			moveSpeed += 0.2f;
 			maxMinions++;
 			minionDamage += 0.11f;
 		}
+
+		ItemLoader.UpdateEquip(armorPiece, this);
 	}
 
-	private void GrantPrefixBenefits(Item item)
+	public void GrantPrefixBenefits(Item item)
 	{
 		if (item.prefix == 62)
 			statDefense++;
@@ -10390,43 +_,61 @@
 			statManaMax2 += 20;
 
 		if (item.prefix == 67) {
+			allCrit += 2;
+			/*
 			meleeCrit += 2;
 			rangedCrit += 2;
 			magicCrit += 2;
+			*/
 		}
 
 		if (item.prefix == 68) {
+			allCrit += 4;
+			/*
 			meleeCrit += 4;
 			rangedCrit += 4;
 			magicCrit += 4;
+			*/
 		}
 
 		if (item.prefix == 69) {
+			allDamage += 0.01f;
+			/*
 			meleeDamage += 0.01f;
 			rangedDamage += 0.01f;
 			magicDamage += 0.01f;
 			minionDamage += 0.01f;
+			*/
 		}
 
 		if (item.prefix == 70) {
+			allDamage += 0.02f;
+			/*
 			meleeDamage += 0.02f;
 			rangedDamage += 0.02f;
 			magicDamage += 0.02f;
 			minionDamage += 0.02f;
+			*/
 		}
 
 		if (item.prefix == 71) {
+			allDamage += 0.03f;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 		}
 
 		if (item.prefix == 72) {
+			allDamage += 0.04f;
+			/*
 			meleeDamage += 0.04f;
 			rangedDamage += 0.04f;
 			magicDamage += 0.04f;
 			minionDamage += 0.04f;
+			*/
 		}
 
 		if (item.prefix == 73)
@@ -10452,6 +_,8 @@
 
 		if (item.prefix == 80)
 			meleeSpeed += 0.04f;
+
+		PrefixLoader.ApplyAccessoryEffects(this, item);
 	}
 
 	private void SpawnHallucination(Item item)
@@ -10590,6 +_,12 @@
 
 	private void ApplyEquipVanity(int itemSlot, Item currentItem)
 	{
+		ApplyEquipVanity(currentItem);
+	}
+
+	//TML: Split to make a public indexless overload.
+	public void ApplyEquipVanity(Item currentItem)
+	{
 		int type = currentItem.type;
 		if (currentItem.wingSlot > 0)
 			wings = currentItem.wingSlot;
@@ -10645,6 +_,8 @@
 
 		UpdateBootVisualEffects(currentItem);
 		UpdateFishingBobber(currentItem);
+
+		ItemLoader.UpdateVanity(currentItem, this);
 	}
 
 	private void DoEyebrellaRainEffect()
@@ -10670,9 +_,13 @@
 		return ArmorIDs.Wing.Sets.Stats[wingID];
 	}
 
-	private void ApplyEquipFunctional(int itemSlot, Item currentItem)
+	//TML: Made public, with the itemSlot parameter removed, so mods can call this method from their own accessory slots.
+	public void ApplyEquipFunctional(Item currentItem, bool hideVisual)
 	{
-		if (currentItem.expertOnly && !Main.expertMode)
+		int itemSlot = 0;
+		bool[] hideVisibleAccessory = { hideVisual };
+
+		if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
 			return;
 
 		if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
@@ -10803,6 +_,9 @@
 
 		if (currentItem.type == 3015) {
 			aggro -= 400;
+			allDamage += 0.05f;
+			allCrit += 5;
+			/*
 			meleeCrit += 5;
 			magicCrit += 5;
 			rangedCrit += 5;
@@ -10810,6 +_,7 @@
 			magicDamage += 0.05f;
 			rangedDamage += 0.05f;
 			minionDamage += 0.05f;
+			*/
 		}
 
 		if (currentItem.type == 3016)
@@ -11045,6 +_,9 @@
 		}
 
 		if (currentItem.type == 1301) {
+			allDamage += 0.1f;
+			allCrit += 8;
+			/*
 			meleeCrit += 8;
 			rangedCrit += 8;
 			magicCrit += 8;
@@ -11052,6 +_,7 @@
 			rangedDamage += 0.1f;
 			magicDamage += 0.1f;
 			minionDamage += 0.1f;
+			*/
 		}
 
 		if (currentItem.type == 111)
@@ -11094,9 +_,12 @@
 		}
 
 		if (currentItem.type == 1248) {
+			allCrit += 10;
+			/*
 			meleeCrit += 10;
 			rangedCrit += 10;
 			magicCrit += 10;
+			*/
 		}
 
 		if (currentItem.type == 854)
@@ -11501,10 +_,13 @@
 			minionDamage += 0.15f;
 
 		if (currentItem.type == 935) {
+			allDamage += 0.12f;
+			/*
 			magicDamage += 0.12f;
 			meleeDamage += 0.12f;
 			rangedDamage += 0.12f;
 			minionDamage += 0.12f;
+			*/
 		}
 
 		if (currentItem.wingSlot != -1)
@@ -11633,13 +_,25 @@
 			manaCost -= 0.08f;
 		}
 
+		//TML: Moved here from UpdateEquips.
+		if (currentItem.wingSlot > 0) {
+			if (!hideVisibleAccessory[itemSlot] || velocity.Y != 0f && !mount.Active)
+				wings = currentItem.wingSlot;
+
+			wingsLogic = currentItem.wingSlot;
+			equippedWings = currentItem;
+		}
+
+		ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
+
+		// Vanilla: Return early if sounds are not relevant
 		if (Main.myPlayer != whoAmI)
 			return;
 
 		if (currentItem.type == 5104 || currentItem.type == 5105) {
 			ApplyWilsonBeard(currentItem);
 		}
-		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0 && Main.curMusic <= Main.maxMusic) {
+		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0) {
 			SoundEngine.PlaySound(SoundID.Item166, base.Center);
 			int num3 = -1;
 			if (Main.curMusic == 1)
@@ -11805,10 +_,12 @@
 				currentItem.SetDefaults(5112);
 			else if (Main.curMusic == 91)
 				currentItem.SetDefaults(5362);
-			else if (Main.curMusic > 13)
+			else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
 				currentItem.SetDefaults(1596 + Main.curMusic - 14);
-			else if (num3 != -1)
+			else if (num3 != -1 && Main.curMusic < Main.maxMusic)
 				currentItem.SetDefaults(num3 + 562);
+			else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out int modMusicBoxType))
+				currentItem.SetDefaults(modMusicBoxType);
 		}
 
 		ApplyMusicBox(currentItem);
@@ -12019,6 +_,9 @@
 		if (currentItem.type == 5362)
 			Main.musicBox2 = 87;
 
+		if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out int modMusicBox))
+			Main.musicBox2 = modMusicBox;
+
 		Main.musicBoxNotModifiedByVolume = Main.musicBox2;
 	}
 
@@ -12057,10 +_,13 @@
 
 		if (head == 112 && body == 75 && legs == 64) {
 			setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
+			allDamage += 0.1f;
+			/*
 			meleeDamage += 0.1f;
 			magicDamage += 0.1f;
 			rangedDamage += 0.1f;
 			minionDamage += 0.1f;
+			*/
 		}
 
 		if (head == 180 && body == 182 && legs == 122) {
@@ -12390,6 +_,9 @@
 
 		if (head == 261 && body == 230 && legs == 213) {
 			setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
+			allDamage += 0.1f;
+			allCrit += 10;
+			/*
 			rangedDamage += 0.1f;
 			meleeDamage += 0.1f;
 			magicDamage += 0.1f;
@@ -12397,6 +_,7 @@
 			rangedCrit += 10;
 			meleeCrit += 10;
 			magicCrit += 10;
+			*/
 			dashType = 5;
 		}
 
@@ -12581,11 +_,16 @@
 			minionDamage += 0.15f;
 			whipRangeMultiplier += 0.3f;
 			float num17 = 1.15f;
+			/*
 			float num18 = 1f / num17;
 			whipUseTimeMultiplier *= num18;
+			*/
+			summonerWeaponSpeedBonus += num17 - 1; //TML: Obsidian armor changed to additive.
 		}
 
 		ApplyArmorSoundAndDustChanges();
+
+		ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
 	}
 
 	public void UpdateSocialShadow()
@@ -12926,6 +_,10 @@
 
 		bool flag9 = point.Y > Main.maxTilesY - 320;
 		bool flag10 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
+
+		//TODO: Are these flags a problem?
+		LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
+
 		ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, vector4 - new Vector2(0f, 10f));
 		ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, vector3 - new Vector2(0f, 10f));
 		ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, vector2 - new Vector2(0f, 10f));
@@ -13080,8 +_,12 @@
 			}
 		}
 
+		// Added by TML.
+		ZonePurity = InZonePurity();
+
 		if (!dead) {
 			Point point2 = base.Center.ToTileCoordinates();
+			// Extra patch context.
 			if (WorldGen.InWorld(point2.X, point2.Y, 1)) {
 				int num21 = 0;
 				if (Main.tile[point2.X, point2.Y] != null)
@@ -13109,10 +_,13 @@
 				AchievementsHelper.HandleSpecialEvent(this, 15);
 			else if (_funkytownAchievementCheckCooldown == 0 && ZoneGraveyard)
 				AchievementsHelper.HandleSpecialEvent(this, 18);
+			// Extra patch context.
 		}
 		else {
 			_funkytownAchievementCheckCooldown = 100;
 		}
+
+		LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
 	}
 
 	private void TrySpawningFaelings()
@@ -13152,6 +_,13 @@
 
 	public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear)
 	{
+		fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
+		hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
+		hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
+		backHairDraw = hair >= 0 && HairID.Sets.DrawBackHair[hair];
+		drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
+
+		/*
 		fullHair = (hatHair = (hideHair = (drawsBackHairWithoutHeadgear = false)));
 		switch (head) {
 			case 0:
@@ -13272,6 +_,7 @@
 		backHairDraw = num > 50 && (num < 56 || num > 63) && (num < 74 || num > 77) && (num < 88 || num > 89) && num != 100 && num != 104 && num != 112 && num < 116;
 		if (num == 133 || num == 134 || num == 146 || num == 162 || num == 6)
 			backHairDraw = true;
+		*/
 	}
 
 	public void UpdateDead()
@@ -13287,6 +_,7 @@
 		ResetFloorFlags();
 		wings = 0;
 		wingsLogic = 0;
+		equippedWings = null; // Added by TML
 		ResetVisibleAccessories();
 		poisoned = false;
 		venom = false;
@@ -13333,6 +_,9 @@
 		leinforsHair = false;
 		overrideFishingBobber = -1;
 		gravDir = 1f;
+
+		PlayerLoader.UpdateDead(this);
+
 		for (int i = 0; i < maxBuffs; i++) {
 			if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]]) {
 				buffTime[i] = 0;
@@ -13538,6 +_,16 @@
 					toolStrategy = 5;
 			}
 
+			int modSelect = TileLoader.AutoSelect(tX, tY, this);
+
+			if (modSelect >= 0) {
+				if (nonTorch == -1)
+					nonTorch = selectedItem;
+
+				selectedItem = modSelect;
+				return;
+			}
+
 			SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
 			_lastSmartCursorToolStrategy = toolStrategy;
 		}
@@ -13580,7 +_,11 @@
 						SmartSelect_SelectItem(i);
 						return;
 					}
+
+					/*
 					if (type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776)
+					*/
+					if (ItemID.Sets.Glowsticks[type])
 						SmartSelect_SelectItem(i);
 					break;
 				case 1:
@@ -13602,16 +_,26 @@
 					}
 					break;
 				case 4:
+					/*
 					if (inventory[i].type != 282 && inventory[i].type != 286 && inventory[i].type != 3002 && inventory[i].type != 3112 && inventory[i].type != 4776 && inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type]) {
+					*/
+					if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type]) {
 						if (nonTorch == -1)
 							nonTorch = selectedItem;
 
+						/*
 						if (inventory[selectedItem].createTile != 4)
+						*/
+						if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 							selectedItem = i;
 
 						break;
 					}
+
+					/*
 					if ((type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776) && wetTile) {
+					*/
+					if (ItemID.Sets.Glowsticks[type] && wetTile) {
 						SmartSelect_SelectItem(i);
 						return;
 					}
@@ -13624,6 +_,9 @@
 							}
 						}
 
+						if (!flag && !ItemLoader.NeedsAmmo(inventory[i], this))
+							flag = true;
+
 						if (flag) {
 							SmartSelect_SelectItem(i);
 							return;
@@ -13639,7 +_,7 @@
 						if (nonTorch == -1)
 							nonTorch = selectedItem;
 
-						if (inventory[selectedItem].createTile != 4)
+						if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 							selectedItem = i;
 
 						break;
@@ -13666,6 +_,7 @@
 						case 3002:
 						case 3112:
 						case 4776:
+						case int thisType when ItemID.Sets.Glowsticks[thisType]:
 							SmartSelect_SelectItem(i);
 							return;
 					}
@@ -13858,6 +_,13 @@
 				if (tile == null)
 					return;
 
+				if (tile.type >= TileID.Count) {
+					if (tile.active() && TileID.Sets.Torch[tile.type])
+						NearbyModTorch.Add(tile.type);
+
+					continue;
+				}
+
 				if (!tile.active() || tile.type != 4 || tile.frameX < 0 || tile.frameY < 0)
 					continue;
 
@@ -13943,7 +_,7 @@
 				NetMessage.SendData(4, -1, -1, null, whoAmI);
 
 			if (numberOfTorchAttacksMade >= 95) {
-				int number = Item.NewItem(new EntitySource_ByItemSourceId(this, 6), (int)position.X, (int)position.Y, width, height, 5043);
+				int number = Item.NewItem(new EntitySource_TorchGod(this, Context: "TorchGod_FavorLoot"), (int)position.X, (int)position.Y, width, height, 5043);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
@@ -13973,7 +_,7 @@
 				float num10 = vector2.Length();
 				vector2.Normalize();
 				vector2 *= num7;
-				int num11 = Projectile.NewProjectile(GetProjectileSource_Misc(10), vector, vector2, 949, num8, 1f, whoAmI, num9, num10);
+				int num11 = Projectile.NewProjectile(new EntitySource_TorchGod(this, Context: "TorchGod_Projectile"), vector, vector2, 949, num8, 1f, whoAmI, num9, num10);
 				Main.projectile[num11].ai[0] = num9;
 				Main.projectile[num11].ai[1] = num10;
 				Main.projectile[num11].netUpdate = true;
@@ -13991,6 +_,9 @@
 		if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < TorchID.Count)
 			nearbyTorch[inventory[selectedItem].placeStyle] = true;
 
+		if (TileLoader.GetTile(inventory[selectedItem].createTile) is ModTile modTile && TileID.Sets.Torch[modTile.Type])
+			NearbyModTorch.Add(modTile.Type);
+
 		float num = 0f;
 		float num2 = 0f;
 		if (!ZoneDungeon && !ZoneLihzhardTemple) {
@@ -14064,8 +_,11 @@
 					num += 2f;
 				else if (ZoneDesert || ZoneCorrupt || ZoneCrimson || ZoneHallow)
 					num += 0.5f;
+				// Extra patch context.
 			}
 		}
+
+		TileLoader.ModifyTorchLuck(this, ref num2, ref num);
 
 		if (num2 >= 1f)
 			torchLuck += 1f;
@@ -14084,6 +_,8 @@
 			nearbyTorch[i] = false;
 		}
 
+		NearbyModTorch.Clear();
+
 		if (torchLuck < 0f)
 			torchLuck = 0f;
 
@@ -14214,10 +_,16 @@
 		arcticDivingGear = false;
 		noBuilding = false;
 		strongBees = false;
+		/*
 		armorPenetration = 0;
+		*/
 		ashWoodBonus = false;
 		shroomiteStealth = false;
+		/*
 		statDefense = 0;
+		*/
+		statDefense = DefenseStat.Default;
+		DefenseEffectiveness = MultipliableFloat.One * VanillaBaseDefenseEffectiveness();
 		accWatch = 0;
 		accCompass = 0;
 		accDepthMeter = 0;
@@ -14225,6 +_,9 @@
 		canFloatInWater = false;
 		lifeRegen = 0;
 		manaCost = 1f;
+
+		//TML: Individual class stats handled by ResetDamageClassData.
+		/*
 		meleeSpeed = 1f;
 		meleeDamage = 1f;
 		rangedDamage = 1f;
@@ -14235,6 +_,8 @@
 		meleeCrit = 4;
 		rangedCrit = 4;
 		magicCrit = 4;
+		*/
+
 		hasFootball = false;
 		drawingFootball = false;
 		minionKB = 0f;
@@ -14275,18 +_,33 @@
 
 		honeyCombItem = null;
 		gravControl2 = false;
+
+		PlayerLoader.ModifyMaxStats(this);
+
 		statLifeMax2 = statLifeMax;
 		statManaMax2 = statManaMax;
 		chloroAmmoCost80 = false;
 		huntressAmmoCost90 = false;
 		ammoCost80 = false;
 		ammoCost75 = false;
+
+		//TML: 1.3 throwing fields' readdition.
+		ThrownCost50 = false;
+		ThrownCost33 = false;
+		ThrownVelocity = 1f;
+
 		manaRegenBuff = false;
 		hasCreditsSceneMusicBox = false;
+		/*
 		arrowDamage = 1f;
 		arrowDamageAdditiveStack = 0f;
 		bulletDamage = 1f;
 		rocketDamage = 1f;
+		*/
+		arrowDamage = StatModifier.Default;
+		bulletDamage = StatModifier.Default;
+		rocketDamage = StatModifier.Default;
+
 		coolWhipBuff = false;
 		yoraiz0rEye = 0;
 		yoraiz0rDarkness = false;
@@ -14366,7 +_,9 @@
 		dangerSense = false;
 		endurance = 0f;
 		whipRangeMultiplier = 1f;
+		/*
 		whipUseTimeMultiplier = 1f;
+		*/
 		calmed = false;
 		beetleOrbs = 0;
 		beetleBuff = false;
@@ -14540,6 +_,7 @@
 		slowOgreSpit = false;
 		wings = 0;
 		wingsLogic = 0;
+		equippedWings = null; // Added by TML.
 		wingTimeMax = 0;
 		brokenArmor = false;
 		silence = false;
@@ -14652,18 +_,23 @@
 			}
 		}
 
+		ResetDamageClassData();
+
 		mount.CheckMountBuff(this);
+
+		PlayerLoader.ResetEffects(this);
+		PlayerLoader.ResetInfoAccessories(this);
 	}
 
 	private void UpdateLadyBugLuckTime()
 	{
 		if (ladyBugLuckTimeLeft > 0) {
-			ladyBugLuckTimeLeft -= Main.dayRate;
+			ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
 			if (ladyBugLuckTimeLeft < 0)
 				ladyBugLuckTimeLeft = 0;
 		}
 		else if (ladyBugLuckTimeLeft < 0) {
-			ladyBugLuckTimeLeft += Main.dayRate;
+			ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
 			if (ladyBugLuckTimeLeft > 0)
 				ladyBugLuckTimeLeft = 0;
 		}
@@ -14836,6 +_,8 @@
 			lifeRegen -= 100;
 		}
 
+		PlayerLoader.UpdateBadLifeRegen(this);
+
 		if (honey && lifeRegen < 0) {
 			lifeRegen += 4;
 			if (lifeRegen > 0)
@@ -14906,6 +_,8 @@
 		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
 			lifeRegen += 2;
 
+		PlayerLoader.UpdateLifeRegen(this);
+
 		if (bleed)
 			lifeRegenTime = 0f;
 
@@ -14973,6 +_,8 @@
 		if (rabid)
 			num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
 
+		PlayerLoader.NaturalLifeRegen(this, ref num5);
+
 		float num7 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
 		num5 *= num7;
 		lifeRegen += (int)Math.Round(num5);
@@ -15166,8 +_,8 @@
 	public void UpdateJumpHeight()
 	{
 		if (mount.Active) {
-			jumpHeight = mount.JumpHeight(velocity.X);
+			jumpHeight = mount.JumpHeight(this, velocity.X);
-			jumpSpeed = mount.JumpSpeed(velocity.X);
+			jumpSpeed = mount.JumpSpeed(this, velocity.X);
 		}
 		else {
 			if (jumpBoost) {
@@ -15582,14 +_,14 @@
 			if (flag4)
 				num5 = 30;
 
-			float damage = (float)num5 * minionDamage;
+			float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
 			float knockback = 10f;
 			if (flag4)
 				knockback = 7f;
 
 			int nPCImmuneTime = 30;
 			int playerImmuneTime = 6;
-			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime);
+			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 44 && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 4f) {
@@ -15599,11 +_,11 @@
 
 			rect2.Width = 2;
 			rect2.Inflate(6, 12);
-			float damage2 = 100f * minionDamage;
+			float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
 			float knockback2 = 12f;
 			int nPCImmuneTime2 = 30;
 			int playerImmuneTime2 = 6;
-			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2);
+			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 45 && Math.Abs(velocity.X) > mount.DashSpeed * 0.9f) {
@@ -15613,11 +_,11 @@
 
 			rect3.Width = 2;
 			rect3.Inflate(6, 12);
-			float damage3 = 120f * minionDamage;
+			float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
 			float knockback3 = 12f;
 			int nPCImmuneTime3 = 30;
 			int playerImmuneTime3 = 6;
-			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3);
+			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 14 && Math.Abs(velocity.X) > mount.RunSpeed / 2f) {
@@ -15627,11 +_,11 @@
 
 			rect4.Width = 2;
 			rect4.Inflate(6, 12);
-			float damage4 = 90f * minionDamage;
+			float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
 			float knockback4 = 10f;
 			int nPCImmuneTime4 = 30;
 			int playerImmuneTime4 = 6;
-			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4);
+			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 17 && Math.Abs(velocity.X) > mount.RunSpeed / 2f) {
@@ -15641,11 +_,11 @@
 
 			rect5.Width = 2;
 			rect5.Inflate(6, 12);
-			float damage5 = 40f * minionDamage;
+			float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 			float knockback5 = 10f;
 			int nPCImmuneTime5 = 30;
 			int playerImmuneTime5 = 12;
-			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5);
+			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5, DamageClass.Summon);
 		}
 
 		TryUsingDiggerCart();
@@ -15680,7 +_,10 @@
 			num -= height;
 
 		if (runSoundDelay == 0 && velocity.Y == 0f) {
+			/*
 			SoundEngine.PlaySound(hermesStepSound.SoundType, (int)position.X, (int)position.Y, hermesStepSound.SoundStyle);
+			*/
+			SoundEngine.PlaySound(hermesStepSound.Style, position);
 			runSoundDelay = hermesStepSound.IntendedCooldown;
 		}
 
@@ -15822,7 +_,7 @@
 		}
 
 		if (num != 0) {
-			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
 			for (int i = 0; i < num2; i++) {
 				WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
 			}
@@ -15833,7 +_,7 @@
 		}
 	}
 
-	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime)
+	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime, DamageClass? damageType = null)
 	{
 		int num = 0;
 		for (int i = 0; i < 200; i++) {
@@ -15851,7 +_,7 @@
 					num2 = 1;
 
 				if (whoAmI == Main.myPlayer)
-					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false);
+					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false, damageType: damageType);
 
 				nPC.immune[whoAmI] = NPCImmuneTime;
 				GiveImmuneTimeForCollisionAttack(PlayerImmuneTime);
@@ -15863,21 +_,71 @@
 		return num;
 	}
 
+	// Added by TML
+	public void ApplyBannerOffenseBuff(NPC npc, ref NPC.HitModifiers modifiers) => ApplyBannerOffenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
+
+	// Added by TML
+	public void ApplyBannerOffenseBuff(int bannerId, ref NPC.HitModifiers modifiers)
+	{
+		if (!HasNPCBannerBuff(bannerId))
+			return;
+
+		var effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
+		modifiers.TargetDamageMultiplier *= Main.expertMode ? effect.ExpertDamageDealt : effect.NormalDamageDealt;
+	}
+
+	// Added by TML
+	public void ApplyBannerDefenseBuff(NPC npc, ref Player.HurtModifiers modifiers) => ApplyBannerDefenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
+
+	// Added by TML
+	public void ApplyBannerDefenseBuff(int bannerId, ref Player.HurtModifiers modifiers)
+	{
+		if (!HasNPCBannerBuff(bannerId))
+			return;
+
+		var effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
+		modifiers.IncomingDamageMultiplier *= Main.expertMode ? effect.ExpertDamageReceived : effect.NormalDamageReceived;
+	}
+
-	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit)
+	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit, DamageClass? damageType = null, bool damageVariation = false)
 	{
+		if (!PlayerLoader.CanHitNPC(this, npc))
+			return;
+
+		/*
 		int num = Item.NPCtoBanner(npc.BannerID());
 		if (num > 0 && HasNPCBannerBuff(num))
 			damage = ((!Main.expertMode) ? ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].NormalDamageDealt)) : ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].ExpertDamageDealt)));
+		*/
+		var modifiers = npc.GetIncomingStrikeModifiers(damageType ?? DamageClass.Default, direction);
+		PlayerLoader.ModifyHitNPC(this, npc, ref modifiers);
 
+		ApplyBannerOffenseBuff(npc, ref modifiers);
+
+		// most instances of this damage in vanilla are not scaling but they still use generic armor penetration bonus
+		modifiers.ArmorPenetration += GetTotalArmorPenetration(damageType ?? DamageClass.Generic);
+
+		StrikeNPCDirect(npc, modifiers.ToHitInfo(damage, crit, knockback, damageVariation, luck));
+	}
+
+	public void StrikeNPCDirect(NPC npc, NPC.HitInfo hit)
+	{
 		OnHit(npc.Center.X, npc.Center.Y, npc);
+		/*
 		damage += npc.checkArmorPenetration(armorPenetration, 0f);
+		*/
 		NPCKillAttempt attempt = new NPCKillAttempt(npc);
-		int dmg = (int)npc.StrikeNPC(damage, knockback, direction, crit);
-		if (accDreamCatcher)
+		int dmg = npc.StrikeNPC(hit);
+		PlayerLoader.OnHitNPC(this, npc, hit, dmg);
+
+		if (accDreamCatcher && !npc.HideStrikeDamage)
 			addDPS(dmg);
 
 		if (Main.netMode != 0)
+			/*
 			NetMessage.SendData(28, -1, -1, null, npc.whoAmI, damage, knockback, direction, crit.ToInt());
+			*/
+			NetMessage.SendStrikeNPC(npc, hit);
 
 		int num2 = Item.NPCtoBanner(npc.BannerID());
 		if (num2 >= 0)
@@ -15931,7 +_,7 @@
 
 				Rectangle rect2 = nPC.getRect();
 				if (rect.Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height))) {
-					float num = 40f * minionDamage;
+					float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 					float knockback = 5f;
 					int num2 = direction;
 					if (velocity.X < 0f)
@@ -15941,7 +_,7 @@
 						num2 = 1;
 
 					if (whoAmI == Main.myPlayer)
-						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false);
+						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false, DamageClass.Summon);
 
 					nPC.immune[whoAmI] = 10;
 					velocity.Y = -10f;
@@ -16334,16 +_,24 @@
 
 					Rectangle rect = nPC.getRect();
 					if (rectangle.Intersects(rect) && (nPC.noTileCollide || CanHit(nPC))) {
+						/*
 						float num = 30f * meleeDamage;
 						float num2 = 9f;
+						*/
+						float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
+						float num2 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 						bool crit = false;
+
+						// Knockback glove and buff moved to UpdateEquips and Update
+						/*
 						if (kbGlove)
 							num2 *= 2f;
 
 						if (kbBuff)
 							num2 *= 1.5f;
+						*/
 
-						if (Main.rand.Next(100) < meleeCrit)
+						if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 							crit = true;
 
 						int num3 = direction;
@@ -16354,7 +_,7 @@
 							num3 = 1;
 
 						if (whoAmI == Main.myPlayer)
-							ApplyDamageToNPC(nPC, (int)num, num2, num3, crit);
+							ApplyDamageToNPC(nPC, (int)num, num2, num3, crit, DamageClass.Melee);
 
 						eocDash = 10;
 						dashDelay = 30;
@@ -16384,16 +_,25 @@
 						ConsumeSolarFlare();
 					}
 
+					/*
 					float num4 = 150f * meleeDamage;
 					float num5 = 9f;
+					*/
+					float num4 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
+					float num5 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
+
 					bool crit2 = false;
+
+					// Knockback glove and buff moved to UpdateEquips and Update
+					/*
 					if (kbGlove)
 						num5 *= 2f;
 
 					if (kbBuff)
 						num5 *= 1.5f;
+					*/
 
-					if (Main.rand.Next(100) < meleeCrit)
+					if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 						crit2 = true;
 
 					int num6 = direction;
@@ -16404,7 +_,7 @@
 						num6 = 1;
 
 					if (whoAmI == Main.myPlayer) {
-						ApplyDamageToNPC(nPC2, (int)num4, num5, num6, crit2);
+						ApplyDamageToNPC(nPC2, (int)num4, num5, num6, crit2, DamageClass.Melee);
 						int num7 = Projectile.NewProjectile(GetProjectileSource_OnHit(nPC2, 2), base.Center.X, base.Center.Y, 0f, 0f, 608, (int)num4, 15f, Main.myPlayer);
 						Main.projectile[num7].Kill();
 					}
@@ -16631,6 +_,14 @@
 		solarDashConsumedFlare = false;
 	}
 
+
+	// TODO:
+	// - Make public, as it has little reason to be private and could be of great help to those making modded dashes
+	// - Properly explain how to use this in the context of programming a modded dash (use ExampleShield for this; see below)
+	// - Make ExampleShield use this, and simplify it accordingly (it currently has way too many moving parts that require extra upkeep, for way too little payoff)
+	//
+	// I'll do all this in an upcoming PR if nobody else does.
+	// - Thomas
 	private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null)
 	{
 		dir = 0;
@@ -16930,6 +_,7 @@
 			if (wingsLogic == 26) {
 				num2 = 0.75f;
 				num5 = 0.15f;
+				// Patch note: num2, num5, num4, num3, num - Used below.
 				num4 = 1f;
 				num3 = 2.5f;
 				num = 0.125f;
@@ -17027,6 +_,8 @@
 					num = 0.15f;
 			}
 
+			ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
+
 			velocity.Y -= num * gravDir;
 			if (gravDir == 1f) {
 				if (velocity.Y > 0f)
@@ -17335,7 +_,7 @@
 					Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
 					RemoveAllGrapplingHooks();
 					int num4 = 13;
-					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode))
+					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
 						num4 = miscEquips[2].mountType;
 
 					int num5 = height + Mount.GetHeightBoost(num4);
@@ -17410,6 +_,12 @@
 			if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
 				continue;
 
+			int type = projectile.type;
+			bool useAiType = projectile.ModProjectile != null && projectile.ModProjectile.AIType > 0;
+			if (useAiType) {
+				projectile.type = projectile.ModProjectile.AIType;
+			}
+
 			num += projectile.position.X + (float)(projectile.width / 2);
 			num2 += projectile.position.Y + (float)(projectile.height / 2);
 			num3++;
@@ -17450,6 +_,12 @@
 				if (vector5.X != 0f)
 					preferredPlayerDirectionToSet = Math.Sign(vector5.X);
 			}
+
+			if (useAiType) {
+				projectile.type = type;
+			}
+
+			ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num2);
 		}
 
 		if (num3 == 0) {
@@ -17474,13 +_,14 @@
 		if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
 			num9 = 16f;
 
+		ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num9);
 		float num10 = num8;
 		num10 = ((!(num8 > num9)) ? 1f : (num9 / num8));
 		preferedPlayerVelocityX *= num10;
 		preferedPlayerVelocityY *= num10;
 	}
 
-	private void RefreshMovementAbilities(bool doubleJumps = true)
+	public void RefreshMovementAbilities(bool doubleJumps = true)
 	{
 		wingTime = wingTimeMax;
 		rocketTime = rocketTimeMax;
@@ -18269,10 +_,10 @@
 		if (gravDir == -1f)
 			num2 = (int)(position.Y - 0.1f) / 16;
 
-		Tile floorTile = GetFloorTile(num, num2);
+		Tile? floorTile = GetFloorTile(num, num2);
 		int num3 = -1;
 		if (floorTile != null)
-			num3 = floorTile.type;
+			num3 = floorTile.Value.type;
 
 		if (num3 <= -1) {
 			ResetFloorFlags();
@@ -18287,11 +_,14 @@
 		if (num3 == 666 && whoAmI == Main.myPlayer)
 			AddBuff(120, 180);
 
+
+		TileLoader.FloorVisuals(num3, this);
+
 		if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
 			num3 = -1;
 
 		if (!wet && !mount.Cart)
-			MakeFloorDust(Falling, num3, floorTile.color());
+			MakeFloorDust(Falling, num3, floorTile.Value.color());
 	}
 
 	public void ResetFloorFlags()
@@ -18303,9 +_,10 @@
 		runningOnSand = false;
 	}
 
+	//TML: Made return value nullable.
-	public static Tile GetFloorTile(int x, int y)
+	public static Tile? GetFloorTile(int x, int y)
 	{
-		Tile result = null;
+		Tile? result = null;
 		if (Main.tile[x - 1, y] == null)
 			Main.tile[x - 1, y] = new Tile();
 
@@ -18351,6 +_,7 @@
 			}, whoAmI);
 		}
 
+		if (TileLoader.HasWalkDust(type)) { } else
 		if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && type != 666)
 			return;
 
@@ -18434,6 +_,7 @@
 			if (num3 == 0 && Main.rand.Next(3) != 0)
 				flag2 = false;
 
+			// Patch note: num3 & flag2 are used below.
 			if (num3 == 53 && Main.rand.Next(3) != 0)
 				flag2 = false;
 
@@ -18447,6 +_,8 @@
 			if (type == 460)
 				newColor = new Color(100, 150, 130, 100);
 
+			TileLoader.WalkDust(type, ref num3, ref flag2, ref newColor);
+
 			if (!Falling) {
 				float num4 = Math.Abs(velocity.X) / 3f;
 				if ((float)Main.rand.Next(100) > num4 * 100f)
@@ -18712,6 +_,9 @@
 
 	public void Update(int i)
 	{
+		// Auto-disposed at the end of the method.
+		using var _currentPlr = new Main.CurrentPlayerOverride(this);
+
 		if (i == Main.myPlayer && Main.netMode != 2)
 			LockOnHelper.Update();
 
@@ -18833,6 +_,7 @@
 		if (whoAmI != Main.myPlayer) {
 			int num2 = (int)(position.X + (float)(width / 2)) / 16;
 			int num3 = (int)(position.Y + (float)(height / 2)) / 16;
+			/*
 			if (!WorldGen.InWorld(num2, num3, 4))
 				flag = true;
 			else if (Main.tile[num2, num3] == null)
@@ -18845,6 +_,9 @@
 				flag = true;
 			else if (Main.tile[num2, num3 + 3] == null)
 				flag = true;
+			*/
+			if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num2 - 3, num3 - 3, num2 + 3, num3 + 3))
+				flag = true;
 
 			if (flag) {
 				outOfRange = true;
@@ -18878,6 +_,9 @@
 
 		UpdateHairDyeDust();
 		UpdateMiscCounter();
+
+		PlayerLoader.PreUpdate(this);
+
 		infernoCounter++;
 		if (infernoCounter >= 180)
 			infernoCounter = 0;
@@ -19218,6 +_,9 @@
 				}
 
 				controlDownHold = holdDownCardinalTimer[0] >= 45;
+
+				PlayerLoader.SetControls(this);
+
 				if (controlInv) {
 					if (releaseInventory)
 						ToggleInv();
@@ -19357,6 +_,7 @@
 						CaptureManager.Instance.Scrolling();
 					}
 					else if (!flag8) {
+						if (PlayerInput.MouseInModdedUI.Count > 0) { } else
 						if (!Main.playerInventory) {
 							HandleHotbar();
 						}
@@ -19397,10 +_,13 @@
 								if (Main.focusRecipe > Main.numAvailableRecipes - 1)
 									Main.focusRecipe = Main.numAvailableRecipes - 1;
 
+								// Extra patch context.
 								if (Main.focusRecipe < 0)
 									Main.focusRecipe = 0;
 							}
 						}
+
+						PlayerInput.MouseInModdedUI.Clear();
 					}
 				}
 				else {
@@ -19566,11 +_,14 @@
 					}
 				}
 
+				/*
 				bool flag11 = false;
 				for (int num23 = 3; num23 < 10; num23++) {
 					if (armor[num23].stack > 0 && armor[num23].wingSlot > -1)
 						flag11 = true;
 				}
+				*/
+				bool flag11 = equippedWings != null;
 
 				if (stoned) {
 					int num24 = (int)(((float)num18 * gravDir - 2f) * 20f);
@@ -19706,9 +_,16 @@
 		else
 			afkCounter = 0;
 
+		// TML:
+		// This, right here, is the principal cause of crit chance being a massive pain.
+		// By commenting this out, your critical strike chance for the vanilla "three" classes capable of crits will no longer be modified based on your current weapon.
+		// This fixes a number of issues related to tooltip crit displays, and while it isn't the primary fix for crit swap, it definitely contributes to it.
+		// - Thomas
+		/*
 		meleeCrit += inventory[selectedItem].crit;
 		magicCrit += inventory[selectedItem].crit;
 		rangedCrit += inventory[selectedItem].crit;
+		*/
 		if (whoAmI == Main.myPlayer) {
 			Main.musicBox2 = -1;
 			if (Main.SceneMetrics.WaterCandleCount > 0)
@@ -19742,12 +_,21 @@
 				AddBuff(194, 2, quiet: false);
 		}
 
+		PlayerLoader.PreUpdateBuffs(this);
+
-		for (int num26 = 0; num26 < BuffID.Count; num26++) {
+		for (int num26 = 0; num26 < BuffLoader.BuffCount; num26++) {
 			buffImmune[num26] = false;
 		}
 
 		UpdateProjectileCaches(i);
 		UpdateBuffs(i);
+
+		PlayerLoader.PostUpdateBuffs(this);
+
+		// Moved from ItemCheck_OwnerOnlyCode/DashMovement/GetWeaponKnockback
+		if (kbBuff)
+			allKB *= 1.5f;
+
 		if (whoAmI == Main.myPlayer) {
 			if (!onFire && !poisoned)
 				trapDebuffSource = false;
@@ -19850,6 +_,10 @@
 		if (shadowDodge && !onHitDodge)
 			ClearBuff(59);
 
+
+		//TODO: Move down?
+		PlayerLoader.PostUpdateEquips(this);
+
 		if (maxTurretsOld != maxTurrets) {
 			UpdateMaxTurrets();
 			maxTurretsOld = maxTurrets;
@@ -19897,9 +_,14 @@
 
 			meleeDamage += (1f - stealth) * 3f;
 			meleeCrit += (int)((1f - stealth) * 30f);
+
+			// Psycho Knife knockback. Moved from ItemCheck_OwnerOnlyCode/GetWeaponKnockback
+			GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
+
+			/*
 			if (meleeCrit > 100)
 				meleeCrit = 100;
-
+			*/
 			aggro -= (int)((1f - stealth) * 750f);
 			if (stealthTimer > 0)
 				stealthTimer--;
@@ -19930,6 +_,10 @@
 
 			rangedDamage += (1f - stealth) * 0.6f;
 			rangedCrit += (int)((1f - stealth) * 10f);
+
+			// Stealth knockback. Moved from GetWeaponKnockback
+			GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
+
 			aggro -= (int)((1f - stealth) * 750f);
 			if (stealthTimer > 0)
 				stealthTimer--;
@@ -19949,6 +_,10 @@
 
 				rangedDamage += (1f - stealth) * 0.8f;
 				rangedCrit += (int)((1f - stealth) * 20f);
+
+				// Stealth knockback. Moved from GetWeaponKnockback
+				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
+
 				aggro -= (int)((1f - stealth) * 1200f);
 				accRunSpeed *= 0.3f;
 				maxRunSpeed *= 0.3f;
@@ -19996,9 +_,12 @@
 		if (manaSick)
 			magicDamage *= 1f - manaSickReduction;
 
+		// Attack speed multipliers now applied in Player.GetWeaponAttackSpeed.
+		/*
 		float num32 = meleeSpeed - 1f;
 		num32 *= ItemID.Sets.BonusMeleeSpeedMultiplier[inventory[selectedItem].type];
 		meleeSpeed = 1f + num32;
+		*/
 		if (tileSpeed > 3f)
 			tileSpeed = 3f;
 
@@ -20007,11 +_,18 @@
 			wallSpeed = 3f;
 
 		wallSpeed = 1f / wallSpeed;
+
+		// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+		/*
 		if (statManaMax2 > 400)
 			statManaMax2 = 400;
+		*/
 
+		// positive value capping builtin to DefenseStat
+		/*
 		if (statDefense < 0)
 			statDefense = 0;
+		*/
 
 		if (slowOgreSpit) {
 			moveSpeed /= 3f;
@@ -20046,6 +_,9 @@
 			pickSpeed = 0.3f;
 
 		CapAttackSpeeds();
+
+		PlayerLoader.PostUpdateMiscEffects(this);
+
 		UpdateLifeRegen();
 		soulDrain = 0;
 		UpdateManaRegen();
@@ -20070,11 +_,14 @@
 			statDefense /= 2;
 
 		if (witheredWeapon) {
+			allDamage *= 0.5f;
+			/*
 			meleeDamage *= 0.5f;
 			rangedDamage *= 0.5f;
 			magicDamage *= 0.5f;
 			minionDamage *= 0.5f;
 			rangedMultDamage *= 0.5f;
+			*/
 		}
 
 		lastTileRangeX = tileRangeX;
@@ -20594,6 +_,8 @@
 					mount.UpdateDrill(this, controlUp, controlDown);
 			}
 
+			PlayerLoader.PostUpdateRunSpeeds(this);
+
 			HorizontalMovement();
 			bool flag20 = !mount.Active;
 			if (forcedGravity > 0) {
@@ -20684,12 +_,13 @@
 				CancelAllJumpVisualEffects();
 			}
 			else {
+				bool isCustomWings = ItemLoader.WingUpdate(this, flag21);
 				if (flag21) {
 					WingAirVisuals();
 					WingMovement();
 				}
 
-				WingFrame(flag21);
+				WingFrame(flag21, isCustomWings);
 				if (wingsLogic > 0 && rocketBoots != 0 && velocity.Y != 0f && rocketTime != 0) {
 					int num45 = 6;
 					int num46 = rocketTime * num45;
@@ -20700,6 +_,7 @@
 					rocketTime = 0;
 				}
 
+				if (isCustomWings) { } else
 				if (flag21 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45) {
 					bool flag22 = wingFrame == 3;
 					if (wings == 43 || wings == 44)
@@ -20916,6 +_,7 @@
 								Main.dust[num59].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
 							}
 
+							if (isCustomWings) { } else
 							if (wings == 4) {
 								rocketDelay2--;
 								if (rocketDelay2 <= 0) {
@@ -21257,12 +_,16 @@
 
 				for (int num79 = 0; num79 < 200; num79++) {
 					if (Main.npc[num79].active && !Main.npc[num79].dontTakeDamage && !Main.npc[num79].friendly && Main.npc[num79].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num79]) && rectangle2.Intersects(new Rectangle((int)Main.npc[num79].position.X, (int)Main.npc[num79].position.Y, Main.npc[num79].width, Main.npc[num79].height))) {
+						/*
 						float num80 = meleeCrit;
 						if (num80 < (float)rangedCrit)
 							num80 = rangedCrit;
 
 						if (num80 < (float)magicCrit)
 							num80 = magicCrit;
+						*/
+						//TML: Potentially bad for performance
+						float num80 = DamageClassLoader.DamageClasses.Select(t => GetTotalCritChance(t)).Max();
 
 						bool crit = false;
 						if ((float)Main.rand.Next(1, 101) <= num80)
@@ -21722,6 +_,8 @@
 		if (vortexDebuff)
 			velocity.Y = velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
 
+		PlayerLoader.PreUpdateMovement(this);
+
 		if (tongued) {
 			position += velocity;
 			flag30 = false;
@@ -21810,11 +_,13 @@
 
 		if (statMana > statManaMax2)
 			statMana = statManaMax2;
-
+		// More patch context.
 		grappling[0] = -1;
 		grapCount = 0;
 		UpdateReleaseUseTile();
 		UpdateAdvancedShadows();
+
+		PlayerLoader.PostUpdate(this);
 	}
 
 	private void TryToToggleSmartCursor(ref bool smartCursorWanted)
@@ -21989,9 +_,11 @@
 
 	private void CapAttackSpeeds()
 	{
+		/*
 		float num = meleeSpeed;
 		meleeSpeed = TurnAttackSpeedToUseTimeMultiplier(num);
 		summonerWeaponSpeedBonus = TurnAttackSpeedToUseTimeMultiplier(num + summonerWeaponSpeedBonus);
+		*/
 	}
 
 	private float TurnAttackSpeedToUseTimeMultiplier(float speed)
@@ -22088,6 +_,9 @@
 
 	public void RecalculateLuck()
 	{
+		if (!PlayerLoader.PreModifyLuck(this, ref luck))
+			goto skipVanillaLuck;
+
 		luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
 		luck += (float)(int)luckPotion * 0.1f;
 		if (usedGalaxyPearl)
@@ -22101,6 +_,9 @@
 
 		luck += equipmentBasedLuckBonus;
 		luck += CalculateCoinLuck();
+		skipVanillaLuck:
+
+		PlayerLoader.ModifyLuck(this, ref luck);
 	}
 
 	public static int GetMouseScrollDelta() => PlayerInput.ScrollWheelDelta / 120;
@@ -22213,6 +_,8 @@
 
 		if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
 			runSlowdown *= 6f;
+
+		ItemLoader.HorizontalWingSpeeds(this);
 	}
 
 	private void RocketBootVisuals()
@@ -22327,7 +_,8 @@
 		}
 	}
 
-	public void WingFrame(bool wingFlap)
+	//TML: Added 'isCustomWings' parameter.
+	public void WingFrame(bool wingFlap, bool isCustomWings = false)
 	{
 		bool flag = wingsLogic != wings;
 		if (wings == 4) {
@@ -22969,6 +_,9 @@
 			num27 = 3;
 		}
 
+		if (isCustomWings)
+			return;
+
 		if (wings == 32)
 			num27 = 3;
 
@@ -23333,7 +_,7 @@
 		if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
 			r = new Rectangle(chestPointX * 16, chestPointY * 16, 32, 32);
 
-		if (tile.type == 88)
+		if (TileID.Sets.BasicDresser[tile.type])
 			r = new Rectangle(chestPointX * 16, chestPointY * 16, 48, 32);
 
 		if (tile.type == 29)
@@ -23552,6 +_,9 @@
 					break;
 			}
 
+			if (!CombinedHooks.CanNPCHitPlayer(Main.npc[i], this, ref specialHitSetter))
+				continue;
+
 			if ((specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
 				continue;
 
@@ -23583,10 +_,15 @@
 					num3 = 1;
 
 				int num4 = Main.DamageVar((float)Main.npc[i].damage * damageMultiplier, 0f - luck);
+
+				// Moved to CombinedHooks.ModifyHitByNPC
+				/*
 				int num5 = Item.NPCtoBanner(Main.npc[i].BannerID());
 				if (num5 > 0 && HasNPCBannerBuff(num5))
 					num4 = ((!Main.expertMode) ? ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].NormalDamageReceived)) : ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].ExpertDamageReceived)));
+				*/
 
+				// Extra patch context.
 				bool flag3 = !immune;
 				if (specialHitSetter >= 0)
 					flag3 = hurtCooldowns[specialHitSetter] == 0;
@@ -23609,8 +_,11 @@
 					ApplyDamageToNPC(Main.npc[i], damage, knockback, -num3, crit: false);
 				}
 
+				// Moved to CombinedHooks.ModifyHitByNPC
+				/*
 				if (resistCold && Main.npc[i].coldDamage)
 					num4 = (int)((float)num4 * 0.7f);
+				*/
 
 				if (flag && Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter) > 0.0 && !dead && !flag2)
 					StatusFromNPC(Main.npc[i]);
@@ -23694,6 +_,9 @@
 
 	public void ItemCheck_ManageRightClickFeatures()
 	{
+		// TODO: Reintegrate AltFunctionUse
+		//ItemLoader.AltFunctionUse(this.inventory[this.selectedItem], this)
+
 		bool flag = selectedItem != 58 && controlUseTile && Main.myPlayer == whoAmI && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
 		bool flag2 = flag;
 		if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
@@ -23814,11 +_,18 @@
 			controlUseItem = true;
 		}
 
+		// Extra patch context.
 		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[inventory[selectedItem].shoot]) {
 			altFunctionUse = 1;
 			controlUseItem = true;
 		}
 
+		// Added by TML
+		if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this)) {
+			altFunctionUse = 1;
+			controlUseItem = true;
+		}
+
 		if (!controlUseItem && altFunctionUse == 1)
 			altFunctionUse = 0;
 
@@ -23995,6 +_,12 @@
 
 	public void ScrollHotbar(int Offset)
 	{
+		//TML:
+		// Disable hotbar scrolling when using auto select.
+		// Previously it only worked when scrolling between 0 and 9, and made the sound.
+		if (selectedItem >= 10)
+			return;
+
 		Offset = ClampHotbarOffset(Offset);
 		selectedItem += Offset;
 		if (Offset != 0) {
@@ -24244,10 +_,13 @@
 			int num7 = Sign.ReadSign(num5, num6, CreateIfMissing: false);
 			if (num7 != -1 && tileTargetX >= num5 && tileTargetY >= num6 && tileTargetX <= num5 + 1 && tileTargetY <= num6 + 1) {
 				Main.signHover = num7;
+				// Extra patch context.
 				cursorItemIconEnabled = false;
 				cursorItemIconID = -1;
 			}
 		}
+
+		TileLoader.MouseOverFar(myX, myY);
 	}
 
 	private void TileInteractionsUse(int myX, int myY)
@@ -24326,7 +_,7 @@
 				Wiring.HitSwitch(myX, myY);
 				NetMessage.SendData(59, -1, -1, null, myX, myY);
 			}
-			else if (Main.tile[myX, myY].type == 139) {
+			else if (Main.tile[myX, myY].type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY])) {
 				flag2 = true;
 				SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
 				WorldGen.SwitchMB(myX, myY);
@@ -24450,7 +_,10 @@
 				flag2 = true;
 				GamepadEnableGrappleCooldown();
 			}
+			/*
 			else if (Main.tile[myX, myY].type == 4 || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90)) {
+			*/
+			else if (TileID.Sets.Torch[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90) || TileID.Sets.CanDropFromRightClick[Main.tile[myX, myY].type]) {
 				WorldGen.KillTile(myX, myY);
 				if (Main.netMode == 1)
 					NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
@@ -24770,7 +_,9 @@
 				if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss) {
 					for (int m = 0; m < 58; m++) {
 						if (inventory[m].type == 1293) {
+							if (ItemLoader.ConsumeItem(inventory[m], this))
-							inventory[m].stack--;
+								inventory[m].stack--;
+
 							if (inventory[m].stack <= 0)
 								inventory[m].SetDefaults();
 
@@ -24788,7 +_,7 @@
 						NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
 				}
 			}
-			else if (Main.tile[myX, myY].type == 10) {
+			else if (TileLoader.IsClosedDoor(Main.tile[myX, myY])) {
 				flag2 = true;
 				if (WorldGen.IsLockedDoor(myX, myY)) {
 					int num43 = 1141;
@@ -24796,13 +_,18 @@
 					for (int n = 0; n < 58; n++) {
 						if (inventory[n].type == num43 && inventory[n].stack > 0) {
 							flag9 = true;
+							if (ItemLoader.ConsumeItem(inventory[n], this))
-							inventory[n].stack--;
+								inventory[n].stack--;
+
 							if (inventory[n].stack <= 0)
 								inventory[n] = new Item();
 
 							WorldGen.UnlockDoor(myX, myY);
 							if (Main.netMode == 1)
 								NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
+
+							// Added by TML.
+							break;
 						}
 					}
 
@@ -24821,18 +_,20 @@
 					}
 				}
 				else {
+					int originalClosedDoorType = Main.tile[myX, myY].type;
+
 					WorldGen.OpenDoor(myX, myY, direction);
-					if (Main.tile[myX, myY].type != 10) {
+					if (Main.tile[myX, myY].type != originalClosedDoorType) {
 						NetMessage.SendData(19, -1, -1, null, 0, myX, myY, direction);
 					}
 					else {
 						WorldGen.OpenDoor(myX, myY, -direction);
-						if (Main.tile[myX, myY].type != 10)
+						if (Main.tile[myX, myY].type != originalClosedDoorType)
 							NetMessage.SendData(19, -1, -1, null, 0, myX, myY, -direction);
 					}
 				}
 			}
-			else if (Main.tile[myX, myY].type == 11) {
+			else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0) {
 				flag2 = true;
 				if (WorldGen.CloseDoor(myX, myY))
 					NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
@@ -25004,7 +_,10 @@
 				if (flag12)
 					NetMessage.SendTileSquare(-1, num62, num63, 2, 2);
 			}
+			/*
 			else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
+			*/
+			else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] && Main.tile[myX, myY].type < TileID.Count || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
 				flag2 = true;
 				Main.mouseRightRelease = false;
 				int num68 = 0;
@@ -25046,7 +_,7 @@
 					editedChestName = false;
 				}
 
-				bool flag13 = Chest.IsLocked(Main.tile[num69, num70]);
+				bool flag13 = Chest.IsLocked(num69, num70);
 				if (Main.netMode == 1 && num68 == 0 && !flag13) {
 					if (num69 == chestX && num70 == chestY && chest != -1) {
 						chest = -1;
@@ -25116,7 +_,9 @@
 
 									flag15 = true;
 									if (flag16) {
+										if (ItemLoader.ConsumeItem(inventory[num76], this))
-										inventory[num76].stack--;
+											inventory[num76].stack--;
+
 										if (inventory[num76].stack <= 0)
 											inventory[num76] = new Item();
 									}
@@ -25190,13 +_,16 @@
 				if (flag17)
 					LaunchMinecartHook(myX, myY);
 			}
+
+			if (TileLoader.RightClick(myX, myY))
+				flag2 = true;
 		}
 
 		if (flag2)
 			tileInteractionHappened = true;
 	}
 
-	private static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
+	public static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
 	{
 		short frameX = Main.tile[myX, myY].frameX;
 		bool flag = frameX / 72 == 1;
@@ -25345,7 +_,14 @@
 			StopPettingAnimal();
 	}
 
+	/// <summary>
+	/// Handles boilerplate for gamepad and UI when opening or closing a container.
+	/// <br/>Sets <see cref="Player.chestX"/>, and <see cref="Player.chestY"/>, and <see cref="Player.chest"/> to the given coordinates.
+	/// </summary>
+	/// <param name="x">The top-left X coordinate of the container.</param>
+	/// <param name="y">The top-left Y coordinate of the container.</param>
+	/// <param name="newChest">The container index in <see cref="Main.chest"/> if opening, or -1 if closing.</param>
-	private void OpenChest(int x, int y, int newChest)
+	public void OpenChest(int x, int y, int newChest)
 	{
 		if (chest != -1 && Main.myPlayer == whoAmI) {
 			for (int i = 0; i < 40; i++) {
@@ -26230,7 +_,10 @@
 			cursorItemIconID = 3747;
 		}
 
+		/*
 		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && (inventory[selectedItem].type == 424 || inventory[selectedItem].type == 1103 || inventory[selectedItem].type == 2339 || inventory[selectedItem].type == 2338 || inventory[selectedItem].type == 2337)) {
+		*/
+		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1) {
 			noThrow = 2;
 			cursorItemIconEnabled = true;
 			cursorItemIconID = inventory[selectedItem].type;
@@ -26824,6 +_,8 @@
 			noThrow = 2;
 		}
 
+		TileLoader.MouseOver(myX, myY);
+
 		if (PlayerInput.UsingGamepad && cursorItemIconText.Length == 0) {
 			cursorItemIconEnabled = false;
 			cursorItemIconID = 0;
@@ -26967,11 +_,23 @@
 			if (!item.active || item.shimmerTime != 0f || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item) || (item.shimmered && !((double)item.velocity.Length() < 0.2)))
 				continue;
 
+			if (!ItemLoader.CanPickup(item, this))
+				continue;
+
 			int itemGrabRange = GetItemGrabRange(item);
 			Rectangle hitbox = item.Hitbox;
 			if (base.Hitbox.Intersects(hitbox)) {
-				if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0))
+				if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0)) {
+					if (!ItemLoader.OnPickup(Main.item[j], this)) {
+						Main.item[j] = new Item();
+						if (Main.netMode == 1)
+							NetMessage.SendData(21, -1, -1, null, j);
+
+						continue;
+					}
+
 					item = PickupItem(i, j, item);
+				}
 			}
 			else {
 				if (!new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2).Intersects(hitbox))
@@ -26985,6 +_,7 @@
 					if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 						flag = true;
 
+					if (ItemLoader.GrabStyle(item, this)) { } else
 					if (flag)
 						PullItem_Pickup(item, 7f, 1);
 					else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
@@ -27105,6 +_,10 @@
 		return itemToPickUp;
 	}
 
+	/// <summary>
+	/// Heals the player for a certain amount.
+	/// </summary>
+	/// <param name="amount">The amount to heal the player by.</param>
 	public void Heal(int amount)
 	{
 		statLife += amount;
@@ -27115,6 +_,12 @@
 			statLife = statLifeMax2;
 	}
 
+	/// <summary>
+	/// Fetches the range at which the given item begins to gravitate towards the player.<br/>
+	/// This range, referred to as item grab range, is measured in pixels.
+	/// </summary>
+	/// <param name="item">The item whose grab range is being evaluated.</param>
+	/// <returns>The item grab range of the player, in pixels.</returns>
 	public int GetItemGrabRange(Item item)
 	{
 		int num = defaultItemGrabRange;
@@ -27139,9 +_,11 @@
 		if (ItemID.Sets.NebulaPickup[item.type])
 			num += 100;
 
+		// Extra patch context.
 		if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 			num += 240;
 
+		ItemLoader.GrabRange(item, this, ref num);
 		return num;
 	}
 
@@ -27569,7 +_,7 @@
 			num2 += 4;
 		}
 
-		for (int i = 0; i < TileID.Count; i++) {
+		for (int i = 0; i < adjTile.Length; i++) {
 			oldAdjTile[i] = adjTile[i];
 			adjTile[i] = false;
 		}
@@ -27580,6 +_,8 @@
 		adjHoney = false;
 		oldAdjLava = adjLava;
 		adjLava = false;
+		oldAdjShimmer = adjShimmer;
+		adjShimmer = false;
 		alchemyTable = false;
 		int num3 = (int)((position.X + (float)(width / 2)) / 16f);
 		int num4 = (int)((position.Y + (float)height) / 16f);
@@ -27610,16 +_,21 @@
 							alchemyTable = true;
 							break;
 					}
+
+					TileLoader.AdjTiles(this, Main.tile[j, k].type);
 				}
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
 					adjWater = true;
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
 					adjHoney = true;
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
 					adjLava = true;
+
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 3) || TileID.Sets.CountsAsShimmerSource[Main.tile[j, k].type])
+					adjShimmer = true;
 			}
 		}
 
@@ -27627,7 +_,7 @@
 			return;
 
 		bool flag = false;
-		for (int l = 0; l < TileID.Count; l++) {
+		for (int l = 0; l < adjTile.Length; l++) {
 			if (oldAdjTile[l] != adjTile[l]) {
 				flag = true;
 				break;
@@ -27643,6 +_,9 @@
 		if (adjLava != oldAdjLava)
 			flag = true;
 
+		if (adjShimmer != oldAdjShimmer)
+			flag = true;
+
 		if (flag)
 			Recipe.FindRecipes();
 	}
@@ -27759,7 +_,7 @@
 			waist = 0;
 
 		if (!dead && body >= 0) {
-			sbyte b = (sbyte)(Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
+			int b = (Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
 			if (b != -1) {
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[b]) {
 					backpack = b;
@@ -27775,7 +_,7 @@
 				}
 			}
 
-			sbyte b2 = (sbyte)ArmorIDs.Body.Sets.IncludedCapeFront[body];
+			int b2 = ArmorIDs.Body.Sets.IncludedCapeFront[body];
 			if (b2 != -1 && front == -1) {
 				front = b2;
 				cFront = cBody;
@@ -27848,9 +_,14 @@
 			SetArmorEffectVisuals(this);
 		}
 
+		/*
 		hermesStepSound.SoundType = 17;
 		hermesStepSound.SoundStyle = -1;
+		*/
+		hermesStepSound.Style = SoundID.Run;
+
 		hermesStepSound.IntendedCooldown = 9;
+
 		if (head == 99 && body == 65 && legs == 54)
 			turtleArmor = true;
 
@@ -27859,8 +_,12 @@
 
 		ApplyArmorSoundAndDustChanges();
 		if (legs == 140) {
+			/*
 			hermesStepSound.SoundType = 2;
 			hermesStepSound.SoundStyle = 24;
+			*/
+			hermesStepSound.Style = SoundID.Item24;
+
 			hermesStepSound.IntendedCooldown = 6;
 		}
 
@@ -27870,6 +_,8 @@
 			faceHead = -1;
 		}
 
+		ItemLoader.PreUpdateVanitySet(this);
+
 		if (head > 0 && face > 0) {
 			if (ArmorIDs.Face.Sets.OverrideHelmet[face]) {
 				head = -1;
@@ -27881,7 +_,7 @@
 		}
 
 		if (head > 0 && faceHead > 0 && ArmorIDs.Head.Sets.UseAltFaceHeadDraw[head]) {
-			sbyte b3 = (sbyte)ArmorIDs.Face.Sets.AltFaceHead[faceHead];
+			int b3 = ArmorIDs.Face.Sets.AltFaceHead[faceHead];
 			if (b3 > 0)
 				faceHead = b3;
 		}
@@ -27905,6 +_,9 @@
 			obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
 		}
 
+		//TODO: Do these hooks go inside or outside the conditional?
+		CombinedHooks.PlayerFrameEffects(this);
+
 		if (!isDisplayDollOrInanimate) {
 			if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0) {
 				int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
@@ -28029,6 +_,9 @@
 		Item.GetDrawHitbox(HeldItem.type, this);
 		bool flag3 = CanVisuallyHoldItem(HeldItem);
 		bool flag4 = HeldItem.type != 4952;
+
+		ItemLoader.UpdateVanitySet(this);
+
 		if (mount.Active) {
 			legFrameCounter = 0.0;
 			legFrame.Y = legFrame.Height * 6;
@@ -28245,6 +_,8 @@
 					}
 				}
 			}
+
+			ItemLoader.UseItemFrame(inventory[selectedItem], this);
 		}
 		else if (pulley) {
 			if (pulleyDir == 2)
@@ -28381,6 +_,10 @@
 			reference9.Y = 0;
 		}
 
+		if (flag3 && itemAnimation <= 0) {
+			ItemLoader.HoldItemFrame(inventory[selectedItem], this);
+		}
+
 		if (legs == 140) {
 			legFrameCounter = 0.0;
 			legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
@@ -28501,6 +_,7 @@
 
 	private void UpdateVisibleAccessories()
 	{
+		/*
 		for (int i = 3; i < 10; i++) {
 			if (!IsItemSlotUnlockedAndUsable(i))
 				continue;
@@ -28531,6 +_,16 @@
 			if (!hideVisibleAccessory[i])
 				UpdateVisibleAccessory(i, item);
 		}
+		*/
+		for (int i = 3; i < 10; i++) {
+			if (!IsItemSlotUnlockedAndUsable(i))
+				continue;
+
+			// Commented code above moved into UpdateVisibileAccessories
+			UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
+		}
+
+		PlayerLoader.UpdateVisibleAccessories(this);
 
 		for (int j = 13; j < 20; j++) {
 			if (IsItemSlotUnlockedAndUsable(j)) {
@@ -28538,7 +_,10 @@
 				if (!ItemIsVisuallyIncompatible(item2))
 					UpdateVisibleAccessory(j, item2);
 			}
+			// Extra patch context
 		}
+
+		PlayerLoader.UpdateVisibleVanityAccessories(this);
 
 		int type = HeldItem.type;
 		if (type == 4760 && ownedProjectileCounts[866] < 1) {
@@ -28547,7 +_,7 @@
 		}
 	}
 
-	private bool ItemIsVisuallyIncompatible(Item item)
+	public bool ItemIsVisuallyIncompatible(Item item)
 	{
 		if (compositeBackArm.enabled && item.shieldSlot > 0)
 			return true;
@@ -28575,7 +_,8 @@
 		return false;
 	}
 
-	private void UpdateVisibleAccessory(int itemSlot, Item item)
+	//TML: Made public, 'modded' parameter added.
+	public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false)
 	{
 		if (item.stringColor > 0)
 			stringColor = item.stringColor;
@@ -28608,7 +_,7 @@
 		if (item.shoeSlot > 0) {
 			shoe = item.shoeSlot;
 			if (!Male && ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe] > 0)
-				shoe = (sbyte)ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
+				shoe = ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
 		}
 
 		if (item.waistSlot > 0)
@@ -28642,9 +_,13 @@
 		if (item.wingSlot > 0)
 			wings = item.wingSlot;
 
-		if (item.type == 3580)
+		if (item.type == 3580) {
 			yoraiz0rEye = itemSlot - 2;
 
+			if (modded) // Treat similar to expert/master mode slots
+				yoraiz0rEye += 5;
+		}
+
 		if (item.type == 3581)
 			yoraiz0rDarkness = true;
 
@@ -28799,6 +_,9 @@
 		if (drawPlayer.head == 267)
 			yoraiz0rDarkness = true;
 
+		//TODO: Rename to SetArmorEffectVisuals?
+		ItemLoader.ArmorSetShadows(drawPlayer);
+
 		if (drawPlayer.stoned || drawPlayer.stealth != 1f) {
 			armorEffectDrawOutlines = false;
 			armorEffectDrawShadow = false;
@@ -28994,10 +_,12 @@
 				case 232:
 					if (!male)
 						num2 = 233;
+					// Patch context
 					break;
 			}
 		}
 
+		ItemLoader.SetMatch(armorSlotRequested, num, male, ref num2, ref somethingSpecial);
 		return num2;
 	}
 
@@ -29189,6 +_,10 @@
 			}
 
 			immune = true;
+
+			if (dead)
+				PlayerLoader.OnRespawn(this);
+
 			dead = false;
 			immuneTime = 0;
 		}
@@ -29505,14 +_,44 @@
 			frostArmor = true;
 	}
 
+	// Added to replace Main.CalculateDamagePlayersTake[InPvP]
+	private static float VanillaBaseDefenseEffectiveness()
+	{
+		if (Main.masterMode)
+			return 1;
+		if (Main.expertMode)
+			return 0.75f;
+
+		return 0.5f;
+	}
+
+	// made internal because public version has Crit param removed, added armorPenetration arg for smaller Projectile patches
-	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, bool Crit = false, int cooldownCounter = -1, bool dodgeable = true)
+	internal double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp, bool quiet, bool Crit, int cooldownCounter, bool dodgeable = true, float armorPenetration = 0)
 	{
+		return Hurt(damageSource, Damage, hitDirection, pvp, quiet, cooldownCounter, dodgeable, armorPenetration);
+	}
+
+	// extra parameters (armorPenetration, scalingArmorPenetration, knockback) added. Crit param removed
+	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0, float scalingArmorPenetration = 0, float knockback = 4.5f)
+	{
+		return Hurt(damageSource, Damage, hitDirection, out _,
+			pvp, quiet, cooldownCounter, dodgeable, armorPenetration, scalingArmorPenetration, knockback);
+	}
+
+	// out param and extras from above added
+	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, out Player.HurtInfo info, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0, float scalingArmorPenetration = 0, float knockback = 4.5f)
+	{
+		info = default;
+
 		if (shimmering && AllowShimmerDodge(damageSource, cooldownCounter, dodgeable))
 			return 0.0;
 
 		if (creativeGodMode)
 			return 0.0;
 
+		if (PlayerLoader.ImmuneTo(this, damageSource, cooldownCounter, dodgeable))
+			return 0.0;
+
 		bool flag = !immune;
 		bool flag2 = false;
 		int hitContext = cooldownCounter;
@@ -29531,6 +_,9 @@
 
 		if (flag) {
 			if (dodgeable) {
+				if (whoAmI == Main.myPlayer && PlayerLoader.FreeDodge(this, damageSource, cooldownCounter))
+					return 0.0;
+
 				if (whoAmI == Main.myPlayer && blackBelt && Main.rand.Next(10) == 0) {
 					NinjaDodge();
 					return 0.0;
@@ -29545,24 +_,67 @@
 					ShadowDodge();
 					return 0.0;
 				}
+
+				if (whoAmI == Main.myPlayer && PlayerLoader.ConsumableDodge(this, damageSource, cooldownCounter))
+					return 0.0;
 			}
 
+			Player.HurtModifiers modifiers = new() {
+				DamageSource = damageSource,
+				PvP = pvp,
+				CooldownCounter = cooldownCounter,
+				Dodgeable = dodgeable,
+				HitDirection = hitDirection
+			};
+			PlayerLoader.ModifyHurt(this, ref modifiers);
+
+			// intentionally add parameter modifiers after, to reduce the temptation to read their values in Modify hooks
+			modifiers.ArmorPenetration += armorPenetration;
+			modifiers.ScalingArmorPenetration += scalingArmorPenetration;
+
+			// ogre knockback re-implemented from below
+			if (flag2) {
+				// this gives the right values for X knockback.
+				// Y knockback will be slightly different, but mostly accurate
+				modifiers.Knockback.Base += 6f;
+				modifiers.KnockbackImmunityEffectiveness *= 0.8f; // still launch the player a little
+			}
+
+			ApplyVanillaHurtEffectModifiers(ref modifiers);
+			info = modifiers.ToHurtInfo(Damage, statDefense, pvp ? 0.5f : DefenseEffectiveness.Value, knockback, noKnockback);
+			Hurt(info, quiet);
+			return info.Damage;
+		}
+
+		return 0.0;
+	}
+
+	private void OnHurt_Part1(HurtInfo info)
+	{
+		int hitDirection = info.HitDirection;
+		{
 			if (whoAmI == Main.myPlayer && panic)
 				AddBuff(63, 480);
 
 			if (whoAmI == Main.myPlayer && setSquireT2)
 				AddBuff(205, 300);
 
+			// Note for future, potential optimization, no need to reset stealth every hit
 			stealth = 1f;
 			if (Main.netMode == 1)
 				NetMessage.SendData(84, -1, -1, null, whoAmI);
 
+			// Note, vanilla condition can never fail, num2 (damage to take) is always at least 1
+			// num is commented out, as it was only used to lie about pvp
+			/*
 			int num = Damage;
 			double num2 = Main.CalculateDamagePlayersTake(num, statDefense);
 			if (Crit)
 				num *= 2;
 
 			if (num2 >= 1.0) {
+			*/
+			{
 				if (whoAmI == Main.myPlayer) {
 					Main.NotifyOfEvent(GameNotificationType.Damage);
 					if (hasFootball) {
@@ -29584,22 +_,60 @@
 					}
 				}
 
+				if (channel && inventory[selectedItem].InterruptChannelOnHurt) {
+					channel = false;
+				}
+
+				if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt) {
+					channel = false;
+					itemAnimation = 0;
+					itemAnimationMax = 0;
+				}
+
 				if (invis) {
 					for (int k = 0; k < maxBuffs; k++) {
 						if (buffType[k] == 10)
 							DelBuff(k);
 					}
 				}
+			}
+		}
+	}
 
+	private void ApplyVanillaHurtEffectModifiers(ref HurtModifiers modifiers)
+	{
+		{
+			modifiers.FinalDamage *= Math.Max(1 - endurance, 0);
+			if (setSolar && solarShields > 0)
+				modifiers.FinalDamage *= 0.8f;
+
+			if (beetleDefense && beetleOrbs > 0)
+				modifiers.FinalDamage *= 1 - 0.15f * beetleOrbs;
+
+			if (defendedByPaladin && whoAmI == Main.myPlayer && TeammateHasPalidinShieldAndCanTakeDamage())
+				modifiers.FinalDamage *= 0.75f;
+		}
+	}
+
+	private void OnHurt_Part2(HurtInfo info)
+	{
+		// Implementations for solar flare, beetle defense and paladin's shield have been split into ApplyVanillaHurtEffectModifiers (above)
+		var damageSource = info.DamageSource;
+		{
+			{
+				/*
 				num2 = (int)((double)(1f - endurance) * num2);
 				if (num2 < 1.0)
 					num2 = 1.0;
+				*/
 
 				if (ConsumeSolarFlare()) {
+					/*
 					float num3 = 0.2f;
 					num2 = (int)((double)(1f - num3) * num2);
 					if (num2 < 1.0)
 						num2 = 1.0;
+						*/
 
 					if (whoAmI == Main.myPlayer) {
 						IEntitySource spawnSource = GetProjectileSource_SetBonus(1);
@@ -29607,15 +_,17 @@
 						if (damageSource.TryGetCausingEntity(out entity))
 							spawnSource = GetProjectileSource_OnHurt(entity, 1);
 
-						int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)(150f * meleeDamage), 15f, Main.myPlayer);
+						int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)GetTotalDamage(DamageClass.Melee).ApplyTo(150f), 15f, Main.myPlayer);
 						Main.projectile[num4].netUpdate = true;
 						Main.projectile[num4].Kill();
 					}
 				}
 
 				if (beetleDefense && beetleOrbs > 0) {
+					/*
 					float num5 = 0.15f * (float)beetleOrbs;
 					num2 = (int)((double)(1f - num5) * num2);
+					*/
 					beetleOrbs--;
 					for (int l = 0; l < maxBuffs; l++) {
 						if (buffType[l] >= 95 && buffType[l] <= 97)
@@ -29626,12 +_,14 @@
 						AddBuff(95 + beetleOrbs - 1, 5, quiet: false);
 
 					beetleCounter = 0f;
+					/*
 					if (num2 < 1.0)
 						num2 = 1.0;
+					*/
 				}
 
 				if (magicCuffs) {
-					int num6 = num;
+					int num6 = info.SourceDamage; //num;
 					statMana += num6;
 					if (statMana > statManaMax2)
 						statMana = statManaMax2;
@@ -29659,14 +_,30 @@
 								}
 
 								if (flag3) {
+									/*
 									int damage = (int)(num2 * 0.25);
 									num2 = (int)(num2 * 0.75);
+									*/
+									int damage = info.Damage / 3; // Damage has already been reduced by 1/4 when applying to target player, so dividing by 3 gives us the correct value
 									player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0);
 								}
 							}
 						}
 					}
+					/*
 					else {
+					*/
+				}
+			}
+		}
+	}
+
+	private bool TeammateHasPalidinShieldAndCanTakeDamage()
+	{
+		{
+			{
+				{
+					{
 						bool flag4 = false;
 						for (int n = 0; n < 255; n++) {
 							if (n != Main.myPlayer && Main.player[n].active && !Main.player[n].dead && !Main.player[n].immune && Main.player[n].hasPaladinShield && Main.player[n].team == team && (float)Main.player[n].statLife > (float)Main.player[n].statLifeMax2 * 0.25f) {
@@ -29675,11 +_,22 @@
 							}
 						}
 
+						/*
 						if (flag4)
 							num2 = (int)(num2 * 0.75);
+						*/
+						return flag4;
 					}
 				}
+			}
+		}
+	}
 
+	private void OnHurt_Part3(HurtInfo info)
+	{
+		double num2 = info.Damage;
+		{
+			{
 				if (brainOfConfusionItem != null && !brainOfConfusionItem.IsAir && Main.myPlayer == whoAmI) {
 					for (int num9 = 0; num9 < 200; num9++) {
 						if (!Main.npc[num9].active || Main.npc[num9].friendly)
@@ -29708,14 +_,37 @@
 
 					Projectile.NewProjectile(GetProjectileSource_Accessory(brainOfConfusionItem), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
 				}
+			}
+		}
+	}
 
+	public void Hurt(HurtInfo info, bool quiet = false)
+	{
+		var damageSource = info.DamageSource;
+		int hitDirection = info.HitDirection;
+		int cooldownCounter = info.CooldownCounter;
+		bool pvp = info.PvP;
+		double num2 = info.Damage;
+		bool Crit = false; // Crit has been removed, since it didn't work anyway
+		bool flag2 = cooldownCounter == ImmunityCooldownID.DD2OgreKnockback;
+
+		{
+			{
 				if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet) {
+					/*
 					if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart))
+					*/
+					if (info.Knockback != 0 && hitDirection != 0 && (!mount.Active || !mount.Cart))
 						NetMessage.SendData(13, -1, -1, null, whoAmI);
 
 					NetMessage.SendData(16, -1, -1, null, whoAmI);
-					NetMessage.SendPlayerHurt(whoAmI, damageSource, Damage, hitDirection, Crit, pvp, hitContext);
+					NetMessage.SendPlayerHurt(whoAmI, info);
 				}
+
+				PlayerLoader.OnHurt(this, info);
+				OnHurt_Part1(info);
+				OnHurt_Part2(info);
+				OnHurt_Part3(info);
 
 				Color color = (Crit ? CombatText.DamagedFriendlyCrit : CombatText.DamagedFriendly);
 				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), color, (int)num2, Crit);
@@ -29821,6 +_,7 @@
 				}
 
 				StopVanityActions();
+				/*
 				if (flag2 && hitDirection != 0) {
 					if (!mount.Active || !mount.Cart) {
 						float num23 = 10.5f;
@@ -29838,9 +_,16 @@
 				else if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart)) {
 					velocity.X = 4.5f * (float)hitDirection;
 					velocity.Y = -3.5f;
+				}
+				*/
+
+				if (info.Knockback != 0 && hitDirection != 0 && (!mount.Active || !mount.Cart)) {
+					velocity.X = info.Knockback * hitDirection;
+					velocity.Y = info.Knockback * -7 / 9;
 					fallStart = (int)(position.Y / 16f);
 				}
 
+				if (info.SoundDisabled) { } else
 				if (stoned)
 					SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
 				else if (mount.Active && mount.Type == 52)
@@ -29858,6 +_,9 @@
 
 				eyeHelper.BlinkBecausePlayerGotHurt();
 				if (statLife > 0) {
+					if (info.DustDisabled)
+						goto PostDust;
+
 					double num24 = num2 / (double)statLifeMax2 * 100.0;
 					float num25 = 2 * hitDirection;
 					float num26 = 0f;
@@ -29882,6 +_,9 @@
 							Dust.NewDust(position, width, height, 5, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
 						}
 					}
+
+					PostDust:
+					PlayerLoader.PostHurt(this, info);
 				}
 				else {
 					statLife = 0;
@@ -29890,13 +_,17 @@
 				}
 			}
 
+			/*
 			if (pvp)
 				num2 = Main.CalculateDamagePlayersTakeInPVP(num, statDefense);
 
 			return num2;
+			*/
 		}
 
+		/*
 		return 0.0;
+		*/
 	}
 
 	private static bool AllowShimmerDodge(PlayerDeathReason damageSource, int cooldownCounter, bool dodgeable)
@@ -29931,6 +_,14 @@
 			if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
 				FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
 
+			//TML: Delete .tplr and .tplr.bak
+			string moddedPlayerPathName = Path.ChangeExtension(Main.playerPathName, ".tplr");
+			if (FileUtilities.Exists(moddedPlayerPathName, isCloudSave))
+				FileUtilities.Delete(moddedPlayerPathName, isCloudSave);
+
+			if (FileUtilities.Exists(moddedPlayerPathName + ".bak", isCloudSave))
+				FileUtilities.Delete(moddedPlayerPathName + ".bak", isCloudSave);
+
 			Main.ActivePlayerFileData = new PlayerFileData();
 		}
 	}
@@ -29941,6 +_,12 @@
 			return;
 
 		StopVanityActions();
+
+		bool playSound = true;
+		bool genGore = true;
+		if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
+			return;
+
 		if (pvp)
 			pvpDeath = true;
 
@@ -30041,12 +_,15 @@
 		headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 		bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 		legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
-		if (stoned) {
+		if (stoned || !genGore) {
 			headPosition = Vector2.Zero;
 			bodyPosition = Vector2.Zero;
 			legPosition = Vector2.Zero;
 		}
 
+		if (!genGore)
+			goto postGore;
+
 		for (int l = 0; l < 100; l++) {
 			if (stoned) {
 				Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
@@ -30063,10 +_,14 @@
 				Dust.NewDust(position, width, height, 5, 2 * hitDirection, -2f);
 			}
 		}
+		postGore:
 
 		mount.Dismount(this);
 		dead = true;
 		respawnTimer = GetRespawnTime(pvp);
+
+		PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
+
 		immuneAlpha = 0;
 		if (!ChildSafety.Disabled)
 			immuneAlpha = 255;
@@ -30191,6 +_,9 @@
 		if (newItem.uniqueStack && HasItem(newItem.type))
 			return new ItemSpaceStatus(CanTakeItem: false);
 
+		if (ItemLoader.ItemSpace(newItem, this))
+			return new ItemSpaceStatus(CanTakeItem: true);
+
 		int num = 50;
 		if (newItem.IsACoin)
 			num = 54;
@@ -30240,7 +_,11 @@
 		if (theSlot.type == 0)
 			return true;
 
+		bool vanillaResult = false;
 		if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			vanillaResult = true;
+
+		if (vanillaResult && ItemLoader.CanStack(theSlot, theItemToAccept))
 			return true;
 
 		return false;
@@ -30277,7 +_,12 @@
 			if (inventory[i].type <= 0 || inventory[i].stack >= inventory[i].maxStack || !newItem.IsTheSameAs(inventory[i]))
 				continue;
 
+			if (!ItemLoader.TryStackItems(inventory[i], newItem, out int numTransfered))
+				continue;
+
 			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
+			// #OnStackHook re-implemented below
+			/*
 			if (newItem.stack + inventory[i].stack <= inventory[i].maxStack) {
 				inventory[i].stack += newItem.stack;
 				if (!settings.NoText)
@@ -30301,6 +_,19 @@
 				Recipe.FindRecipes();
 
 			settings.HandlePostAction(inventory[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered);
+
+			DoCoins(i);
+			if (plr == Main.myPlayer)
+				Recipe.FindRecipes();
+
+			settings.HandlePostAction(inventory[i]);
+
+			if (newItem.stack <= 0)
+				return new Item();
 		}
 
 		if (newItem.CanFillEmptyAmmoSlot()) {
@@ -30416,11 +_,16 @@
 	private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
 	{
 		if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
+			if (!ItemLoader.TryStackItems(inv[i], returnItem, out int numTransfered))
+				return false;
+
 			if (newItem.IsACoin)
 				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 			else
 				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+			// #OnStackHook re-implemented below
+			/*
 			if (returnItem.stack + inv[i].stack <= inv[i].maxStack) {
 				inv[i].stack += returnItem.stack;
 				if (!settings.NoText)
@@ -30438,6 +_,16 @@
 
 			inv[i].stack = inv[i].maxStack;
 			settings.HandlePostAction(inv[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, numTransfered, noStack: false, settings.LongText);
+
+			AchievementsHelper.NotifyItemPickup(this, returnItem);
+			settings.HandlePostAction(inv[i]);
+
+			if (returnItem.stack <= 0)
+				return true;
 		}
 
 		return false;
@@ -30446,12 +_,18 @@
 	private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
 	{
 		if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
+			if (!ItemLoader.TryStackItems(inventory[i], returnItem, out int numTransfered))
+				return false;
+
 			if (newItem.IsACoin)
 				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 			else
 				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+			// #OnStackHook re-implemented below
+			/*
 			if (returnItem.stack + inventory[i].stack <= inventory[i].maxStack) {
+
 				inventory[i].stack += returnItem.stack;
 				if (!settings.NoText)
 					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, returnItem.stack, noStack: false, settings.LongText);
@@ -30476,6 +_,19 @@
 				Recipe.FindRecipes();
 
 			settings.HandlePostAction(inventory[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered, noStack: false, settings.LongText);
+
+			DoCoins(i);
+			if (plr == Main.myPlayer)
+				Recipe.FindRecipes();
+
+			AchievementsHelper.NotifyItemPickup(this, returnItem);
+			settings.HandlePostAction(inventory[i]);
+			if (returnItem.stack <= 0)
+				return true;
 		}
 
 		return false;
@@ -30560,6 +_,8 @@
 			return;
 
 		bool flag = true;
+		flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
+
 		if (TileReplacementEnabled)
 			flag = PlaceThing_TryReplacingWalls(flag);
 
@@ -30568,6 +_,8 @@
 
 		WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
 		if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall) {
+			WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
+
 			ApplyItemTime(inventory[selectedItem], wallSpeed);
 			if (Main.netMode == 1)
 				NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
@@ -30627,7 +_,9 @@
 
 			WorldGen.PlaceWall(num, num2, createWall);
 			if (Main.tile[num, num2].wall == createWall) {
+				if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
-				inventory[selectedItem].stack--;
+					inventory[selectedItem].stack--;
+
 				if (inventory[selectedItem].stack == 0)
 					inventory[selectedItem].SetDefaults();
 
@@ -30673,6 +_,7 @@
 			int? forcedRandom = null;
 			TileObject objectData = default(TileObject);
 			FigureOutWhatToPlace(tile, item, out tileToCreate, out var previewPlaceStyle, out overrideCanPlace, out forcedRandom);
+			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
 			if (overrideCanPlace.HasValue) {
 				canPlace = overrideCanPlace.Value;
 			}
@@ -30757,9 +_,15 @@
 			if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
 				return false;
 
+			if (!TileLoader.CanReplace(tileTargetX, tileTargetY, tile.type, HeldItem.createTile))
+				return false;
+
+			if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
+				return false;
+
 			if (0 == 0) {
 				if (hitReplace.AddDamage(num, pickaxeDamage) < 100) {
-					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
 					for (int i = 0; i < num2; i++) {
 						WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
 					}
@@ -30833,8 +_,17 @@
 		if (TileID.Sets.Platforms[tile.type] && tile.type == createTile)
 			return tile.frameY != num * 18;
 
+		if (TileID.Sets.Torch[tile.type] && TileID.Sets.Torch[createTile]) {
+			if (tile.frameY == num * 22)
+				return tile.type != createTile;
+
+			return true;
+		}
+
+		/*
 		if (tile.type == 4 && tile.type == createTile)
 			return tile.frameY != num * 22;
+		*/
 
 		if (tile.type == 215 && tile.type == createTile)
 			return tile.frameX / 54 != num;
@@ -30964,8 +_,12 @@
 			PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
 			PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
 			PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, tileToCreate);
+
+			// Extra patch context.
 			if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
 				Main.blockMouse = true;
+
+			TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 		}
 
 		return data;
@@ -31253,7 +_,9 @@
 				int num7 = FindItem(849);
 				if (num7 > -1 && WorldGen.PlaceActuator(num5, num6)) {
 					NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
+					if (ItemLoader.ConsumeItem(inventory[num7], this))
-					inventory[num7].stack--;
+						inventory[num7].stack--;
+
 					if (inventory[num7].stack <= 0)
 						inventory[num7].SetDefaults();
 				}
@@ -31648,7 +_,7 @@
 			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
 				canPlace = true;
 		}
-		else if (inventory[selectedItem].createTile == 4 || inventory[selectedItem].createTile == 136) {
+		else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136) {
 			if (Main.tile[tileTargetX, tileTargetY].wall > 0) {
 				canPlace = true;
 			}
@@ -32318,7 +_,9 @@
 		byte paint = targetItem.paint;
 		if (paintingAWall) {
 			if (Main.tile[x, y].wallColor() != paint && WorldGen.paintWall(x, y, paint, broadCast: true)) {
+				if (ItemLoader.ConsumeItem(targetItem, this))
-				targetItem.stack--;
+					targetItem.stack--;
+
 				if (targetItem.stack <= 0)
 					targetItem.SetDefaults();
 
@@ -32327,7 +_,9 @@
 			}
 		}
 		else if (Main.tile[x, y].color() != paint && WorldGen.paintTile(x, y, paint, broadCast: true)) {
+			if (ItemLoader.ConsumeItem(targetItem, this))
-			targetItem.stack--;
+				targetItem.stack--;
+
 			if (targetItem.stack <= 0)
 				targetItem.SetDefaults();
 
@@ -32383,13 +_,19 @@
 		int num6 = -1;
 		int num7 = 1;
 		switch (extractType) {
+			/*
 			case 1:
+			*/
+			case ItemID.DesertFossil:
 				num /= 3;
 				num2 *= 2;
 				num3 = 20;
 				num4 = 10;
 				break;
+			/*
 			case 2:
+			*/
+			case ItemID.OldShoe:
 				num = -1;
 				num2 = -1;
 				num3 = -1;
@@ -32397,7 +_,10 @@
 				num5 = 1;
 				num7 = -1;
 				break;
+			/*
 			case 3:
+			*/
+			case ItemID.LavaMoss:
 				num = -1;
 				num2 = -1;
 				num3 = -1;
@@ -32767,6 +_,8 @@
 				num9 += Main.rand.Next(0, 6);
 		}
 
+		ItemLoader.ExtractinatorUse(ref num8, ref num9, extractType, extractinatorBlockType);
+
 		if (num8 > 0)
 			DropItemFromExtractinator(num8, num9);
 	}
@@ -32875,8 +_,13 @@
 	public PlayerFishingConditions GetFishingConditions()
 	{
 		PlayerFishingConditions result = default(PlayerFishingConditions);
+
+		/*
 		Fishing_GetBestFishingPole(out result.PolePower, out result.PoleItemType);
 		Fishing_GetBait(out result.BaitPower, out result.BaitItemType);
+		*/
+		Fishing_GetBestFishingPole(out result.Pole);
+		Fishing_GetBait(out result.Bait);
 		if (result.BaitItemType == 2673)
 			return result;
 
@@ -32894,12 +_,15 @@
 			num += 5;
 
 		int num2 = result.BaitPower + result.PolePower + fishingSkill + num;
-		result.LevelMultipliers = Fishing_GetPowerMultiplier();
+		result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
 		result.FinalFishingLevel = (int)((float)num2 * result.LevelMultipliers);
 		return result;
 	}
 
+	/*
 	private static float Fishing_GetPowerMultiplier()
+	*/
+	private float Fishing_GetPowerMultiplier(Item pole, Item bait)
 	{
 		float num = 1f;
 		if (Main.raining)
@@ -32932,44 +_,46 @@
 		if (Main.bloodMoon)
 			num *= 1.1f;
 
+		PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
 		return num;
 	}
 
+	/*
 	private void Fishing_GetBait(out int baitPower, out int baitType)
+	*/
+	private void Fishing_GetBait(out Item bait)
 	{
-		baitPower = 0;
-		baitType = 0;
+		bait = null;
 		for (int i = 54; i < 58; i++) {
 			if (inventory[i].stack > 0 && inventory[i].bait > 0) {
-				baitPower = inventory[i].bait;
-				baitType = inventory[i].type;
+				bait = inventory[i];
 				break;
 			}
 		}
 
-		if (baitPower != 0 || baitType != 0)
+		if (bait != null)
 			return;
 
 		for (int j = 0; j < 50; j++) {
 			if (inventory[j].stack > 0 && inventory[j].bait > 0) {
-				baitPower = inventory[j].bait;
-				baitType = inventory[j].type;
+				bait = inventory[j];
 				break;
 			}
 		}
 	}
 
+	/*
 	private void Fishing_GetBestFishingPole(out int fishingPolePower, out int fishingPoleType)
+	*/
+	private void Fishing_GetBestFishingPole(out Item pole)
 	{
-		fishingPolePower = inventory[selectedItem].fishingPole;
-		fishingPoleType = inventory[selectedItem].type;
+		pole = inventory[selectedItem];
-		if (fishingPolePower != 0)
+		if (pole.fishingPole != 0)
 			return;
 
 		for (int i = 0; i < 58; i++) {
-			if (inventory[i].fishingPole > fishingPolePower) {
+			if (inventory[i].fishingPole > pole.fishingPole) {
-				fishingPolePower = inventory[i].fishingPole;
+				pole = inventory[i];
-				fishingPoleType = inventory[i].type;
 			}
 		}
 	}
@@ -32995,7 +_,9 @@
 	{
 		for (int i = 0; i < 58; i++) {
 			if (inventory[i].type == 2997 && inventory[i].stack > 0) {
+				if (ItemLoader.ConsumeItem(inventory[i], this))
-				inventory[i].stack--;
+					inventory[i].stack--;
+
 				if (inventory[i].stack <= 0)
 					inventory[i].SetDefaults();
 
@@ -33008,7 +_,9 @@
 
 		for (int j = 0; j < 40; j++) {
 			if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0) {
+				if (ItemLoader.ConsumeItem(bank4.item[j], this))
-				bank4.item[j].stack--;
+					bank4.item[j].stack--;
+
 				if (bank4.item[j].stack <= 0)
 					bank4.item[j].SetDefaults();
 
@@ -33191,12 +_,21 @@
 		return TextureAssets.Item[type].Frame();
 	}
 
+	/// <summary>
+	/// Used to determine what the overall scale of an item should be.<br></br>
+	/// <see cref="CombinedHooks.ModifyItemScale"/> is called here.
+	/// </summary>
+	/// <param name="item">The item to fetch the adjusted scale of.</param>
+	/// <returns>
+	/// The final scale of the item, after the Titan Glove effect and all modded calculations.
+	/// </returns>
 	public float GetAdjustedItemScale(Item item)
 	{
 		float scale = item.scale;
 		if (item.melee)
 			ApplyMeleeScale(ref scale);
 
+		CombinedHooks.ModifyItemScale(this, item, ref scale);
 		return scale;
 	}
 
@@ -33220,6 +_,14 @@
 
 	public void ItemCheck()
 	{
+		if (PlayerLoader.PreItemCheck(this))
+			ItemCheck_Inner();
+
+		PlayerLoader.PostItemCheck(this);
+	}
+
+	private void ItemCheck_Inner()
+	{
 		if (CCed) {
 			channel = false;
 			itemAnimation = (itemAnimationMax = 0);
@@ -33237,10 +_,10 @@
 			}
 
 			if (!cursorItemIconEnabled && item.stack > 0 && item.fishingPole > 0) {
-				Fishing_GetBait(out var _, out var baitType);
-				if (baitType > 0) {
+				Fishing_GetBait(out var bait);
+				if (bait != null) {
 					cursorItemIconEnabled = true;
-					cursorItemIconID = baitType;
+					cursorItemIconID = bait.type;
 					cursorItemIconPush = 6;
 				}
 			}
@@ -33268,6 +_,54 @@
 			}
 		}
 
+		// #2351
+		// TML is motivated to bring the itemAnimation and itemTime counters to parity, fixing desync bugs with autoReuse items and providing clearer behaviour.
+		// The flow of this method has changed as follows...
+		//
+		// VANILLA:
+		// 1. Reuse delay is applied
+		// 2. Item animation is applied if button is pressed
+		// 3. Item animation is reduced
+		// 4. 'releaseUseItem' is set
+		// 5. Item time is reduced
+		// 6. Hold / Use styles are invoked
+		// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+		// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+		//
+		// TML:
+		// 1. Item animation is reduced
+		// 2. Item time is reduced
+		// 3. Reuse delay is applied
+		// 4. Item animation is applied if button is pressed
+		// 5. 'releaseUseItem' is set
+		// 6. Hold / Use styles are invoked
+		// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+		// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+		//
+		// At the end of ItemCheck:
+		//   VANILLA: itemAnimation goes from itemAnimationMax-1 to 0, before it can restart
+		//   TML:     itemAnimation goes from itemAnimationMax to 1, before it can restart
+		//
+		//   VANILLA: If the item has autoReuse, then it can restart at itemAnimation = 1, making the actual animation one frame shorter than expected.
+		//            If a reusuable item has equal itemAnimation and itemTime, the animation will be faster, and they will start to fire at different times
+		//
+		//   TML:     ItemCheck_HandleMPItemAnimation unnecessary. Animation times for modded items as written. See Item.ApplyItemAnimationCompensations
+		//
+		//   VANILLA: All items which don't have autoReuse get 1 frame where itemAnimation == 0, this is often used to despawn projectiles
+		//   TML:     There will be no frame with itemAnimation == 0 if an item is 'reused immediately', via autoReuse, knockbackGlove, or perfect click timing.
+		//            bound projectiles should despawn in the frame of itemAnimation <= 1, after doing damage.
+		//            Player.ItemAnimationEndingOrEnded has been made for this purpose but its use is not recommended due to potential for multiplayer desync.
+		//            Better to have ai counters for projectile lifetime set to itemAnimationMax on spawn
+		//
+		//   VANILLA: hitbox calulation and duration is based on an itemAnimation value between itemAnimationMax-1 and 1, resulting in itemAnimationMax-1 frames of hitbox
+		//   TML:     hitbox lasts the same length as itemAnimation, slightly more backswing (rotation) in the first frame
+		//
+		//   VANILLA: itemTime goes from itemTimeMax to 1, before it can restart, 0 means not using item
+		//   TML:     no change
+
+		goto DecrementItemAnimation;
+
+		ReuseDelayAndAnimationStart:
 		ItemCheck_HandleMount();
 		int weaponDamage = GetWeaponDamage(item);
 		ItemCheck_HandleMPItemAnimation(item);
@@ -33309,7 +_,7 @@
 			if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
 				mount.SetMount(item.mountType, this);
 
-			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && item.shoot < ProjectileID.Count && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
+			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
 				FreeUpPetsAndMinions(item);
 
 			if (flag3)
@@ -33323,6 +_,9 @@
 		if (!flag4)
 			channel = false;
 
+		goto ReleaseUseItem;
+
+		DecrementItemAnimation:
 		Item item2 = ((itemAnimation > 0) ? lastVisualizedSelectedItem : item);
 		Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
 		compositeFrontArm.enabled = false;
@@ -33345,7 +_,13 @@
 				PlayerInput.TryEndingFastUse();
 		}
 
+		goto DecrementItemTime;
+
+		ReleaseUseItem:
 		releaseUseItem = !controlUseItem;
+		goto HoldAndUseStyle;
+
+		DecrementItemTime:
 		if (itemTime > 0) {
 			itemTime--;
 			if (ItemTimeIsZero && whoAmI == Main.myPlayer && !JustDroppedAnItem) {
@@ -33355,6 +_,11 @@
 			}
 		}
 
+		goto ReuseDelayAndAnimationStart;
+
+		HoldAndUseStyle:
+		ItemLoader.HoldItem(item, this);
+
 		if (itemAnimation > 0)
 			ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 		else
@@ -33364,14 +_,19 @@
 			ItemCheck_EmitHeldItemLight(item);
 			ItemCheck_EmitFoodParticles(item);
 			ItemCheck_EmitDrinkParticles(item);
-			if (whoAmI == Main.myPlayer)
+
+			// TML attempts to make ApplyItemTime calls run on remote players, so this check is removed. #ItemTimeOnAllClients
+			if (whoAmI == Main.myPlayer || true)
 				ItemCheck_OwnerOnlyCode(ref context, item, weaponDamage, drawHitbox);
 
 			if (ItemTimeIsZero && itemAnimation > 0) {
+				if (ItemLoader.UseItem(item, this) == true)
+					ApplyItemTime(item, callUseItem: false);
+
 				if (item.hairDye >= 0) {
 					ApplyItemTime(item);
 					if (whoAmI == Main.myPlayer) {
-						hairDye = (byte)item.hairDye;
+						hairDye = item.hairDye;
 						NetMessage.SendData(4, -1, -1, null, whoAmI);
 					}
 				}
@@ -33484,7 +_,7 @@
 				if (ItemTimeIsZero) {
 					ApplyItemTime(item);
 				}
-				else if (itemTime == item.useTime / 2) {
+				else if (itemTime == itemTimeMax / 2) { // item.useTime -> itemTimeMax
 					for (int l = 0; l < 70; l++) {
 						Dust.NewDust(position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
 					}
@@ -33608,7 +_,7 @@
 						Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33634,7 +_,7 @@
 						Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33649,7 +_,7 @@
 					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
 						NetMessage.SendData(73);
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33665,11 +_,11 @@
 							NetMessage.SendData(4, -1, -1, null, whoAmI);
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 				else {
-					float num10 = item.useTime;
+					float num10 = itemTimeMax;
 					num10 = (num10 - (float)itemTime) / num10;
 					float num11 = 44f;
 					float num12 = (float)Math.PI * 3f;
@@ -33703,11 +_,16 @@
 			}
 
 			if (whoAmI == Main.myPlayer) {
+				/*
 				if (!dontConsumeWand && itemTime == (int)((float)item.useTime * tileSpeed) && item.tileWand > 0) {
+				*/
+				if (!dontConsumeWand && itemTimeMax != 0 && itemTime == itemTimeMax && item.tileWand > 0) {
 					int tileWand = item.tileWand;
 					for (int num15 = 0; num15 < 58; num15++) {
 						if (tileWand == inventory[num15].type && inventory[num15].stack > 0) {
+							if (ItemLoader.ConsumeItem(inventory[num15], this))
-							inventory[num15].stack--;
+								inventory[num15].stack--;
+
 							if (inventory[num15].stack <= 0)
 								inventory[num15] = new Item();
 
@@ -33732,6 +_,15 @@
 							flag6 = false;
 					}
 
+					// Copied as-is from 1.3
+					if (item.CountsAsClass(DamageClass.Throwing)) {
+						if (ThrownCost50 && Main.rand.Next(100) < 50)
+							flag6 = false;
+
+						if (ThrownCost33 && Main.rand.Next(100) < 33)
+							flag6 = false;
+					}
+
 					if (item.IsACoin)
 						flag6 = true;
 
@@ -33739,7 +_,7 @@
 					if (flag7.HasValue)
 						flag6 = flag7.Value;
 
-					if (flag6) {
+					if (flag6 && ItemLoader.ConsumeItem(item, this)) {
 						if (item.stack > 0)
 							item.stack--;
 
@@ -33770,6 +_,8 @@
 		if (Main.myPlayer == whoAmI && itemAnimation == 0) {
 			Tile targetTile = Main.tile[tileTargetX, tileTargetY];
 			FigureOutWhatToPlace(targetTile, sItem, out var tileToCreate, out var previewPlaceStyle, out var overrideCanPlace, out var forcedRandom);
+			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
+
 			if ((!overrideCanPlace.HasValue || overrideCanPlace.Value) && TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle))
 				TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out var _, onlyCheck: true, forcedRandom);
 		}
@@ -33820,13 +_,18 @@
 			_spawnMuramasaCut = true;
 
 		if (type == 3852) {
+			//TML: This is handled by Item.useLimitPerAnimation
+			/*
 			if (itemAnimation < itemAnimationMax - 12)
 				flag = false;
+			*/
 
 			if (altFunctionUse == 2 && !ItemAnimationJustStarted)
 				flag = false;
 		}
 
+		//TML: Eventide and nightglow handled by Item.useLimitPerAnimation. Zenith use limit didn't do anything anyway
+		/*
 		if (type == 4956 && itemAnimation < itemAnimationMax - 3 * sItem.useTime)
 			flag = false;
 
@@ -33835,10 +_,15 @@
 
 		if (type == 4953 && itemAnimation < itemAnimationMax - 10)
 			flag = false;
+		*/
 
 		if (type == 5451 && ownedProjectileCounts[1020] > 0)
 			flag = false;
 
+		// Added by TML
+		if (sItem.useLimitPerAnimation != null && ItemUsesThisAnimation >= sItem.useLimitPerAnimation.Value)
+			flag = false;
+
 		ItemCheck_TurretAltFeatureUse(sItem, flag);
 		ItemCheck_MinionAltFeatureUse(sItem, flag);
 		bool flag2 = itemAnimation > 0 && ItemTimeIsZero && flag;
@@ -33848,6 +_,10 @@
 		if (sItem.shoot > 0 && flag2)
 			ItemCheck_Shoot(whoAmI, sItem, weaponDamage);
 
+		// Added by TML. #ItemTimeOnAllClients - TODO: item time application with these item types
+		if (whoAmI != Main.myPlayer)
+			return;
+
 		ItemCheck_UseWiringTools(sItem);
 		ItemCheck_UseLawnMower(sItem);
 		ItemCheck_PlayInstruments(sItem);
@@ -33898,7 +_,10 @@
 			Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, vector.X, vector.Y, 532, 25, 5f, whoAmI);
 		}
 
+		/*
 		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && sItem.type != 1991 && sItem.type != 3183 && sItem.type != 4821 && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
+		*/
+		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && !ItemID.Sets.CatchingTool[sItem.type] && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
 			return;
 
 		ItemCheck_GetMeleeHitbox(sItem, heldItemFrame, out var dontAttack, out var itemRectangle);
@@ -33906,7 +_,11 @@
 			return;
 
 		itemRectangle = ItemCheck_EmitUseVisuals(sItem, itemRectangle);
+
+		/*
 		if (Main.myPlayer == whoAmI && (sItem.type == 1991 || sItem.type == 3183 || sItem.type == 4821))
+		*/
+		if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[sItem.type])
 			itemRectangle = ItemCheck_CatchCritters(sItem, itemRectangle);
 
 		if (sItem.type == 3183 || sItem.type == 4821) {
@@ -33916,7 +_,9 @@
 
 		if (sItem.damage > 0) {
 			UpdateMeleeHitCooldowns();
-			float knockBack = sItem.knockBack;
+			float knockBack = GetWeaponKnockback(sItem, sItem.knockBack);
+			// Knockback glove, buff and psycho knife moved to UpdateEquips, Update
+			/*
 			float num = 1f;
 			if (kbGlove)
 				num += 1f;
@@ -33927,6 +_,7 @@
 			knockBack *= num;
 			if (inventory[selectedItem].type == 3106)
 				knockBack += knockBack * (1f - stealth);
+			*/
 
 			bool[] shouldIgnore2 = ItemCheck_GetTileCutIgnoreList(sItem);
 			ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore2);
@@ -34216,15 +_,21 @@
 			if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !itemRectangle.Intersects(player.Hitbox) || !CanHit(player))
 				continue;
 
+			if (!CombinedHooks.CanHitPvp(this, sItem, player))
+				continue;
+
 			bool flag = false;
+			/*
 			if (Main.rand.Next(1, 101) <= 10)
 				flag = true;
+			*/
 
 			int num = Main.DamageVar(damage, luck);
+
 			StatusToPlayerPvP(sItem.type, i);
 			OnHit(player.Center.X, player.Center.Y, player);
-			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayer(whoAmI);
+			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayerItem(whoAmI, sItem);
-			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag);
+			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag, -1);
 			if (inventory[selectedItem].type == 3211) {
 				Vector2 vector = new Vector2(direction * 100 + Main.rand.Next(-25, 26), Main.rand.Next(-75, 76));
 				vector.Normalize();
@@ -34260,6 +_,8 @@
 				}
 			}
 
+			// Extra context
+
 			if (inventory[selectedItem].type == 3106) {
 				stealth = 1f;
 				if (Main.netMode == 1)
@@ -34375,9 +_,20 @@
 				TakeDamageFromJellyfish(npcIndex);
 		}
 		else {
+			// TODO: Should this be able to bypass the conditions above?
+			// https://github.com/tModLoader/tModLoader/pull/2984
+			bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, nPC);
+			if (modCanHit is false)
+				return;
+
+			if (modCanHit is true)
+				goto skipVanillaHitChecks;
+
 			if (nPC.friendly && (nPC.type != 22 || !killGuide) && (nPC.type != 54 || !killClothier) && (!nPC.isLikeATownNPC || sItem.type != 5129))
 				return;
 
+			skipVanillaHitChecks:
+
 			Rectangle rectangle = new Rectangle((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
 			bool flag = itemRectangle.Intersects(rectangle);
 			int type = sItem.type;
@@ -34388,21 +_,34 @@
 				flag = ((!_spawnVolcanoExplosion) ? (flag || flag2) : flag2);
 			}
 
+			bool? modCanCollide = CombinedHooks.CanPlayerMeleeAttackCollideWithNPC(this, sItem, itemRectangle, nPC);
+			if (modCanCollide == false)
+				return;
+			if (modCanCollide == true)
+				flag = true;
+
 			if (!flag || (!nPC.noTileCollide && !CanHit(nPC)))
 				return;
 
+			var modifiers = nPC.GetIncomingStrikeModifiers(sItem.DamageType, direction);
+			/*
 			int num = originalDamage;
+			*/
+			float num = 1000f; // to reduce patches, set to 1000, and then turn it into a multiplier later
 			bool flag3 = false;
 			int weaponCrit = GetWeaponCrit(sItem);
 			if (Main.rand.Next(1, 101) <= weaponCrit)
 				flag3 = true;
 
+			/*
 			int num2 = Item.NPCtoBanner(nPC.BannerID());
 			if (num2 > 0 && HasNPCBannerBuff(num2))
 				num = ((!Main.expertMode) ? ((int)((float)num * ItemID.Sets.BannerStrength[Item.BannerToItem(num2)].NormalDamageDealt)) : ((int)((float)num * ItemID.Sets.BannerStrength[Item.BannerToItem(num2)].ExpertDamageDealt)));
+			*/
+			ApplyBannerOffenseBuff(nPC, ref modifiers);
 
 			if (parryDamageBuff && sItem.melee) {
-				num *= 5;
+				modifiers.ScalingBonusDamage += 4f; //num *= 5;
 				parryDamageBuff = false;
 				ClearBuff(198);
 			}
@@ -34437,12 +_,15 @@
 				}, whoAmI);
 			}
 
+			/*
 			int num6 = Main.DamageVar(num, luck);
+			*/
+			modifiers.SourceDamage *= num / 1000f;
 			float armorPenetrationPercent = 0f;
 			if (sItem.type == 5129 && nPC.isLikeATownNPC) {
 				armorPenetrationPercent = 1f;
 				if (nPC.type == 18)
-					num6 *= 2;
+					modifiers.TargetDamageMultiplier *= 2; //num6 *= 2;
 			}
 
 			if (sItem.type == 3258) {
@@ -34470,23 +_,41 @@
 			if (nPC.life > 5)
 				OnHit(nPC.Center.X, nPC.Center.Y, nPC);
 
+			/*
 			num6 += nPC.checkArmorPenetration(armorPenetration, armorPenetrationPercent);
+			*/
+			modifiers.ArmorPenetration += GetWeaponArmorPenetration(sItem);
+			modifiers.ScalingArmorPenetration += armorPenetrationPercent;
+			CombinedHooks.ModifyPlayerHitNPCWithItem(this, sItem, nPC, ref modifiers);
+			var strike = modifiers.ToHitInfo(originalDamage, flag3, knockBack, damageVariation: true, luck);
+
 			NPCKillAttempt attempt = new NPCKillAttempt(nPC);
-			int dmgDone = (int)nPC.StrikeNPC(num6, knockBack, direction, flag3);
+			int dmgDone = nPC.StrikeNPC(strike);
+
+			CombinedHooks.OnPlayerHitNPCWithItem(this, sItem, nPC, strike, dmgDone);
+			/*
 			ApplyNPCOnHitEffects(sItem, itemRectangle, num, knockBack, npcIndex, num6, dmgDone);
+			*/
+			// num was pre-variation and post buffs. Equivalent to strike.SourceDamage.
+			// num6 is post-variation and armor pen, only used by bees and muramasa.
+			// By switching to strike.SourceDamage for num6, we introduce a slight vanilla discrepancy, but we remove the double damage randomization, and armor penetration
+			ApplyNPCOnHitEffects(sItem, itemRectangle, strike.SourceDamage, strike.KnockBack, npcIndex, strike.SourceDamage, dmgDone);
 			int num7 = Item.NPCtoBanner(nPC.BannerID());
 			if (num7 >= 0)
 				lastCreatureHit = num7;
 
 			if (Main.netMode != 0) {
+				/*
 				if (flag3)
 					NetMessage.SendData(28, -1, -1, null, npcIndex, num6, knockBack, direction, 1);
 				else
 					NetMessage.SendData(28, -1, -1, null, npcIndex, num6, knockBack, direction);
+				*/
+				NetMessage.SendStrikeNPC(nPC, strike);
 			}
 
-			if (accDreamCatcher)
-				addDPS(num6);
+			if (accDreamCatcher && !nPC.HideStrikeDamage)
+				addDPS(dmgDone); // Intentionally changed from num6 (strike damage)
 
 			SetMeleeHitCooldown(npcIndex, itemAnimation);
 			if (attempt.DidNPCDie())
@@ -34746,11 +_,17 @@
 
 	private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle)
 	{
+		//TML: Effectively replaced by ItemID.Sets.LavaproofCatchingTool
+		/*
 		bool flag = sItem.type == 3183 || sItem.type == 4821;
+		*/
 		for (int i = 0; i < 200; i++) {
 			if (!Main.npc[i].active || Main.npc[i].catchItem <= 0)
 				continue;
 
+			NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
+
+			/*
 			Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
 			if (!itemRectangle.Intersects(value))
 				continue;
@@ -34766,6 +_,7 @@
 			else {
 				NPC.CatchNPC(i, whoAmI);
 			}
+			*/
 		}
 
 		return itemRectangle;
@@ -35074,6 +_,8 @@
 			Main.dust[num29].velocity.Y *= 2f;
 		}
 
+		CombinedHooks.MeleeEffects(this, sItem, itemRectangle);
+
 		return itemRectangle;
 	}
 
@@ -35153,6 +_,8 @@
 			}
 		}
 
+		ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
+
 		if (sItem.type == 1450 && Main.rand.Next(3) == 0) {
 			int num3 = -1;
 			float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
@@ -35256,29 +_,75 @@
 		releaseUseItem = false;
 	}
 
+	// Added by TML.
+	public void UseManaMaxIncreasingItem(int increase)
+	{
+		// Failsafe.  Might not be needed?
+		if (increase < 0)
+			increase = 0;
+
+		statManaMax += increase;
+		statManaMax2 += increase;
+		statMana += increase;
+
+		if (Main.myPlayer == whoAmI)
+			ManaEffect(increase);
+	}
+
 	private void ItemCheck_UseManaCrystal(Item sItem)
 	{
+		/*
 		if (sItem.type == 109 && itemAnimation > 0 && statManaMax < 200 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 109 && itemAnimation > 0 && ConsumedManaCrystals < ManaCrystalMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statManaMax += 20;
 			statManaMax2 += 20;
 			statMana += 20;
 			if (Main.myPlayer == whoAmI)
 				ManaEffect(20);
+			*/
+			UseManaMaxIncreasingItem(20);
+			ConsumedManaCrystals++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 1);
 		}
 	}
 
+	// Added by TML.
+	public void UseHealthMaxIncreasingItem(int increase)
+	{
+		// Failsafe.  Might not be needed?
+		if (increase < 0)
+			increase = 0;
+
+		statLifeMax += increase;
+		statLifeMax2 += increase;
+		statLife += increase;
+
+		if (Main.myPlayer == whoAmI)
+			HealEffect(increase);
+	}
+
 	private void ItemCheck_UseLifeFruit(Item sItem)
 	{
+		/*
 		if (sItem.type == 1291 && itemAnimation > 0 && statLifeMax >= 400 && statLifeMax < 500 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 1291 && itemAnimation > 0 && ConsumedLifeCrystals == LifeCrystalMax && ConsumedLifeFruit < LifeFruitMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statLifeMax += 5;
 			statLifeMax2 += 5;
 			statLife += 5;
 			if (Main.myPlayer == whoAmI)
 				HealEffect(5);
+			*/
+			UseHealthMaxIncreasingItem(5);
+			ConsumedLifeFruit++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 2);
 		}
@@ -35286,13 +_,21 @@
 
 	private void ItemCheck_UseLifeCrystal(Item sItem)
 	{
+		/*
 		if (sItem.type == 29 && itemAnimation > 0 && statLifeMax < 400 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 29 && itemAnimation > 0 && ConsumedLifeCrystals < LifeCrystalMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statLifeMax += 20;
 			statLifeMax2 += 20;
 			statLife += 20;
 			if (Main.myPlayer == whoAmI)
 				HealEffect(20);
+			*/
+			UseHealthMaxIncreasingItem(20);
+			ConsumedLifeCrystals++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 0);
 		}
@@ -35516,7 +_,10 @@
 
 		if (toolTime == 0 && itemAnimation > 0 && controlUseItem) {
 			Tile tile = Main.tile[tileTargetX, tileTargetY];
+			/*
 			if (!tile.active() || IsTilePoundable(tile))
+			*/
+			if (!tile.active() || IsTilePoundable(tile) && !TileID.Sets.CanBeSloped[tile.type])
 				poundRelease = false;
 		}
 
@@ -35566,7 +_,14 @@
 		if (Main.tileHammer[tile.type]) {
 			canHitWalls = false;
 			if (sItem.hammer > 0) {
+				if (TileLoader.GetTile(tile.type) is ModTile modTile) {
+					num2 += (int)(sItem.hammer / modTile.MineResist);
+					goto skipVanillaHammerPower;
+				}
+
 				num2 += sItem.hammer;
+				skipVanillaHammerPower:
+
 				if (!WorldGen.CanKillTile(x, y))
 					num2 = 0;
 
@@ -35596,10 +_,17 @@
 			}
 		}
 		else if (Main.tileAxe[tile.type]) {
+			if (TileLoader.GetTile(tile.type) is ModTile modTile) {
+				num2 += (int)(sItem.axe / modTile.MineResist);
+				goto skipVanillaAxePower;
+			}
+
 			num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
 			if (Main.getGoodWorld)
 				num2 = (int)((double)num2 * 1.3);
 
+			skipVanillaAxePower:
+
 			if (sItem.axe > 0) {
 				AchievementsHelper.CurrentlyMining = true;
 				if (!WorldGen.CanKillTile(x, y))
@@ -35630,7 +_,7 @@
 						NetMessage.SendData(17, -1, -1, null, 0, x, y);
 
 					if (sItem.type == 5295 && flag)
-						TryReplantingTree();
+						TryReplantingTree(x, y);
 				}
 				else {
 					WorldGen.KillTile(x, y, fail: true);
@@ -35673,10 +_,13 @@
 		return true;
 	}
 
-	private void TryReplantingTree()
+	private void TryReplantingTree(int x, int y)
 	{
-		ushort type = 20;
+		int type = 20;
 		int style = 0;
+
+		PlantLoader.CheckAndInjectModSapling(x, y, ref type, ref style);
+
 		if (!TileObject.CanPlace(tileTargetX, tileTargetY, type, style, direction, out var objectData))
 			return;
 
@@ -35798,7 +_,14 @@
 	private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y)
 	{
 		Tile tile = Main.tile[x, y];
+
+		/*
 		if (sItem.hammer > 0 && tile.active() && (Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442) && poundRelease) {
+		*/
+		bool canTrySloping = sItem.hammer > 0 && tile.active() && poundRelease;
+		bool vanillaSloping = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
+
+		if (canTrySloping && (vanillaSloping || TileID.Sets.CanBeSloped[tile.type])) {
 			hitWall = false;
 			ApplyItemTime(sItem);
 			int damageAmount = 100;
@@ -35810,6 +_,7 @@
 				if (!poundRelease)
 					return;
 
+				if (TileLoader.Slope(x, y, Main.tile[x, y].type)) { } else
 				if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
 					if (tile.halfBrick()) {
 						WorldGen.PoundTile(x, y);
@@ -36439,7 +_,9 @@
 			}
 
 			if (num3 >= 0 && WorldGen.PlaceWire(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num3], this))
-				inventory[num3].stack--;
+					inventory[num3].stack--;
+
 				if (inventory[num3].stack <= 0)
 					inventory[num3].SetDefaults();
 
@@ -36457,7 +_,9 @@
 			}
 
 			if (num4 >= 0 && WorldGen.PlaceWire2(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num4], this))
-				inventory[num4].stack--;
+					inventory[num4].stack--;
+
 				if (inventory[num4].stack <= 0)
 					inventory[num4].SetDefaults();
 
@@ -36476,7 +_,9 @@
 			}
 
 			if (num5 >= 0 && WorldGen.PlaceWire3(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num5], this))
-				inventory[num5].stack--;
+					inventory[num5].stack--;
+
 				if (inventory[num5].stack <= 0)
 					inventory[num5].SetDefaults();
 
@@ -36495,7 +_,9 @@
 			}
 
 			if (num6 >= 0 && WorldGen.PlaceWire4(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num6], this))
-				inventory[num6].stack--;
+					inventory[num6].stack--;
+
 				if (inventory[num6].stack <= 0)
 					inventory[num6].SetDefaults();
 
@@ -36528,7 +_,9 @@
 		else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2)) {
 			ApplyItemTime(sItem);
 			NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
+			if (ItemLoader.ConsumeItem(sItem, this))
-			sItem.stack--;
+				sItem.stack--;
+
 			if (sItem.stack <= 0)
 				sItem.SetDefaults();
 		}
@@ -36620,11 +_,21 @@
 
 	private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage)
 	{
+		if (!CombinedHooks.CanShoot(this, sItem))
+			return;
+
 		int projToShoot = sItem.shoot;
 		float speed = sItem.shootSpeed;
 		int damage = sItem.damage;
 		if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
-			speed /= meleeSpeed;
+			speed /= inverseMeleeSpeed;
+
+		// Copied as-is from 1.3
+		if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f) {
+			speed *= ThrownVelocity;
+			if (speed > 16f)
+				speed = 16f;
+		}
 
 		bool canShoot = false;
 		int Damage = weaponDamage;
@@ -36678,6 +_,12 @@
 		if (!canShoot)
 			return;
 
+		// Added by TML. #ItemTimeOnAllClients
+		if (whoAmI != Main.myPlayer) {
+			ApplyItemTime(sItem);
+			return;
+		}
+
 		KnockBack = GetWeaponKnockback(sItem, KnockBack);
 		IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
 		if (projToShoot == 228)
@@ -36824,6 +_,16 @@
 			num3 = vector5.Y;
 		}
 
+		goto DirtBallShoot;
+
+		ShootHook:
+		Vector2 velocity = new Vector2(num2, num3);
+
+		CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
+
+		num2 = velocity.X;
+		num3 = velocity.Y;
+
 		if (sItem.useStyle == 5) {
 			if (sItem.type == 3029) {
 				Vector2 vector6 = new Vector2(num2, num3);
@@ -36859,6 +_,12 @@
 			NetMessage.SendData(41, -1, -1, null, whoAmI);
 		}
 
+		if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
+			return;
+
+		goto ShootProj;
+
+		DirtBallShoot:
 		if (projToShoot == 17) {
 			pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
 			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
@@ -36868,6 +_,9 @@
 			LimitPointToPlayerReachableArea(ref pointPoisition);
 		}
 
+		goto ShootHook;
+
+		ShootProj:
 		if (projToShoot == 76) {
 			projToShoot += Main.rand.Next(3);
 			float num7 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
@@ -38410,10 +_,14 @@
 		projType = 721;
 		Item item = inventory[selectedItem];
 		if (!item.IsAir && item.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item.shoot]) {
+			// Extra patch context.
 			projType = item.shoot;
 			return;
 		}
 
+		if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
+			return;
+
 		for (int num = 19; num >= 0; num--) {
 			if (IsItemSlotUnlockedAndUsable(num)) {
 				_ = num % 10;
@@ -38438,6 +_,11 @@
 	{
 		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			// Added by TML. #ItemTimeOnAllClients
+			if (whoAmI != Main.myPlayer)
+				return;
+
 			MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
 		}
 	}
@@ -38448,6 +_,11 @@
 			return;
 
 		ApplyItemTime(sItem);
+
+		// Added by TML. #ItemTimeOnAllClients
+		if (whoAmI != Main.myPlayer)
+			return;
+
 		for (int i = 0; i < 1000; i++) {
 			Projectile projectile = Main.projectile[i];
 			if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
@@ -38777,6 +_,12 @@
 
 	private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
 	{
+		ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
+		ItemLoader.HoldStyle(sItem, this, heldItemFrame);
+	}
+
+	private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
+	{
 		if (isPettingAnimal) {
 			int num = miscCounter % 14 / 7;
 			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
@@ -39041,7 +_,10 @@
 
 	private void ItemCheck_ApplyManaRegenDelay(Item sItem)
 	{
+		/*
 		if (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))
+		*/
+ 		if (GetManaCost(sItem) > 0)
 			manaRegenDelay = (int)maxRegenDelay;
 	}
 
@@ -39105,6 +_,12 @@
 
 	public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
 	{
+		ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
+		ItemLoader.UseStyle(sItem, this, heldItemFrame);
+	}
+
+	private void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
+	{
 		if (Main.dedServ)
 			return;
 
@@ -39862,8 +_,12 @@
 
 	private void ApplyLifeAndOrMana(Item item)
 	{
+		/*
 		int num = item.healLife;
 		int healMana = item.healMana;
+		*/
+		int num = GetHealLife(item, true);
+		int healMana = GetHealMana(item, true);
 		if (item.type == 3001) {
 			int healLife = item.healLife;
 			int num2 = 120;
@@ -39903,6 +_,9 @@
 
 	private bool ItemCheck_CheckCanUse(Item sItem)
 	{
+		if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
+			return false;
+
 		int num = whoAmI;
 		bool flag = true;
 		int num2 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
@@ -40262,7 +_,7 @@
 		if (baitTypeUsed == 2673)
 			flag = true;
 
-		if (flag) {
+		if (CombinedHooks.CanConsumeBait(this, item) ?? flag) {
 			if (item.type == 4361 || item.type == 4362)
 				NPC.LadyBugKilled(base.Center, item.type == 4362);
 
@@ -40306,6 +_,11 @@
 		if (sItem.type == 3006)
 			flag2 = true;
 
+		if (sItem.type != ItemID.MedusaHead /*3269*/ && !CheckMana(sItem, pay:!flag2))
+			canUse = false;
+
+		return canUse; // TML: The below code was moved to CheckMana and GetManaCost in Player.TML.
+
 		if (sItem.type != 3269 && (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))) {
 			if (statMana >= num) {
 				if (!flag2)
@@ -40475,6 +_,13 @@
 
 	private void ItemCheck_HandleMPItemAnimation(Item sItem)
 	{
+		// Firstly, in vanilla, autoReuse items go from itemAnimation == 1 to itemAnimationMax-1 here, skipping the frame where itemAnimation == 0
+		//   this prevents the item flickering out while being auto-reused, and prevents other control inputs that can happen on that 'frame where item is not in use' like useTurn
+		//   but has the side-effect that autoReuse items are one frame shorter. tML fixes the itemAnimation counter, see the comments near the top of ItemCheck_Inner (#2351)
+		//
+		// Secondly, we don't need to play the shoot-sound and ensure hold-out animation looping for remote players because Shoot logic now runs remote side in tML (#ItemTimeOnAllClients)
+
+		/*
 		if (sItem.autoReuse && !noItems) {
 			releaseUseItem = true;
 			if (itemAnimation == 1 && sItem.stack > 0) {
@@ -40484,23 +_,43 @@
 					itemAnimation = 0;
 			}
 		}
+		*/
 
 		TryAllowingItemReuse(sItem);
 	}
 
 	private void TryAllowingItemReuse(Item sItem)
 	{
+		if (CanAutoReuseItem(sItem))
+			releaseUseItem = true;
+	}
+
+	//TML: Public method split from TryAllowingItemReuse
+	public bool CanAutoReuseItem(Item sItem)
+	{
+		if (CombinedHooks.CanAutoReuseItem(this, sItem) is bool autoReuse)
+			return autoReuse;
+
+		/*
 		bool flag = false;
+		*/
+		bool flag = sItem.autoReuse;
 		if (autoReuseGlove) {
+			/*
 			flag |= sItem.melee && sItem.type != 3030;
 			flag |= sItem.summon && ItemID.Sets.SummonerWeaponThatScalesWithAttackSpeed[sItem.type];
+			*/
+			flag |= sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed);
 		}
 
 		if (autoReuseAllWeapons && sItem.damage > 0 && (!sItem.channel || !channel))
 			flag = true;
 
+		/*
 		if (flag)
 			releaseUseItem = true;
+		*/
+		return flag;
 	}
 
 	private void ItemCheck_HandleMount()
@@ -40508,6 +_,7 @@
 		if (!mount.Active)
 			return;
 
+		MountLoader.UseAbility(this, Vector2.Zero, false);
 		if (whoAmI == Main.myPlayer && gravDir == -1f) {
 			mount.Dismount(this);
 		}
@@ -40853,8 +_,14 @@
 		}
 	}
 
+	// TML-specific overload that exists for consistency with other GetWeaponXYZ methods
+	public float GetWeaponKnockback(Item sItem) => GetWeaponKnockback(sItem, sItem.knockBack);
+
+	//TML: 'KnockBack' -> 'baseKnockback'.
-	public float GetWeaponKnockback(Item sItem, float KnockBack)
+	public float GetWeaponKnockback(Item sItem, float baseKnockback)
 	{
+		// knockback moved into UpdateEquips/Update as sensible
+		/*
 		if (sItem.summon)
 			KnockBack += minionKB;
 
@@ -40871,10 +_,16 @@
 			KnockBack *= 1f + (1f - stealth) * 0.5f;
 
 		return KnockBack;
+		*/
+
+		StatModifier modifier = GetTotalKnockback(sItem.DamageType);
+		CombinedHooks.ModifyWeaponKnockback(this, sItem, ref modifier);
+		return Math.Max(0f, modifier.ApplyTo(baseKnockback));
 	}
 
 	public int GetWeaponCrit(Item sItem)
 	{
+		/*
 		if (sItem.melee)
 			return meleeCrit;
 
@@ -40885,10 +_,17 @@
 			return magicCrit;
 
 		return 0;
+		*/
+
+		float crit = sItem.crit + GetTotalCritChance(sItem.DamageType);
+		CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
+		return (int)(crit + 5E-06f);
 	}
 
-	public int GetWeaponDamage(Item sItem)
+	//TML: Added 'forTooltip' parameter.
+	public int GetWeaponDamage(Item sItem, bool forTooltip = false)
 	{
+		/*
 		int num = sItem.damage;
 		if (num > 0) {
 			if (sItem.melee) {
@@ -40919,10 +_,44 @@
 		}
 
 		return num;
+		*/
+
+		StatModifier modifier = GetTotalDamage(sItem.DamageType);
+
+		if (AmmoID.Sets.IsArrow[sItem.useAmmo])
+			modifier = modifier.CombineWith(arrowDamage);
+
+		if (AmmoID.Sets.IsBullet[sItem.useAmmo])
+			modifier = modifier.CombineWith(bulletDamage);
+
+		if (AmmoID.Sets.IsRocket[sItem.useAmmo])
+			modifier = modifier.CombineWith(rocketDamage);
+
+		CombinedHooks.ModifyWeaponDamage(this, sItem, ref modifier);
+
+		float baseDamage = sItem.damage;
+		if (forTooltip)
+			baseDamage *= ItemID.Sets.ToolTipDamageMultiplier[sItem.type];
+
+		return Math.Max(0, (int)(modifier.ApplyTo(baseDamage) + 5E-06f));
 	}
 
+	/// <summary>
+	/// Whether or not the player has ammunition available for the given weapon.
+	/// </summary>
+	/// <param name="sItem">The weapon for which to try to find ammunition.</param>
+	/// <returns>True if the player has ammo available; false otherwise.</returns>
+	public bool HasAmmo(Item sItem) => HasAmmo(sItem, canUse: true);
+
+	//TML: Internal split for vanilla canUse calls
-	public bool HasAmmo(Item sItem, bool canUse)
+	internal bool HasAmmo(Item sItem, bool canUse)
 	{
+		if (!canUse)
+			return false; // just in case I guess...
+
+		return sItem.useAmmo == 0 || ChooseAmmo(sItem) != null || !ItemLoader.NeedsAmmo(sItem, this);
+
+		/*
 		if (sItem.useAmmo > 0) {
 			canUse = false;
 			for (int i = 0; i < 58; i++) {
@@ -40934,6 +_,7 @@
 		}
 
 		return canUse;
+		*/
 	}
 
 	private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId)
@@ -40945,15 +_,68 @@
 		return false;
 	}
 
+	// Overloaded added by TML.
+	/// <summary>
+	/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
+	/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
+	/// </summary>
+	/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
+	/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
+	/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
+	/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+	/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+	/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
+	/// <param name="dontConsume">
+	/// Whether or not ammo consumption logic should be called upon.<br></br>
+	/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
+	/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
+	/// </param>
+	/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
+	public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false)
+	{
+		projToShoot = weapon.shoot;
+		speed = weapon.shootSpeed;
+		damage = GetWeaponDamage(weapon);
+		knockBack = GetWeaponKnockback(weapon);
+
+		bool canShoot = false;
+		PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
+
+		if (!canShoot) {
+			projToShoot = 0;
+			return false;
+		}
+
+		return true;
+	}
+
+	//TML: Method split, 1st part of original PickAmmo.
+	/*
 	public void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int Damage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
+	*/
+	/// <summary>
+	/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
+	/// </summary>
+	/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
+	/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
+	public Item ChooseAmmo(Item weapon)
 	{
-		Item item = new Item();
+		var sItem = weapon;
+		Item item = null;
 		bool flag = false;
+		/*
 		usedAmmoItemId = 0;
+		*/
+		bool canShoot = false; // Dummy.
+
 		if (sItem.useAmmo == AmmoID.Coin) {
 			for (int i = 0; i < 4; i++) {
 				int num = 50 + i;
+
+				/*
 				if (inventory[num].ammo == sItem.useAmmo && inventory[num].stack > 0) {
+				*/
+				if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[i], this)) {
 					item = inventory[num];
 					canShoot = true;
 					flag = true;
@@ -40963,7 +_,10 @@
 		}
 
 		for (int j = 54; j < 58; j++) {
+			/*
 			if (inventory[j].ammo == sItem.useAmmo && inventory[j].stack > 0) {
+			*/
+			if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[j], this)) {
 				item = inventory[j];
 				canShoot = true;
 				flag = true;
@@ -40973,7 +_,10 @@
 
 		if (!flag) {
 			for (int k = 0; k < 54; k++) {
+				/*
 				if (inventory[k].ammo == sItem.useAmmo && inventory[k].stack > 0) {
+				*/
+				if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[k], this)) {
 					item = inventory[k];
 					canShoot = true;
 					break;
@@ -40981,10 +_,43 @@
 			}
 		}
 
+		return item;
+	}
+
+	//TML: Method split, 2nd part of original PickAmmo. This one gets called by vanilla in place of it.
+	internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
+	{
+		usedAmmoItemId = 0;
+		Item item = ChooseAmmo(sItem);
+		canShoot = item != null;
+
+		bool shootWithNoAmmo = false;
+		if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this)) {
+			item = ContentSamples.ItemsByType[sItem.useAmmo];
+			if (item.ammo == sItem.useAmmo)
+				canShoot = shootWithNoAmmo = true;
+		}
+
 		if (!canShoot)
 			return;
 
 		usedAmmoItemId = item.type;
+
+		StatModifier ammoDamage = GetTotalDamage(item.DamageType);
+		if (AmmoID.Sets.IsArrow[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(arrowDamage);
+
+		if (AmmoID.Sets.IsBullet[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(bulletDamage);
+
+		if (AmmoID.Sets.IsRocket[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(rocketDamage);
+
+		// TODO: Why do we reset Base to 0 here? Why not use += for Flat?
+		ammoDamage.Base = 0;
+		ammoDamage.Flat = totalDamage;
+		ref float Damage = ref ammoDamage.Flat; // Vanilla projectile damage applied from here on is interpreted as flat additions
+
 		int pickedProjectileId = -1;
 		if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
 			projToShoot = pickedProjectileId;
@@ -41043,6 +_,9 @@
 			speed *= 1.1f;
 		}
 
+		// Item damage applied below, with ammoDamage.ApplyTo(item.damage)
+		// Damage class boosts come from the ammo damage class
+		/*
 		if (item.ranged) {
 			if (item.damage > 0)
 				Damage += (int)((float)item.damage * rangedDamage);
@@ -41050,6 +_,7 @@
 		else {
 			Damage += item.damage;
 		}
+		*/
 
 		if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery) {
 			if (speed < 20f) {
@@ -41058,11 +_,69 @@
 					speed = 20f;
 			}
 
+			//TML: Archery potion damage buff moved into arrowDamage stat modifier
+			/*
 			Damage = (int)((double)Damage * 1.1);
+			*/
 		}
 
 		KnockBack += item.knockBack;
+
+		ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref ammoDamage, ref KnockBack);
+		totalDamage = (int)(ammoDamage.ApplyTo(item.damage) + 5E-06f);
+
+		if (!dontConsume && !shootWithNoAmmo && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot)) {
+			CombinedHooks.OnConsumeAmmo(this, sItem, item);
+			item.stack--;
+			if (item.stack <= 0) {
+				item.active = false;
+				item.TurnToAir();
+			}
+		}
+	}
+
+	//TML: Method split, 3rd part of original PickAmmo.
+	/// <summary>
+	/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
+	/// </summary>
+	/// <param name="weapon">The weapon attempting to consume the ammo.</param>
+	/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
+	/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
+	/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
+	public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot)
+	{
+		Item sItem = weapon;
+		Item item = ammo;
+
+		// TODO:
+		// The current approach to ammo consumption hooks demands that vanilla conservation chances still be allowed to factor in.
+		// While this is fine for some, for others, it may be preferable to be able to guarantee ammo consumption if it should happen.
+		// For this, two approaches exist. each has their ups and downs:
+		// 1 - CanConsumeAmmo to nullable, return given value if it exists
+		// 2 - separate hook for forced ammo consumption. returns false by default, return true to bypass all vanilla conservation chances
+		//
+		// Post-May-freeze, will decide on one and make changes accordingly.
+		// - Thomas
+
+		if (!CombinedHooks.CanConsumeAmmo(this, sItem, item))
+			return true;
+
+		if (sItem.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
+			return true;
+
+		if (sItem.consumeAmmoOnLastShotOnly) {
+			int useTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
+			bool isLastShot = itemAnimation <= useTime || // not enough time to shoot again
+				sItem.useLimitPerAnimation != null && ItemUsesThisAnimation == sItem.useLimitPerAnimation - 1; // this shot hits the limit
+
+			if (!isLastShot)
+				return true;
+		}
+
+		/*
 		bool flag2 = dontConsume;
+		*/
+		bool flag2 = false;
 		if (sItem.type == 3475 && Main.rand.Next(3) != 0)
 			flag2 = true;
 
@@ -41075,7 +_,10 @@
 		if (sItem.type == 5134 && Main.rand.Next(3) == 0)
 			flag2 = true;
 
+		/*
 		if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && Main.rand.Next(5) == 0)
+		*/
+		if (magicQuiver && AmmoID.Sets.IsArrow[sItem.useAmmo] && Main.rand.Next(5) == 0)
 			flag2 = true;
 
 		if (ammoBox && Main.rand.Next(5) == 0)
@@ -41102,11 +_,15 @@
 		if (sItem.type == 1553 && Main.rand.Next(3) != 0)
 			flag2 = true;
 
+
+		//TML: Clockwork Assault Rifle + Eventide. Handled by consumeAmmoOnLastShotOnly.
+		/*
 		if (sItem.type == 434 && !ItemAnimationJustStarted)
 			flag2 = true;
 
 		if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
 			flag2 = true;
+		*/
 
 		if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
 			flag2 = true;
@@ -41120,9 +_,20 @@
 		if (ammoCost75 && Main.rand.Next(4) == 0)
 			flag2 = true;
 
+		// Copied as-is from 1.3
+		if (item.CountsAsClass(DamageClass.Throwing)) {
+			if (ThrownCost50 && Main.rand.Next(100) < 50)
+				flag2 = true;
+
+			if (ThrownCost33 && Main.rand.Next(100) < 33)
+				flag2 = true;
+		}
+
 		if (Main.remixWorld && sItem.type == 1319 && Main.rand.Next(2) == 0)
 			flag2 = true;
 
+		//TML: Flamethrower + Elf Melter (handled by consumeAmmoOnFirstShotOnly) + Clentaminator (handled by consumeAmmoOnFirstShotOnly)
+		/*
 		if (projToShoot == 85 && itemAnimation < itemAnimationMax - sItem.useTime)
 			flag2 = true;
 
@@ -41136,6 +_,9 @@
 				item.TurnToAir();
 			}
 		}
+		*/
+
+		return flag2;
 	}
 
 	public void GetOtherPlayersPickTile(int x, int y, int pickDamage)
@@ -41173,7 +_,7 @@
 					NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
 				}
 
-				if (Main.tile[x, y].type == 21)
+				if (Main.tile[x, y].type == 21 || Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type])
 					NetMessage.SendData(34, -1, -1, null, 1, x, y);
 
 				if (Main.tile[x, y].type == 467)
@@ -41181,6 +_,14 @@
 
 				if (Main.tile[x, y].type == 88)
 					NetMessage.SendData(34, -1, -1, null, 3, x, y);
+
+				if (Main.tile[x, y].type >= TileID.Count) {
+					if (TileID.Sets.BasicChest[Main.tile[x, y].type])
+						NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type, 0);
+
+					if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
+						NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type, 0);
+				}
 			}
 			else {
 				bool flag = Main.tile[x, y].active();
@@ -41260,7 +_,14 @@
 		if (Main.tileNoFail[tileTarget.type])
 			num = 100;
 
+		if (TileLoader.GetTile(tileTarget.type) is ModTile modTile) {
+			num += (int)(pickPower / modTile.MineResist);
+			goto skipVanillaPickPower;
+		}
+
 		num = ((!Main.tileDungeon[tileTarget.type] && tileTarget.type != 25 && tileTarget.type != 58 && tileTarget.type != 117 && tileTarget.type != 203) ? ((tileTarget.type == 85) ? ((!Main.getGoodWorld) ? (num + pickPower / 3) : (num + pickPower / 4)) : ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2))) : (num + pickPower / 2));
+		skipVanillaPickPower:
+
 		if (tileTarget.type == 211 && pickPower < 200)
 			num = 0;
 
@@ -41315,6 +_,9 @@
 		else if (tileTarget.type == 223 && pickPower < 150) {
 			num = 0;
 		}
+		else {
+			TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
+		}
 
 		if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
 			num += pickPower;
@@ -41631,15 +_,43 @@
 	public void DropItems()
 	{
 		IEntitySource itemSource_Death = GetItemSource_Death();
+
+		var startInventory = PlayerLoader.GetStartingItems(this, DropItems_GetDefaults().Where(item => !item.IsAir), true);
+		var startCounts = new Dictionary<int, int>();
+
+		foreach (Item item in startInventory) {
+			if (!startCounts.ContainsKey(item.netID))
+				startCounts[item.netID] = 0;
+
+			startCounts[item.netID] += item.stack;
+		}
+
+		startCounts[ModContent.ItemType<ModLoader.Default.StartBag>()] = 1;
+
+		//TML: Drop code for modded accessory Slots, should run prior to dropping other items in case conditions are used based on player's current equips
+		AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
+
 		for (int i = 0; i < 59; i++) {
 			if (inventory[i].stack > 0) {
 				bool flag = true;
 				int type = inventory[i].type;
+
+				/*
 				if ((uint)(type - 3506) <= 1u || type == 3509)
 					flag = false;
 
 				if (flag)
 					TryDroppingSingleItem(itemSource_Death, inventory[i]);
+				*/
+				Item itemToDrop = inventory[i];
+				if (startCounts.TryGetValue(type, out int startCount)) {
+					int n = Math.Min(itemToDrop.stack, startCount);
+					itemToDrop.stack -= n;
+					startCounts[type] -= n;
+				}
+
+				if (itemToDrop.stack > 0)
+					TryDroppingSingleItem(itemSource_Death, itemToDrop);
 			}
 
 			inventory[i].TurnToAir();
@@ -41661,23 +_,48 @@
 			loadouts[type].TryDroppingItems(this, itemSource_Death);
 		}
 
+		DropItems_End(startInventory);
+	}
+
+	//TML: Method split.
+	private IEnumerable<Item> DropItems_GetDefaults()
+	{
+		var inventory = new Item[this.inventory.Length];
+
+		for (int i = 0; i < inventory.Length; i++) {
+			inventory[i] = new Item();
+		}
+
 		inventory[0].SetDefaults(3507);
 		inventory[0].Prefix(-1);
 		inventory[1].SetDefaults(3509);
 		inventory[1].Prefix(-1);
 		inventory[2].SetDefaults(3506);
 		inventory[2].Prefix(-1);
+
+		return inventory;
+	}
+
+	//TML: Method split.
+	private void DropItems_End(IList<Item> startInventory)
+	{
+		PlayerLoader.SetStartInventory(this, startInventory);
 		Main.mouseItem.TurnToAir();
 	}
 
 	public void TryDroppingSingleItem(IEntitySource source, Item theItem)
 	{
 		if (theItem.stack > 0) {
+			/*
 			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem.type);
+			*/
+			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem);
 			Item obj = Main.item[num];
+			/*
 			obj.netDefaults(theItem.netID);
 			obj.Prefix(theItem.prefix);
 			obj.stack = theItem.stack;
+			*/
 			obj.velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
 			obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 			obj.noGrabDelay = 100;
@@ -41733,9 +_,13 @@
 		}
 	}
 
+	private Player _clientClone;
 	public Player clientClone()
 	{
-		Player player = new Player();
+		// Disable cloning until the end of the method.
+		using var _disableItemCLone = new Item.DisableCloneMethod("Item.Clone is bad for performance, and should not be called during Player.clientClone or ModPlayer.CopyClientStateTo. Use Item.CopyNetStateTo instead");
+
+		Player player = _clientClone ??= new Player();
 		player.zone1 = zone1;
 		player.zone2 = zone2;
 		player.zone3 = zone3;
@@ -41743,6 +_,9 @@
 		player.zone5 = zone5;
 		player.voidVaultInfo = voidVaultInfo;
 		player.luck = luck;
+
+		BiomeLoader.CopyCustomBiomesTo(this, player);
+
 		player.extraAccessory = extraAccessory;
 		player.MinionRestTargetPoint = MinionRestTargetPoint;
 		player.MinionAttackTargetNPC = MinionAttackTargetNPC;
@@ -41771,34 +_,34 @@
 		player.hideMisc = hideMisc;
 		player.shieldRaised = shieldRaised;
 		for (int i = 0; i < 59; i++) {
-			player.inventory[i] = inventory[i].Clone();
+			inventory[i].CopyNetStateTo(player.inventory[i]);
 			if (i < armor.Length)
-				player.armor[i] = armor[i].Clone();
+				armor[i].CopyNetStateTo(player.armor[i]);
 
 			if (i < dye.Length)
-				player.dye[i] = dye[i].Clone();
+				dye[i].CopyNetStateTo(player.dye[i]);
 
 			if (i < miscEquips.Length)
-				player.miscEquips[i] = miscEquips[i].Clone();
+				miscEquips[i].CopyNetStateTo(player.miscEquips[i]);
 
 			if (i < miscDyes.Length)
-				player.miscDyes[i] = miscDyes[i].Clone();
+				miscDyes[i].CopyNetStateTo(player.miscDyes[i]);
 
 			if (i < bank.item.Length)
-				player.bank.item[i] = bank.item[i].Clone();
+				bank.item[i].CopyNetStateTo(player.bank.item[i]);
 
 			if (i < bank2.item.Length)
-				player.bank2.item[i] = bank2.item[i].Clone();
+				bank2.item[i].CopyNetStateTo(player.bank2.item[i]);
 
 			if (i < bank3.item.Length)
-				player.bank3.item[i] = bank3.item[i].Clone();
+				bank3.item[i].CopyNetStateTo(player.bank3.item[i]);
 
 			if (i < bank4.item.Length)
-				player.bank4.item[i] = bank4.item[i].Clone();
+				bank4.item[i].CopyNetStateTo(player.bank4.item[i]);
 		}
 
 		CloneLoadouts(player);
-		player.trashItem = trashItem.Clone();
+		trashItem.CopyNetStateTo(player.trashItem);
 		for (int j = 0; j < maxBuffs; j++) {
 			player.buffType[j] = buffType[j];
 			player.buffTime[j] = buffTime[j];
@@ -41806,6 +_,9 @@
 
 		DpadRadial.CopyTo(player.DpadRadial);
 		CircularRadial.CopyTo(player.CircularRadial);
+
+		PlayerLoader.CopyClientState(this, player);
+
 		return player;
 	}
 
@@ -41814,26 +_,26 @@
 		Item[] array = armor;
 		Item[] array2 = clonePlayer.armor;
 		for (int i = 0; i < array.Length; i++) {
-			array2[i] = array[i].Clone();
+			array[i].CopyNetStateTo(array2[i]);
 		}
 
 		array = dye;
 		array2 = clonePlayer.dye;
 		for (int j = 0; j < array.Length; j++) {
-			array2[j] = array[j].Clone();
+			array[j].CopyNetStateTo(array2[j]);
 		}
 
 		for (int k = 0; k < Loadouts.Length; k++) {
 			array = Loadouts[k].Armor;
 			array2 = clonePlayer.Loadouts[k].Armor;
 			for (int l = 0; l < array.Length; l++) {
-				array2[l] = array[l].Clone();
+				array[l].CopyNetStateTo(array2[l]);
 			}
 
 			array = Loadouts[k].Dye;
 			array2 = clonePlayer.Loadouts[k].Dye;
 			for (int m = 0; m < array.Length; m++) {
-				array2[m] = array[m].Clone();
+				array[m].CopyNetStateTo(array2[m]);
 			}
 		}
 	}
@@ -41855,7 +_,10 @@
 		if (Main.tile[x, y - 1] == null)
 			return false;
 
+		/*
 		if (!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != 79)
+		*/
+		if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
 			return false;
 
 		for (int i = x - 1; i <= x + 1; i++) {
@@ -41963,7 +_,13 @@
 			}
 		}
 		catch (Exception exception) {
+			// IO Exception
 			FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path);
+
+			if (!Main.gameMenu)
+				WorldGen.SaveAndQuit();
+
+			Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{exception}", Main.menuMode);
 			throw;
 		}
 	}
@@ -41979,21 +_,52 @@
 		if (string.IsNullOrEmpty(path))
 			return;
 
+		// TML: Delay vanilla saving until modded data is serialized (in case of exceptions)
+		// Moved to the bottom
+		/*
 		if (FileUtilities.Exists(path, isCloudSave))
 			FileUtilities.Copy(path, path + ".bak", isCloudSave);
+		*/
 
 		RijndaelManaged rijndaelManaged = new RijndaelManaged();
+
+		/*
 		using Stream stream = (isCloudSave ? ((Stream)new MemoryStream(2000)) : ((Stream)new FileStream(path, FileMode.Create)));
+		*/
+		using Stream stream = new MemoryStream(2000);
 		using CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write);
 		using BinaryWriter binaryWriter = new BinaryWriter(cryptoStream);
+
+		PlayerLoader.PreSavePlayer(player);
+
 		binaryWriter.Write(279);
 		playerFile.Metadata.Write(binaryWriter);
 		Serialize(playerFile, player, binaryWriter);
 		binaryWriter.Flush();
 		cryptoStream.FlushFinalBlock();
 		stream.Flush();
+
+		// TML: Delay vanilla saving until modded data is serialized (in case of exceptions)
+		// Replaced with FileUtilities.WriteAllBytes at the bottom
+		/*
 		if (isCloudSave && SocialAPI.Cloud != null)
 			SocialAPI.Cloud.Write(playerFile.Path, ((MemoryStream)stream).ToArray());
+		*/
+
+		byte[] bytes = ((MemoryStream)stream).ToArray();
+
+		PlayerLoader.PostSavePlayer(player); // For native data only
+
+		//TML: Delay vanilla saving until modded data is serialized (in case of exceptions)
+		var tag = PlayerIO.SaveData(player);
+
+		BackupIO.Player.ArchivePlayer(path, isCloudSave);
+		if (FileUtilities.Exists(path, isCloudSave))
+			FileUtilities.Copy(path, path + ".bak", isCloudSave);
+
+		FileUtilities.WriteAllBytes(path, bytes, isCloudSave);
+
+		PlayerIO.Save(tag, path, isCloudSave);
 	}
 
 	private static void Serialize(PlayerFileData playerFile, Player newPlayer, BinaryWriter fileIO)
@@ -42002,7 +_,7 @@
 		fileIO.Write(newPlayer.difficulty);
 		fileIO.Write(playerFile.GetPlayTime().Ticks);
 		fileIO.Write(newPlayer.hair);
-		fileIO.Write(newPlayer.hairDye);
+		PlayerIO.WriteByteVanillaHairDye(newPlayer.hairDye, fileIO);
 		BitsByte bitsByte = (byte)0;
 		for (int i = 0; i < 8; i++) {
 			bitsByte[i] = newPlayer.hideVisibleAccessory[i];
@@ -42018,9 +_,13 @@
 		fileIO.Write(newPlayer.hideMisc);
 		fileIO.Write((byte)newPlayer.skinVariant);
 		fileIO.Write(newPlayer.statLife);
-		fileIO.Write(newPlayer.statLifeMax);
+
+		// Keep the player state valid with vanilla (#HealthManaAPI)
+		// Any modifications to statLifeMax/statManaMax by mods can just be done during runtime
+		fileIO.Write(100 + newPlayer.ConsumedLifeCrystals * 20 + newPlayer.ConsumedLifeFruit * 5); // newPlayer.statLifeMax
 		fileIO.Write(newPlayer.statMana);
-		fileIO.Write(newPlayer.statManaMax);
+		fileIO.Write(20 + newPlayer.ConsumedManaCrystals * 20); // newPlayer.statManaMax
+
 		fileIO.Write(newPlayer.extraAccessory);
 		fileIO.Write(newPlayer.unlockedBiomeTorches);
 		fileIO.Write(newPlayer.UsingBiomeTorches);
@@ -42057,57 +_,58 @@
 		fileIO.Write(newPlayer.shoeColor.G);
 		fileIO.Write(newPlayer.shoeColor.B);
 		for (int k = 0; k < newPlayer.armor.Length; k++) {
-			fileIO.Write(newPlayer.armor[k].netID);
-			fileIO.Write(newPlayer.armor[k].prefix);
+			ItemIO.WriteVanillaID(newPlayer.armor[k], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.armor[k], fileIO);
 		}
 
 		for (int l = 0; l < newPlayer.dye.Length; l++) {
-			fileIO.Write(newPlayer.dye[l].netID);
-			fileIO.Write(newPlayer.dye[l].prefix);
+			ItemIO.WriteVanillaID(newPlayer.dye[l], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.dye[l], fileIO);
 		}
 
 		for (int m = 0; m < 58; m++) {
-			fileIO.Write(newPlayer.inventory[m].netID);
+			ItemIO.WriteVanillaID(newPlayer.inventory[m], fileIO);
 			fileIO.Write(newPlayer.inventory[m].stack);
-			fileIO.Write(newPlayer.inventory[m].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.inventory[m], fileIO);
 			fileIO.Write(newPlayer.inventory[m].favorited);
 		}
 
 		for (int n = 0; n < newPlayer.miscEquips.Length; n++) {
-			fileIO.Write(newPlayer.miscEquips[n].netID);
-			fileIO.Write(newPlayer.miscEquips[n].prefix);
-			fileIO.Write(newPlayer.miscDyes[n].netID);
-			fileIO.Write(newPlayer.miscDyes[n].prefix);
+			ItemIO.WriteVanillaID(newPlayer.miscEquips[n], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.miscEquips[n], fileIO);
+			ItemIO.WriteVanillaID(newPlayer.miscDyes[n], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.miscDyes[n], fileIO);
 		}
 
 		for (int num = 0; num < 40; num++) {
-			fileIO.Write(newPlayer.bank.item[num].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank.item[num], fileIO);
 			fileIO.Write(newPlayer.bank.item[num].stack);
-			fileIO.Write(newPlayer.bank.item[num].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank.item[num], fileIO);
 		}
 
 		for (int num2 = 0; num2 < 40; num2++) {
-			fileIO.Write(newPlayer.bank2.item[num2].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank2.item[num2], fileIO);
 			fileIO.Write(newPlayer.bank2.item[num2].stack);
-			fileIO.Write(newPlayer.bank2.item[num2].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank2.item[num2], fileIO);
 		}
 
 		for (int num3 = 0; num3 < 40; num3++) {
-			fileIO.Write(newPlayer.bank3.item[num3].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank3.item[num3], fileIO);
 			fileIO.Write(newPlayer.bank3.item[num3].stack);
-			fileIO.Write(newPlayer.bank3.item[num3].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank3.item[num3], fileIO);
 		}
 
 		for (int num4 = 0; num4 < 40; num4++) {
-			fileIO.Write(newPlayer.bank4.item[num4].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank4.item[num4], fileIO);
 			fileIO.Write(newPlayer.bank4.item[num4].stack);
-			fileIO.Write(newPlayer.bank4.item[num4].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank4.item[num4], fileIO);
 			fileIO.Write(newPlayer.bank4.item[num4].favorited);
 		}
 
 		fileIO.Write(newPlayer.voidVaultInfo);
-		for (int num5 = 0; num5 < maxBuffs; num5++) {
-			if (Main.buffNoSave[newPlayer.buffType[num5]]) {
+		for (int num5 = 0; num5 < 44; num5++) {
+			//TML: Don't save buffs to vanilla player
+			if (true || Main.buffNoSave[newPlayer.buffType[num5]]) {
 				fileIO.Write(0);
 				fileIO.Write(0);
 			}
@@ -42130,7 +_,7 @@
 		}
 
 		fileIO.Write(newPlayer.hbLocked);
-		for (int num7 = 0; num7 < newPlayer.hideInfo.Length; num7++) {
+		for (int num7 = 0; num7 < InfoDisplayLoader.DefaultDisplayCount; num7++) {
 			fileIO.Write(newPlayer.hideInfo[num7]);
 		}
 
@@ -42216,22 +_,22 @@
 	{
 		Item mouseItem = new Item();
 		if (_temporaryItemSlots[0] != null)
-			mouseItem = _temporaryItemSlots[0].Clone();
+			_temporaryItemSlots[0].CopyNetStateTo(mouseItem);
 
 		Main.mouseItem = mouseItem;
 		mouseItem = new Item();
 		if (_temporaryItemSlots[1] != null)
-			mouseItem = _temporaryItemSlots[1].Clone();
+			_temporaryItemSlots[1].CopyNetStateTo(mouseItem);
 
 		Main.CreativeMenu.SetItembyIndex(mouseItem, 0);
 		mouseItem = new Item();
 		if (_temporaryItemSlots[2] != null)
-			mouseItem = _temporaryItemSlots[2].Clone();
+			_temporaryItemSlots[2].CopyNetStateTo(mouseItem);
 
 		Main.guideItem = mouseItem;
 		mouseItem = new Item();
 		if (_temporaryItemSlots[3] != null)
-			mouseItem = _temporaryItemSlots[3].Clone();
+			_temporaryItemSlots[3].CopyNetStateTo(mouseItem);
 
 		Main.reforgeItem = mouseItem;
 		CreativePowerManager.Instance.ApplyLoadedDataToPlayer(this);
@@ -42272,6 +_,10 @@
 
 		Player player = new Player();
 		bool gotToReadName = false;
+
+		// Override Main.CurrentPlayer until the end of this method.
+		using var _currentPlr = new Main.CurrentPlayerOverride(player);
+
 		try {
 			RijndaelManaged rijndaelManaged = new RijndaelManaged();
 			rijndaelManaged.Padding = PaddingMode.None;
@@ -42299,6 +_,9 @@
 			playerFileData.Player = player;
 			return playerFileData;
 		}
+		catch (CustomModDataException e) {
+			playerFileData.customDataFail = e;
+		}
 		catch {
 		}
 
@@ -42322,12 +_,20 @@
 		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
 		Serialize(_visualCloneDummyData, this, _visualCloneWriter);
 		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
-		Deserialize(_visualCloneDummyData, player, _visualCloneReader, 279, out var _);
+		Deserialize(_visualCloneDummyData, player, _visualCloneReader, PlayerIO.SaveData(this), Main.curRelease, out var _); // Added PlayerIO.SaveData argument
 		return player;
 	}
 
 	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, int release, out bool gotToReadName)
 	{
+		if (!PlayerIO.TryLoadData(data.Path, data.IsCloudSave, out var tag))
+			tag = null;
+
+		Deserialize(data, newPlayer, fileIO, tag, release, out gotToReadName);
+	}
+
+	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, TagCompound modData, int release, out bool gotToReadName)
+	{
 		gotToReadName = false;
 		newPlayer.name = fileIO.ReadString();
 		gotToReadName = true;
@@ -42394,8 +_,16 @@
 		if (newPlayer.statManaMax > 200)
 			newPlayer.statManaMax = 200;
 
+		// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+		/*
 		if (newPlayer.statMana > 400)
 			newPlayer.statMana = 400;
+		*/
+
+		// Clamping of the values happens automatically
+		newPlayer.ConsumedLifeCrystals = (newPlayer.statLifeMax - 100) / 20;
+		newPlayer.ConsumedLifeFruit = (newPlayer.statLifeMax - 400) / 5;
+		newPlayer.ConsumedManaCrystals = (newPlayer.statManaMax - 20) / 20;
 
 		if (release >= 125)
 			newPlayer.extraAccessory = fileIO.ReadBoolean();
@@ -42795,6 +_,9 @@
 			}
 		}
 
+		if (modData != null)
+			PlayerIO.Load(newPlayer, modData);
+
 		LoadPlayer_LastMinuteFixes(newPlayer);
 	}
 
@@ -42856,7 +_,29 @@
 	private static void LoadPlayer_LastMinuteFixes(Player newPlayer)
 	{
 		newPlayer.skinVariant = (int)MathHelper.Clamp(newPlayer.skinVariant, 0f, PlayerVariantID.Count - 1);
+
 		for (int i = 3; i < 10; i++) {
+			LoadPlayer_LastMinuteFixes(newPlayer, newPlayer.armor[i]);
+		}
+
+		var modSlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
+		for (int i = 0; i < modSlotPlayer.SlotCount; i++) {
+			LoadPlayer_LastMinuteFixes(newPlayer, modSlotPlayer.exAccessorySlot[i]);
+		}
+
+		LoadPlayer_Finish(newPlayer);
+	}
+
+	//TML: Method split to take an individual item param
+	private static void LoadPlayer_LastMinuteFixes(Player newPlayer, Item item)
+	{
+		// Fake variables
+		var armor = newPlayer.armor;
+		newPlayer.armor = new[] {item};
+		int i = 0;
+
+		// Originally the for loop in the previous method
+		{
 			int type = newPlayer.armor[i].type;
 			if (type == 908 || type == 5000)
 				newPlayer.lavaMax += 420;
@@ -42864,8 +_,10 @@
 			if (type == 906 || type == 4038 || type == 3999 || type == 4003)
 				newPlayer.lavaMax += 420;
 
-			if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0)
+			if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0) {
 				newPlayer.wingsLogic = newPlayer.armor[i].wingSlot;
+				newPlayer.equippedWings = newPlayer.armor[i];
+			}
 
 			if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
 				newPlayer.noFallDmg = true;
@@ -42876,7 +_,16 @@
 			newPlayer.lavaTime = newPlayer.lavaMax;
 		}
 
+		// restore armor variable
+		newPlayer.armor = armor;
+	}
+
+	private static void LoadPlayer_Finish(Player newPlayer)
+	{
 		newPlayer.FixLoadedData();
+
+		// Added by TML, makes sure player is ready to go!
+		newPlayer.ResetEffects();
 	}
 
 	public static PlayerFileData GetFileData(string file, bool cloudSave)
@@ -42887,12 +_,17 @@
 		PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
 		if (playerFileData.Player != null) {
 			if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1) {
+				CustomModDataException customDataFail = playerFileData.customDataFail;
-				if (FileUtilities.Exists(file + ".bak", cloudSave))
+				if (FileUtilities.Exists(file + ".bak", cloudSave)) {
 					FileUtilities.Move(file + ".bak", file, cloudSave);
+					PlayerIO.LoadBackup(file, cloudSave);
+				}
 
 				playerFileData = LoadPlayer(file, cloudSave);
 				if (playerFileData.Player == null)
 					return null;
+
+				playerFileData.customDataFail = customDataFail;
 			}
 
 			return playerFileData;
@@ -42907,6 +_,13 @@
 		return GameShaders.Hair.GetColor(hairDye, this, useLighting ? color : Color.White);
 	}
 
+	/// <summary>
+	/// Checks if the player has the specified item in their <see cref="inventory"/>. <br/>
+	/// Does not check Void Bag. <br/>
+	/// Use <see cref="Player.CountItem(int, int)"/> instead to count the total amount if needed. <br/>
+	/// </summary>
+	/// <param name="type">The item type to count</param>
+	/// <returns>True if the player has the item</returns>
 	public bool HasItem(int type)
 	{
 		for (int i = 0; i < 58; i++) {
@@ -42917,6 +_,9 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Similar to <see cref="HasItem(int)"/>, but checks the provided Item[] <paramref name="collection"/> for items instad. Useful for checking other Item arrays, such as <see cref="Player.armor"/> or <see cref="Player.bank"/>.
+	/// </summary>
 	public bool HasItem(int type, Item[] collection)
 	{
 		for (int i = 0; i < collection.Length; i++) {
@@ -42927,6 +_,9 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Similar to <see cref="HasItem(int)"/>, but also checks the Void Bag.
+	/// </summary>
 	public bool HasItemInInventoryOrOpenVoidBag(int type)
 	{
 		if (!HasItem(type)) {
@@ -43028,6 +_,17 @@
 
 	public Player()
 	{
+		ResetDamageClassData();
+
+		buffType = new int[maxBuffs];
+		buffTime = new int[maxBuffs];
+		buffImmune = new bool[BuffLoader.BuffCount]; // TODO: Move all these patches to field initializers.
+		ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
+		npcTypeNoAggro = new bool[NPCLoader.NPCCount];
+
+		PlayerLoader.SetupPlayer(this);
+		LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
+
 		width = 20;
 		height = 42;
 		name = string.Empty;
@@ -43075,7 +_,10 @@
 		usedGalaxyPearl = false;
 		usedGummyWorm = false;
 		usedAmbrosia = false;
+
+		PlayerLoader.ModifyMaxStats(this);
+
-		for (int n = 0; n < TileID.Count; n++) {
+		for (int n = 0; n < adjTile.Length; n++) {
 			adjTile[n] = false;
 			oldAdjTile[n] = false;
 		}
@@ -43332,11 +_,29 @@
 		int questsDone = anglerQuestsFinished;
 		float anglerRewardRarityMultiplier = GetAnglerRewardRarityMultiplier(questsDone);
 		anglerRewardRarityMultiplier *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
+
+		var rewardItems = new List<Item>();
+
 		GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
-		GetAnglerReward_MainReward(source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
+		GetAnglerReward_MainReward(rewardItems, source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
-		GetAnglerReward_Decoration(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Decoration(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-		GetAnglerReward_Money(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Money(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-		GetAnglerReward_Bait(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Bait(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+
+		PlayerLoader.AnglerQuestReward(this, anglerRewardRarityMultiplier, rewardItems);
+
+		foreach (Item rewardItem in rewardItems) {
+			rewardItem.position = Center;
+
+			Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
+
+			if (getItem.stack > 0) {
+				int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
+
+				if (Main.netMode == 1)
+					NetMessage.SendData(21, -1, -1, null, number, 1f);
+			}
+		}
 	}
 
 	public static float GetAnglerRewardRarityMultiplier(int questsDone)
@@ -43346,7 +_,8 @@
 		return num * 0.9f;
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_MainReward(IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
 	{
 		Item item = new Item();
 		item.type = 0;
@@ -43482,6 +_,8 @@
 			}
 		}
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 		if (item2.stack > 0) {
@@ -43489,11 +_,14 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 
 		if (item.type == 2417) {
 			Item item3 = new Item();
 			Item item4 = new Item();
 			item3.SetDefaults(2418);
+			rewardItems.Add(item3);
+			/*
 			item3.position = base.Center;
 			item2 = GetItem(whoAmI, item3, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -43501,15 +_,20 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number2, 1f);
 			}
+			*/
 
 			item4.SetDefaults(2419);
+			rewardItems.Add(item4);
+			/*
 			item4.position = base.Center;
 			item2 = GetItem(whoAmI, item4, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number3 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number3, 1f);
 			}
+			*/
 		}
 		else {
 			if (item.type != 2498)
@@ -43518,26 +_,35 @@
 			Item item5 = new Item();
 			Item item6 = new Item();
 			item5.SetDefaults(2499);
+			rewardItems.Add(item5);
+			/*
 			item5.position = base.Center;
 			item2 = GetItem(whoAmI, item5, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number4 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number4, 1f);
 			}
+			*/
 
 			item6.SetDefaults(2500);
+			rewardItems.Add(item6);
+			/*
 			item6.position = base.Center;
 			item2 = GetItem(whoAmI, item6, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number5 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
 			}
+			*/
 		}
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Decoration(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Decoration(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		float value = 1f - rarityReduction;
 		int num = 100;
@@ -43609,6 +_,8 @@
 		}
 
 		item.SetDefaults(defaults);
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 		if (item2.stack > 0) {
@@ -43616,9 +_,11 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Bait(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		if (Main.rand.Next((int)(100f * rarityReduction)) > 50)
 			return;
@@ -43649,6 +_,8 @@
 		if (Main.rand.Next(250) <= questsDone)
 			item.stack++;
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 		if (item2.stack > 0) {
@@ -43656,9 +_,11 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Money(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		Item item = new Item();
 		int num = (questsDone + 50) / 2;
@@ -43692,6 +_,8 @@
 			item.stack = num;
 		}
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 		if (item2.stack > 0) {
@@ -43699,6 +_,7 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
 	public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, float totalChance, out bool botheredRollingForADrop, out int itemIdToDrop)
@@ -43845,13 +_,17 @@
 				list.Add(3556);
 			}
 
+			// Extra patch context.
 			if (NPC.downedMoonlord)
 				list.Add(3024);
 		}
 
+		PlayerLoader.GetDyeTraderReward(this, list);
+
 		num = list[Main.rand.Next(list.Count)];
 		Item item = new Item();
 		item.SetDefaults(num);
+		// Extra patch context.
 		item.stack = 6;
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
@@ -44020,7 +_,10 @@
 			}
 		}
 
+		/*
 		int damage = (int)(20f * (1f + magicDamage + minionDamage - 2f));
+		*/
+		int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
 		IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
 		_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
 	}
