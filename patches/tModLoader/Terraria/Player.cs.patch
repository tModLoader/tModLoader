--- src/TerrariaNetCore/Terraria/Player.cs
+++ src/tModLoader/Terraria/Player.cs
@@ -34,10 +_,16 @@
 using Terraria.UI.Gamepad;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Exceptions;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
+using System.Linq;
+using LegacySoundStyle = Terraria.Audio.SoundStyle;
 
 namespace Terraria
 {
-	public class Player : Entity
+	public partial class Player : Entity
 	{
 		public static class BuilderAccToggleIDs
 		{
@@ -186,18 +_,28 @@
 
 			public static void PlayerConnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerConnect(playerIndex);
 			}
 
 			public static void PlayerDisconnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerDisconnect(playerIndex);
 			}
 
 			public static void EnterWorld(int playerIndex) {
+				Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Size={2}x{3}", Main.ActivePlayerFileData.Name, Main.ActivePlayerFileData.IsCloudSave, Main.maxTilesX, Main.maxTilesY);
+				Interface.ResetData();
 				if (Hooks.OnEnterWorld != null)
 					Hooks.OnEnterWorld(Main.player[playerIndex]);
 
+				PlayerLoader.OnEnterWorld(playerIndex);
+
-				if (playerIndex == Main.myPlayer)
+				if (playerIndex == Main.myPlayer) {
 					Main.ToggleGameplayUpdates(state: true);
+
+					// Added by TML.
+					Social.Steam.SteamedWraps.BeginPlaytimeTracking();
+				}
 			}
 		}
 
@@ -398,7 +_,7 @@
 
 		public int emoteTime;
 		public CreativeUnlocksTracker creativeTracker;
-		private static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
+		internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
 		public OverheadMessage chatOverhead;
 		public SelectionRadial DpadRadial = new SelectionRadial();
 		public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);
@@ -407,7 +_,7 @@
 		public int HotbarOffset;
 		public bool GoingDownWithGrapple;
 		public byte spelunkerTimer;
-		public bool[] hideInfo = new bool[13];
+		public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];
 		public int[] builderAccStatus = new int[12] {
 			1,
 			0,
@@ -434,8 +_,8 @@
 		private static SlotId _insideBlizzardSound = SlotId.Invalid;
 		public string name = "";
 		public int taxMoney;
-		public int taxTimer;
+		public double taxTimer;
-		public static int taxRate = 3600;
+		public static double taxRate = 3600;
 		public static int crystalLeafDamage = 100;
 		public static int crystalLeafKB = 10;
 		public float basiliskCharge;
@@ -516,10 +_,35 @@
 		public int ropeCount;
 		public int manaRegenBonus;
 		public int manaRegenDelayBonus;
+		/// <summary>
+		/// The current vanilla dash that the player is using.<br/>
+		/// The following values correspond to vanilla dashes:<br/>
+		/// 1 => Tabi / Master Ninja Gear<br/>
+		/// 2 => Shield of Cthulhu<br/>
+		/// 3 => Solar Flare armor set bonus<br/>
+		/// 4 => Unused, though a dash for this value DOES exist<br/>
+		/// 5 => Crystal Assassin set bonus<br/>
+		/// </summary>
 		public int dashType;
+		/// <summary>
+		/// The current vanilla dash that the player is VISIBLY using.<br/>
+		/// Unlike <see cref="dashType"/>, this does not update if a dash cannot currently be input.<br/>
+		/// </summary>
 		public int dash;
+		/// <summary>
+		/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br/>
+		/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br/>
+		/// </summary>
 		public int dashTime;
+		/// <summary>
+		/// The amount of time that has passed, in ticks, since this player last performed a dash.
+		/// </summary>
 		public int timeSinceLastDashStarted;
+		/// <summary>
+		/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br/>
+		/// For the first frame of any given dash, this is set to -1. After that frame has passsed, it is set to 20 ticks, or 1/3 of a second.<br/>
+		/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br/>
+		/// </summary>
 		public int dashDelay;
 		public int eocDash;
 		public int eocHit;
@@ -528,6 +_,23 @@
 		public int gem = -1;
 		public int gemCount;
 		public BitsByte ownedLargeGems;
+		/// <summary>
+		/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br/>
+		/// Defaults to 0, which denotes that the player does not currently have a flask active.<br/>
+		/// The following values correspond to vanilla flasks:<br/>
+		/// 1 => Flask of Venom (affected weapons proc Acid Venom on hit)<br/>
+		/// 2 => Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br/>
+		/// 3 => Flask of Fire (affected weapons proc On Fire! on hit)<br/>
+		/// 4 => Flask of Gold (affected weapons proc Midas on hit)<br/>
+		/// 5 => Flask of Ichor (affected weapons proc Ichor on hit)<br/>
+		/// 6 => Flask of Nanites (affected weapons proc Confused on hit)<br/>
+		/// 7 => Flask of Party (affected weapons sometimes release confetti explosions on hit)<br/>
+		/// 8 => Flask of Poison (affected weapons proc Poisoned on hit)<br/>
+		/// </summary>
+		// TO-DO:
+		// transform to int later, make proper flask effect system maybe?
+		// concrete use cases exist. just gotta find a way to make a system for 'em intuitive
+		// -thomas
 		public byte meleeEnchant;
 		public byte pulleyDir;
 		public bool pulley;
@@ -539,7 +_,13 @@
 		public int snowBallLauncherInteractionCooldown;
 		public bool iceSkate;
 		public bool carpet;
-		public int spikedBoots;
+		/// <summary>
+		/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br/>
+		/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br/>
+		/// A value of 1 causes the player to slowly slide down them while holding onto them.<br/>
+		/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
+		/// </summary>
+		public int spikedBoots; // tML: documentation added because this field can be a little tricky to understand at first glance
 		public int carpetFrame = -1;
 		public float carpetFrameCounter;
 		public bool canCarpet;
@@ -564,7 +_,7 @@
 		public byte oldLuckPotion;
 		public float endurance;
 		public float whipRangeMultiplier;
-		public float whipUseTimeMultiplier;
+		internal ref float whipUseTimeMultiplier => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);
 		public bool loveStruck;
 		public bool stinky;
 		public bool resistCold;
@@ -702,7 +_,7 @@
 		public bool poundRelease;
 		public float ghostFade;
 		public float ghostDir = 1f;
-		public const int maxBuffs = 22;
+		public static int MaxBuffs => 22 + BuffLoader.extraPlayerBuffCount;
 		public int[] buffType = new int[22];
 		public int[] buffTime = new int[22];
 		public bool[] buffImmune = new bool[338];
@@ -872,7 +_,7 @@
 		public int golferScoreAccumulated;
 		public int bartenderQuestLog;
 		public bool downedDD2EventAnyDifficulty;
-		public int armorPenetration;
+		internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);
 		public int statDefense;
 		public int statLifeMax = 100;
 		public int statLifeMax2 = 100;
@@ -1080,22 +_,22 @@
 		public bool parryDamageBuff;
 		public bool ballistaPanic;
 		public bool JustDroppedAnItem;
-		public int meleeCrit = 4;
-		public int magicCrit = 4;
-		public int rangedCrit = 4;
-		public float meleeDamage = 1f;
-		public float magicDamage = 1f;
-		public float rangedDamage = 1f;
-		public int meleeAddDamage;
-		public int rangedAddDamage;
-		public int magicAddDamage;
-		public int minionAddDamage;
-		public float bulletDamage = 1f;
-		public float arrowDamage = 1f;
-		public float rocketDamage = 1f;
-		public float minionDamage = 1f;
-		public float minionKB;
-		public float meleeSpeed = 1f;
+		internal ref float allCrit => ref GetCritChance(DamageClass.Generic);
+		internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);
+		internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);
+		internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);
+		internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic);
+		internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);
+		internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);
+		internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);
+		public StatModifier bulletDamage = StatModifier.Default;
+		public StatModifier arrowDamage = StatModifier.Default;
+		public StatModifier rocketDamage = StatModifier.Default;
+		internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);
+		internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic);
+		internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;
+		internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);
+		internal float inverseMeleeSpeed => 1 / GetTotalAttackSpeed(DamageClass.Melee); // meleeSpeed is now a damage multiplier, so inverseMeleeSpeed is the useTime multiplier. By using GetTotalAttackSpeed we also incorporate anyone that adds attackSpeed to the Generic damage class
 		public float moveSpeed = 1f;
 		public float pickSpeed = 1f;
 		public float wallSpeed = 1f;
@@ -1130,12 +_,30 @@
 		public bool oldAdjWater;
 		public bool oldAdjHoney;
 		public bool oldAdjLava;
-		public bool[] adjTile = new bool[625];
-		public bool[] oldAdjTile = new bool[625];
+		private bool[] _adjTile = new bool[TileLoader.TileCount];
+		public bool[] adjTile {
+			get {
+				if (_adjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _adjTile, TileLoader.TileCount);
+
+				return _adjTile;
+			}
+			set { _adjTile = value; }
+		}
+		private bool[] _oldAdjTile = new bool[TileLoader.TileCount];
+		public bool[] oldAdjTile {
+			get {
+				if (_oldAdjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
+
+				return _oldAdjTile;
+			}
+			set { _oldAdjTile = value; }
+		}
 		public static int defaultItemGrabRange = 42;
 		private static float itemGrabSpeed = 0.45f;
 		private static float itemGrabSpeedMax = 4f;
-		public byte hairDye;
+		public int hairDye; //TML: Changed from byte to int.
 		public Color hairDyeColor = Color.Transparent;
 		public float hairDyeVar;
 		public int skinDyePacked;
@@ -1380,7 +_,7 @@
 		private int[] unlitTorchY = new int[maxTorchAttacks];
 		private static int[] _torchAttackPosX = new int[400];
 		private static int[] _torchAttackPosY = new int[400];
-		public int ladyBugLuckTimeLeft;
+		public double ladyBugLuckTimeLeft;
 		public float luck;
 		public float luckMinimumCap = -0.7f;
 		public float luckMaximumCap = 1f;
@@ -2084,6 +_,7 @@
 		public void SetTalkNPC(int npcIndex, bool fromNet = false) {
 			talkNPC = npcIndex;
 			if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
+				// Gut feeling there is a to do on the above conditional
 				Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
 
 			if (talkNPC == -1)
@@ -2100,12 +_,12 @@
 			itemTimeMax = frames;
 		}
 
-		public void ApplyItemTime(Item sItem) {
-			SetItemTime(sItem.useTime);
-		}
+		public void ApplyItemTime(Item sItem, float multiplier = 1, bool? callUseItem = null) {
+			if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+				return;
 
-		public void ApplyItemTime(Item sItem, float multiplier) {
-			SetItemTime((int)((float)sItem.useTime * multiplier));
+			SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime * multiplier, this, sItem));
+			ItemUsesThisAnimation++;
 		}
 
 		public void SetDummyItemTime(int frames) {
@@ -2114,39 +_,44 @@
 			itemTimeMax = frames + 1;
 		}
 
-		private void SetItemAnimation(int frames) {
+		public void SetItemAnimation(int frames) {
 			itemAnimation = frames;
 			itemAnimationMax = frames;
 		}
 
-		private void ApplyItemAnimation(Item sItem, float multiplier, int itemReuseDelay = 0) {
-			SetItemAnimation((int)((float)sItem.useAnimation * multiplier));
-			reuseDelay = itemReuseDelay;
+		public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null) {
+			ItemLoader.UseAnimation(sItem, this);
+
+			SetItemAnimation(CombinedHooks.TotalAnimationTime(sItem.useAnimation * multiplier, this, sItem));
+
+			reuseDelay = (int)((itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
+			ItemUsesThisAnimation = 0;
 		}
 
-		private void ApplyItemAnimation(Item sItem) {
+		public void ApplyItemAnimation(Item sItem) {
+			/*
 			if (sItem.melee) {
-				SetItemAnimation((int)((float)sItem.useAnimation * meleeSpeed));
+				ApplyItemAnimation(sItem, meleeSpeed);
 				return;
 			}
 
 			if (sItem.summon && ItemID.Sets.SummonerWeaponThatScalesWithAttackSpeed[sItem.type]) {
-				SetItemAnimation((int)((float)sItem.useAnimation * meleeSpeed * whipUseTimeMultiplier));
+				ApplyItemAnimation(sItem, meleeSpeed * whipUseTimeMultiplier);
 				return;
 			}
+			*/
 
 			if (sItem.createTile >= 0) {
-				SetItemAnimation((int)((float)sItem.useAnimation * tileSpeed));
+				ApplyItemAnimation(sItem, tileSpeed);
 				return;
 			}
 
 			if (sItem.createWall >= 0) {
-				SetItemAnimation((int)((float)sItem.useAnimation * wallSpeed));
+				ApplyItemAnimation(sItem, wallSpeed);
 				return;
 			}
 
-			SetItemAnimation(sItem.useAnimation);
-			reuseDelay = sItem.reuseDelay;
+			ApplyItemAnimation(sItem, 1);
 		}
 
 		public bool InOpposingTeam(Player otherPlayer) {
@@ -2475,7 +_,9 @@
 				Main.guideItem.position = base.Center;
 				Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
 				if (item.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+					Main.item[num] = item.Clone();
 					Main.item[num].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num, 1f);
@@ -2488,7 +_,9 @@
 				Main.reforgeItem.position = base.Center;
 				Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
 				if (item2.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num2 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+					Main.item[num2] = item2.Clone();
 					Main.item[num2].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num2, 1f);
@@ -2523,7 +_,9 @@
 				Main.mouseItem.position = base.Center;
 				Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
 				if (item3.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num3 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+					Main.item[num3] = item3.Clone();
 					Main.item[num3].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num3, 1f);
@@ -2624,7 +_,7 @@
 			if (buffImmune[type])
 				return -1;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1 && buffType[i] == type)
 					return i;
 			}
@@ -2632,12 +_,19 @@
 			return -1;
 		}
 
+		/// <summary>
+		/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="BuffID"/> and modded buffs are typically retrieved using <see cref="ModContent.BuffType{T}"/>. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations, run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
+		/// </summary>
+		/// <param name="type">The buff type</param>
+		/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
+		/// <param name="quiet">If true, the network sync message is skipped.</param>
+		/// <param name="foodHack">unused</param>
 		public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false) {
 			if (buffImmune[type])
 				return;
 
 			if (BuffID.Sets.IsFedState[type]) {
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (BuffID.Sets.IsFedState[buffType[i]])
 						DelBuff(i);
 				}
@@ -2658,7 +_,7 @@
 			int num = -1;
 			while (num == -1) {
 				int num2 = -1;
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (!Main.debuff[buffType[i]]) {
 						num2 = i;
 						break;
@@ -2668,7 +_,7 @@
 				if (num2 == -1)
 					return false;
 
-				for (int j = num2; j < 22; j++) {
+				for (int j = num2; j < MaxBuffs; j++) {
 					if (buffType[j] == 0) {
 						num = j;
 						break;
@@ -2688,7 +_,7 @@
 			if (!Main.meleeBuff[type])
 				return;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type && Main.meleeBuff[buffType[i]]) {
 					DelBuff(i);
 					i--;
@@ -2698,7 +_,7 @@
 
 		private void AddBuff_RemoveOldPetBuffsOfMatchingType(int type) {
 			if (Main.lightPet[type]) {
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (Main.lightPet[buffType[i]])
 						DelBuff(i);
 				}
@@ -2707,7 +_,7 @@
 			if (!Main.vanityPet[type])
 				return;
 
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (Main.vanityPet[buffType[j]])
 					DelBuff(j);
 			}
@@ -2715,11 +_,13 @@
 
 		private bool AddBuff_TryUpdatingExistingBuffTime(int type, int time) {
 			bool result = false;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type)
 					continue;
 
+				if (BuffLoader.ReApply(type, this, time, i)) {
+				}
-				if (type == 94) {
+				else if (type == 94) {
 					buffTime[i] += time;
 					if (buffTime[i] > manaSickTimeMax)
 						buffTime[i] = manaSickTimeMax;
@@ -2737,7 +_,7 @@
 
 		private int AddBuff_DetermineBuffTimeToAdd(int type, int time1) {
 			int num = time1;
-			if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80)) {
+			if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type]) {
 				float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
 				if (Main.GameModeInfo.IsJourneyMode) {
 					if (Main.masterMode)
@@ -2752,27 +_,39 @@
 			return num;
 		}
 
+		/// <summary>
+		/// Removes the buff at the provided index and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.ClearBuff"/> if you only know the buff type
+		/// </summary>
+		/// <param name="b">The index of the buff to remove.</param>
 		public void DelBuff(int b) {
 			buffTime[b] = 0;
 			buffType[b] = 0;
+			//single pass compactor (vanilla is n^2)
+			int packedIdx = 0;
-			for (int i = 0; i < 21; i++) {
+			for (int i = 0; i < MaxBuffs - 1; i++) {
-				if (buffTime[i] != 0 && buffType[i] != 0)
+				if (buffTime[i] == 0 || buffType[i] == 0)
 					continue;
 
-				for (int j = i + 1; j < 22; j++) {
-					if (buffTime[j] > 0 && buffType[j] > 0) {
-						buffTime[i] = buffTime[j];
-						buffType[i] = buffType[j];
-						buffTime[j] = 0;
-						buffType[j] = 0;
-						break;
-					}
+				if (packedIdx < i) {
+					buffTime[packedIdx] = buffTime[i];
+					buffType[packedIdx] = buffType[i];
+					buffTime[i] = 0;
+					buffType[i] = 0;
 				}
+
+				packedIdx++;
 			}
 		}
 
+		/// <summary>
+		/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.DelBuff(int)"/> if you only know the buff index
+		/// </summary>
+		/// <param name="type">The buff type</param>
 		public void ClearBuff(int type) {
+			if (type == 0)
+				return;
+
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] == type)
 					DelBuff(i);
 			}
@@ -2780,7 +_,7 @@
 
 		public int CountBuffs() {
 			int num = 0;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[num] > 0)
 					num++;
 			}
@@ -2812,24 +_,29 @@
 				}
 			}
 
+			ItemLoader.UseItem(item, this);
+			int healLife = GetHealLife(item, true);
+			int healMana = GetHealMana(item, true);
-			statLife += item.healLife;
+			statLife += healLife;
-			statMana += item.healMana;
+			statMana += healMana;
 			if (statLife > statLifeMax2)
 				statLife = statLifeMax2;
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
 
-			if (item.healLife > 0 && Main.myPlayer == whoAmI)
-				HealEffect(item.healLife);
+			if (healLife > 0 && Main.myPlayer == whoAmI)
+				HealEffect(healLife, true);
 
-			if (item.healMana > 0) {
+			if (healMana > 0) {
 				AddBuff(94, manaSickTime);
 				if (Main.myPlayer == whoAmI)
-					ManaEffect(item.healMana);
+					ManaEffect(healMana);
 			}
 
+			if (ItemLoader.ConsumeItem(item, this))
-			item.stack--;
+				item.stack--;
+
 			if (item.stack <= 0)
 				item.TurnToAir();
 
@@ -2845,7 +_,10 @@
 				if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0)
 					continue;
 
-				int num3 = item.healLife - num;
+				if(!CombinedHooks.CanUseItem(this, item))
+					continue;
+
+				int num3 = GetHealLife(item, true) - num;
 				if (item.type == 227 && num3 < 0) {
 					num3 += 30;
 					if (num3 > 0)
@@ -2874,7 +_,7 @@
 			int num = 0;
 			while (true) {
 				if (num < 58) {
-					if (inventory[num].stack > 0 && inventory[num].type > 0 && inventory[num].healMana > 0 && (potionDelay == 0 || !inventory[num].potion))
+					if (inventory[num].stack > 0 && inventory[num].type > 0 && inventory[num].healMana > 0 && (potionDelay == 0 || !inventory[num].potion) && CombinedHooks.CanUseItem(this, inventory[num]))
 						break;
 
 					num++;
@@ -2900,24 +_,29 @@
 				}
 			}
 
-			statLife += inventory[num].healLife;
-			statMana += inventory[num].healMana;
+			ItemLoader.UseItem(inventory[num], this);
+			int healLife = GetHealLife(inventory[num], true);
+			int healMana = GetHealMana(inventory[num], true);
+			statLife += healLife;
+			statMana += healMana;
 			if (statLife > statLifeMax2)
 				statLife = statLifeMax2;
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
 
-			if (inventory[num].healLife > 0 && Main.myPlayer == whoAmI)
-				HealEffect(inventory[num].healLife);
+			if (healLife > 0 && Main.myPlayer == whoAmI)
+				HealEffect(healLife, true);
 
-			if (inventory[num].healMana > 0) {
+			if (healMana > 0) {
 				AddBuff(94, manaSickTime);
 				if (Main.myPlayer == whoAmI)
-					ManaEffect(inventory[num].healMana);
+					ManaEffect(healMana);
 			}
 
+			if (ItemLoader.ConsumeItem(inventory[num], this))
-			inventory[num].stack--;
+				inventory[num].stack--;
+
 			if (inventory[num].stack <= 0)
 				inventory[num].TurnToAir();
 
@@ -2926,7 +_,7 @@
 
 		public Item QuickMana_GetItemToUse() {
 			for (int i = 0; i < 58; i++) {
-				if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion))
+				if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion) && CombinedHooks.CanUseItem(this, inventory[i]))
 					return inventory[i];
 			}
 
@@ -2937,8 +_,8 @@
 			if (cursed || CCed || dead)
 				return;
 
-			LegacySoundStyle legacySoundStyle = null;
+			SoundStyle? legacySoundStyle = null;
-			if (CountBuffs() == 22)
+			if (CountBuffs() == MaxBuffs)
 				return;
 
 			Item item = QuickBuff_PickBestFoodItem();
@@ -2949,22 +_,26 @@
 					num = 3600;
 
 				AddBuff(item.buffType, num);
-				if (item.consumable) {
+				if (item.consumable && ItemLoader.ConsumeItem(item, this)) {
 					item.stack--;
 					if (item.stack <= 0)
 						item.TurnToAir();
 				}
 			}
 
-			if (CountBuffs() != 22) {
+			if (CountBuffs() != MaxBuffs) {
 				for (int i = 0; i < 58; i++) {
 					Item item2 = inventory[i];
 					if (item2.stack <= 0 || item2.type <= 0 || item2.buffType <= 0 || item2.summon)
 						continue;
 
 					int num2 = item2.buffType;
-					bool flag = QuickBuff_ShouldBotherUsingThisBuff(num2);
+					bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num2);
 					if (item2.mana > 0 && flag) {
+						if (CheckMana(item2, -1, true, true))
+							manaRegenDelay = (int)maxRegenDelay;
+
+						goto SkipManaCode;
 						if (statMana >= (int)((float)item2.mana * manaCost)) {
 							manaRegenDelay = (int)maxRegenDelay;
 							statMana -= (int)((float)item2.mana * manaCost);
@@ -2974,6 +_,7 @@
 						}
 					}
 
+					SkipManaCode:
 					if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
 						flag = false;
 
@@ -2992,19 +_,21 @@
 					if (!flag)
 						continue;
 
+					ItemLoader.UseItem(item2, this);
 					legacySoundStyle = item2.UseSound;
 					int num3 = item2.buffTime;
 					if (num3 == 0)
 						num3 = 3600;
 
 					AddBuff(num2, num3);
-					if (item2.consumable) {
+					if (item2.consumable && ItemLoader.ConsumeItem(item2, this)) {
 						item2.stack--;
+
 						if (item2.stack <= 0)
 							item2.TurnToAir();
 					}
 
-					if (CountBuffs() == 22)
+					if (CountBuffs() == MaxBuffs)
 						break;
 				}
 			}
@@ -3018,7 +_,7 @@
 		private Item QuickBuff_PickBestFoodItem() {
 			int num = 0;
 			Item item = null;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1) {
 					int num2 = QuickBuff_FindFoodPriority(buffType[i]);
 					if (num <= num2)
@@ -3055,7 +_,7 @@
 
 		private bool QuickBuff_ShouldBotherUsingThisBuff(int attemptedType) {
 			bool result = true;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (attemptedType == 27 && (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102)) {
 					result = false;
 					break;
@@ -3078,7 +_,7 @@
 			}
 
 			if (Main.lightPet[attemptedType] || Main.vanityPet[attemptedType]) {
-				for (int j = 0; j < 22; j++) {
+				for (int j = 0; j < MaxBuffs; j++) {
 					if (Main.lightPet[buffType[j]] && Main.lightPet[attemptedType])
 						result = false;
 
@@ -3102,6 +_,7 @@
 				if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this)) {
 					if (!QuickMinecartSnap()) {
 						mount.SetMount(item.mountType, this);
+						ItemLoader.UseItem(item, this);
 						if (item.UseSound != null)
 							SoundEngine.PlaySound(item.UseSound, base.Center);
 					}
@@ -3173,12 +_,12 @@
 
 		public Item QuickMount_GetItemToUse() {
 			Item item = null;
-			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
+			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType] && CombinedHooks.CanUseItem(this, miscEquips[3]))
 				item = miscEquips[3];
 
 			if (item == null) {
 				for (int i = 0; i < 58; i++) {
-					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType]) {
+					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType] && CombinedHooks.CanUseItem(this, inventory[i])) {
 						item = inventory[i];
 						break;
 					}
@@ -3238,7 +_,12 @@
 			if (item == null)
 				return;
 
+			bool? modCanGrapple = ProjectileLoader.CanUseGrapple(item.shoot, this);
+			if (modCanGrapple.HasValue) {
+				if (!modCanGrapple.Value)
+					item = null;
+			}
-			if (item.shoot == 73) {
+			else if (item.shoot == 73) {
 				int num2 = 0;
 				for (int i = 0; i < 1000; i++) {
 					if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && (Main.projectile[i].type == 73 || Main.projectile[i].type == 74))
@@ -3313,11 +_,21 @@
 			float shootSpeed = item.shootSpeed;
 			int damage = item.damage;
 			float knockBack = item.knockBack;
+			bool? modSingleHook = ProjectileLoader.SingleGrappleHook(num7, this);
+			bool modSingleHookFalse = modSingleHook.HasValue ? !modSingleHook.Value : false;
+			bool modSingleHookTrue = modSingleHook.HasValue ? modSingleHook.Value : false;
-			if (num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935) {
+			if ((num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935 || modSingleHookTrue) && !modSingleHookFalse) {
 				grappling[0] = -1;
 				grapCount = 0;
 				for (int num8 = 0; num8 < 1000; num8++) {
 					if (Main.projectile[num8].active && Main.projectile[num8].owner == whoAmI) {
+						bool? modSingleHook2 = ProjectileLoader.SingleGrappleHook(Main.projectile[num8].type, this);
+						if(modSingleHook2.HasValue) {
+							if (modSingleHook2.Value)
+								Main.projectile[num8].Kill();
+							continue;
+						}
+
 						switch (Main.projectile[num8].type) {
 							case 13:
 							case 230:
@@ -3409,6 +_,8 @@
 				}
 			}
 
+			ProjectileLoader.UseGrapple(this, ref num7);
+
 			Vector2 vector = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 			float num21 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
 			float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
@@ -3763,7 +_,7 @@
 			}
 
 			if (!crystalLeaf || petalTimer != 0)
-				return;
+				goto End;
 
 			_ = inventory[selectedItem].type;
 			int num5 = 0;
@@ -3776,7 +_,7 @@
 					continue;
 				}
 
-				return;
+				goto End;
 			}
 
 			petalTimer = 50;
@@ -3788,9 +_,22 @@
 			num6 *= num8;
 			num7 *= num8;
 			Projectile.NewProjectile(GetProjectileSource_SetBonus(6), Main.projectile[num5].Center.X - 4f, Main.projectile[num5].Center.Y, num6, num7, 227, crystalLeafDamage, crystalLeafKB, whoAmI);
+
+			End:
+
+			PlayerLoader.OnHitAnything(this, x, y, victim);
 		}
 
 		public void OpenPresent(int itemType) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("present", this, itemType))
+				return;
+
+			DropFromItem(itemType);
+
+			ItemLoader.OpenVanillaBag_Obsolete("present", this, itemType);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 			if (Main.rand.Next(15) == 0 && Main.hardMode) {
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 602);
@@ -4009,21 +_,42 @@
 					}
 				default: {
 						int number21 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 591, Main.rand.Next(20, 50));
+						// Extra patch context for the below.
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, number21, 1f);
 
 						break;
 					}
 			}
+			*/
 		}
 
+		// Return value added by TML.
-		public void QuickSpawnItem(IEntitySource source, int item, int stack = 1) {
+		public int QuickSpawnItem(IEntitySource source, int item, int stack = 1) {
 			int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
+
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
+
+			return number;
 		}
 
 		public void OpenBossBag(int type) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("bossBag", this, type))
+				return;
+
+			DropFromItem(type);
+
+			ItemLoader.OpenBossBag_Obsolete(type, this);
+			ItemLoader.OpenVanillaBag_Obsolete("bossBag", this, type);
+
+			if ((!ItemID.Sets.PreHardmodeLikeBossBag[type] || Main.tenthAnniversaryWorld)) {
+				TryGettingDevArmor(GetItemSource_OpenItem(type));
+			}
+
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(type);
 			switch (type) {
 				case 3318: {
@@ -4560,15 +_,19 @@
 				}
 
 				int num15 = (int)value;
+				// Extra patch context for the below.
 				if (num15 < 1)
 					num15 = 1;
 
 				value -= (float)num15;
 				QuickSpawnItem(itemSource_OpenItem, 71, num15);
 			}
+			*/
 		}
 
-		private void TryGettingDevArmor(IEntitySource source) {
+		public void TryGettingDevArmor(IEntitySource source) {
+			ModLoader.Default.ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
+
 			if (Main.rand.Next(Main.tenthAnniversaryWorld ? 10 : 20) == 0) {
 				switch (Main.rand.Next(18)) {
 					case 0:
@@ -4689,6 +_,15 @@
 		}
 
 		public void OpenFishingCrate(int crateItemID) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("crate", this, crateItemID))
+				return;
+
+			DropFromItem(crateItemID);
+
+			ItemLoader.OpenVanillaBag_Obsolete("crate", this, crateItemID);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(crateItemID);
 			bool flag = ItemID.Sets.IsFishingCrateHardmode[crateItemID];
 			switch (crateItemID) {
@@ -5974,10 +_,12 @@
 						break;
 				}
 
+				// Extra patch context for the below.
 				int number66 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, type44, stack41);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number66, 1f);
 			}
+			*/
 		}
 
 		public int CountItem(int type, int stopCountingAt = 0) {
@@ -6005,7 +_,9 @@
 
 			for (int i = num; i != num2; i += num3) {
 				if (inventory[i].stack > 0 && inventory[i].type == type) {
+					if (ItemLoader.ConsumeItem(inventory[i], this))
-					inventory[i].stack--;
+						inventory[i].stack--;
+
 					if (inventory[i].stack <= 0)
 						inventory[i].SetDefaults();
 
@@ -6017,6 +_,15 @@
 		}
 
 		public void OpenShadowLockbox(int boxType) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("obsidianLockBox", this, boxType))
+				return;
+
+			DropFromItem(boxType);
+
+			ItemLoader.OpenVanillaBag_Obsolete("obsidianLockBox", this, boxType);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			bool flag = true;
 			while (flag) {
 				flag = false;
@@ -6042,13 +_,24 @@
 						break;
 				}
 
+				// Extra patch context for the below.
 				int number = Item.NewItem(GetItemSource_OpenItem(boxType), (int)position.X, (int)position.Y, width, height, num, 1, noBroadcast: false, -1);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
 		public void OpenLockBox(int lockboxItemType) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("lockBox", this, lockboxItemType))
+				return;
+
+			DropFromItem(lockboxItemType);
+
+			ItemLoader.OpenVanillaBag_Obsolete("lockBox", this, lockboxItemType);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			bool flag = true;
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(lockboxItemType);
 			while (flag) {
@@ -6082,15 +_,26 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 
+				// Extra patch context for the below.
 				if (Main.rand.Next(3) == 0) {
 					int number2 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 329, 1, noBroadcast: false, -1);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number2, 1f);
 				}
 			}
+			*/
 		}
 
 		public void OpenHerbBag(int bagType) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("herbBag", this, bagType))
+				return;
+
+			DropFromItem(bagType);
+
+			ItemLoader.OpenVanillaBag_Obsolete("herbBag", this, bagType);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(bagType);
 			int num = Main.rand.Next(2, 5);
 			if (Main.rand.Next(3) == 0)
@@ -6144,20 +_,27 @@
 				if (Main.rand.Next(3) == 0)
 					num3 += Main.rand.Next(1, 5);
 
+				// Extra patch context for the below.
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, num2, num3);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
 		public void OpenCanofWorms(int sourceItemType) {
+			DropFromItem(sourceItemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 			QuickSpawnItem(itemSource_OpenItem, 2002, Main.rand.Next(5, 9));
 			if (Main.rand.Next(10) < 3)
 				QuickSpawnItem(itemSource_OpenItem, 3191, Main.rand.Next(1, 3));
 
+			// Extra patch context.
 			if (Main.rand.Next(20) == 0)
 				QuickSpawnItem(itemSource_OpenItem, 2895);
+			*/
 		}
 
 		public void OpenCapricornTail(int sourceItemType) {
@@ -6169,6 +_,9 @@
 		}
 
 		public void OpenOyster(int sourceItemType) {
+			DropFromItem(sourceItemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 			if (Main.rand.Next(5) == 0) {
 				if (Main.rand.Next(15) == 0)
@@ -6177,12 +_,23 @@
 					QuickSpawnItem(itemSource_OpenItem, 4413);
 				else
 					QuickSpawnItem(itemSource_OpenItem, 4412);
+				// Extra patch context for the below.
 			}
 
 			QuickSpawnItem(itemSource_OpenItem, 4411);
+			*/
 		}
 
 		public void OpenGoodieBag(int itemType) {
+			if (!ItemLoader.PreOpenVanillaBag_Obsolete("goodieBag", this, itemType))
+				return;
+
+			DropFromItem(itemType);
+
+			ItemLoader.OpenVanillaBag_Obsolete("goodieBag", this, itemType);
+			NPCLoader.blockLoot.Clear();
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 			if (Main.rand.Next(150) == 0) {
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1810);
@@ -6463,17 +_,22 @@
 						int number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1851);
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, number5, 1f);
+						// Extra patch context for the below.
 
 						number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1852);
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, number5, 1f);
 
+						// Extra patch context for the below.
 						break;
 					}
 			}
+			*/
 		}
 
 		public void UpdateDyes() {
+			// Extra patch context for the above.
+
 			cShieldFallback = -1;
 			cHead = (cBody = (cLegs = (cHandOn = (cHandOff = (cBack = (cFront = (cShoe = (cWaist = (cShield = (cNeck = (cFace = (cFaceHead = (cFaceFlower = (cBalloon = (cBalloon = (cWings = (cCarpet = (cFloatingTube = (cBackpack = (cTail = 0))))))))))))))))))));
 			cGrapple = (cMount = (cMinecart = (cPet = (cLight = (cYorai = (cPortalbeStool = (cUnicornHorn = (cAngelHalo = (cBeard = (cMinion = (cLeinShampoo = 0)))))))))));
@@ -6495,11 +_,12 @@
 					UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
 				}
 			}
+			PlayerLoader.UpdateDyes(this);
 
 			cYorai = cPet;
 		}
 
-		private void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem) {
+		internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem) {
 			if (armorItem.IsAir)
 				return;
 
@@ -6511,13 +_,13 @@
 			if (!num && flag)
 				return;
 
-			if (armorItem.handOnSlot > 0 && armorItem.handOnSlot < 23)
+			if (armorItem.handOnSlot > 0)
 				cHandOn = dyeItem.dye;
 
-			if (armorItem.handOffSlot > 0 && armorItem.handOffSlot < 15)
+			if (armorItem.handOffSlot > 0)
 				cHandOff = dyeItem.dye;
 
-			if (armorItem.backSlot > 0 && armorItem.backSlot < 35) {
+			if (armorItem.backSlot > 0) {
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
 					cBackpack = dyeItem.dye;
 				else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
@@ -6526,22 +_,22 @@
 					cBack = dyeItem.dye;
 			}
 
-			if (armorItem.frontSlot > 0 && armorItem.frontSlot < 12)
+			if (armorItem.frontSlot > 0)
 				cFront = dyeItem.dye;
 
-			if (armorItem.shoeSlot > 0 && armorItem.shoeSlot < 27)
+			if (armorItem.shoeSlot > 0)
 				cShoe = dyeItem.dye;
 
-			if (armorItem.waistSlot > 0 && armorItem.waistSlot < 17)
+			if (armorItem.waistSlot > 0)
 				cWaist = dyeItem.dye;
 
-			if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < 10)
+			if (armorItem.shieldSlot > 0)
 				cShield = dyeItem.dye;
 
-			if (armorItem.neckSlot > 0 && armorItem.neckSlot < 12)
+			if (armorItem.neckSlot > 0)
 				cNeck = dyeItem.dye;
 
-			if (armorItem.faceSlot > 0 && armorItem.faceSlot < 20) {
+			if (armorItem.faceSlot > 0) {
 				if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
 					cFaceHead = dyeItem.dye;
 				else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
@@ -6550,17 +_,17 @@
 					cFace = dyeItem.dye;
 			}
 
-			if (armorItem.beardSlot > 0 && armorItem.beardSlot < 5)
+			if (armorItem.beardSlot > 0)
 				cBeard = dyeItem.dye;
 
-			if (armorItem.balloonSlot > 0 && armorItem.balloonSlot < 19) {
+			if (armorItem.balloonSlot > 0) {
 				if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
 					cBalloonFront = dyeItem.dye;
 				else
 					cBalloon = dyeItem.dye;
 			}
 
-			if (armorItem.wingSlot > 0 && armorItem.wingSlot < 47)
+			if (armorItem.wingSlot > 0)
 				cWings = dyeItem.dye;
 
 			if (armorItem.type == 934)
@@ -6598,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public IEntitySource GetProjectileSource_Buff(int buffIndex) {
 			int buffId = buffType[buffIndex];
 			return new EntitySource_Buff(this, buffId, buffIndex);
@@ -6617,21 +_,51 @@
 		public IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 		public IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 		public IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => new EntitySource_OnHit_ByItemSourceID(this, victim, itemSourceId);
+		*/
+
+		// Internal redirects:
+		internal IEntitySource GetProjectileSource_Buff(int buffIndex) => GetSource_Buff(buffIndex);
+		internal IEntitySource GetProjectileSource_Item(Item item) => GetSource_ItemUse(item);
+		internal IEntitySource GetItemSource_OpenItem(int itemType) => GetSource_OpenItem(itemType);
+		internal IEntitySource GetItemSource_Death() => GetSource_Death();
+		internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId) => GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
+		internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => GetSource_OnHit(victim, context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId) => GetSource_OnHurt(attacker, context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_Accessory(Item item) => GetSource_Accessory(item);
+		internal IEntitySource GetProjectileSource_Misc(int projectileSourceId) => GetSource_Misc(context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => GetSource_OnHit(victim, context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId) => GetSource_FromThis(context: ProjectileSourceID.ToContextString(projectileSourceId));
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   Player.TML.Sources.cs (if exists);
 
 		public void UpdateBuffs(int i) {
+			/*
+			tML:
+			all accessories that previously used each class-specific crit field individually now use allCrit instead where appropriate
+			this allows them to automagically account for new classes, preventin' modders from havin' to do extra work for no reason
+			- thomas
+			*/
 			if (soulDrain > 0 && whoAmI == Main.myPlayer)
 				AddBuff(151, 2);
 
 			if (Main.dontStarveWorld)
 				UpdateStarvingState(withEmote: true);
 
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (buffType[j] <= 0 || buffTime[j] <= 0)
 					continue;
 
 				if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
 					buffTime[j]--;
 
+				int originalIndex = j;
+
 				if (buffType[j] == 1) {
 					lavaImmune = true;
 					fireWalk = true;
@@ -6645,18 +_,31 @@
 				else if (buffType[j] == 158) {
 					manaRegenBonus += 2;
 				}
+				/*
 				else if (buffType[j] == 159 && inventory[selectedItem].melee) {
 					armorPenetration = 12;
 				}
+
+				tML:
+				commented out in favor of the below check for solely the Sharpening Station buff
+				this fixes the Sharpening Station's armor penetration bonus bein' able to be applied to non-melee weapons (most notably summons) by holdin' a melee weapon
+				- thomas
+				*/
+				else if (buffType[j] == 159) {
+					GetArmorPenetration(DamageClass.Melee) += 12;
+				}
 				else if (buffType[j] == 192) {
 					pickSpeed -= 0.2f;
 					moveSpeed += 0.2f;
 				}
 				else if (buffType[j] == 321) {
 					int num = 10;
+					allCrit += num;
+					/*
 					meleeCrit += num;
 					rangedCrit += num;
 					magicCrit += num;
+					*/
 					minionDamage += (float)num / 100f;
 				}
 				else if (buffType[j] == 2) {
@@ -6704,6 +_,7 @@
 				}
 				else if (buffType[j] == 16) {
 					archery = true;
+					arrowDamage *= 1.2f; // moved from PickAmmo, as StatModifier allows multiplicative buffs to be 'registered' alongside additive ones
 				}
 				else if (buffType[j] == 17) {
 					detectCreature = true;
@@ -6828,9 +_,12 @@
 					endurance += 0.1f;
 				}
 				else if (buffType[j] == 115) {
+					allCrit += 10;
+					/*
 					meleeCrit += 10;
 					rangedCrit += 10;
 					magicCrit += 10;
+					*/
 				}
 				else if (buffType[j] == 116) {
 					inferno = true;
@@ -6874,10 +_,13 @@
 					}
 				}
 				else if (buffType[j] == 117) {
+					allDamage += 0.1f;
+					/*
 					meleeDamage += 0.1f;
 					rangedDamage += 0.1f;
 					magicDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 				}
 				else if (buffType[j] == 119) {
 					loveStruck = true;
@@ -6922,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int m = 0; m < 22; m++) {
+							for (int m = 0; m < MaxBuffs; m++) {
 								if (buffType[m] >= 95 && buffType[m] <= 95 + num4 - 1) {
 									DelBuff(m);
 									m--;
@@ -6950,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int n = 0; n < 22; n++) {
+							for (int n = 0; n < MaxBuffs; n++) {
 								if (buffType[n] >= 170 && buffType[n] <= 170 + num5 - 1) {
 									DelBuff(n);
 									n--;
@@ -6974,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num7 = 0; num7 < 22; num7++) {
+							for (int num7 = 0; num7 < MaxBuffs; num7++) {
 								if (buffType[num7] >= 98 && buffType[num7] <= 98 + num6 - 1) {
 									DelBuff(num7);
 									num7--;
@@ -7004,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num10 = 0; num10 < 22; num10++) {
+							for (int num10 = 0; num10 < MaxBuffs; num10++) {
 								if (buffType[num10] >= 176 && buffType[num10] <= 178 + num9 - 1) {
 									DelBuff(num10);
 									num10--;
@@ -7029,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num13 = 0; num13 < 22; num13++) {
+							for (int num13 = 0; num13 < MaxBuffs; num13++) {
 								if (buffType[num13] >= 173 && buffType[num13] <= 175 + num12 - 1) {
 									DelBuff(num13);
 									num13--;
@@ -7056,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num16 = 0; num16 < 22; num16++) {
+							for (int num16 = 0; num16 < MaxBuffs; num16++) {
 								if (buffType[num16] >= 179 && buffType[num16] <= 181 + num15 - 1) {
 									DelBuff(num16);
 									num16--;
@@ -7073,10 +_,13 @@
 					}
 
 					float num17 = 0.15f * (float)nebulaLevelDamage;
+					allDamage += num17;
+					/*
 					meleeDamage += num17;
 					rangedDamage += num17;
 					magicDamage += num17;
 					minionDamage += num17;
+					*/
 				}
 				else if (buffType[j] == 62) {
 					if ((double)statLife <= (double)statLifeMax2 * 0.5) {
@@ -7741,10 +_,13 @@
 						}
 					}
 
+					allDamage += 0.2f;
+					/*
 					meleeDamage += 0.2f;
 					magicDamage += 0.2f;
 					rangedDamage += 0.2f;
 					minionDamage += 0.2f;
+					*/
 				}
 				else if (buffType[j] == 41) {
 					buffTime[j] = 18000;
@@ -8130,14 +_,20 @@
 				else if (buffType[j] == 26) {
 					wellFed = true;
 					statDefense += 2;
+					allCrit += 2;
+					allDamage += 0.05f;
+					/*
 					meleeCrit += 2;
 					meleeDamage += 0.05f;
+					*/
 					meleeSpeed += 0.05f;
+					/*
 					magicCrit += 2;
 					magicDamage += 0.05f;
 					rangedCrit += 2;
 					rangedDamage += 0.05f;
 					minionDamage += 0.05f;
+					*/
 					minionKB += 0.5f;
 					moveSpeed += 0.2f;
 					pickSpeed -= 0.05f;
@@ -8145,14 +_,20 @@
 				else if (buffType[j] == 206) {
 					wellFed = true;
 					statDefense += 3;
+					allCrit += 3;
+					allDamage += 0.075f;
+					/*
 					meleeCrit += 3;
 					meleeDamage += 0.075f;
+					*/
 					meleeSpeed += 0.075f;
+					/*
 					magicCrit += 3;
 					magicDamage += 0.075f;
 					rangedCrit += 3;
 					rangedDamage += 0.075f;
 					minionDamage += 0.075f;
+					*/
 					minionKB += 0.75f;
 					moveSpeed += 0.3f;
 					pickSpeed -= 0.1f;
@@ -8160,14 +_,18 @@
 				else if (buffType[j] == 207) {
 					wellFed = true;
 					statDefense += 4;
+					//meleeCrit += 4;
-					meleeCrit += 4;
+					allCrit += 4;
-					meleeDamage += 0.1f;
+					allDamage += 0.1f;
+					//meleeDamage += 0.1f;
 					meleeSpeed += 0.1f;
+					/*
 					magicCrit += 4;
 					magicDamage += 0.1f;
 					rangedCrit += 4;
 					rangedDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 					minionKB += 1f;
 					moveSpeed += 0.4f;
 					pickSpeed -= 0.15f;
@@ -8175,28 +_,40 @@
 				else if (buffType[j] == 333) {
 					hungry = true;
 					statDefense -= 2;
+					allCrit -= 2;
+					allDamage -= 0.05f;
+					/*
 					meleeCrit -= 2;
 					meleeDamage -= 0.05f;
+					*/
 					meleeSpeed -= 0.05f;
+					/*
 					magicCrit -= 2;
 					magicDamage -= 0.05f;
 					rangedCrit -= 2;
 					rangedDamage -= 0.05f;
 					minionDamage -= 0.05f;
+					*/
 					minionKB -= 0.5f;
 					pickSpeed += 0.05f;
 				}
 				else if (buffType[j] == 334) {
 					starving = true;
 					statDefense -= 4;
+					allCrit -= 4;
+					allDamage -= 0.1f;
+					/*
 					meleeCrit -= 4;
 					meleeDamage -= 0.1f;
+					*/
 					meleeSpeed -= 0.1f;
+					/*
 					magicCrit -= 4;
 					magicDamage -= 0.1f;
 					rangedCrit -= 4;
 					rangedDamage -= 0.1f;
 					minionDamage -= 0.1f;
+					*/
 					minionKB -= 1f;
 					pickSpeed += 0.15f;
 				}
@@ -8227,6 +_,8 @@
 				else if (buffType[j] == 79) {
 					meleeEnchant = 8;
 				}
+				if (j == originalIndex)
+					BuffLoader.Update(buffType[j], this, ref j);
 			}
 
 			UpdateHungerBuffs();
@@ -8237,7 +_,7 @@
 		}
 
 		public void UpdateHungerBuffs() {
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] <= 0 || buffTime[i] <= 0)
 					continue;
 
@@ -8270,7 +_,7 @@
 				return;
 
 			bool flag = false;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] > 0 && BuffID.Sets.IsFedState[buffType[i]]) {
 					flag = true;
 					break;
@@ -8577,12 +_,19 @@
 			}
 		}
 
-		public void UpdateEquips(int i) {
+		//public void UpdateEquips(int i) {
+		public void VanillaPreUpdateInventory() {
 			if (inventory[selectedItem].type == 277 && (!mount.Active || !mount.Cart))
 				trident = true;
+		}
 
+		public void VanillaUpdateInventory(Item item) {
+			/*
 			for (int j = 0; j < 58; j++) {
 				int type = inventory[j].type;
+			*/
+			{
+				int type = item.type;
 				if ((type == 15 || type == 707) && accWatch < 1)
 					accWatch = 1;
 
@@ -8657,13 +_,21 @@
 
 				if (type == 4743)
 					hasFootball = true;
+
+				ItemLoader.UpdateInventory(item, this);
 			}
 
+		}
+
+		public void VanillaPostUpdateInventory() {
 			if (inventory[58].type == 4743)
 				hasFootball = true;
+		}
 
+		public void VanillaUpdateEquip(Item item) {
+			Item[] armor = {item};
-			for (int k = 0; k < 10; k++) {
+			for (int k = 0; k < 1; k++) {
-				if (!IsAValidEquipmentSlotForIteration(k) || (armor[k].expertOnly && !Main.expertMode))
+				if ((armor[k].expertOnly && !Main.expertMode) || (armor[k].masterOnly && !Main.masterMode))
 					continue;
 
 				int type2 = armor[k].type;
@@ -8888,6 +_,9 @@
 					armorPenetration += 5;
 
 				if (armor[k].type == 2277) {
+					allDamage += 0.05f;
+					allCrit += 5;
+					/*
 					magicDamage += 0.05f;
 					meleeDamage += 0.05f;
 					rangedDamage += 0.05f;
@@ -8895,6 +_,7 @@
 					magicCrit += 5;
 					rangedCrit += 5;
 					meleeCrit += 5;
+					*/
 					meleeSpeed += 0.1f;
 					moveSpeed += 0.1f;
 				}
@@ -8909,9 +_,12 @@
 					nightVision = true;
 
 				if (armor[k].type == 256 || armor[k].type == 257 || armor[k].type == 258) {
+					allCrit += 3;
+					/*
 					rangedCrit += 3;
 					meleeCrit += 3;
 					magicCrit += 3;
+					*/
 				}
 
 				if (armor[k].type == 3374)
@@ -8956,10 +_,13 @@
 					meleeSpeed += 0.07f;
 
 				if (armor[k].type == 792 || armor[k].type == 793 || armor[k].type == 794) {
+					allDamage += 0.02f;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
+					*/
 				}
 
 				if (armor[k].type == 231)
@@ -8988,16 +_,22 @@
 				}
 
 				if (armor[k].type == 374) {
+					allCrit += 5;
+					/*
 					magicCrit += 5;
 					meleeCrit += 5;
 					rangedCrit += 5;
+					*/
 				}
 
 				if (armor[k].type == 375) {
+					allDamage += 0.03f;
+					/*
 					rangedDamage += 0.03f;
 					meleeDamage += 0.03f;
 					magicDamage += 0.03f;
 					minionDamage += 0.03f;
+					*/
 					moveSpeed += 0.1f;
 				}
 
@@ -9017,16 +_,22 @@
 				}
 
 				if (armor[k].type == 379) {
+					allDamage += 0.07f;
+					/*
 					rangedDamage += 0.07f;
 					meleeDamage += 0.07f;
 					magicDamage += 0.07f;
 					minionDamage += 0.07f;
+					*/
 				}
 
 				if (armor[k].type == 380) {
+					allCrit += 10;
+					/*
 					magicCrit += 10;
 					meleeCrit += 10;
 					rangedCrit += 10;
+					*/
 				}
 
 				if (armor[k].type >= 2367 && armor[k].type <= 2369)
@@ -9049,16 +_,22 @@
 				}
 
 				if (armor[k].type == 403) {
+					allDamage += 0.08f;
+					/*
 					rangedDamage += 0.08f;
 					meleeDamage += 0.08f;
 					magicDamage += 0.08f;
 					minionDamage += 0.08f;
+					*/
 				}
 
 				if (armor[k].type == 404) {
+					allCrit += 7;
+					/*
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 					moveSpeed += 0.05f;
 				}
 
@@ -9079,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1208) {
+					allDamage += 0.03f;
+					allCrit += 2;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
@@ -9086,16 +_,21 @@
 					magicCrit += 2;
 					meleeCrit += 2;
 					rangedCrit += 2;
+					*/
 				}
 
 				if (armor[k].type == 1209) {
+					allDamage += 0.02f;
+					allCrit += 1;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
-					magicCrit++;
-					meleeCrit++;
-					rangedCrit++;
+					magicCrit += 1;
+					meleeCrit += 1;
+					rangedCrit += 1;
+					*/
 				}
 
 				if (armor[k].type == 1210) {
@@ -9115,9 +_,12 @@
 				}
 
 				if (armor[k].type == 1213) {
+					allCrit += 6;
+					/*
 					magicCrit += 6;
 					meleeCrit += 6;
 					rangedCrit += 6;
+					*/
 				}
 
 				if (armor[k].type == 1214)
@@ -9141,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1218) {
+					allDamage += 0.04f;
+					allCrit += 3;
+					/*
 					meleeDamage += 0.04f;
 					rangedDamage += 0.04f;
 					magicDamage += 0.04f;
@@ -9148,9 +_,13 @@
 					magicCrit += 3;
 					meleeCrit += 3;
 					rangedCrit += 3;
+					*/
 				}
 
 				if (armor[k].type == 1219) {
+					allDamage += 0.03f;
+					allCrit += 3;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
@@ -9158,6 +_,7 @@
 					magicCrit += 3;
 					meleeCrit += 3;
 					rangedCrit += 3;
+					*/
 					moveSpeed += 0.06f;
 				}
 
@@ -9184,31 +_,43 @@
 				}
 
 				if (armor[k].type == 551 || armor[k].type == 4900) {
+					allCrit += 7;
+					/*
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 				}
 
 				if (armor[k].type == 552 || armor[k].type == 4901) {
+					allDamage += 0.07f;
+					/*
 					rangedDamage += 0.07f;
 					meleeDamage += 0.07f;
 					magicDamage += 0.07f;
 					minionDamage += 0.07f;
+					*/
 					moveSpeed += 0.08f;
 				}
 
 				if (armor[k].type == 4982) {
+					allCrit += 5;
+					/*
 					rangedCrit += 5;
 					meleeCrit += 5;
 					magicCrit += 5;
+					*/
 					manaCost -= 0.1f;
 				}
 
 				if (armor[k].type == 4983) {
+					allDamage += 0.05f;
+					/*
 					rangedDamage += 0.05f;
 					meleeDamage += 0.05f;
 					magicDamage += 0.05f;
 					minionDamage += 0.05f;
+					*/
 					huntressAmmoCost90 = true;
 				}
 
@@ -9234,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1004) {
+					allDamage += 0.05f;
+					allCrit += 7;
+					/*
 					meleeDamage += 0.05f;
 					magicDamage += 0.05f;
 					rangedDamage += 0.05f;
@@ -9241,12 +_,16 @@
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 				}
 
 				if (armor[k].type == 1005) {
+					allCrit += 8;
+					/*
 					magicCrit += 8;
 					meleeCrit += 8;
 					rangedCrit += 8;
+					*/
 					moveSpeed += 0.05f;
 				}
 
@@ -9269,17 +_,17 @@
 
 				if (armor[k].type == 1546) {
 					rangedCrit += 5;
-					arrowDamage += 0.15f;
+					arrowDamage *= 1.15f; // tML += -> *= to imitate vanilla stacking behaviour
 				}
 
 				if (armor[k].type == 1547) {
 					rangedCrit += 5;
-					bulletDamage += 0.15f;
+					bulletDamage *= 1.15f; // tML += -> *= to imitate vanilla stacking behaviour
 				}
 
 				if (armor[k].type == 1548) {
 					rangedCrit += 5;
-					rocketDamage += 0.15f;
+					rocketDamage *= 1.15f; // tML += -> *= to imitate vanilla stacking behaviour
 				}
 
 				if (armor[k].type == 1549) {
@@ -9514,43 +_,61 @@
 					statManaMax2 += 20;
 
 				if (armor[k].prefix == 67) {
+					allCrit += 2;
+					/*
 					meleeCrit += 2;
 					rangedCrit += 2;
 					magicCrit += 2;
+					*/
 				}
 
 				if (armor[k].prefix == 68) {
+					allCrit += 4;
+					/*
 					meleeCrit += 4;
 					rangedCrit += 4;
 					magicCrit += 4;
+					*/
 				}
 
 				if (armor[k].prefix == 69) {
+					allDamage += 0.01f;
+					/*
 					meleeDamage += 0.01f;
 					rangedDamage += 0.01f;
 					magicDamage += 0.01f;
 					minionDamage += 0.01f;
+					*/
 				}
 
 				if (armor[k].prefix == 70) {
+					allDamage += 0.02f;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
+					*/
 				}
 
 				if (armor[k].prefix == 71) {
+					allDamage += 0.03f;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
 					minionDamage += 0.03f;
+					*/
 				}
 
 				if (armor[k].prefix == 72) {
+					allDamage += 0.04f;
+					/*
 					meleeDamage += 0.04f;
 					rangedDamage += 0.04f;
 					magicDamage += 0.04f;
 					minionDamage += 0.04f;
+					*/
 				}
 
 				if (armor[k].prefix == 73)
@@ -9576,6 +_,22 @@
 
 				if (armor[k].prefix == 80)
 					meleeSpeed += 0.04f;
+
+				ItemLoader.UpdateEquip(armor[k], this);
+			}
+		}
+
+		public void UpdateEquips(int i)
+		{
+			VanillaPreUpdateInventory();
+			for (int j = 0; j < 58; j++) {
+				VanillaUpdateInventory(inventory[j]);
+			}
+			VanillaPostUpdateInventory();
+
+			for (int k = 0; k < 10; k++) {
+				if (IsAValidEquipmentSlotForIteration(k))
+					VanillaUpdateEquip(armor[k]);
 			}
 
 			equippedAnyWallSpeedAcc = false;
@@ -9586,21 +_,30 @@
 
 			for (int l = 3; l < 10; l++) {
 				if (IsAValidEquipmentSlotForIteration(l))
-					ApplyEquipFunctional(l, armor[l]);
+					ApplyEquipFunctional(armor[l], hideVisibleAccessory[l]);
 			}
+
+			PlayerLoader.UpdateEquips(this);
+
+			if (kbGlove)
+				GetKnockback(DamageClass.Melee) *= 2f;
 
 			if (skyStoneEffects) {
 				lifeRegen += 2;
 				statDefense += 4;
 				meleeSpeed += 0.1f;
+				allDamage += 0.1f;
+				allCrit += 2;
+				/*
 				meleeDamage += 0.1f;
 				meleeCrit += 2;
 				rangedDamage += 0.1f;
 				rangedCrit += 2;
 				magicDamage += 0.1f;
 				magicCrit += 2;
+				*/
 				pickSpeed -= 0.15f;
-				minionDamage += 0.1f;
+				//minionDamage += 0.1f;
 				minionKB += 0.5f;
 			}
 
@@ -9609,6 +_,7 @@
 				maxTurrets++;
 			}
 
+			/* wing loop is merged into ApplyEquipFunctional
 			for (int m = 3; m < 10; m++) {
 				if (armor[m].wingSlot > 0 && IsAValidEquipmentSlotForIteration(m)) {
 					if (!hideVisibleAccessory[m] || (velocity.Y != 0f && !mount.Active))
@@ -9617,6 +_,7 @@
 					wingsLogic = armor[m].wingSlot;
 				}
 			}
+			*/
 
 			for (int n = 13; n < 20; n++) {
 				if (IsAValidEquipmentSlotForIteration(n))
@@ -9825,6 +_,10 @@
 		}
 
 		private void ApplyEquipVanity(int itemSlot, Item currentItem) {
+			ApplyEquipVanity(currentItem); //remove itemSlot parameter and make public so mods can call from their own accessory slots
+		}
+
+		public void ApplyEquipVanity(Item currentItem) {
 			int type = currentItem.type;
 			if (currentItem.wingSlot > 0)
 				wings = currentItem.wingSlot;
@@ -9849,6 +_,8 @@
 				ApplyMusicBox(currentItem);
 
 			UpdateBootVisualEffects(currentItem);
+
+			ItemLoader.UpdateVanity(currentItem, this);
 		}
 
 		private void DoEyebrellaRainEffect() {
@@ -9872,8 +_,12 @@
 			return ArmorIDs.Wing.Sets.Stats[wingID];
 		}
 
-		private void ApplyEquipFunctional(int itemSlot, Item currentItem) {
-			if (currentItem.expertOnly && !Main.expertMode)
+		// made public and itemSlot parameter removed, so mods can call this method from their own accessory slots
+		public void ApplyEquipFunctional(Item currentItem, bool hideVisual) {
+			int itemSlot = 0;
+			bool[] hideVisibleAccessory = { hideVisual };
+
+			if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
 				return;
 
 			if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
@@ -9999,6 +_,9 @@
 
 			if (currentItem.type == 3015) {
 				aggro -= 400;
+				allDamage += 0.05f;
+				allCrit += 5;
+				/*
 				meleeCrit += 5;
 				magicCrit += 5;
 				rangedCrit += 5;
@@ -10006,6 +_,7 @@
 				magicDamage += 0.05f;
 				rangedDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 			}
 
 			if (currentItem.type == 3016)
@@ -10193,6 +_,9 @@
 			}
 
 			if (currentItem.type == 1301) {
+				allDamage += 0.1f;
+				allCrit += 8;
+				/*
 				meleeCrit += 8;
 				rangedCrit += 8;
 				magicCrit += 8;
@@ -10200,6 +_,7 @@
 				rangedDamage += 0.1f;
 				magicDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (currentItem.type == 111)
@@ -10242,9 +_,12 @@
 			}
 
 			if (currentItem.type == 1248) {
+				allCrit += 10;
+				/*
 				meleeCrit += 10;
 				rangedCrit += 10;
 				magicCrit += 10;
+				*/
 			}
 
 			if (currentItem.type == 854)
@@ -10376,7 +_,7 @@
 			if (currentItem.type == 861) {
 				accMerman = true;
 				wolfAcc = true;
-				if (hideVisibleAccessory[itemSlot]) {
+					if (hideVisibleAccessory[itemSlot]) {
 					hideMerman = true;
 					hideWolf = true;
 				}
@@ -10628,10 +_,7 @@
 				minionDamage += 0.15f;
 
 			if (currentItem.type == 935) {
-				magicDamage += 0.12f;
+				allDamage += 0.12f;
-				meleeDamage += 0.12f;
-				rangedDamage += 0.12f;
-				minionDamage += 0.12f;
 			}
 
 			if (currentItem.wingSlot != -1)
@@ -10747,13 +_,24 @@
 				manaCost -= 0.08f;
 			}
 
+			if (currentItem.wingSlot > 0) {
+				if (!hideVisibleAccessory[itemSlot] || velocity.Y != 0f && !mount.Active)
+					wings = currentItem.wingSlot;
+
+				wingsLogic = currentItem.wingSlot;
+				equippedWings = currentItem;
+			}
+
+			ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
+
+			// Vanilla: Return early if sounds are not relevant
 			if (Main.myPlayer != whoAmI)
 				return;
 
 			if (currentItem.type == 5104 || currentItem.type == 5105) {
 				ApplyWilsonBeard(currentItem);
 			}
-			else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0 && Main.curMusic <= 91) {
+			else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0) {
 				SoundEngine.PlaySound(SoundID.Item166, base.Center);
 				int num3 = -1;
 				if (Main.curMusic == 1)
@@ -10917,10 +_,12 @@
 					currentItem.SetDefaults(5044);
 				else if (Main.curMusic == 90)
 					currentItem.SetDefaults(5112);
-				else if (Main.curMusic > 13)
+				else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(1596 + Main.curMusic - 14);
-				else if (num3 != -1)
+				else if (num3 != -1 && Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(num3 + 562);
+				else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out int modMusicBoxType))
+					currentItem.SetDefaults(modMusicBoxType);
 			}
 
 			ApplyMusicBox(currentItem);
@@ -11126,6 +_,9 @@
 			if (currentItem.type == 5112)
 				Main.musicBox2 = 86;
 
+			if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out int modMusicBox))
+				Main.musicBox2 = modMusicBox;
+
 			Main.musicBoxNotModifiedByVolume = Main.musicBox2;
 		}
 
@@ -11158,10 +_,13 @@
 
 			if (head == 112 && body == 75 && legs == 64) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
+				allDamage += 0.1f;
+				/*
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
 				rangedDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (head == 180 && body == 182 && legs == 122) {
@@ -11219,7 +_,7 @@
 					beetleCounter += 200f;
 
 				if (num != beetleOrbs && beetleOrbs > 0) {
-					for (int j = 0; j < 22; j++) {
+					for (int j = 0; j < MaxBuffs; j++) {
 						if (buffType[j] >= 98 && buffType[j] <= 100 && buffType[j] != 97 + num)
 							DelBuff(j);
 					}
@@ -11232,7 +_,7 @@
 				int num5 = 180;
 				if (beetleCounter >= (float)num5) {
 					if (beetleOrbs > 0 && beetleOrbs < 3) {
-						for (int k = 0; k < 22; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] >= 95 && buffType[k] <= 96)
 								DelBuff(k);
 						}
@@ -11373,7 +_,7 @@
 				AddBuff(60, 18000);
 			}
 			else if (crystalLeaf) {
-				for (int n = 0; n < 22; n++) {
+				for (int n = 0; n < MaxBuffs; n++) {
 					if (buffType[n] == 60)
 						DelBuff(n);
 				}
@@ -11480,6 +_,9 @@
 
 			if (head == 261 && body == 230 && legs == 213) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
+				allDamage += 0.1f;
+				allCrit += 10;
+				/*
 				rangedDamage += 0.1f;
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
@@ -11487,6 +_,7 @@
 				rangedCrit += 10;
 				meleeCrit += 10;
 				magicCrit += 10;
+				*/
 				dashType = 5;
 			}
 
@@ -11520,7 +_,7 @@
 				int num9 = 180;
 				if (solarCounter >= num9) {
 					if (solarShields > 0 && solarShields < 3) {
-						for (int num10 = 0; num10 < 22; num10++) {
+						for (int num10 = 0; num10 < MaxBuffs; num10++) {
 							if (buffType[num10] >= 170 && buffType[num10] <= 171)
 								DelBuff(num10);
 						}
@@ -11668,10 +_,12 @@
 				whipRangeMultiplier += 0.5f;
 				float num17 = 1.35f;
 				float num18 = 1f / num17;
-				whipUseTimeMultiplier *= num18;
+				whipUseTimeMultiplier *= num17;
 			}
 
 			ApplyArmorSoundAndDustChanges();
+
+			ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
 		}
 
 		public void UpdateSocialShadow() {
@@ -11898,6 +_,10 @@
 			bool flag6 = ZoneRain && ZoneSnow;
 			bool flag7 = point.Y > Main.maxTilesY - 320;
 			bool flag8 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
+
+			// TODO: Are these flags a problem?
+			LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
+
 			ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, value4 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, value3 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, value2 - new Vector2(0f, 10f));
@@ -12046,6 +_,7 @@
 				}
 			}
 
+			ZonePurity = InZonePurity();
 			if (!dead) {
 				Point point2 = base.Center.ToTileCoordinates();
 				if (WorldGen.InWorld(point2.X, point2.Y, 1)) {
@@ -12076,6 +_,7 @@
 			else {
 				_funkytownAchievementCheckCooldown = 100;
 			}
+			LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
 		}
 
 		public void ManageSpecialBiomeVisuals(string biomeName, bool inZone, Vector2 activationSource = default(Vector2)) {
@@ -12105,6 +_,13 @@
 		}
 
 		public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear) {
+			fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
+			hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
+			hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
+			backHairDraw = hair >= 0 && ArmorIDs.Head.Sets.DrawBackHair[hair];
+			drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
+
+			/*
 			fullHair = (hatHair = (hideHair = (drawsBackHairWithoutHeadgear = false)));
 			switch (head) {
 				case 0:
@@ -12221,6 +_,7 @@
 			backHairDraw = (num > 50 && (num < 56 || num > 63) && (num < 74 || num > 77) && (num < 88 || num > 89) && num != 100 && num != 104 && num != 112 && num < 116);
 			if (num == 133 || num == 134 || num == 146 || num == 162 || num == 6)
 				backHairDraw = true;
+			*/
 		}
 
 		public void UpdateDead() {
@@ -12232,6 +_,7 @@
 			ResetFloorFlags();
 			wings = 0;
 			wingsLogic = 0;
+			equippedWings = null;
 			ResetVisibleAccessories();
 			poisoned = false;
 			venom = false;
@@ -12275,8 +_,9 @@
 			hasAngelHalo = false;
 			hasRainbowCursor = false;
 			leinforsHair = false;
+			PlayerLoader.UpdateDead(this);
 			gravDir = 1f;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]]) {
 					buffTime[i] = 0;
 					buffType[i] = 0;
@@ -12472,6 +_,16 @@
 						toolStrategy = 5;
 				}
 
+				int modSelect = TileLoader.AutoSelect(tX, tY, this);
+
+				if (modSelect >= 0) {
+					if (nonTorch == -1)
+						nonTorch = selectedItem;
+
+					selectedItem = modSelect;
+					return;
+				}
+
 				SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
 				_lastSmartCursorToolStrategy = toolStrategy;
 			}
@@ -12512,7 +_,7 @@
 							SmartSelect_SelectItem(i);
 							return;
 						}
-						if (type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776)
+						if (ItemID.Sets.Glowsticks[type])
 							SmartSelect_SelectItem(i);
 						break;
 					case 1:
@@ -12534,16 +_,16 @@
 						}
 						break;
 					case 4:
-						if (inventory[i].type != 282 && inventory[i].type != 286 && inventory[i].type != 3002 && inventory[i].type != 3112 && inventory[i].type != 4776 && inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type]) {
+						if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type]) {
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
 						}
-						if ((type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776) && wetTile) {
+						if (ItemID.Sets.Glowsticks[type] && wetTile) {
 							SmartSelect_SelectItem(i);
 							return;
 						}
@@ -12556,6 +_,9 @@
 								}
 							}
 
+							if (!flag2 && !ItemLoader.NeedsAmmo(inventory[i], this))
+								flag2 = true;
+
 							if (flag2) {
 								SmartSelect_SelectItem(i);
 								return;
@@ -12571,7 +_,7 @@
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
@@ -12598,6 +_,7 @@
 							case 3002:
 							case 3112:
 							case 4776:
+							case int thisType when ItemID.Sets.Glowsticks[thisType]:
 								SmartSelect_SelectItem(i);
 								return;
 						}
@@ -12777,6 +_,13 @@
 					if (tile == null)
 						return;
 
+					if (tile.type > TileID.Count) {
+						if (tile.active() && TileID.Sets.Torch[tile.type])
+							NearbyModTorch.Add(tile.type);
+
+						continue;
+					}
+
 					if (!tile.active() || tile.type != 4)
 						continue;
 
@@ -12860,7 +_,12 @@
 					NetMessage.SendData(4, -1, -1, null, whoAmI);
 
 				if (numberOfTorchAttacksMade >= 95) {
+					/*
 					int number = Item.NewItem(new EntitySource_ByItemSourceId(this, 6), (int)position.X, (int)position.Y, width, height, 5043);
+					*/
+
+					int number = Item.NewItem(new EntitySource_TorchGod(this, Context: "TorchGod_FavorLoot"), (int)position.X, (int)position.Y, width, height, 5043);
+
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number, 1f);
 				}
@@ -12890,7 +_,13 @@
 					float num10 = velocity.Length();
 					velocity.Normalize();
 					velocity *= num7;
+
+					/*
 					int num11 = Projectile.NewProjectile(GetProjectileSource_Misc(10), vector, velocity, 949, num8, 1f, whoAmI, num9, num10);
+					*/
+
+					int num11 = Projectile.NewProjectile(new EntitySource_TorchGod(this, Context: "TorchGod_Projectile"), vector, velocity, 949, num8, 1f, whoAmI, num9, num10);
+
 					Main.projectile[num11].ai[0] = num9;
 					Main.projectile[num11].ai[1] = num10;
 					Main.projectile[num11].netUpdate = true;
@@ -12907,6 +_,9 @@
 			if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < 22)
 				nearbyTorch[inventory[selectedItem].placeStyle] = true;
 
+			if (TileLoader.GetTile(inventory[selectedItem].createTile) is ModTile modTile && TileID.Sets.Torch[modTile.Type])
+				NearbyModTorch.Add(modTile.Type);
+
 			float num = 0f;
 			float num2 = 0f;
 			if (!ZoneDungeon && !ZoneLihzhardTemple) {
@@ -12976,6 +_,7 @@
 				}
 			}
 
+			TileLoader.ModifyTorchLuck(this, ref num2, ref num);
 			if (num2 >= 1f)
 				torchLuck += 1f;
 			else if (num2 > 0f)
@@ -12992,6 +_,7 @@
 			for (int i = 0; i < 22; i++) {
 				nearbyTorch[i] = false;
 			}
+			NearbyModTorch.Clear();
 
 			if (torchLuck < 0f)
 				torchLuck = 0f;
@@ -13052,7 +_,7 @@
 			arcticDivingGear = false;
 			noBuilding = false;
 			strongBees = false;
-			armorPenetration = 0;
+			// armorPenetration = 0;
 			shroomiteStealth = false;
 			statDefense = 0;
 			accWatch = 0;
@@ -13062,6 +_,7 @@
 			canFloatInWater = false;
 			lifeRegen = 0;
 			manaCost = 1f;
+			/* individual class stats handled by ResetDamageClassData
 			meleeSpeed = 1f;
 			meleeDamage = 1f;
 			rangedDamage = 1f;
@@ -13074,6 +_,7 @@
 			meleeCrit = 4;
 			rangedCrit = 4;
 			magicCrit = 4;
+			*/
 			hasFootball = false;
 			drawingFootball = false;
 			minionKB = 0f;
@@ -13116,11 +_,19 @@
 			huntressAmmoCost90 = false;
 			ammoCost80 = false;
 			ammoCost75 = false;
+			ThrownCost50 = false;
+			ThrownCost33 = false;
+			ThrownVelocity = 1f;
 			manaRegenBuff = false;
 			hasCreditsSceneMusicBox = false;
+			arrowDamage = StatModifier.Default;
+			bulletDamage = StatModifier.Default;
+			rocketDamage = StatModifier.Default;
+			/*
 			arrowDamage = 1f;
 			bulletDamage = 1f;
 			rocketDamage = 1f;
+			*/
 			coolWhipBuff = false;
 			yoraiz0rEye = 0;
 			yoraiz0rDarkness = false;
@@ -13189,7 +_,7 @@
 
 			endurance = 0f;
 			whipRangeMultiplier = 1f;
-			whipUseTimeMultiplier = 1f;
+			//whipUseTimeMultiplier = 1f;
 			calmed = false;
 			beetleOrbs = 0;
 			beetleBuff = false;
@@ -13356,6 +_,7 @@
 			slowOgreSpit = false;
 			wings = 0;
 			wingsLogic = 0;
+			equippedWings = null;
 			wingTimeMax = 0;
 			brokenArmor = false;
 			silence = false;
@@ -13461,17 +_,19 @@
 				}
 			}
 
+			ResetDamageClassData();
 			mount.CheckMountBuff(this);
+			PlayerLoader.ResetEffects(this);
 		}
 
 		private void UpdateLadyBugLuckTime() {
 			if (ladyBugLuckTimeLeft > 0) {
-				ladyBugLuckTimeLeft -= Main.dayRate;
+				ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
 				if (ladyBugLuckTimeLeft < 0)
 					ladyBugLuckTimeLeft = 0;
 			}
 			else if (ladyBugLuckTimeLeft < 0) {
-				ladyBugLuckTimeLeft += Main.dayRate;
+				ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
 				if (ladyBugLuckTimeLeft > 0)
 					ladyBugLuckTimeLeft = 0;
 			}
@@ -13602,6 +_,7 @@
 				lifeRegen -= 100;
 			}
 
+			PlayerLoader.UpdateBadLifeRegen(this);
 			if (honey && lifeRegen < 0) {
 				lifeRegen += 4;
 				if (lifeRegen > 0)
@@ -13669,6 +_,7 @@
 			if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
 				lifeRegen += 2;
 
+			PlayerLoader.UpdateLifeRegen(this);
 			if (bleed)
 				lifeRegenTime = 0;
 
@@ -13733,6 +_,7 @@
 			if (rabid)
 				num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
 
+			PlayerLoader.NaturalLifeRegen(this, ref num5);
 			float num7 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
 			num5 *= num7;
 			lifeRegen += (int)Math.Round(num5);
@@ -13916,8 +_,8 @@
 
 		public void UpdateJumpHeight() {
 			if (mount.Active) {
-				jumpHeight = mount.JumpHeight(velocity.X);
+				jumpHeight = mount.JumpHeight(this, velocity.X);
-				jumpSpeed = mount.JumpSpeed(velocity.X);
+				jumpSpeed = mount.JumpSpeed(this, velocity.X);
 			}
 			else {
 				if (jumpBoost) {
@@ -14215,7 +_,7 @@
 						direction = -1;
 				}
 				else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange) {
-					direction = -1;
+					direction = -1 ;
 				}
 
 				if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly()) {
@@ -14330,7 +_,7 @@
 				if (flag4)
 					num5 = 30;
 
-				float damage = (float)num5 * minionDamage;
+				float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
 				float knockback = 10f;
 				if (flag4)
 					knockback = 7f;
@@ -14347,7 +_,7 @@
 
 				rect2.Width = 2;
 				rect2.Inflate(6, 12);
-				float damage2 = 100f * minionDamage;
+				float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
 				float knockback2 = 12f;
 				int nPCImmuneTime2 = 30;
 				int playerImmuneTime2 = 6;
@@ -14361,7 +_,7 @@
 
 				rect3.Width = 2;
 				rect3.Inflate(6, 12);
-				float damage3 = 120f * minionDamage;
+				float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
 				float knockback3 = 12f;
 				int nPCImmuneTime3 = 30;
 				int playerImmuneTime3 = 6;
@@ -14375,7 +_,7 @@
 
 				rect4.Width = 2;
 				rect4.Inflate(6, 12);
-				float damage4 = 90f * minionDamage;
+				float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
 				float knockback4 = 10f;
 				int nPCImmuneTime4 = 30;
 				int playerImmuneTime4 = 6;
@@ -14389,7 +_,7 @@
 
 				rect5.Width = 2;
 				rect5.Inflate(6, 12);
-				float damage5 = 40f * minionDamage;
+				float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 				float knockback5 = 10f;
 				int nPCImmuneTime5 = 30;
 				int playerImmuneTime5 = 12;
@@ -14426,7 +_,10 @@
 				num -= height;
 
 			if (runSoundDelay == 0 && velocity.Y == 0f) {
+				/*
 				SoundEngine.PlaySound(hermesStepSound.SoundType, (int)position.X, (int)position.Y, hermesStepSound.SoundStyle);
+				*/
+				SoundEngine.PlaySound(hermesStepSound.Style, position);
 				runSoundDelay = hermesStepSound.IntendedCooldown;
 			}
 
@@ -14555,7 +_,7 @@
 			}
 
 			if (num != 0) {
-				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
 				for (int i = 0; i < num2; i++) {
 					WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
 				}
@@ -14601,8 +_,10 @@
 				damage = ((!Main.expertMode) ? ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].NormalDamageDealt)) : ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].ExpertDamageDealt)));
 
 			OnHit(npc.Center.X, npc.Center.Y, npc);
+
+			// TODO: should armorPenetration be passed in to this function? Class specific armor penetration bonuses are currently ignored
 			if (armorPenetration > 0)
-				damage += npc.checkArmorPenetration(armorPenetration);
+				damage += npc.checkArmorPenetration((int)armorPenetration);
 
 			NPCKillAttempt attempt = new NPCKillAttempt(npc);
 			int dmg = (int)npc.StrikeNPC(damage, knockback, direction, crit);
@@ -14663,7 +_,7 @@
 
 					Rectangle rect2 = nPC.getRect();
 					if (rect.Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(base.position, width, height, nPC.position, nPC.width, nPC.height))) {
-						float num = 40f * minionDamage;
+						float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 						float knockback = 5f;
 						int direction = base.direction;
 						if (velocity.X < 0f)
@@ -15065,16 +_,17 @@
 
 						Rectangle rect = nPC.getRect();
 						if (rectangle.Intersects(rect) && (nPC.noTileCollide || CanHit(nPC))) {
-							float num = 30f * meleeDamage;
-							float num2 = 9f;
+							float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
+							float num2 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 							bool crit = false;
+							/*
 							if (kbGlove)
 								num2 *= 2f;
 
 							if (kbBuff)
 								num2 *= 1.5f;
-
-							if (Main.rand.Next(100) < meleeCrit)
+							*/
+							if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 								crit = true;
 
 							int num3 = base.direction;
@@ -15115,16 +_,17 @@
 							ConsumeSolarFlare();
 						}
 
-						float num4 = 150f * meleeDamage;
-						float num5 = 9f;
+						float num4 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
+						float num5 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 						bool crit2 = false;
+						/*
 						if (kbGlove)
 							num5 *= 2f;
 
 						if (kbBuff)
 							num5 *= 1.5f;
-
-						if (Main.rand.Next(100) < meleeCrit)
+						*/
+						if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 							crit2 = true;
 
 						int direction = base.direction;
@@ -15361,6 +_,15 @@
 			solarDashConsumedFlare = false;
 		}
 
+		/*
+		TO-DO:
+		- make public, as it has little reason to be private and could be of great help to those makin' modded dashes
+		- properly explain how to use this in the context of programmin' a modded dash (use ExampleShield for this; see below)
+		- make ExampleShield use this, and simplify it accordingly (it currently has way too many movin' parts that require extra upkeep, for way too little payoff)
+
+		I'll do all this in an upcomin' PR if nobody else does
+		-thomas
+		*/
 		private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null) {
 			dir = 0;
 			dashing = false;
@@ -15654,8 +_,10 @@
 				float num5 = 0.1f;
 				if (wingsLogic == 26) {
 					num2 = 0.75f;
+					//patch file: num2, num5
 					num5 = 0.15f;
 					num4 = 1f;
+					//patch file: num, num3, num4
 					num3 = 2.5f;
 					num = 0.125f;
 				}
@@ -15752,6 +_,7 @@
 						num = 0.15f;
 				}
 
+				ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
 				velocity.Y -= num * gravDir;
 				if (gravDir == 1f) {
 					if (velocity.Y > 0f)
@@ -16056,7 +_,7 @@
 						Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
 						RemoveAllGrapplingHooks();
 						int num4 = 13;
-						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode))
+						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
 							num4 = miscEquips[2].mountType;
 
 						int num5 = height + Mount.GetHeightBoost(num4);
@@ -16128,6 +_,11 @@
 				Projectile projectile = Main.projectile[grappling[i]];
 				if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
 					continue;
+				int type = projectile.type;
+				bool useAiType = projectile.ModProjectile != null && projectile.ModProjectile.AIType > 0;
+				if (useAiType) {
+					projectile.type = projectile.ModProjectile.AIType;
+				}
 
 				num += projectile.position.X + (float)(projectile.width / 2);
 				num2 += projectile.position.Y + (float)(projectile.height / 2);
@@ -16169,6 +_,10 @@
 					if (value2.X != 0f)
 						preferredPlayerDirectionToSet = Math.Sign(value2.X);
 				}
+				if (useAiType) {
+					projectile.type = type;
+				}
+				ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num2);
 			}
 
 			if (num3 == 0) {
@@ -16193,13 +_,14 @@
 			if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
 				num9 = 16f;
 
+			ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num9);
 			float num10 = num8;
 			num10 = ((!(num8 > num9)) ? 1f : (num9 / num8));
 			preferedPlayerVelocityX *= num10;
 			preferedPlayerVelocityY *= num10;
 		}
 
-		private void RefreshMovementAbilities(bool doubleJumps = true) {
+		public void RefreshMovementAbilities(bool doubleJumps = true) { //Made public, because this is useful
 			wingTime = wingTimeMax;
 			rocketTime = rocketTimeMax;
 			rocketDelay = 0;
@@ -16830,6 +_,9 @@
 			slippy2 = (num3 == 197);
 			powerrun = (num3 == 198);
 			runningOnSand = (TileID.Sets.Conversion.Sand[num3] || TileID.Sets.Conversion.Sandstone[num3] || TileID.Sets.Conversion.HardenedSand[num3]);
+
+			TileLoader.FloorVisuals(num3, this);
+
 			if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
 				num3 = -1;
 
@@ -16867,7 +_,7 @@
 		}
 
 		private void MakeFloorDust(bool Falling, int type) {
-			if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460)
+			if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && !TileLoader.HasWalkDust(type))
 				return;
 
 			int num = 1;
@@ -16877,6 +_,7 @@
 			for (int i = 0; i < num; i++) {
 				bool flag = true;
 				int num2 = 76;
+				//patch file: type, num2, flag
 				if (type == 53)
 					num2 = 32;
 
@@ -16942,6 +_,7 @@
 
 				if (num2 == 53 && Main.rand.Next(3) != 0)
 					flag = false;
+				// Patch context: num2 & flag
 
 				Color newColor = default(Color);
 				if (type == 193)
@@ -16953,6 +_,7 @@
 				if (type == 460)
 					newColor = new Color(100, 150, 130, 100);
 
+				TileLoader.WalkDust(type, ref num2, ref flag, ref newColor);
 				if (!Falling) {
 					float num3 = Math.Abs(velocity.X) / 3f;
 					if ((float)Main.rand.Next(100) > num3 * 100f)
@@ -17181,6 +_,8 @@
 		}
 
 		public void Update(int i) {
+			using var _currentPlr = new Main.CurrentPlayerOverride(this);
+
 			if (i == Main.myPlayer && Main.netMode != 2)
 				LockOnHelper.Update();
 
@@ -17289,6 +_,7 @@
 			if (whoAmI != Main.myPlayer) {
 				int num2 = (int)(base.position.X + (float)(width / 2)) / 16;
 				int num3 = (int)(base.position.Y + (float)(height / 2)) / 16;
+				/*
 				if (!WorldGen.InWorld(num2, num3, 4))
 					flag = true;
 				else if (Main.tile[num2, num3] == null)
@@ -17301,6 +_,9 @@
 					flag = true;
 				else if (Main.tile[num2, num3 + 3] == null)
 					flag = true;
+				*/
+				if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num2 - 3, num3 - 3, num2 + 3, num3 + 3))
+					flag = true;
 
 				if (flag) {
 					outOfRange = true;
@@ -17334,6 +_,7 @@
 
 			UpdateHairDyeDust();
 			UpdateMiscCounter();
+			PlayerLoader.PreUpdate(this);
 			infernoCounter++;
 			if (infernoCounter >= 180)
 				infernoCounter = 0;
@@ -17672,6 +_,7 @@
 						}
 					}
 
+					PlayerLoader.SetControls(this);
 					if (controlInv) {
 						if (releaseInventory)
 							ToggleInv();
@@ -17811,7 +_,10 @@
 							CaptureManager.Instance.Scrolling();
 						}
 						else if (!flag8) {
+							if (PlayerInput.MouseInModdedUI.Count > 0) {
+								//Do nothing
+							}
-							if (!Main.playerInventory) {
+							else if (!Main.playerInventory) {
 								HandleHotbar();
 							}
 							else {
@@ -17855,6 +_,7 @@
 										Main.focusRecipe = 0;
 								}
 							}
+							PlayerInput.MouseInModdedUI.Clear();
 						}
 					}
 					else {
@@ -18046,12 +_,6 @@
 						}
 					}
 
-					bool flag12 = false;
-					for (int num23 = 3; num23 < 10; num23++) {
-						if (armor[num23].stack > 0 && armor[num23].wingSlot > -1)
-							flag12 = true;
-					}
-
 					if (stoned) {
 						int num24 = (int)(((float)num18 * gravDir - 2f) * 20f);
 						if (num24 > 0) {
@@ -18059,7 +_,7 @@
 							immune = false;
 						}
 					}
-					else if (((gravDir == 1f && num18 > num17) || (gravDir == -1f && num18 < -num17)) && !noFallDmg && !flag12) {
+					else if (((gravDir == 1f && num18 > num17) || (gravDir == -1f && num18 < -num17)) && !noFallDmg && equippedWings == null) {
 						immune = false;
 						int num25 = (int)((float)num18 * gravDir - (float)num17) * 10;
 						if (mount.Active)
@@ -18174,9 +_,17 @@
 			else
 				afkCounter = 0;
 
+			/*
 			meleeCrit += inventory[selectedItem].crit;
 			magicCrit += inventory[selectedItem].crit;
 			rangedCrit += inventory[selectedItem].crit;
+
+			tML:
+			this, right here, is the principal cause of crit chance bein' a massive pain in the ass
+			by commentin' this out, your critical strike chance for the vanilla "three" classes capable of crits will no longer be modified based on your current weapon
+			this fixes a number of issues related to tooltip crit displays, and while it isn't the primary fix for crit swap, it definitely contributes to it
+			- thomas
+			*/
 			if (whoAmI == Main.myPlayer) {
 				Main.musicBox2 = -1;
 				if (Main.SceneMetrics.WaterCandleCount > 0)
@@ -18207,12 +_,14 @@
 					AddBuff(194, 2, quiet: false);
 			}
 
+			PlayerLoader.PreUpdateBuffs(this);
-			for (int num26 = 0; num26 < 338; num26++) {
+			for (int num26 = 0; num26 < BuffLoader.BuffCount; num26++) {
 				buffImmune[num26] = false;
 			}
 
 			UpdateProjectileCaches(i);
 			UpdateBuffs(i);
+			PlayerLoader.PostUpdateBuffs(this);
 			if (whoAmI == Main.myPlayer) {
 				if (!onFire && !poisoned)
 					trapDebuffSource = false;
@@ -18221,6 +_,9 @@
 				UpdatePetLight(i);
 			}
 
+			if (kbBuff)
+				allKB *= 1.5f;
+
 			UpdateLuckFactors();
 			RecalculateLuck();
 			if (luckNeedsSync && whoAmI == Main.myPlayer) {
@@ -18256,7 +_,7 @@
 			hideWolf = false;
 			forceWerewolf = false;
 			if (whoAmI == Main.myPlayer) {
-				for (int num27 = 0; num27 < 22; num27++) {
+				for (int num27 = 0; num27 < MaxBuffs; num27++) {
 					if (buffType[num27] > 0 && buffTime[num27] <= 0)
 						DelBuff(num27);
 				}
@@ -18309,6 +_,7 @@
 
 			UpdateArmorLights();
 			UpdateArmorSets(i);
+			PlayerLoader.PostUpdateEquips(this); // TODO, move down?
 			if (maxTurretsOld != maxTurrets) {
 				UpdateMaxTurrets();
 				maxTurretsOld = maxTurrets;
@@ -18356,8 +_,11 @@
 
 				meleeDamage += (1f - stealth) * 3f;
 				meleeCrit += (int)((1f - stealth) * 30f);
+				GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
+				/*
 				if (meleeCrit > 100)
-					meleeCrit = 100;
+					meleeCrit = new Modifier(100);
+				*/
 
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
@@ -18389,6 +_,7 @@
 
 				rangedDamage += (1f - stealth) * 0.6f;
 				rangedCrit += (int)((1f - stealth) * 10f);
+				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
 					stealthTimer--;
@@ -18408,6 +_,7 @@
 
 					rangedDamage += (1f - stealth) * 0.8f;
 					rangedCrit += (int)((1f - stealth) * 20f);
+					GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 					aggro -= (int)((1f - stealth) * 1200f);
 					accRunSpeed *= 0.3f;
 					maxRunSpeed *= 0.3f;
@@ -18455,15 +_,20 @@
 			if (manaSick)
 				magicDamage *= 1f - manaSickReduction;
 
+			/*
 			float num32 = meleeSpeed - 1f;
 			num32 *= ItemID.Sets.BonusMeleeSpeedMultiplier[inventory[selectedItem].type];
 			meleeSpeed = 1f + num32;
+
+			tML: attack speed multipliers now applied in Player.GetWeaponAttackSpeed
+			*/
 			if ((double)pickSpeed < 0.3)
 				pickSpeed = 0.3f;
-
+			// tML: no longer capped for consistency with other usage-speed-related modifiers
+			/*
 			if (meleeSpeed > 3f)
 				meleeSpeed = 3f;
-
+			*/
 			if (tileSpeed > 3f)
 				tileSpeed = 3f;
 
@@ -18507,7 +_,9 @@
 				}
 			}
 
+			// tML: no longer set to reciprocal for consistency with other usage-speed-related modifiers. See inverseMeleeSpeed for vanilla uses of the stat
-			meleeSpeed = 1f / meleeSpeed;
+			// meleeSpeed = 1f / meleeSpeed;
+			PlayerLoader.PostUpdateMiscEffects(this);
 			UpdateLifeRegen();
 			soulDrain = 0;
 			UpdateManaRegen();
@@ -18520,7 +_,7 @@
 			runAcceleration *= moveSpeed;
 			maxRunSpeed *= moveSpeed;
 			UpdateJumpHeight();
-			for (int num33 = 0; num33 < 22; num33++) {
+			for (int num33 = 0; num33 < MaxBuffs; num33++) {
 				if (buffType[num33] > 0 && buffTime[num33] > 0 && buffImmune[buffType[num33]])
 					DelBuff(num33);
 			}
@@ -18532,10 +_,7 @@
 				statDefense /= 2;
 
 			if (witheredWeapon) {
-				meleeDamage *= 0.5f;
+				allDamage *= 0.5f;
-				rangedDamage *= 0.5f;
-				magicDamage *= 0.5f;
-				minionDamage *= 0.5f;
 			}
 
 			lastTileRangeX = tileRangeX;
@@ -19042,6 +_,7 @@
 						mount.UpdateDrill(this, controlUp, controlDown);
 				}
 
+				PlayerLoader.PostUpdateRunSpeeds(this);
 				HorizontalMovement();
 				if (gravControl) {
 					if (controlUp && releaseUp) {
@@ -19128,12 +_,13 @@
 					CancelAllJumpVisualEffects();
 				}
 				else {
+					bool isCustomWings = ItemLoader.WingUpdate(this, flag20);
 					if (flag20) {
 						WingAirVisuals();
 						WingMovement();
 					}
 
-					WingFrame(flag20);
+					WingFrame(flag20, isCustomWings);
 					if (wingsLogic > 0 && rocketBoots != 0 && base.velocity.Y != 0f && rocketTime != 0) {
 						int num45 = 6;
 						int num46 = rocketTime * num45;
@@ -19144,7 +_,7 @@
 						rocketTime = 0;
 					}
 
-					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45) {
+					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45 && !isCustomWings) {
 						bool flag21 = wingFrame == 3;
 						if (wings == 43 || wings == 44)
 							flag21 = (wingFrame == 4);
@@ -19397,7 +_,7 @@
 											wingFrame = 0;
 									}
 								}
-								else if (wings != 22 && wings != 28) {
+								else if (wings != 22 && wings != 28 && !isCustomWings) {
 									if (wings == 30) {
 										wingFrameCounter++;
 										int num62 = 5;
@@ -19604,7 +_,7 @@
 				}
 
 				if (flag22 && Main.myPlayer == whoAmI) {
-					for (int num79 = 0; num79 < 22; num79++) {
+					for (int num79 = 0; num79 < MaxBuffs; num79++) {
 						if (buffType[num79] == 38)
 							DelBuff(num79);
 					}
@@ -19677,6 +_,7 @@
 					Rectangle rectangle2 = new Rectangle((int)base.position.X, (int)base.position.Y, width, height);
 					for (int num80 = 0; num80 < 200; num80++) {
 						if (Main.npc[num80].active && !Main.npc[num80].dontTakeDamage && !Main.npc[num80].friendly && Main.npc[num80].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num80]) && rectangle2.Intersects(new Rectangle((int)Main.npc[num80].position.X, (int)Main.npc[num80].position.Y, Main.npc[num80].width, Main.npc[num80].height))) {
+							/*
 							float num81 = meleeCrit;
 							if (num81 < (float)rangedCrit)
 								num81 = rangedCrit;
@@ -19684,8 +_,18 @@
 							if (num81 < (float)magicCrit)
 								num81 = magicCrit;
 
+							tML:
+							the below accomplishes what this was tryin' to, and while accountin' for every damage type currently available
+							- thomas
+							*/
 							bool crit = false;
-							if ((float)Main.rand.Next(1, 101) <= num81)
+							float highestClassSpecificCrit = 0;
+							foreach (DamageClass damageType in DamageClassLoader.DamageClasses)
+							{
+								if (GetCritChance(damageType) > highestClassSpecificCrit)
+									highestClassSpecificCrit = GetCritChance(damageType);
+							}
+							if (Main.rand.Next(100) < allCrit + highestClassSpecificCrit)
 								crit = true;
 
 							float currentSpeed = Math.Abs(base.velocity.X) / maxRunSpeed;
@@ -19729,7 +_,7 @@
 				else if (vector3.Y != 0f) {
 					int damage3 = Main.DamageVar(vector3.Y, 0f - luck);
 					Hurt(PlayerDeathReason.ByOther(3), damage3, 0, pvp: false, quiet: false, Crit: false, 0);
-					if (vector3.Y == 60f || vector3.Y == 80f)
+					if (vector3.Y == 60f || vector3.Y == 80f) //These values have to match TileID.Sets.TouchDamageOther, which is unused in vanilla and was not up to date with 1.4 --direwolf420
 						AddBuff(30, Main.rand.Next(240, 600));
 				}
 				else {
@@ -19815,7 +_,7 @@
 
 			if (num83) {
 				if ((onFire || onFire3) && !lavaWet) {
-					for (int num84 = 0; num84 < 22; num84++) {
+					for (int num84 = 0; num84 < MaxBuffs; num84++) {
 						int num85 = buffType[num84];
 						if (num85 == 24 || num85 == 323)
 							DelBuff(num84);
@@ -20062,6 +_,7 @@
 			if (vortexDebuff)
 				base.velocity.Y = base.velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
 
+			PlayerLoader.PreUpdateMovement(this);
 			if (tongued) {
 				base.position += base.velocity;
 				flag28 = false;
@@ -20147,11 +_,12 @@
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
-
+			// More patch context.
 			grappling[0] = -1;
 			grapCount = 0;
 			UpdateReleaseUseTile();
 			UpdateAdvancedShadows();
+			PlayerLoader.PostUpdate(this);
 		}
 
 		private void ResetControls() {
@@ -20213,6 +_,9 @@
 		}
 
 		public void RecalculateLuck() {
+			if (!PlayerLoader.PreModifyLuck(this, ref luck))
+				goto skipVanillaLuck;
+
 			luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
 			luck += (float)(int)luckPotion * 0.1f;
 			if (LanternNight.LanternsUp)
@@ -20220,6 +_,9 @@
 
 			if (HasGardenGnomeNearby)
 				luck += 0.2f;
+
+			skipVanillaLuck:
+			PlayerLoader.ModifyLuck(this, ref luck);
 		}
 
 		public static int GetMouseScrollDelta() => PlayerInput.ScrollWheelDelta / 120;
@@ -20318,6 +_,8 @@
 
 			if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
 				runSlowdown *= 6f;
+
+			ItemLoader.HorizontalWingSpeeds(this);
 		}
 
 		private void RocketBootVisuals() {
@@ -20424,7 +_,7 @@
 			}
 		}
 
-		public void WingFrame(bool wingFlap) {
+		public void WingFrame(bool wingFlap, bool isCustomWings = false) {
 			bool flag = wingsLogic != wings;
 			if (wings == 4) {
 				if (wingFlap || jump > 0) {
@@ -21065,6 +_,8 @@
 				num27 = 3;
 			}
 
+			if (isCustomWings) return;
+
 			if (wings == 32)
 				num27 = 3;
 
@@ -21425,7 +_,7 @@
 			if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
 				r = new Rectangle(chestPointX * 16, chestPointY * 16, 32, 32);
 
-			if (tile.type == 88)
+			if (TileID.Sets.BasicDresser[tile.type])
 				r = new Rectangle(chestPointX * 16, chestPointY * 16, 48, 32);
 
 			if (tile.type == 29)
@@ -21639,6 +_,9 @@
 						break;
 				}
 
+				if (!NPCLoader.CanHitPlayer(Main.npc[i], this, ref specialHitSetter) || !PlayerLoader.CanBeHitByNPC(this, Main.npc[i], ref specialHitSetter))
+					continue;
+
 				if ((specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
 					continue;
 
@@ -21678,6 +_,10 @@
 					if (specialHitSetter >= 0)
 						flag3 = (hurtCooldowns[specialHitSetter] == 0);
 
+					bool crit = false;
+					NPCLoader.ModifyHitPlayer(Main.npc[i], this, ref num4, ref crit);
+					PlayerLoader.ModifyHitByNPC(this, Main.npc[i], ref num4, ref crit);
+
 					if (whoAmI == Main.myPlayer && num2 > 0f && flag3 && !Main.npc[i].dontTakeDamage) {
 						int num6 = (int)((float)num4 * num2);
 						if (num6 > 1000)
@@ -21699,8 +_,15 @@
 					if (resistCold && Main.npc[i].coldDamage)
 						num4 = (int)((float)num4 * 0.7f);
 
-					if (flag && Hurt(PlayerDeathReason.ByNPC(i), num4, num3, pvp: false, quiet: false, Crit: false, specialHitSetter) > 0.0 && !dead && !flag2)
-						StatusFromNPC(Main.npc[i]);
+					if (flag) { //TODO, what is this flag?
+						int realDamage = (int)Hurt(PlayerDeathReason.ByNPC(i), num4, num3, pvp: false, quiet: false, Crit: false, specialHitSetter);
+
+						if (realDamage > 0 && !dead && !flag2)
+							StatusFromNPC(Main.npc[i]);
+
+						NPCLoader.OnHitPlayer(Main.npc[i], this, realDamage, crit);
+						PlayerLoader.OnHitByNPC(this, Main.npc[i], realDamage, crit);
+					}
 
 					if (num) {
 						GiveImmuneTimeForCollisionAttack(longInvince ? 60 : 30);
@@ -21775,6 +_,8 @@
 		}
 
 		public void ItemCheck_ManageRightClickFeatures() {
+			//ItemLoader.AltFunctionUse(this.inventory[this.selectedItem], this)
+			// TODO, reintegrate AltFunctionUse
 			bool flag = selectedItem != 58 && controlUseTile && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
 			bool flag2 = flag;
 			if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
@@ -21821,6 +_,11 @@
 				controlUseItem = true;
 			}
 
+			if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this)) {
+				altFunctionUse = 1;
+				controlUseItem = true;
+			}
+
 			if (!controlUseItem && altFunctionUse == 1)
 				altFunctionUse = 0;
 
@@ -21979,6 +_,9 @@
 		}
 
 		public void ScrollHotbar(int Offset) {
+			//disable hotbar scrolling when using auto select
+			//previously it only worked when scrolling between 0 and 9, and made the sound
+			if (selectedItem >= 10) return;
 			Offset = ClampHotbarOffset(Offset);
 			selectedItem += Offset;
 			if (Offset != 0) {
@@ -22222,6 +_,8 @@
 					cursorItemIconID = -1;
 				}
 			}
+
+			TileLoader.MouseOverFar(myX, myY);
 		}
 
 		private void TileInteractionsUse(int myX, int myY) {
@@ -22237,7 +_,8 @@
 				bool flag3 = false;
 				for (int i = 0; i < 58; i++) {
 					if (inventory[i].type == 949 && inventory[i].stack > 0) {
+						if (ItemLoader.ConsumeItem(inventory[i], this))
-						inventory[i].stack--;
+							inventory[i].stack--;
 						if (inventory[i].stack <= 0)
 							inventory[i].SetDefaults();
 
@@ -22312,7 +_,7 @@
 					Wiring.HitSwitch(myX, myY);
 					NetMessage.SendData(59, -1, -1, null, myX, myY);
 				}
-				else if (Main.tile[myX, myY].type == 139) {
+				else if (Main.tile[myX, myY].type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY])) {
 					flag2 = true;
 					SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
 					WorldGen.SwitchMB(myX, myY);
@@ -22436,7 +_,7 @@
 					flag2 = true;
 					GamepadEnableGrappleCooldown();
 				}
-				else if (Main.tile[myX, myY].type == 4 || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90)) {
+				else if (TileID.Sets.Torch[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90) || TileID.Sets.CanDropFromRightClick[Main.tile[myX, myY].type]) {
 					WorldGen.KillTile(myX, myY);
 					if (Main.netMode == 1)
 						NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
@@ -22740,7 +_,8 @@
 					if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss) {
 						for (int n = 0; n < 58; n++) {
 							if (inventory[n].type == 1293) {
+								if (ItemLoader.ConsumeItem(inventory[n], this))
-								inventory[n].stack--;
+									inventory[n].stack--;
 								if (inventory[n].stack <= 0)
 									inventory[n].SetDefaults();
 
@@ -22758,19 +_,22 @@
 							NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
 					}
 				}
-				else if (Main.tile[myX, myY].type == 10) {
+				else if (Main.tile[myX, myY].type == TileID.ClosedDoor || TileLoader.OpenDoorID(Main.tile[myX, myY]) >= 0) {
 					flag2 = true;
 					if (WorldGen.IsLockedDoor(myX, myY)) {
 						int num43 = 1141;
 						for (int num44 = 0; num44 < 58; num44++) {
 							if (inventory[num44].type == num43 && inventory[num44].stack > 0) {
+								if (ItemLoader.ConsumeItem(inventory[num44], this))
-								inventory[num44].stack--;
+									inventory[num44].stack--;
 								if (inventory[num44].stack <= 0)
 									inventory[num44] = new Item();
 
 								WorldGen.UnlockDoor(myX, myY);
 								if (Main.netMode == 1)
 									NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
+
+								break;
 							}
 						}
 					}
@@ -22786,7 +_,7 @@
 						}
 					}
 				}
-				else if (Main.tile[myX, myY].type == 11) {
+				else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0) {
 					flag2 = true;
 					if (WorldGen.CloseDoor(myX, myY))
 						NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
@@ -22958,7 +_,7 @@
 					if (flag12)
 						NetMessage.SendTileSquare(-1, num62, num63, 2, 2);
 				}
-				else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
+				else if ((TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) && Main.tile[myX, myY].type < TileID.Count) {
 					flag2 = true;
 					Main.mouseRightRelease = false;
 					int num68 = 0;
@@ -23000,7 +_,7 @@
 						editedChestName = false;
 					}
 
-					bool flag13 = Chest.IsLocked(Main.tile[num69, num70]);
+					bool flag13 = Chest.IsLocked(num69, num70);
 					if (Main.netMode == 1 && num68 == 0 && !flag13) {
 						if (num69 == chestX && num70 == chestY && chest != -1) {
 							chest = -1;
@@ -23062,7 +_,9 @@
 												continue;
 
 											if (num72 != 329) {
+												if (ItemLoader.ConsumeItem(inventory[num75], this))
-												inventory[num75].stack--;
+													inventory[num75].stack--;
+
 												if (inventory[num75].stack <= 0)
 													inventory[num75] = new Item();
 											}
@@ -23120,13 +_,17 @@
 					if (flag15)
 						LaunchMinecartHook(myX, myY);
 				}
+
+				if (TileLoader.RightClick(myX, myY))
+					flag2 = true;
+				// todo check out this flag2. return? "this.releaseUseTile = false;"
 			}
 
 			if (flag2)
 				tileInteractionHappened = true;
 		}
 
-		private static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
+		public static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
 			short frameX = Main.tile[myX, myY].frameX;
 			bool flag = frameX / 72 == 1;
 			bool flag2 = frameX % 72 < 36;
@@ -23248,7 +_,14 @@
 				StopPettingAnimal();
 		}
 
+		/// <summary>
+		/// Handles boilerplate for gamepad and UI when opening or closing a container.
+		/// <br/>Sets <see cref="Player.chestX"/>, and <see cref="Player.chestY"/>, and <see cref="Player.chest"/> to the given coordinates.
+		/// </summary>
+		/// <param name="x">The top-left X coordinate of the container.</param>
+		/// <param name="y">The top-left Y coordinate of the container.</param>
+		/// <param name="newChest">The container index in <see cref="Main.chest"/> if opening, or -1 if closing.</param>
-		private void OpenChest(int x, int y, int newChest) {
+		public void OpenChest(int x, int y, int newChest) {
 			if (chest != -1 && Main.myPlayer == whoAmI) {
 				for (int i = 0; i < 40; i++) {
 					ItemSlot.SetGlow(i, -1f, chest: true);
@@ -24067,7 +_,7 @@
 				cursorItemIconID = 3747;
 			}
 
-			if (Main.tile[myX, myY].type == 219 && (inventory[selectedItem].type == 424 || inventory[selectedItem].type == 1103)) {
+			if (Main.tile[myX, myY].type == 219 && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1) {
 				noThrow = 2;
 				cursorItemIconEnabled = true;
 				cursorItemIconID = inventory[selectedItem].type;
@@ -24645,6 +_,8 @@
 				cursorItemIconEnabled = false;
 				cursorItemIconID = 0;
 			}
+
+			TileLoader.MouseOver(myX, myY);
 		}
 
 		public Color ChatColor() {
@@ -24778,11 +_,21 @@
 				if (!item.active || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item))
 					continue;
 
+				if (!ItemLoader.CanPickup(item, this))
+					continue;
+
 				int itemGrabRange = GetItemGrabRange(item);
 				Rectangle hitbox = item.Hitbox;
 				if (base.Hitbox.Intersects(hitbox)) {
-					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0))
+					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0)) {
+						if (!ItemLoader.OnPickup(Main.item[j], this)) {
+							Main.item[j] = new Item();
+							if (Main.netMode == 1)
+								NetMessage.SendData(21, -1, -1, null, j);
+							continue;
+						}
 						item = PickupItem(i, j, item);
+					}
 				}
 				else {
 					if (!new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2).Intersects(hitbox))
@@ -24791,7 +_,9 @@
 					ItemSpaceStatus status = ItemSpace(item);
 					if (CanPullItem(item, status)) {
 						item.beingGrabbed = true;
+						if (ItemLoader.GrabStyle(item, this)) {
+						}
-						if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
+						else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
 							PullItem_Pickup(item, 12f, 5);
 						else if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
 							PullItem_Pickup(item, 15f, 5);
@@ -24905,7 +_,12 @@
 			return itemToPickUp;
 		}
 
+		/// <summary>
+		/// Heals the player for a certain amount.
+		/// </summary>
+		/// <param name="player">The player to heal.</param>
+		/// <param name="amount">The amount to heal the player by.</param>
-		private void Heal(int amount) {
+		public void Heal(int amount) {
 			statLife += amount;
 			if (Main.myPlayer == whoAmI)
 				HealEffect(amount);
@@ -24914,7 +_,13 @@
 				statLife = statLifeMax2;
 		}
 
+		/// <summary>
+		/// Fetches the range at which the given item begins to gravitate towards the player.<br/>
+		/// This range, referred to as item grab range, is measured in pixels.
+		/// </summary>
+		/// <param name="item">The item whose grab range is being evaluated.</param>
+		/// <returns>The item grab range of the player, in pixels.</returns>
-		private int GetItemGrabRange(Item item) {
+		public int GetItemGrabRange(Item item) {
 			int num = defaultItemGrabRange;
 			if (goldRing && item.IsACoin)
 				num += Item.coinGrabRange;
@@ -24937,6 +_,7 @@
 			if (ItemID.Sets.NebulaPickup[item.type])
 				num += 100;
 
+			ItemLoader.GrabRange(item, this, ref num);
 			return num;
 		}
 
@@ -25347,7 +_,7 @@
 		public void AdjTiles() {
 			int num = 4;
 			int num2 = 3;
-			for (int i = 0; i < 625; i++) {
+			for (int i = 0; i < adjTile.Length; i++) {
 				oldAdjTile[i] = adjTile[i];
 				adjTile[i] = false;
 			}
@@ -25388,15 +_,17 @@
 								alchemyTable = true;
 								break;
 						}
+
+						TileLoader.AdjTiles(this, Main.tile[j, k].type);
 					}
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
 						adjWater = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
 						adjHoney = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
 						adjLava = true;
 				}
 			}
@@ -25405,7 +_,7 @@
 				return;
 
 			bool flag = false;
-			for (int l = 0; l < 625; l++) {
+			for (int l = 0; l < adjTile.Length; l++) {
 				if (oldAdjTile[l] != adjTile[l]) {
 					flag = true;
 					break;
@@ -25490,8 +_,9 @@
 			if (armor[12].legSlot >= 0)
 				legs = armor[12].legSlot;
 
-			if (!dead)
+			if (!dead) {
 				UpdateVisibleAccessories();
+			}
 
 			wearsRobe = false;
 			bool somethingSpecial = false;
@@ -25610,9 +_,14 @@
 				SetArmorEffectVisuals(this);
 			}
 
+			/*
 			hermesStepSound.SoundType = 17;
 			hermesStepSound.SoundStyle = -1;
+			*/
+			hermesStepSound.Style = SoundID.Run;
+			
 			hermesStepSound.IntendedCooldown = 9;
+
 			if (head == 99 && body == 65 && legs == 54)
 				turtleArmor = true;
 
@@ -25621,8 +_,12 @@
 
 			ApplyArmorSoundAndDustChanges();
 			if (legs == 140) {
+				/*
 				hermesStepSound.SoundType = 2;
 				hermesStepSound.SoundStyle = 24;
+				*/
+				hermesStepSound.Style = SoundID.Item24;
+
 				hermesStepSound.IntendedCooldown = 6;
 			}
 
@@ -25632,6 +_,7 @@
 				faceHead = -1;
 			}
 
+			ItemLoader.PreUpdateVanitySet(this);
 			if (head > 0 && face > 0) {
 				if (ArmorIDs.Face.Sets.OverrideHelmet[face]) {
 					head = -1;
@@ -25667,6 +_,9 @@
 				obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
 			}
 
+			//TODO: Do these hooks go inside or outside the conditional?
+			PlayerLoader.FrameEffects(this);
+			EquipLoader.EquipFrameEffects(this);
 			if (!isDisplayDollOrInanimate) {
 				if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0) {
 					int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
@@ -25791,6 +_,7 @@
 			Item.GetDrawHitbox(HeldItem.type, this);
 			bool flag3 = CanVisuallyHoldItem(HeldItem);
 			bool flag4 = HeldItem.type != 4952;
+			ItemLoader.UpdateVanitySet(this);
 			if (mount.Active) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * 6;
@@ -26007,6 +_,8 @@
 						}
 					}
 				}
+
+				ItemLoader.UseItemFrame(inventory[selectedItem], this);
 			}
 			else if (pulley) {
 				if (pulleyDir == 2)
@@ -26140,6 +_,10 @@
 				reference9.Y = 0;
 			}
 
+			if (flag3 && itemAnimation <= 0) {
+				ItemLoader.HoldItemFrame(inventory[selectedItem], this);
+			}
+
 			if (legs == 140) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
@@ -26220,6 +_,7 @@
 		}
 
 		private void UpdateVisibleAccessories() {
+			/*
 			for (int i = 3; i < 10; i++) {
 				if (!IsAValidEquipmentSlotForIteration(i))
 					continue;
@@ -26258,6 +_,24 @@
 						UpdateVisibleAccessory(j, item2);
 				}
 			}
+			*/
+			for (int i = 3; i < 10; i++) {
+				if (!IsAValidEquipmentSlotForIteration(i))
+					continue;
+
+				UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
+			}
+
+			PlayerLoader.UpdateVisibleAccessories(this);
+
+			for (int i = 13; i < 20; i++) {
+				if (!IsAValidEquipmentSlotForIteration(i))
+					continue;
+
+				UpdateVisibleAccessory(i, armor[i]);
+			}
+
+			PlayerLoader.UpdateVisibleVanityAccessories(this);
 
 			if (HeldItem.type == 4760 && ownedProjectileCounts[866] < 1) {
 				shield = 9;
@@ -26265,7 +_,7 @@
 			}
 		}
 
-		private bool ItemIsVisuallyIncompatible(Item item) {
+		public bool ItemIsVisuallyIncompatible(Item item) {
 			if (compositeBackArm.enabled && item.shieldSlot > 0)
 				return true;
 
@@ -26291,7 +_,7 @@
 			return false;
 		}
 
-		private void UpdateVisibleAccessory(int itemSlot, Item item) {
+		public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false) {
 			if (item.stringColor > 0)
 				stringColor = item.stringColor;
 
@@ -26357,8 +_,15 @@
 			if (item.wingSlot > 0)
 				wings = item.wingSlot;
 
-			if (item.type == 3580)
-				yoraiz0rEye = itemSlot - 2;
+			if (item.type == 3580) {
+				if (modded) {
+					// Treat similar to expert/master mode slots
+					yoraiz0rEye = 5 + itemSlot - 2;
+				}
+				else {
+					yoraiz0rEye = itemSlot - 2;
+				}
+			}
 
 			if (item.type == 3581)
 				yoraiz0rDarkness = true;
@@ -26513,6 +_,8 @@
 			if (drawPlayer.head == 267)
 				yoraiz0rDarkness = true;
 
+			ItemLoader.ArmorSetShadows(drawPlayer);
+			// TODO, rename to this? SetArmorEffectVisuals
 			if (drawPlayer.stoned || drawPlayer.stealth != 1f) {
 				armorEffectDrawOutlines = false;
 				armorEffectDrawShadow = false;
@@ -26693,6 +_,7 @@
 				}
 			}
 
+			ItemLoader.SetMatch(armorslot, type, male, ref num, ref somethingSpecial);
 			return num;
 		}
 
@@ -26877,6 +_,9 @@
 				}
 
 				immune = true;
+				if (dead)
+					PlayerLoader.OnRespawn(this);
+
 				dead = false;
 				immuneTime = 0;
 			}
@@ -27073,7 +_,7 @@
 			if (whoAmI != Main.myPlayer)
 				return;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] > 0 && buffType[i] == 59)
 					DelBuff(i);
 			}
@@ -27134,6 +_,7 @@
 				NetMessage.SendData(62, -1, -1, null, whoAmI, 1f);
 		}
 
+		//TODO: what does this method accomplish? Just determining frost and bone armor?
 		public void ApplyArmorSoundAndDustChanges() {
 			int num = armor[0].headSlot;
 			int num2 = armor[1].bodySlot;
@@ -27196,6 +_,12 @@
 					return 0.0;
 				}
 
+				bool customDamage = false;
+				bool playSound = true;
+				bool genGore = true;
+				if (!PlayerLoader.PreHurt(this, pvp, quiet, ref Damage, ref hitDirection, ref Crit, ref customDamage, ref playSound, ref genGore, ref damageSource, ref cooldownCounter))
+					return 0.0;
+
 				if (whoAmI == Main.myPlayer && panic)
 					AddBuff(63, 480);
 
@@ -27207,7 +_,7 @@
 					NetMessage.SendData(84, -1, -1, null, whoAmI);
 
 				int num = Damage;
-				double num2 = Main.CalculateDamagePlayersTake(num, statDefense);
+				double num2 = customDamage ? num : Main.CalculateDamagePlayersTake(num, statDefense);
 				if (Crit)
 					num *= 2;
 
@@ -27233,8 +_,18 @@
 						}
 					}
 
+					if (channel && inventory[selectedItem].InterruptChannelOnHurt) {
+						channel = false;
+					}
+
+					if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt) {
+						channel = false;
+						itemAnimation = 0;
+						itemAnimationMax = 0;
+					}
+
 					if (invis) {
-						for (int k = 0; k < 22; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] == 10)
 								DelBuff(k);
 						}
@@ -27266,7 +_,7 @@
 						float num5 = 0.15f * (float)beetleOrbs;
 						num2 = (int)((double)(1f - num5) * num2);
 						beetleOrbs--;
-						for (int l = 0; l < 22; l++) {
+						for (int l = 0; l < MaxBuffs; l++) {
 							if (buffType[l] >= 95 && buffType[l] <= 97)
 								DelBuff(l);
 						}
@@ -27358,6 +_,8 @@
 						Projectile.NewProjectile(GetProjectileSource_Accessory(brainOfConfusionItem), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
 					}
 
+					//TODO: Is 'num2' correct? Ensure and add patch context.
+					PlayerLoader.Hurt(this, pvp, quiet, num2, hitDirection, Crit, cooldownCounter);
 					if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet) {
 						if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart))
 							NetMessage.SendData(13, -1, -1, null, whoAmI);
@@ -27490,6 +_,9 @@
 						fallStart = (int)(position.Y / 16f);
 					}
 
+					if (!playSound)
+						goto PostSound;
+
 					if (stoned)
 						SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
 					else if ((wereWolf || forceWerewolf) && !hideWolf)
@@ -27504,7 +_,14 @@
 						SoundEngine.PlaySound(Male ? 1 : 20, position);
 
 					eyeHelper.BlinkBecausePlayerGotHurt();
+
+					PostSound:
+
 					if (statLife > 0) {
+						if (!genGore)
+							goto PostGore;
+
+						// Context: The patch that defines postGore used num2.
 						double num24 = num2 / (double)statLifeMax2 * 100.0;
 						float num25 = 2 * hitDirection;
 						float num26 = 0f;
@@ -27529,6 +_,10 @@
 								Dust.NewDust(position, width, height, 5, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
 							}
 						}
+
+						PostGore:
+
+						PlayerLoader.PostHurt(this, pvp, quiet, num2, hitDirection, Crit, cooldownCounter);
 					}
 					else {
 						statLife = 0;
@@ -27556,6 +_,13 @@
 				if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
 					FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
 
+				string moddedPlayerPathName = Path.ChangeExtension(Main.playerPathName, ".tplr");
+				if (FileUtilities.Exists(moddedPlayerPathName, isCloudSave))
+					FileUtilities.Delete(moddedPlayerPathName, isCloudSave);
+
+				if (FileUtilities.Exists(moddedPlayerPathName + ".bak", isCloudSave))
+					FileUtilities.Delete(moddedPlayerPathName + ".bak", isCloudSave);
+
 				Main.ActivePlayerFileData = new PlayerFileData();
 			}
 		}
@@ -27565,6 +_,11 @@
 				return;
 
 			StopVanityActions();
+			bool playSound = true;
+			bool genGore = true;
+			if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
+				return;
+
 			if (pvp)
 				pvpDeath = true;
 
@@ -27623,19 +_,24 @@
 				}
 			}
 
-			SoundEngine.PlaySound(5, (int)position.X, (int)position.Y);
+			if (playSound)
+				SoundEngine.PlaySound(5, (int)position.X, (int)position.Y, 1, 1f, 0f);
+
 			headVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			bodyVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			legVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
-			if (stoned) {
+			if (stoned || !genGore) {
 				headPosition = Vector2.Zero;
 				bodyPosition = Vector2.Zero;
 				legPosition = Vector2.Zero;
 			}
 
+			if (!genGore)
+				goto postGore; //goto minimizes diff file size
+
 			for (int j = 0; j < 100; j++) {
 				if (stoned) {
 					Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
@@ -27653,6 +_,7 @@
 				}
 			}
 
+			postGore:
 			mount.Dismount(this);
 			dead = true;
 			respawnTimer = 600;
@@ -27672,6 +_,7 @@
 			if (Main.expertMode)
 				respawnTimer = (int)((double)respawnTimer * 1.5);
 
+			PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
 			immuneAlpha = 0;
 			if (!ChildSafety.Disabled)
 				immuneAlpha = 255;
@@ -27748,6 +_,9 @@
 			if (newItem.uniqueStack && HasItem(newItem.type))
 				return new ItemSpaceStatus(CanTakeItem: false);
 
+			if (ItemLoader.ItemSpace(newItem, this))
+				return new ItemSpaceStatus(CanTakeItem: true);
+
 			int num = 50;
 			if (newItem.IsACoin)
 				num = 54;
@@ -27795,7 +_,8 @@
 			if (theSlot.type == 0)
 				return true;
 
-			if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			//if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot) && ItemLoader.CanStack(theSlot, theItemToAccept))
 				return true;
 
 			return false;
@@ -27961,7 +_,8 @@
 		}
 
 		private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i) {
-			if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
+			//if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
+			if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i]) && ItemLoader.CanStack(inv[i], returnItem)) {
 				if (newItem.IsACoin)
 					SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 				else
@@ -27990,7 +_,8 @@
 		}
 
 		private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i) {
-			if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
+			//if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
+			if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i]) && ItemLoader.CanStack(inventory[i], newItem)) {
 				if (newItem.IsACoin)
 					SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 				else
@@ -28098,6 +_,8 @@
 				return;
 
 			bool flag = true;
+			flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
+
 			if (TileReplacementEnabled)
 				flag = PlaceThing_TryReplacingWalls(flag);
 
@@ -28106,6 +_,7 @@
 
 			WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
 			if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall) {
+				WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 				ApplyItemTime(inventory[selectedItem], wallSpeed);
 				if (Main.netMode == 1)
 					NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
@@ -28164,7 +_,8 @@
 
 				WorldGen.PlaceWall(num, num2, createWall);
 				if (Main.tile[num, num2].wall == createWall) {
+					if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
-					inventory[selectedItem].stack--;
+						inventory[selectedItem].stack--;
 					if (inventory[selectedItem].stack == 0)
 						inventory[selectedItem].SetDefaults();
 
@@ -28196,9 +_,18 @@
 				bool canPlace = false;
 				bool newObjectType = false;
 				TileObject objectData = default(TileObject);
+				if (!TileLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createTile)) {
+				}
-				if (TileObjectData.CustomPlace(createTile, inventory[selectedItem].placeStyle) && createTile != 82 && createTile != 227) {
+				else if (TileObjectData.CustomPlace(createTile, inventory[selectedItem].placeStyle) && createTile != 82 && createTile != 227) {
 					newObjectType = true;
-					canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, (ushort)inventory[selectedItem].createTile, inventory[selectedItem].placeStyle, direction, out objectData);
+					int hackCreateTile = inventory[selectedItem].createTile;
+					int hackPlaceStyle = inventory[selectedItem].placeStyle;
+					if (hackCreateTile == TileID.Saplings) {
+						Tile soil = Main.tile[tileTargetX, tileTargetY + 1];
+						if (soil.active())
+							TileLoader.SaplingGrowthType(soil.type, ref hackCreateTile, ref hackPlaceStyle);
+					}
+					canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, hackCreateTile, hackPlaceStyle, direction, out objectData, false);
 					PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref canPlace, ref objectData);
 					PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref canPlace, ref objectData);
 					PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref canPlace, ref objectData);
@@ -28250,9 +_,12 @@
 				if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
 					return false;
 
+				if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
+					return false;
+
 				if (0 == 0) {
 					if (hitReplace.AddDamage(num, pickaxeDamage) < 100) {
-						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
 						for (int i = 0; i < num2; i++) {
 							WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
 						}
@@ -28420,8 +_,11 @@
 				PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
 				PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
 				PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches);
+				// Extra context.
 				if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
 					Main.blockMouse = true;
+
+				TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 			}
 
 			return data;
@@ -28609,7 +_,8 @@
 					int num7 = FindItem(849);
 					if (num7 > -1 && WorldGen.PlaceActuator(num5, num6)) {
 						NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
+						if (ItemLoader.ConsumeItem(inventory[num7], this))
-						inventory[num7].stack--;
+							inventory[num7].stack--;
 						if (inventory[num7].stack <= 0)
 							inventory[num7].SetDefaults();
 					}
@@ -28974,7 +_,7 @@
 				if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
 					canPlace = true;
 			}
-			else if (inventory[selectedItem].createTile == 4 || inventory[selectedItem].createTile == 136) {
+			else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136) {
 				if (Main.tile[tileTargetX, tileTargetY].wall > 0) {
 					canPlace = true;
 				}
@@ -29501,7 +_,8 @@
 
 			if (paintingAWall) {
 				if (b != byte.MaxValue && Main.tile[x, y].wallColor() != b && WorldGen.paintWall(x, y, b, broadCast: true)) {
+					if (ItemLoader.ConsumeItem(item, this))
-					item.stack--;
+						item.stack--;
 					if (item.stack <= 0)
 						item.SetDefaults();
 
@@ -29510,7 +_,8 @@
 				}
 			}
 			else if (b != byte.MaxValue && Main.tile[x, y].color() != b && WorldGen.paintTile(x, y, b, broadCast: true)) {
+				if (ItemLoader.ConsumeItem(item, this))
-				item.stack--;
+					item.stack--;
 				if (item.stack <= 0)
 					item.SetDefaults();
 
@@ -29560,7 +_,7 @@
 			int num2 = 25;
 			int num3 = 50;
 			int num4 = -1;
-			if (extractType == 1) {
+			if (extractType == ItemID.DesertFossil) {
 				num /= 3;
 				num2 *= 2;
 				num3 = 20;
@@ -29803,6 +_,8 @@
 					num6 += Main.rand.Next(0, 6);
 			}
 
+			ItemLoader.ExtractinatorUse(ref num5, ref num6, extractType);
+
 			if (num5 > 0) {
 				Vector2 vector = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
 				if (Main.SmartCursorIsUsed || PlayerInput.UsingGamepad)
@@ -29898,8 +_,8 @@
 
 		public PlayerFishingConditions GetFishingConditions() {
 			PlayerFishingConditions result = default(PlayerFishingConditions);
-			Fishing_GetBestFishingPole(out result.PolePower, out result.PoleItemType);
-			Fishing_GetBait(out result.BaitPower, out result.BaitItemType);
+			Fishing_GetBestFishingPole(out result.Pole);
+			Fishing_GetBait(out result.Bait);
 			if (result.BaitItemType == 2673)
 				return result;
 
@@ -29907,12 +_,12 @@
 				return result;
 
 			int num = result.BaitPower + result.PolePower + fishingSkill;
-			result.LevelMultipliers = Fishing_GetPowerMultiplier();
+			result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
 			result.FinalFishingLevel = (int)((float)num * result.LevelMultipliers);
 			return result;
 		}
 
-		private static float Fishing_GetPowerMultiplier() {
+		private float Fishing_GetPowerMultiplier(Item pole, Item bait) {
 			float num = 1f;
 			if (Main.raining)
 				num *= 1.2f;
@@ -29944,21 +_,20 @@
 			if (Main.bloodMoon)
 				num *= 1.1f;
 
+			PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
 			return num;
 		}
 
-		private void Fishing_GetBait(out int baitPower, out int baitType) {
-			baitPower = 0;
-			baitType = 0;
+		private void Fishing_GetBait(out Item bait) {
+			bait = null;
 			for (int i = 54; i < 58; i++) {
 				if (inventory[i].stack > 0 && inventory[i].bait > 0) {
-					baitPower = inventory[i].bait;
-					baitType = inventory[i].type;
+					bait = inventory[i];
 					break;
 				}
 			}
 
-			if (baitPower != 0 || baitType != 0)
+			if (bait != null)
 				return;
 
 			int num = 0;
@@ -29974,20 +_,17 @@
 				return;
 			}
 
-			baitPower = inventory[num].bait;
-			baitType = inventory[num].type;
+			bait = inventory[num];
 		}
 
-		private void Fishing_GetBestFishingPole(out int fishingPolePower, out int fishingPoleType) {
-			fishingPolePower = inventory[selectedItem].fishingPole;
-			fishingPoleType = inventory[selectedItem].type;
-			if (fishingPolePower != 0)
+		private void Fishing_GetBestFishingPole(out Item pole) {
+			pole = inventory[selectedItem];
+			if (pole.fishingPole != 0)
 				return;
 
 			for (int i = 0; i < 58; i++) {
-				if (inventory[i].fishingPole > fishingPolePower) {
+				if (inventory[i].fishingPole > pole.fishingPole) {
-					fishingPolePower = inventory[i].fishingPole;
+					pole = inventory[i];
-					fishingPoleType = inventory[i].type;
 				}
 			}
 		}
@@ -30015,7 +_,8 @@
 				return;
 			}
 
+			if (ItemLoader.ConsumeItem(inventory[num], this))
-			inventory[num].stack--;
+				inventory[num].stack--;
 			if (inventory[num].stack <= 0)
 				inventory[num].SetDefaults();
 		}
@@ -30177,6 +_,9 @@
 		}
 
 		public Rectangle GetItemDrawFrame(int type) {
+			if(Main.dedServ)
+				return Rectangle.Empty;
+
 			Main.instance.LoadItem(type);
 			if (type == 75)
 				return TextureAssets.Item[type].Frame(1, 8);
@@ -30184,11 +_,20 @@
 			return TextureAssets.Item[type].Frame();
 		}
 
+		/// <summary>
+		/// Used to determine what the overall scale of an item should be.<br></br>
+		/// <see cref="CombinedHooks.ModifyItemScale"/> is called here.
+		/// </summary>
+		/// <param name="item">The item to fetch the adjusted scale of.</param>
+		/// <returns>
+		/// The final scale of the item, after the Titan Glove effect and all modded calculations.
+		/// </returns>
 		public float GetAdjustedItemScale(Item item) {
 			float num = item.scale;
 			if (item.melee && meleeScaleGlove)
 				num *= 1.1f;
 
+			CombinedHooks.ModifyItemScale(this, item, ref num);
 			return num;
 		}
 
@@ -30204,6 +_,12 @@
 		}
 
 		public void ItemCheck(int i) {
+			if (PlayerLoader.PreItemCheck(this))
+				ItemCheck_Inner(i);
+
+			PlayerLoader.PostItemCheck(this);
+		}
+		private void ItemCheck_Inner(int i) {
 			if (CCed) {
 				channel = false;
 				itemAnimation = (itemAnimationMax = 0);
@@ -30216,6 +_,57 @@
 			if (Main.myPlayer == i && PlayerInput.ShouldFastUseItem)
 				controlUseItem = true;
 
+			// #2351
+			// tML is motivated to bring the itemAnimation and itemTime counters to parity, fixing desync bugs with autoReuse items and providing clearer behaviour
+			//
+			// the flow of this method has changed as follows
+			// VANILLA:
+			// 1. Reuse delay is applied
+			// 2. Item animation is applied if button is pressed
+			// 3. Item animation is reduced
+			// 4. Hold / Use styles are invoked
+			// 5. 'releaseUseItem' is set
+			// 6. Item time is reduced
+			// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+			// 8. ItemCheck_GetMeleeHitbox/MeleeDamage/CutTiles if (itemAnimation > 0)
+			// 9. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+			// 
+			// TML:
+			// 1. Item animation is reduced
+			// 2. Item time is reduced
+			// 3. Reuse delay is applied
+			// 4. Item animation is applied if button is pressed
+			// 5. Hold / Use styles are invoked
+			// 6. 'releaseUseItem' is set
+			// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+			// 8. ItemCheck_GetMeleeHitbox/MeleeDamage/CutTiles if (itemAnimation > 0)
+			// 9. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+			//
+			// At the end of ItemCheck:
+			//   VANILLA: itemAnimation goes from itemAnimationMax-1 to 0, before it can restart
+			//   TML:     itemAnimation goes from itemAnimationMax to 1, before it can restart
+			//
+			//   VANILLA: If the item has autoReuse, then it can restart at itemAnimation = 1, making the actual animation one frame shorter than expected.
+			//            If a reusuable item has equal itemAnimation and itemTime, the animation will be faster, and they will start to fire at different times
+			//
+			//   TML:     ItemCheck_HandleMPItemAnimation unnecessary. Animation times for modded items as written. See Item.ApplyItemAnimationCompensations
+			//
+			//   VANILLA: All items which don't have autoReuse get 1 frame where itemAnimation == 0, this is often used to despawn projectiles
+			//   TML:     There will be no frame with itemAnimation == 0 if an item is 'reused immediately', via autoReuse, knockbackGlove, or perfect click timing.
+			//            bound projectiles should despawn in the frame of itemAnimation <= 1, after doing damage.
+			//            Player.ItemAnimationEndingOrEnded has been made for this purpose but its use is not recommended due to potential for multiplayer desync.
+			//            Better to have ai counters for projectile lifetime set to itemAnimationMax on spawn
+			//
+			//   VANILLA: hitbox calulation and duration is based on an itemAnimation value between itemAnimationMax-1 and 1, resulting in itemAnimationMax-1 frames of hitbox
+			//   TML:     hitbox lasts the same length as itemAnimation, slightly more backswing (rotation) in the first frame
+			//
+			//   VANILLA: itemTime goes from itemTimeMax to 1, before it can restart, 0 means not using item
+			//   TML:     no change
+
+			goto DecrementItemAnimation;
+
+			ReuseDelayAndAnimationStart:
+
 			ItemCheck_HandleMount();
 			int weaponDamage = GetWeaponDamage(item);
 			ItemCheck_HandleMPItemAnimation(item);
@@ -30229,8 +_,17 @@
 			if (itemAnimation == 0 && reuseDelay > 0)
 				ApplyReuseDelay();
 
-			if (Main.myPlayer == i && itemAnimation == 0 && TileObjectData.CustomPlace(item.createTile, item.placeStyle))
-				TileObject.CanPlace(tileTargetX, tileTargetY, item.createTile, item.placeStyle, direction, out TileObject _, onlyCheck: true);
+			if (Main.myPlayer == i && itemAnimation == 0 && TileObjectData.CustomPlace(item.createTile, item.placeStyle)) {
+				int hackCreateTile = item.createTile;
+				int hackPlaceStyle = item.placeStyle;
+				if (hackCreateTile == TileID.Saplings) {
+					Tile soil = Main.tile[tileTargetX, tileTargetY + 1];
+					if (soil.active())
+						TileLoader.SaplingGrowthType(soil.type, ref hackCreateTile, ref hackPlaceStyle);
+				}
+
+				TileObject.CanPlace(tileTargetX, tileTargetY, hackCreateTile, hackPlaceStyle, direction, out _, true);
+			}
 
 			if (itemAnimation == 0 && altFunctionUse == 2)
 				altFunctionUse = 0;
@@ -30259,7 +_,7 @@
 				if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
 					mount.SetMount(item.mountType, this);
 
-				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && item.shoot < 972 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
+				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
 					FreeUpPetsAndMinions(item);
 
 				if (flag3)
@@ -30269,6 +_,10 @@
 			if (!controlUseItem)
 				channel = false;
 
+			goto HoldAndUseStyle;
+
+			DecrementItemAnimation:
+
 			Item item2 = (itemAnimation > 0) ? lastVisualizedSelectedItem : item;
 			Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
 			compositeFrontArm.enabled = false;
@@ -30289,12 +_,22 @@
 				itemAnimation--;
 			}
 
+			goto DecrementItemTime;
+
+			HoldAndUseStyle:
+
+			ItemLoader.HoldItem(item, this);
+
 			if (itemAnimation > 0)
 				ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 			else
 				ItemCheck_ApplyHoldStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 
 			releaseUseItem = !controlUseItem;
+			goto ItemTimeUseItem;
+
+			DecrementItemTime:
+
 			if (itemTime > 0) {
 				itemTime--;
 				if (ItemTimeIsZero && whoAmI == Main.myPlayer) {
@@ -30308,30 +_,40 @@
 				}
 			}
 
+			goto ReuseDelayAndAnimationStart;
+
+			ItemTimeUseItem:
+
 			if (!JustDroppedAnItem) {
 				ItemCheck_EmitHeldItemLight(item);
 				ItemCheck_EmitFoodParticles(item);
 				ItemCheck_EmitDrinkParticles(item);
+
+				// TML attempts to make ApplyItemTime calls run on remote players, so this check is removed. #ItemTimeOnAllClients
-				if (whoAmI == Main.myPlayer) {
+				// if (whoAmI == Main.myPlayer) {
+				if (true) { 
 					bool flag4 = true;
 					int type2 = item.type;
-					if ((type2 == 65 || type2 == 676 || type2 == 723 || type2 == 724 || type2 == 757 || type2 == 674 || type2 == 675 || type2 == 989 || type2 == 1226 || type2 == 1227) && itemAnimation != itemAnimationMax - 1)
+					if ((type2 == 65 || type2 == 676 || type2 == 723 || type2 == 724 || type2 == 757 || type2 == 674 || type2 == 675 || type2 == 989 || type2 == 1226 || type2 == 1227) && !ItemAnimationJustStarted)
 						flag4 = false;
 
-					if (type2 == 5097 && itemAnimation == itemAnimationMax - 1)
+					if (type2 == 5097 && ItemAnimationJustStarted)
 						_batbatCanHeal = true;
 
-					if (type2 == 5094 && itemAnimation == itemAnimationMax - 1)
+					if (type2 == 5094 && ItemAnimationJustStarted)
 						_spawnTentacleSpikes = true;
 
 					if (type2 == 3852) {
+						/* handled by Item.useLimitPerAnimation
 						if (itemAnimation < itemAnimationMax - 12)
 							flag4 = false;
+						*/
 
-						if (altFunctionUse == 2 && itemAnimation != itemAnimationMax - 1)
+						if (altFunctionUse == 2 && !ItemAnimationJustStarted)
 							flag4 = false;
 					}
 
+					/* Eventide and nightglow handled by Item.useLimitPerAnimation. Zenith use limit didn't do anything anyway
 					if (type2 == 4956 && itemAnimation < itemAnimationMax - 3 * item.useTime)
 						flag4 = false;
 
@@ -30340,12 +_,20 @@
 
 					if (type2 == 4953 && itemAnimation < itemAnimationMax - 10)
 						flag4 = false;
+					*/
+
+					if (item.useLimitPerAnimation != null && ItemUsesThisAnimation >= item.useLimitPerAnimation.Value)
+						flag4 = false;
 
 					ItemCheck_TurretAltFeatureUse(item, flag4);
 					ItemCheck_MinionAltFeatureUse(item, flag4);
 					if (item.shoot > 0 && itemAnimation > 0 && ItemTimeIsZero && flag4)
 						ItemCheck_Shoot(i, item, weaponDamage);
 
+					// Added by TML. #ItemTimeOnAllClients - TODO: item time application with these item types
+					if (whoAmI != Main.myPlayer)
+						goto endItemChecks;
+
 					ItemCheck_UseWiringTools(item);
 					ItemCheck_UseLawnMower(item);
 					ItemCheck_PlayInstruments(item);
@@ -30390,13 +_,14 @@
 						Vector2 vector = DirectionTo(ApplyRangeCompensation(0.2f, center, Main.MouseWorld)) * 10f;
 						Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, vector.X, vector.Y, 532, 25, 5f, whoAmI);
 					}
+					endItemChecks: {}
 				}
 
-				if (((item.damage >= 0 && item.type > 0 && !item.noMelee) || item.type == 1450 || item.type == 1991 || item.type == 3183 || item.type == 4821 || item.type == 3542 || item.type == 3779) && itemAnimation > 0) {
+				if (((item.damage >= 0 && item.type > 0 && !item.noMelee) || item.type == 1450 || ItemID.Sets.CatchingTool[item.type] || item.type == 3542 || item.type == 3779) && itemAnimation > 0) {
 					ItemCheck_GetMeleeHitbox(item, drawHitbox, out bool dontAttack, out Rectangle itemRectangle);
 					if (!dontAttack) {
 						itemRectangle = ItemCheck_EmitUseVisuals(item, itemRectangle);
-						if (Main.myPlayer == whoAmI && (item.type == 1991 || item.type == 3183 || item.type == 4821))
+						if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[item.type])
 							itemRectangle = ItemCheck_CatchCritters(item, itemRectangle);
 
 						if (item.type == 3183 || item.type == 4821) {
@@ -30406,7 +_,8 @@
 
 						if (Main.myPlayer == i && item.damage > 0) {
 							int num = weaponDamage;
-							float knockBack = item.knockBack;
+							float knockBack = GetWeaponKnockback(item, item.knockBack);
+							/*
 							float num2 = 1f;
 							if (kbGlove)
 								num2 += 1f;
@@ -30417,6 +_,7 @@
 							knockBack *= num2;
 							if (inventory[selectedItem].type == 3106)
 								knockBack += knockBack * (1f - stealth);
+							*/
 
 							List<ushort> ignoreList2 = ItemCheck_GetTileCutIgnoreList(item);
 							ItemCheck_CutTiles(item, itemRectangle, ignoreList2);
@@ -30428,27 +_,32 @@
 				}
 
 				if (ItemTimeIsZero && itemAnimation > 0) {
+					if (ItemLoader.UseItem(item, this) == true)
+						ApplyItemTime(item, callUseItem: false);
+
 					if (item.hairDye >= 0) {
 						ApplyItemTime(item);
 						if (whoAmI == Main.myPlayer) {
-							hairDye = (byte)item.hairDye;
+							hairDye = item.hairDye;
 							NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 					}
 
 					if (item.healLife > 0) {
+						int healLife = GetHealLife(item);
-						statLife += item.healLife;
+						statLife += healLife;
 						ApplyItemTime(item);
-						if (Main.myPlayer == whoAmI)
-							HealEffect(item.healLife);
+						if (healLife > 0 && Main.myPlayer == whoAmI)
+							HealEffect(healLife, true);
 					}
 
 					if (item.healMana > 0) {
+						int healMana = GetHealMana(item);
-						statMana += item.healMana;
+						statMana += healMana;
 						ApplyItemTime(item);
-						if (Main.myPlayer == whoAmI) {
+						if (healMana > 0 && Main.myPlayer == whoAmI) {
 							AddBuff(94, manaSickTime);
-							ManaEffect(item.healMana);
+							ManaEffect(healMana);
 						}
 					}
 
@@ -30553,7 +_,7 @@
 					if (ItemTimeIsZero) {
 						ApplyItemTime(item);
 					}
-					else if (itemTime == item.useTime / 2) {
+					else if (itemTime == itemTimeMax / 2) {
 						for (int k = 0; k < 70; k++) {
 							Dust.NewDust(base.position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
 						}
@@ -30642,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30668,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30683,7 +_,7 @@
 						else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
 							NetMessage.SendData(73);
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30699,11 +_,11 @@
 								NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 					else {
-						float num10 = item.useTime;
+						float num10 = itemTimeMax;
 						num10 = (num10 - (float)itemTime) / num10;
 						float num11 = 44f;
 						float num12 = (float)Math.PI * 3f;
@@ -30737,11 +_,12 @@
 				}
 
 				if (i == Main.myPlayer) {
-					if (!dontConsumeWand && itemTime == (int)((float)item.useTime * tileSpeed) && item.tileWand > 0) {
+					if (itemTimeMax != 0 && item.tileWand > 0 && !dontConsumeWand && itemTime == itemTimeMax) {
 						int tileWand = item.tileWand;
 						for (int num15 = 0; num15 < 58; num15++) {
 							if (tileWand == inventory[num15].type && inventory[num15].stack > 0) {
+								if (ItemLoader.ConsumeItem(inventory[num15], this))
-								inventory[num15].stack--;
+									inventory[num15].stack--;
 								if (inventory[num15].stack <= 0)
 									inventory[num15] = new Item();
 
@@ -30773,7 +_,7 @@
 						if (flag7.HasValue)
 							flag6 = flag7.Value;
 
-						if (flag6) {
+						if (flag6 && ItemLoader.ConsumeItem(item, this)) {
 							if (item.stack > 0)
 								item.stack--;
 
@@ -31056,11 +_,18 @@
 				if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !itemRectangle.Intersects(player.Hitbox) || !CanHit(player))
 					continue;
 
+				if (!ItemLoader.CanHitPvp(sItem, this, player) || !PlayerLoader.CanHitPvp(this, sItem, player))
+					continue; //TODO: PvP crit hook?
+
 				bool flag = false;
 				if (Main.rand.Next(1, 101) <= 10)
 					flag = true;
 
 				int num = Main.DamageVar(damage, luck);
+
+				ItemLoader.ModifyHitPvp(sItem, this, player, ref num, ref flag);
+				PlayerLoader.ModifyHitPvp(this, sItem, player, ref num, ref flag);
+
 				StatusToPlayerPvP(sItem.type, i);
 				OnHit(player.Center.X, player.Center.Y, player);
 				PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayer(whoAmI);
@@ -31099,12 +_,17 @@
 					}
 				}
 
+				// Extra context
+
 				if (inventory[selectedItem].type == 3106) {
 					stealth = 1f;
 					if (Main.netMode == 1)
 						NetMessage.SendData(84, -1, -1, null, whoAmI);
 				}
 
+				ItemLoader.OnHitPvp(sItem, this, Main.player[i], num2, flag);
+				PlayerLoader.OnHitPvp(this, sItem, Main.player[i], num2, flag);
+
 				if (Main.netMode != 0)
 					NetMessage.SendPlayerHurt(i, playerDeathReason, num, direction, flag, pvp: true, -1);
 
@@ -31142,11 +_,18 @@
 				if (!Main.npc[i].active || Main.npc[i].immune[whoAmI] != 0 || attackCD != 0)
 					continue;
 
+				bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, Main.npc[i]);
+
+				if (modCanHit == false) {
+					continue;
+				}
+
 				Main.npc[i].position += Main.npc[i].netOffset;
-				if (!Main.npc[i].dontTakeDamage && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[i])) {
-					if (!Main.npc[i].friendly || (Main.npc[i].type == 22 && killGuide) || (Main.npc[i].type == 54 && killClothier)) {
+				if (modCanHit == true || ((!Main.npc[i].dontTakeDamage && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[i])))) {
+					if (modCanHit == true || ((!Main.npc[i].friendly || (Main.npc[i].type == 22 && killGuide) || (Main.npc[i].type == 54 && killClothier)))) {
 						Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
+
-						if (itemRectangle.Intersects(value) && (Main.npc[i].noTileCollide || CanHit(Main.npc[i]))) {
+						if (modCanHit == true || (itemRectangle.Intersects(value) && (Main.npc[i].noTileCollide || CanHit(Main.npc[i])))) {
 							int num = originalDamage;
 							bool flag = false;
 							int weaponCrit = GetWeaponCrit(sItem);
@@ -31194,15 +_,25 @@
 							}
 
 							int num6 = Main.DamageVar(num, luck);
+
+							ItemLoader.ModifyHitNPC(sItem, this, Main.npc[i], ref num6, ref knockBack, ref flag);
+							NPCLoader.ModifyHitByItem(Main.npc[i], this, sItem, ref num6, ref knockBack, ref flag);
+							PlayerLoader.ModifyHitNPC(this, sItem, Main.npc[i], ref num6, ref knockBack, ref flag);
+
 							StatusToNPC(sItem.type, i);
 							if (Main.npc[i].life > 5)
 								OnHit(Main.npc[i].Center.X, Main.npc[i].Center.Y, Main.npc[i]);
 
-							if (armorPenetration > 0)
+							if (GetWeaponArmorPenetration(sItem) > 0)
-								num6 += Main.npc[i].checkArmorPenetration(armorPenetration);
+								num6 += Main.npc[i].checkArmorPenetration(GetWeaponArmorPenetration(sItem));
 
 							NPCKillAttempt attempt = new NPCKillAttempt(Main.npc[i]);
 							int dmgDone = (int)Main.npc[i].StrikeNPC(num6, knockBack, direction, flag);
+
+							ItemLoader.OnHitNPC(sItem, this, Main.npc[i], dmgDone, knockBack, flag);
+							NPCLoader.OnHitByItem(Main.npc[i], this, sItem, dmgDone, knockBack, flag);
+							PlayerLoader.OnHitNPC(this, sItem, Main.npc[i], dmgDone, knockBack, flag);
+
 							ApplyNPCOnHitEffects(sItem, itemRectangle, num, knockBack, i, num6, dmgDone);
 							int num7 = Item.NPCtoBanner(Main.npc[i].BannerID());
 							if (num7 >= 0)
@@ -31438,11 +_,13 @@
 		}
 
 		private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle) {
-			bool flag = sItem.type == 3183 || sItem.type == 4821;
+			//bool flag = sItem.type == 3183 || sItem.type == 4821; // effectively replaced by ItemID.Sets.LavaproofCatchingTool
 			for (int i = 0; i < 200; i++) {
 				if (!Main.npc[i].active || Main.npc[i].catchItem <= 0)
 					continue;
 
+				NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
+				/*
 				Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
 				if (!itemRectangle.Intersects(value))
 					continue;
@@ -31458,6 +_,7 @@
 				else {
 					NPC.CatchNPC(i, whoAmI);
 				}
+				*/
 			}
 
 			return itemRectangle;
@@ -31738,6 +_,9 @@
 				Main.dust[num30].velocity.Y *= 2f;
 			}
 
+			ItemLoader.MeleeEffects(sItem, this, itemRectangle);
+			PlayerLoader.MeleeEffects(this, sItem, itemRectangle);
+
 			return itemRectangle;
 		}
 
@@ -31816,6 +_,7 @@
 				}
 			}
 
+			ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
 			if (sItem.type == 1450 && Main.rand.Next(3) == 0) {
 				int num3 = -1;
 				float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
@@ -32078,7 +_,7 @@
 
 			if (toolTime == 0 && itemAnimation > 0 && controlUseItem) {
 				Tile tile = Main.tile[tileTargetX, tileTargetY];
-				if (!tile.active() || IsTilePoundable(tile))
+				if (!tile.active() || IsTilePoundable(tile) && !TileID.Sets.CanBeSloped[tile.type])
 					poundRelease = false;
 			}
 
@@ -32127,7 +_,7 @@
 			if (Main.tileHammer[tile.type]) {
 				canHitWalls = false;
 				if (sItem.hammer > 0) {
-					num2 += sItem.hammer;
+					TileLoader.MineDamage(sItem.hammer, ref num2);
 					if (!WorldGen.CanKillTile(x, y))
 						num2 = 0;
 
@@ -32157,7 +_,10 @@
 				}
 			}
 			else if (Main.tileAxe[tile.type]) {
-				num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
+				if (tile.type == 80)
+					num2 += (int)(sItem.axe * 3 * 1.2f);
+				else
+					TileLoader.MineDamage(sItem.axe, ref num2);
 				if (sItem.axe > 0) {
 					AchievementsHelper.CurrentlyMining = true;
 					if (!WorldGen.CanKillTile(x, y))
@@ -32310,7 +_,11 @@
 
 		private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y) {
 			Tile tile = Main.tile[x, y];
-			if (sItem.hammer > 0 && tile.active() && (Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442) && poundRelease) {
+
+			bool canTrySloping = sItem.hammer > 0 && tile.active() && poundRelease;
+			bool vanillaSloping = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
+
+			if (canTrySloping && (vanillaSloping || TileID.Sets.CanBeSloped[tile.type])) {
 				hitWall = false;
 				ApplyItemTime(sItem);
 				int damageAmount = 100;
@@ -32322,7 +_,10 @@
 					if (!poundRelease)
 						return;
 
+					if (TileLoader.Slope(x, y, Main.tile[x, y].type)) {
+						; // Nothing!
+					}
-					if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
+					else if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
 						if (tile.halfBrick()) {
 							WorldGen.PoundTile(x, y);
 							if (Main.netMode == 1)
@@ -32777,7 +_,7 @@
 				}
 			}
 
-			if (sItem.type == 4715 && ((Main.mouseLeft && Main.mouseLeftRelease) | (itemAnimation == itemAnimationMax - 1))) {
+			if (sItem.type == 4715 && ((Main.mouseLeft && Main.mouseLeftRelease) | (ItemAnimationJustStarted))) {
 				Vector2 vector4 = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 				float num13 = (float)Main.mouseX + Main.screenPosition.X - vector4.X;
 				float num14 = (float)Main.mouseY + Main.screenPosition.Y - vector4.Y;
@@ -32914,7 +_,8 @@
 				}
 
 				if (num3 >= 0 && WorldGen.PlaceWire(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num3], this))
-					inventory[num3].stack--;
+						inventory[num3].stack--;
 					if (inventory[num3].stack <= 0)
 						inventory[num3].SetDefaults();
 
@@ -32932,7 +_,8 @@
 				}
 
 				if (num4 >= 0 && WorldGen.PlaceWire2(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num4], this))
-					inventory[num4].stack--;
+						inventory[num4].stack--;
 					if (inventory[num4].stack <= 0)
 						inventory[num4].SetDefaults();
 
@@ -32951,7 +_,8 @@
 				}
 
 				if (num5 >= 0 && WorldGen.PlaceWire3(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num5], this))
-					inventory[num5].stack--;
+						inventory[num5].stack--;
 					if (inventory[num5].stack <= 0)
 						inventory[num5].SetDefaults();
 
@@ -32970,7 +_,8 @@
 				}
 
 				if (num6 >= 0 && WorldGen.PlaceWire4(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num6], this))
-					inventory[num6].stack--;
+						inventory[num6].stack--;
 					if (inventory[num6].stack <= 0)
 						inventory[num6].SetDefaults();
 
@@ -33003,7 +_,8 @@
 			else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2)) {
 				ApplyItemTime(sItem);
 				NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
+				if (ItemLoader.ConsumeItem(sItem, this))
-				sItem.stack--;
+					sItem.stack--;
 				if (sItem.stack <= 0)
 					sItem.SetDefaults();
 			}
@@ -33081,16 +_,28 @@
 		}
 
 		private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage) {
+			if (!CombinedHooks.CanShoot(this, sItem))
+				return;
+
 			int projToShoot = sItem.shoot;
 			float speed = sItem.shootSpeed;
 			int damage = sItem.damage;
-			if (sItem.melee && projToShoot != 699 && projToShoot != 707 && (uint)(projToShoot - 877) > 2u)
-				speed /= meleeSpeed;
+			if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
+				speed /= inverseMeleeSpeed;
+
+			// Copied as-is from 1.3
+			if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f) {
+				speed *= ThrownVelocity;
+				if (speed > 16f)
+					speed = 16f;
+			}
 
 			bool canShoot = false;
 			int Damage = weaponDamage;
 			float KnockBack = sItem.knockBack;
+
+			// WhoAmI check added by TML. #ItemTimeOnAllClients
-			if (projToShoot == 13 || projToShoot == 32 || projToShoot == 315 || (projToShoot >= 230 && projToShoot <= 235) || projToShoot == 331) {
+			if (whoAmI == Main.myPlayer && (projToShoot == 13 || projToShoot == 32 || projToShoot == 315 || (projToShoot >= 230 && projToShoot <= 235) || projToShoot == 331)) {
 				grappling[0] = -1;
 				grapCount = 0;
 				for (int j = 0; j < 1000; j++) {
@@ -33160,6 +_,12 @@
 			}
 
 			if (canShoot) {
+				// Added by TML. #ItemTimeOnAllClients
+				if (whoAmI != Main.myPlayer) {
+					ApplyItemTime(sItem);
+					return;
+				}
+
 				KnockBack = GetWeaponKnockback(sItem, KnockBack);
 				IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
 				if (projToShoot == 228)
@@ -33192,7 +_,7 @@
 				Vector2 value = Vector2.UnitX.RotatedBy(fullRotation);
 				Vector2 vector = Main.MouseWorld - pointPoisition;
 				Vector2 v = itemRotation.ToRotationVector2() * direction;
-				if (sItem.type == 3852 && itemAnimation != itemAnimationMax - 1)
+				if (sItem.type == 3852 && !ItemAnimationJustStarted)
 					vector = (v.ToRotation() + fullRotation).ToRotationVector2();
 
 				if (vector != Vector2.Zero)
@@ -33241,7 +_,7 @@
 
 				float num2 = (float)Main.mouseX + Main.screenPosition.X - pointPoisition.X;
 				float num3 = (float)Main.mouseY + Main.screenPosition.Y - pointPoisition.Y;
-				if (sItem.type == 3852 && itemAnimation != itemAnimationMax - 1) {
+				if (sItem.type == 3852 && !ItemAnimationJustStarted) {
 					Vector2 vector3 = vector;
 					num2 = vector3.X;
 					num3 = vector3.Y;
@@ -33298,6 +_,13 @@
 					num3 = vector4.Y;
 				}
 
+				goto DirtBallShoot;
+				ShootHook:
+				Vector2 velocity = new Vector2(num2, num3);
+				CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
+				num2 = velocity.X;
+				num3 = velocity.Y;
+
 				if (sItem.useStyle == 5) {
 					if (sItem.type == 3029) {
 						Vector2 vector5 = new Vector2(num2, num3);
@@ -33333,6 +_,11 @@
 					NetMessage.SendData(41, -1, -1, null, whoAmI);
 				}
 
+				if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
+					return;
+
+				goto ShootProj;
+				DirtBallShoot:
 				if (projToShoot == 17) {
 					pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
 					pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
@@ -33341,6 +_,8 @@
 
 					LimitPointToPlayerReachableArea(ref pointPoisition);
 				}
+				goto ShootHook;
+				ShootProj:
 
 				if (projToShoot == 76) {
 					projToShoot += Main.rand.Next(3);
@@ -34526,6 +_,10 @@
 				}
 			}
 			else if (sItem.useStyle == 5 || sItem.useStyle == 13) {
+				// Added by TML. #ItemTimeOnAllClients
+				if (whoAmI != Main.myPlayer)
+					return;
+
 				itemRotation = 0f;
 				NetMessage.SendData(41, -1, -1, null, whoAmI);
 			}
@@ -34695,6 +_,9 @@
 				return;
 			}
 
+			if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
+				return;
+
 			for (int num = 19; num >= 0; num--) {
 				if (IsAValidEquipmentSlotForIteration(num)) {
 					_ = num % 10;
@@ -34727,6 +_,11 @@
 		private void ItemCheck_MinionAltFeatureUse(Item sItem, bool cShoot) {
 			if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+
+				// Added by TML. #ItemTimeOnAllClients
+				if (whoAmI != Main.myPlayer)
+					return;
+
 				MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
 			}
 		}
@@ -34736,6 +_,11 @@
 				return;
 
 			ApplyItemTime(sItem);
+
+			// Added by TML. #ItemTimeOnAllClients
+			if (whoAmI != Main.myPlayer)
+				return;
+
 			for (int i = 0; i < 1000; i++) {
 				Projectile projectile = Main.projectile[i];
 				if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
@@ -35049,6 +_,11 @@
 		}
 
 		private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.HoldStyle(sItem, this, heldItemFrame);
+		}
+
+		private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (isPettingAnimal) {
 				int num = miscCounter % 14 / 7;
 				CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
@@ -35291,10 +_,13 @@
 				SetCompositeArmBack(enabled: true, stretch6, (float)Math.PI * -3f / 5f * (float)direction);
 				FlipItemLocationAndRotationForGravity();
 			}
+			//else if (!Main.dedServ) { // Added by TML.
+			//	ItemLoader.UseStyle(sItem, this);
+			//}
 		}
 
 		private void ItemCheck_ApplyManaRegenDelay(Item sItem) {
-			if (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))
+ 			if (GetManaCost(sItem) > 0)
 				manaRegenDelay = (int)maxRegenDelay;
 		}
 
@@ -35355,6 +_,10 @@
 		}
 
 		public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.UseStyle(sItem, this, heldItemFrame);
+		}
+		public void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (Main.dedServ)
 				return;
 
@@ -36086,6 +_,9 @@
 		}
 
 		private bool ItemCheck_CheckCanUse(Item sItem) {
+			if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
+				return false;
+
 			int whoAmI = base.whoAmI;
 			bool flag = true;
 			int num = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
@@ -36414,7 +_,7 @@
 			if (baitTypeUsed == 2673)
 				flag = true;
 
-			if (flag) {
+			if (CombinedHooks.CanConsumeBait(this, item) ?? flag) {
 				if (item.type == 4361 || item.type == 4362)
 					NPC.LadyBugKilled(base.Center, item.type == 4362);
 
@@ -36456,6 +_,11 @@
 			if (sItem.type == 3006)
 				flag2 = true;
 
+			if (sItem.type != ItemID.MedusaHead /*3269*/ && !CheckMana(sItem, pay:!flag2))
+				canUse = false;
+
+			return canUse; //TODO: Explain this in a comment.
+
 			if (sItem.type != 3269 && (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))) {
 				if (statMana >= num) {
 					if (!flag2)
@@ -36621,6 +_,13 @@
 		}
 
 		private void ItemCheck_HandleMPItemAnimation(Item sItem) {
+			// Firstly, in vanilla, autoReuse items go from itemAnimation == 1 to itemAnimationMax-1 here, skipping the frame where itemAnimation == 0
+			//   this prevents the item flickering out while being auto-reused, and prevents other control inputs that can happen on that 'frame where item is not in use' like useTurn
+			//   but has the side-effect that autoReuse items are one frame shorter. tML fixes the itemAnimation counter, see the comments near the top of ItemCheck_Inner (#2351)
+			//
+			// Secondly, we don't need to play the shoot-sound and ensure hold-out animation looping for remote players because Shoot logic now runs remote side in tML (#ItemTimeOnAllClients)
+
+			/*
 			if (sItem.autoReuse && !noItems) {
 				releaseUseItem = true;
 				if (itemAnimation == 1 && sItem.stack > 0) {
@@ -36634,11 +_,14 @@
 					}
 				}
 			}
+			*/
 
 			TryAllowingItemReuse(sItem);
 		}
 
+		
 		private void TryAllowingItemReuse(Item sItem) {
+			/*
 			bool flag = false;
 			if (autoReuseGlove) {
 				flag |= sItem.melee;
@@ -36646,13 +_,23 @@
 			}
 
 			if (flag)
+			*/
+			if (CanAutoReuseItem(sItem))
 				releaseUseItem = true;
+		}
+
+		public bool CanAutoReuseItem(Item sItem) {
+			if (CombinedHooks.CanAutoReuseItem(this, sItem) is bool autoReuse)
+				return autoReuse;
+
+			return sItem.autoReuse || autoReuseGlove && (sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed));
 		}
 
 		private void ItemCheck_HandleMount() {
 			if (!mount.Active)
 				return;
 
+			MountLoader.UseAbility(this, Vector2.Zero, false);
 			if (mount.Type == 8) {
 				noItems = true;
 				if (controlUseItem) {
@@ -36810,7 +_,7 @@
 				if (num == 2)
 					num = 102;
 
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102) {
 						DelBuff(i);
 						i--;
@@ -36973,7 +_,11 @@
 			}
 		}
 
+		// tML-specific overload that exists for consistency with other GetWeaponXYZ methods
+		public float GetWeaponKnockback(Item sItem) => GetWeaponKnockback(sItem, sItem.knockBack);
+
-		public float GetWeaponKnockback(Item sItem, float KnockBack) {
+		public float GetWeaponKnockback(Item sItem, float baseKnockback) {
+			/*
 			if (sItem.summon)
 				KnockBack += minionKB;
 
@@ -36988,11 +_,15 @@
 
 			if (sItem.ranged && setVortex)
 				KnockBack *= 1f + (1f - stealth) * 0.5f;
+			*/
 
-			return KnockBack;
+			StatModifier modifier = GetTotalKnockback(sItem.DamageType);
+			CombinedHooks.ModifyWeaponKnockback(this, sItem, ref modifier);
+			return Math.Max(0f, modifier.ApplyTo(baseKnockback));
 		}
 
 		public int GetWeaponCrit(Item sItem) {
+			/*
 			if (sItem.melee)
 				return meleeCrit;
 
@@ -37003,9 +_,16 @@
 				return magicCrit;
 
 			return 0;
+			*/
+
+			// TODO: Should ModifyWeaponCrit be float?
+			float crit = sItem.crit + GetTotalCritChance(sItem.DamageType);
+			CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
+			return (int)(crit + 5E-06f);
 		}
 
-		public int GetWeaponDamage(Item sItem) {
+		public int GetWeaponDamage(Item sItem, bool forTooltip = false) {
+			/*
 			int num = sItem.damage;
 			if (num > 0) {
 				if (sItem.melee) {
@@ -37031,9 +_,34 @@
 			}
 
 			return num;
+			*/
+
+			StatModifier modifier = GetTotalDamage(sItem.DamageType);
+
+			if (AmmoID.Sets.IsArrow[sItem.useAmmo])
+				modifier = modifier.CombineWith(arrowDamage);
+
+			if (AmmoID.Sets.IsBullet[sItem.useAmmo])
+				modifier = modifier.CombineWith(bulletDamage);
+
+			if (AmmoID.Sets.IsRocket[sItem.useAmmo])
+				modifier = modifier.CombineWith(rocketDamage);
+
+			CombinedHooks.ModifyWeaponDamage(this, sItem, ref modifier);
+			int baseDamage = forTooltip ? (int)(sItem.damage * ItemID.Sets.ToolTipDamageMultiplier[sItem.type]) : sItem.damage;
+			return Math.Max(0, (int)(modifier.ApplyTo(baseDamage) + 5E-06f));
 		}
 
+		/// <summary>
+		/// Whether or not the player has ammunition available for the given weapon.
+		/// </summary>
+		/// <param name="sItem">The weapon for which to try to find ammunition.</param>
+		/// <returns>True if the player has ammo available; false otherwise.</returns>
+		public bool HasAmmo(Item sItem) => HasAmmo(sItem, canUse: true);
+
-		public bool HasAmmo(Item sItem, bool canUse) {
+		internal bool HasAmmo(Item sItem, bool canUse) {
+			return sItem.useAmmo == 0 || ChooseAmmo(sItem) != null || !ItemLoader.NeedsAmmo(sItem, this);
+			/*
 			if (sItem.useAmmo > 0) {
 				canUse = false;
 				for (int i = 0; i < 58; i++) {
@@ -37045,6 +_,7 @@
 			}
 
 			return canUse;
+			*/
 		}
 
 		private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId) {
@@ -37055,14 +_,52 @@
 			return false;
 		}
 
-		public void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int Damage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false) {
-			Item item = new Item();
+		/// <summary>
+		/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
+		/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
+		/// </summary>
+		/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
+		/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
+		/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
+		/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+		/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+		/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
+		/// <param name="dontConsume">
+		/// Whether or not ammo consumption logic should be called upon.<br></br>
+		/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
+		/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
+		/// </param>
+		/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
+		public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false) {
+			projToShoot = weapon.shoot;
+			speed = weapon.shootSpeed;
+			damage = GetWeaponDamage(weapon);
+			knockBack = GetWeaponKnockback(weapon);
+			bool canShoot = false;
+			PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
+			if (!canShoot) {
+				projToShoot = 0;
+				return false;
+			}
+
+			return true;
+		}
+
+		/// <summary>
+		/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
+		/// </summary>
+		/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
+		/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
+		public Item ChooseAmmo(Item weapon) {
+			var sItem = weapon;
+			Item item = null;
 			bool flag = false;
-			usedAmmoItemId = 0;
+			bool canShoot = false;
+
 			if (sItem.useAmmo == AmmoID.Coin) {
 				for (int i = 0; i < 4; i++) {
 					int num = 50 + i;
-					if (inventory[num].ammo == sItem.useAmmo && inventory[num].stack > 0) {
+					if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[i], this)) {
 						item = inventory[num];
 						canShoot = true;
 						flag = true;
@@ -37072,7 +_,7 @@
 			}
 
 			for (int j = 54; j < 58; j++) {
-				if (inventory[j].ammo == sItem.useAmmo && inventory[j].stack > 0) {
+				if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[j], this)) {
 					item = inventory[j];
 					canShoot = true;
 					flag = true;
@@ -37082,7 +_,7 @@
 
 			if (!flag) {
 				for (int k = 0; k < 54; k++) {
-					if (inventory[k].ammo == sItem.useAmmo && inventory[k].stack > 0) {
+					if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[k], this)) {
 						item = inventory[k];
 						canShoot = true;
 						break;
@@ -37090,10 +_,39 @@
 				}
 			}
 
+			return item;
+		}
+
+		internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false) {
+			usedAmmoItemId = 0;
+			Item item = ChooseAmmo(sItem);
+			canShoot = item != null;
+
+			bool shootWithNoAmmo = false;
+			if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this)) {
+				item = ContentSamples.ItemsByType[sItem.useAmmo];
+				if (item.ammo == sItem.useAmmo)
+					canShoot = shootWithNoAmmo = true;
+			}
+
 			if (!canShoot)
 				return;
 
 			usedAmmoItemId = item.type;
+
+			StatModifier ammoDamage = GetTotalDamage(item.DamageType);
+			if (AmmoID.Sets.IsArrow[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(arrowDamage);
+
+			if (AmmoID.Sets.IsBullet[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(bulletDamage);
+
+			if (AmmoID.Sets.IsRocket[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(rocketDamage);
+
+			ammoDamage.Base = 0;
+			ammoDamage.Flat = totalDamage;
+
 			int pickedProjectileId = -1;
 			if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
 				projToShoot = pickedProjectileId;
@@ -37126,15 +_,15 @@
 			if (projToShoot == 42) {
 				if (item.type == 370) {
 					projToShoot = 65;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 				else if (item.type == 408) {
 					projToShoot = 68;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 				else if (item.type == 1246) {
 					projToShoot = 354;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 			}
 
@@ -37143,15 +_,16 @@
 
 			if (hasMoltenQuiver && projToShoot == 1) {
 				projToShoot = 2;
-				Damage += 2;
+				ammoDamage.Flat += 2;
 			}
 
 			if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake)) {
-				KnockBack = (int)((double)KnockBack * 1.1);
+				KnockBack *= 1.1f;
 				speed *= 1.1f;
 			}
 
 			speed += item.shootSpeed;
+			/*
 			if (item.ranged) {
 				if (item.damage > 0)
 					Damage += (int)((float)item.damage * rangedDamage);
@@ -37159,6 +_,7 @@
 			else {
 				Damage += item.damage;
 			}
+			*/
 
 			if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery) {
 				if (speed < 20f) {
@@ -37167,11 +_,62 @@
 						speed = 20f;
 				}
 
+				// archery potion buff moved into arrowDamage stat modifier
-				Damage = (int)((double)Damage * 1.2);
+				// Damage = (int)((double)Damage * 1.2);
 			}
 
 			KnockBack += item.knockBack;
+
+			ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref ammoDamage, ref KnockBack);
+			totalDamage = (int)(ammoDamage.ApplyTo(item.damage) + 5E-06f);
+
+			if (!dontConsume && !shootWithNoAmmo && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot)) {
+				CombinedHooks.OnConsumeAmmo(this, sItem, item);
+				item.stack--;
+				if (item.stack <= 0) {
+					item.active = false;
+					item.TurnToAir();
+				}
+			}
+		}
+
+		/// <summary>
+		/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
+		/// </summary>
+		/// <param name="weapon">The weapon attempting to consume the ammo.</param>
+		/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
+		/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
+		/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
+		public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot) {
+			Item sItem = weapon;
+			Item item = ammo;
+			/*
+			TODO:
+			the current approach to ammo consumption hooks demands that vanilla conservation chances still be allowed to factor in
+			while this is fine for some, for others, it may be preferable to be able to guarantee ammo consumption if it should happen
+			for this, two approaches exist. each has their ups and downs:
+			1 - CanConsumeAmmo to nullable, return given value if it exists
+			2 - separate hook for forced ammo consumption. returns false by default, return true to bypass all vanilla conservation chances
+
+			post-May-freeze, will decide on one and make changes accordingly
+			- thomas
+			*/
+			if (!CombinedHooks.CanConsumeAmmo(this, sItem, item))
+				return true;
+
+			if (sItem.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
+				return true;
+
+			if (sItem.consumeAmmoOnLastShotOnly) {
+				int useTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
+				bool isLastShot = itemAnimation <= useTime || // not enough time to shoot again
+					sItem.useLimitPerAnimation != null && ItemUsesThisAnimation == sItem.useLimitPerAnimation - 1; // this shot hits the limit
+
+				if (!isLastShot)
+					return true;
+			}
+
-			bool flag2 = dontConsume;
+			bool flag2 = false;
 			if (sItem.type == 3475 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
@@ -37181,7 +_,7 @@
 			if (sItem.type == 3540 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
-			if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && Main.rand.Next(5) == 0)
+			if (magicQuiver && AmmoID.Sets.IsArrow[sItem.useAmmo] && Main.rand.Next(5) == 0)
 				flag2 = true;
 
 			if (ammoBox && Main.rand.Next(5) == 0)
@@ -37208,11 +_,13 @@
 			if (sItem.type == 1553 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
+			/* Clockwork Assault Rifle + Eventide. Handled by consumeAmmoOnLastShotOnly.
 			if (sItem.type == 434 && itemAnimation < sItem.useAnimation - 2)
 				flag2 = true;
 
-			if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
+			if (sItem.type == 4953 && itemAnimation >= sItem.useAnimation - 8)
 				flag2 = true;
+			*/
 
 			if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
 				flag2 = true;
@@ -37226,6 +_,16 @@
 			if (ammoCost75 && Main.rand.Next(4) == 0)
 				flag2 = true;
 
+			// Copied as-is from 1.3
+			if (item.CountsAsClass(DamageClass.Throwing)) {
+				if (ThrownCost50 && Main.rand.Next(100) < 50)
+					flag2 = true;
+
+				if (ThrownCost33 && Main.rand.Next(100) < 33)
+					flag2 = true;
+			}
+
+			/* Flamethrower + Elf Melter (handled by consumeAmmoOnFirstShotOnly) + Clentaminator (handled by consumeAmmoOnFirstShotOnly)
 			if (projToShoot == 85 && itemAnimation < itemAnimationMax - 2)
 				flag2 = true;
 
@@ -37239,6 +_,9 @@
 					item.TurnToAir();
 				}
 			}
+			*/
+
+			return flag2;
 		}
 
 		public void GetOtherPlayersPickTile(int x, int y, int pickDamage) {
@@ -37274,7 +_,7 @@
 						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
 					}
 
-					if (Main.tile[x, y].type == 21)
+					if (Main.tile[x, y].type == 21 || Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type])
 						NetMessage.SendData(34, -1, -1, null, 1, x, y);
 
 					if (Main.tile[x, y].type == 467)
@@ -37282,11 +_,20 @@
 
 					if (Main.tile[x, y].type == 88)
 						NetMessage.SendData(34, -1, -1, null, 3, x, y);
+
+					if (Main.tile[x, y].type >= TileID.Count) {
+						if (TileID.Sets.BasicChest[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type, 0);
+
+						if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type, 0);
+					}
 				}
 				else {
 					bool num3 = Main.tile[x, y].active();
 					WorldGen.KillTile(x, y);
-					if (num3 && !Main.tile[x, y].active())
+
+					if (!Main.dedServ && num3 && !Main.tile[x, y].active())
 						AchievementsHelper.HandleMining();
 
 					if (Main.netMode == 1)
@@ -37356,7 +_,24 @@
 			if (Main.tileNoFail[tileTarget.type])
 				num = 100;
 
-			num = ((!Main.tileDungeon[tileTarget.type] && tileTarget.type != 25 && tileTarget.type != 58 && tileTarget.type != 117 && tileTarget.type != 203) ? ((tileTarget.type == 85) ? (num + pickPower / 3) : ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2))) : (num + pickPower / 2));
+			if(Main.tileDungeon[tileTarget.type] || tileTarget.type == 25 || tileTarget.type == 58 || tileTarget.type == 117 || tileTarget.type == 203)
+				num += pickPower / 2;
+			else if(tileTarget.type == 85)
+				num += pickPower / 3;
+			else if(tileTarget.type == 48 || tileTarget.type == 232)
+				num += pickPower * 2;
+			else if(tileTarget.type == 226)
+				num += pickPower / 4;
+			else if(tileTarget.type == 107 || tileTarget.type == 221)
+				num += pickPower / 2;
+			else if(tileTarget.type == 108 || tileTarget.type == 222)
+				num += pickPower / 3;
+			else if(tileTarget.type == 111 || tileTarget.type == 223)
+				num += pickPower / 4;
+			else if(tileTarget.type == 211)
+				num += pickPower / 5;
+			else
+				TileLoader.MineDamage(pickPower, ref num);
 			if (tileTarget.type == 211 && pickPower < 200)
 				num = 0;
 
@@ -37411,6 +_,9 @@
 			else if (tileTarget.type == 223 && pickPower < 150) {
 				num = 0;
 			}
+			else {
+				TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
+			}
 
 			if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
 				num += pickPower;
@@ -37704,24 +_,54 @@
 
 		public void DropItems() {
 			IEntitySource itemSource_Death = GetItemSource_Death();
+
+			var startInventory = PlayerLoader.GetStartingItems(this, DropItems_GetDefaults().Where(item => !item.IsAir), true);
+			var startCounts = new Dictionary<int, int>();
+
+			foreach (Item item in startInventory) {
+				if (!startCounts.ContainsKey(item.netID))
+					startCounts[item.netID] = 0;
+
+				startCounts[item.netID] += item.stack;
+			}
+
+			//TML: Drop code for modded accessory Slots, should run prior to dropping other items in case conditions are used based on player's current equips
+			AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
+
+			startCounts[ModContent.ItemType<ModLoader.Default.StartBag>()] = 1;
+
 			for (int i = 0; i < 59; i++) {
 				if (inventory[i].stack > 0) {
+					Item item = inventory[i];
 					bool flag = true;
-					if (inventory[i].type == 3507 || inventory[i].type == 3506 || inventory[i].type == 3509)
+					if (startCounts.TryGetValue(item.netID, out int startingCount) && startingCount >= item.stack)
 						flag = false;
 
 					if (flag) {
+						int stack = item.stack;
+						if (startCounts.ContainsKey(item.netID)) {
+							stack -= startCounts[item.netID];
+							startCounts[item.netID] = 0;
+						}
+
 						int num = Item.NewItem(itemSource_Death, (int)position.X, (int)position.Y, width, height, inventory[i].type);
 						Main.item[num].netDefaults(inventory[i].netID);
 						Main.item[num].Prefix(inventory[i].prefix);
-						Main.item[num].stack = inventory[i].stack;
+						Main.item[num].stack = stack; // inventory[i].stack
 						Main.item[num].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
 						Main.item[num].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num].noGrabDelay = 100;
 						Main.item[num].newAndShiny = false;
+
+						Main.item[num].ModItem = item.ModItem;
+						Main.item[num].globalItems = item.globalItems;
+
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num);
 					}
+					else if (item.stack > 0 && startCounts.ContainsKey(item.netID)) {
+						startCounts[item.netID] -= item.stack;
+					}
 				}
 
 				inventory[i].TurnToAir();
@@ -37735,6 +_,10 @@
 						Main.item[num2].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num2].noGrabDelay = 100;
 						Main.item[num2].newAndShiny = false;
+
+						Main.item[num2].ModItem = armor[i].ModItem;
+						Main.item[num2].globalItems = armor[i].globalItems;
+
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num2);
 					}
@@ -37752,6 +_,8 @@
 						Main.item[num3].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num3].noGrabDelay = 100;
 						Main.item[num3].newAndShiny = false;
+						Main.item[num3].ModItem = dye[i].ModItem;
+						Main.item[num3].globalItems = dye[i].globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num3);
 					}
@@ -37769,6 +_,8 @@
 						Main.item[num4].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num4].noGrabDelay = 100;
 						Main.item[num4].newAndShiny = false;
+						Main.item[num4].ModItem = miscEquips[i].ModItem;
+						Main.item[num4].globalItems = miscEquips[i].globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num4);
 					}
@@ -37788,6 +_,8 @@
 					Main.item[num5].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 					Main.item[num5].noGrabDelay = 100;
 					Main.item[num5].newAndShiny = false;
+					Main.item[num5].ModItem = miscDyes[i].ModItem;
+					Main.item[num5].globalItems = miscDyes[i].globalItems;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num5);
 				}
@@ -37795,12 +_,26 @@
 				miscDyes[i].TurnToAir();
 			}
 
+			DropItems_End(startInventory);
+		}
+		private IEnumerable<Item> DropItems_GetDefaults() { //Split by tML.
+			var inventory = new Item[this.inventory.Length];
+
+			for (int i = 0; i < inventory.Length; i++) {
+				inventory[i] = new Item();
+			}
+
 			inventory[0].SetDefaults(3507);
 			inventory[0].Prefix(-1);
 			inventory[1].SetDefaults(3509);
 			inventory[1].Prefix(-1);
 			inventory[2].SetDefaults(3506);
 			inventory[2].Prefix(-1);
+
+			return inventory;
+		}
+		private void DropItems_End(IList<Item> startInventory) { //Split by tML.
+			PlayerLoader.SetStartInventory(this, startInventory);
 			Main.mouseItem.TurnToAir();
 		}
 
@@ -37855,6 +_,7 @@
 			player.zone4 = zone4;
 			player.voidVaultInfo = voidVaultInfo;
 			player.luck = luck;
+			BiomeLoader.CopyCustomBiomesTo(this, player);
 			player.extraAccessory = extraAccessory;
 			player.MinionRestTargetPoint = MinionRestTargetPoint;
 			player.MinionAttackTargetNPC = MinionAttackTargetNPC;
@@ -37907,13 +_,14 @@
 			}
 
 			player.trashItem = trashItem.Clone();
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				player.buffType[j] = buffType[j];
 				player.buffTime[j] = buffTime[j];
 			}
 
 			DpadRadial.CopyTo(player.DpadRadial);
 			CircularRadial.CopyTo(player.CircularRadial);
+			PlayerLoader.clientClone(this, player);
 			return player;
 		}
 
@@ -37932,7 +_,7 @@
 			if (Main.tile[x, y - 1] == null)
 				return false;
 
-			if (!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != 79)
+			if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
 				return false;
 
 			for (int i = x - 1; i <= x + 1; i++) {
@@ -38052,7 +_,12 @@
 				}
 			}
 			catch (Exception exception) {
-				FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path);
+				FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path); // IO Exception
+
+				if (!Main.gameMenu)
+					WorldGen.SaveAndQuit();
+
+				Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{exception}", Main.menuMode);
 				throw;
 			}
 		}
@@ -38067,20 +_,30 @@
 			if (string.IsNullOrEmpty(path))
 				return;
 
+			/* tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
 			if (FileUtilities.Exists(path, isCloudSave))
 				FileUtilities.Copy(path, path + ".bak", isCloudSave);
+			*/
 
+			byte[] bytes;
 			RijndaelManaged rijndaelManaged = new RijndaelManaged();
-			using (Stream stream = isCloudSave ? ((Stream)new MemoryStream(2000)) : ((Stream)new FileStream(path, FileMode.Create))) {
+			using (Stream stream = (Stream)new MemoryStream(2000)) {
 				using (CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write)) {
 					using (BinaryWriter binaryWriter = new BinaryWriter(cryptoStream)) {
+						PlayerLoader.PreSavePlayer(player);
+
 						binaryWriter.Write(248);
 						playerFile.Metadata.Write(binaryWriter);
 						binaryWriter.Write(player.name);
 						binaryWriter.Write(player.difficulty);
 						binaryWriter.Write(playerFile.GetPlayTime().Ticks);
 						binaryWriter.Write(player.hair);
+						/*
 						binaryWriter.Write(player.hairDye);
+						*/
+
+						PlayerIO.WriteByteVanillaHairDye(player.hairDye, binaryWriter);
+
 						BitsByte bb = (byte)0;
 						for (int i = 0; i < 8; i++) {
 							bb[i] = player.hideVisibleAccessory[i];
@@ -38126,63 +_,57 @@
 						binaryWriter.Write(player.shoeColor.G);
 						binaryWriter.Write(player.shoeColor.B);
 						for (int k = 0; k < player.armor.Length; k++) {
-							binaryWriter.Write(player.armor[k].netID);
-							binaryWriter.Write(player.armor[k].prefix);
+							ItemIO.WriteVanillaID(player.armor[k], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.armor[k], binaryWriter);
 						}
 
 						for (int l = 0; l < player.dye.Length; l++) {
-							binaryWriter.Write(player.dye[l].netID);
-							binaryWriter.Write(player.dye[l].prefix);
+							ItemIO.WriteVanillaID(player.dye[l], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.dye[l], binaryWriter);
 						}
 
 						for (int m = 0; m < 58; m++) {
-							binaryWriter.Write(player.inventory[m].netID);
+							ItemIO.WriteVanillaID(player.inventory[m], binaryWriter);
 							binaryWriter.Write(player.inventory[m].stack);
-							binaryWriter.Write(player.inventory[m].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.inventory[m], binaryWriter);
 							binaryWriter.Write(player.inventory[m].favorited);
 						}
 
 						for (int n = 0; n < player.miscEquips.Length; n++) {
-							binaryWriter.Write(player.miscEquips[n].netID);
-							binaryWriter.Write(player.miscEquips[n].prefix);
-							binaryWriter.Write(player.miscDyes[n].netID);
-							binaryWriter.Write(player.miscDyes[n].prefix);
+							ItemIO.WriteVanillaID(player.miscEquips[n], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.miscEquips[n], binaryWriter);
+							ItemIO.WriteVanillaID(player.miscDyes[n], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.miscDyes[n], binaryWriter);
 						}
 
 						for (int num = 0; num < 40; num++) {
-							binaryWriter.Write(player.bank.item[num].netID);
+							ItemIO.WriteVanillaID(player.bank.item[num], binaryWriter);
 							binaryWriter.Write(player.bank.item[num].stack);
-							binaryWriter.Write(player.bank.item[num].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank.item[num], binaryWriter);
 						}
 
 						for (int num2 = 0; num2 < 40; num2++) {
-							binaryWriter.Write(player.bank2.item[num2].netID);
+							ItemIO.WriteVanillaID(player.bank2.item[num2], binaryWriter);
 							binaryWriter.Write(player.bank2.item[num2].stack);
-							binaryWriter.Write(player.bank2.item[num2].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank2.item[num2], binaryWriter);
 						}
 
 						for (int num3 = 0; num3 < 40; num3++) {
-							binaryWriter.Write(player.bank3.item[num3].netID);
+							ItemIO.WriteVanillaID(player.bank3.item[num3], binaryWriter);
 							binaryWriter.Write(player.bank3.item[num3].stack);
-							binaryWriter.Write(player.bank3.item[num3].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank3.item[num3], binaryWriter);
 						}
 
 						for (int num4 = 0; num4 < 40; num4++) {
-							binaryWriter.Write(player.bank4.item[num4].netID);
+							ItemIO.WriteVanillaID(player.bank4.item[num4], binaryWriter);
 							binaryWriter.Write(player.bank4.item[num4].stack);
-							binaryWriter.Write(player.bank4.item[num4].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank4.item[num4], binaryWriter);
 						}
 
 						binaryWriter.Write(player.voidVaultInfo);
 						for (int num5 = 0; num5 < 22; num5++) {
-							if (Main.buffNoSave[player.buffType[num5]]) {
-								binaryWriter.Write(0);
+							binaryWriter.Write(0);
-								binaryWriter.Write(0);
+							binaryWriter.Write(0);
-							}
-							else {
-								binaryWriter.Write(player.buffType[num5]);
-								binaryWriter.Write(player.buffTime[num5]);
-							}
 						}
 
 						for (int num6 = 0; num6 < 200; num6++) {
@@ -38198,7 +_,7 @@
 						}
 
 						binaryWriter.Write(player.hbLocked);
-						for (int num7 = 0; num7 < player.hideInfo.Length; num7++) {
+						for (int num7 = 0; num7 < 13; num7++) {
 							binaryWriter.Write(player.hideInfo[num7]);
 						}
 
@@ -38225,11 +_,28 @@
 						binaryWriter.Flush();
 						cryptoStream.FlushFinalBlock();
 						stream.Flush();
+
+						/* tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
 						if (isCloudSave && SocialAPI.Cloud != null)
 							SocialAPI.Cloud.Write(playerFile.Path, ((MemoryStream)stream).ToArray());
+						*/
+						bytes = ((MemoryStream)stream).ToArray();
+
+						PlayerLoader.PostSavePlayer(player); // For native data only
 					}
 				}
 			}
+
+			// tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
+			var tag = PlayerIO.SaveData(player);
+
+			BackupIO.Player.ArchivePlayer(path, isCloudSave);
+			if (FileUtilities.Exists(path, isCloudSave))
+				FileUtilities.Copy(path, path + ".bak", isCloudSave);
+
+			FileUtilities.WriteAllBytes(path, bytes, isCloudSave);
+
+			PlayerIO.Save(tag, path, isCloudSave);
 		}
 
 		private void SaveTemporaryItemSlotContents(BinaryWriter writer) {
@@ -38334,6 +_,8 @@
 
 			Player player = new Player();
 			bool flag = false;
+			using var _currentPlr = new Main.CurrentPlayerOverride(player);
+
 			try {
 				RijndaelManaged rijndaelManaged = new RijndaelManaged();
 				rijndaelManaged.Padding = PaddingMode.None;
@@ -38673,7 +_,7 @@
 							if (num >= 11) {
 								int num28 = 22;
 								if (num < 74)
-									num28 = 10;
+									num28 -= 12;
 
 								for (int num29 = 0; num29 < num28; num29++) {
 									player.buffType[num29] = binaryReader.ReadInt32();
@@ -38763,7 +_,7 @@
 							if (num >= 220)
 								CreativePowerManager.Instance.LoadToPlayer(player, binaryReader, num);
 
-							LoadPlayer_LastMinuteFixes(player);
+							LoadPlayer_LastMinuteFixes(player, playerFileData);
 						}
 					}
 				}
@@ -38773,6 +_,9 @@
 				playerFileData.Player = player;
 				return playerFileData;
 			}
+			catch (CustomModDataException e) {
+				playerFileData.customDataFail = e;
+			}
 			catch {
 			}
 
@@ -38803,9 +_,13 @@
 			}
 		}
 
-		private static void LoadPlayer_LastMinuteFixes(Player newPlayer) {
+		private static void LoadPlayer_LastMinuteFixes(Player newPlayer, PlayerFileData playerFileData) {
 			newPlayer.skinVariant = (int)MathHelper.Clamp(newPlayer.skinVariant, 0f, 11f);
+			if(PlayerIO.TryLoadData(playerFileData.Path, playerFileData.IsCloudSave, out var tag))
+				PlayerIO.Load(newPlayer, tag);
 			for (int i = 3; i < 10; i++) {
+				LoadPlayer_LastMinuteFixes(newPlayer.armor[i], newPlayer);
+				/*
 				int type = newPlayer.armor[i].type;
 				if (type == 908 || type == 4874 || type == 5000)
 					newPlayer.lavaMax += 420;
@@ -38813,14 +_,24 @@
 				if (type == 906 || type == 4038)
 					newPlayer.lavaMax += 420;
 
-				if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0)
+				if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0) {
 					newPlayer.wingsLogic = newPlayer.armor[i].wingSlot;
+					newPlayer.equippedWings = newPlayer.armor[i];
+				}
 
 				if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
 					newPlayer.noFallDmg = true;
 
 				newPlayer.lavaTime = newPlayer.lavaMax;
+				*/
 			}
+
+			var modSlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
+			for (int i = 0; i < modSlotPlayer.SlotCount; i++) {
+				LoadPlayer_LastMinuteFixes(modSlotPlayer.exAccessorySlot[i], newPlayer);
+			}
+
+			newPlayer.ResetEffects();
 		}
 
 		public static PlayerFileData GetFileData(string file, bool cloudSave) {
@@ -38830,12 +_,17 @@
 			PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
 			if (playerFileData.Player != null) {
 				if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1) {
+					CustomModDataException customDataFail = playerFileData.customDataFail;
-					if (FileUtilities.Exists(file + ".bak", cloudSave))
+					if (FileUtilities.Exists(file + ".bak", cloudSave)) {
 						FileUtilities.Move(file + ".bak", file, cloudSave);
+						PlayerIO.LoadBackup(file, cloudSave);
+					}
 
 					playerFileData = LoadPlayer(file, cloudSave);
 					if (playerFileData.Player == null)
 						return null;
+
+					playerFileData.customDataFail = customDataFail;
 				}
 
 				return playerFileData;
@@ -38886,6 +_,14 @@
 		}
 
 		public Player() {
+			ResetDamageClassData();
+			buffType = new int[MaxBuffs];
+			buffTime = new int[MaxBuffs];
+			buffImmune = new bool[BuffLoader.BuffCount]; // TODO: Move all these patches to field initializers.
+			ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
+			npcTypeNoAggro = new bool[NPCLoader.NPCCount];
+			PlayerLoader.SetupPlayer(this);
+			LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
 			width = 20;
 			height = 42;
 			name = string.Empty;
@@ -38926,7 +_,7 @@
 			grappling[0] = -1;
 			statManaMax = 20;
 			extraAccessory = false;
-			for (int n = 0; n < 625; n++) {
+			for (int n = 0; n < adjTile.Length; n++) {
 				adjTile[n] = false;
 				oldAdjTile[n] = false;
 			}
@@ -39162,13 +_,31 @@
 			num2 = ((num <= 50) ? (num2 - (float)num * 0.01f) : ((num <= 100) ? (0.5f - (float)(num - 50) * 0.005f) : ((num > 150) ? 0.15f : (0.25f - (float)(num - 100) * 0.002f))));
 			num2 *= 0.9f;
 			num2 *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
+			
+			List<Item> rewardItems = new List<Item>();
+			
 			GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
-			GetAnglerReward_MainReward(source, num, num2, ref anglerRewardSettings);
+			GetAnglerReward_MainReward(rewardItems, source, num, num2, ref anglerRewardSettings);
-			GetAnglerReward_Money(source, num, num2, ref anglerRewardSettings);
+			GetAnglerReward_Money(rewardItems, source, num, num2, ref anglerRewardSettings);
-			GetAnglerReward_Bait(source, num, num2, ref anglerRewardSettings);
+			GetAnglerReward_Bait(rewardItems, source, num, num2, ref anglerRewardSettings);
+			
+			PlayerLoader.AnglerQuestReward(this, num2, rewardItems);
+
+			foreach (Item rewardItem in rewardItems) {
+				rewardItem.position = Center;
+				
+				Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
+				
+				if (getItem.stack > 0) {
+					int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
+					
+					if (Main.netMode == 1)
+						NetMessage.SendData(21, -1, -1, null, number, 1f);
+				}
+			}
 		}
 
-		private void GetAnglerReward_MainReward(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			Item item = new Item();
 			item.type = 0;
 			switch (questsDone) {
@@ -39349,6 +_,8 @@
 					}
 			}
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -39356,11 +_,14 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 
 			if (item.type == 2417) {
 				Item item3 = new Item();
 				Item item4 = new Item();
 				item3.SetDefaults(2418);
+				rewardItems.Add(item3);
+				/*
 				item3.position = base.Center;
 				item2 = GetItem(whoAmI, item3, anglerRewardSettings);
 				if (item2.stack > 0) {
@@ -39368,15 +_,20 @@
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number2, 1f);
 				}
+				*/
 
 				item4.SetDefaults(2419);
+				rewardItems.Add(item4);
+				/*
 				item4.position = base.Center;
 				item2 = GetItem(whoAmI, item4, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number3 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number3, 1f);
 				}
+				*/
 			}
 			else {
 				if (item.type != 2498)
@@ -39385,26 +_,34 @@
 				Item item5 = new Item();
 				Item item6 = new Item();
 				item5.SetDefaults(2499);
+				rewardItems.Add(item5);
+				/*
 				item5.position = base.Center;
 				item2 = GetItem(whoAmI, item5, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number4 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number4, 1f);
 				}
+				*/
 
 				item6.SetDefaults(2500);
+				rewardItems.Add(item6);
+				/*
 				item6.position = base.Center;
 				item2 = GetItem(whoAmI, item6, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number5 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number5, 1f);
 				}
+				*/
 			}
 		}
 
-		private void GetAnglerReward_Bait(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			if (Main.rand.Next((int)(100f * rarityReduction)) > 50)
 				return;
 
@@ -39434,6 +_,8 @@
 			if (Main.rand.Next(250) <= questsDone)
 				item.stack++;
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 			if (item2.stack > 0) {
@@ -39441,9 +_,10 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
-		private void GetAnglerReward_Money(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			Item item = new Item();
 			int num = (questsDone + 50) / 2;
 			num = (int)((float)(num * Main.rand.Next(50, 201)) * 0.015f);
@@ -39473,6 +_,8 @@
 				item.stack = num;
 			}
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -39480,6 +_,7 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
 		public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, int randomChanceForASingleAcc, out bool botheredRollingForADrop, out int itemIdToDrop) {
@@ -39603,13 +_,17 @@
 					list.Add(3556);
 				}
 
+				// Extra patch context.
 				if (NPC.downedMoonlord)
 					list.Add(3024);
 			}
 
+			PlayerLoader.GetDyeTraderReward(this, list);
+
 			num = list[Main.rand.Next(list.Count)];
 			Item item = new Item();
 			item.SetDefaults(num);
+			// Extra patch context.
 			item.stack = 3;
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
@@ -39652,7 +_,7 @@
 		public bool ConsumeSolarFlare() {
 			if (setSolar && solarShields > 0) {
 				solarShields--;
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] >= 170 && buffType[i] <= 172)
 						DelBuff(i);
 				}
@@ -39772,7 +_,7 @@
 				}
 			}
 
-			int damage = (int)(20f * (1f + magicDamage + minionDamage - 2f));
+			int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
 			IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
 			_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
 		}
@@ -39891,7 +_,7 @@
 				return;
 
 			int timeToAdd = 480;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] >= type && buffType[i] < type + 3)
 					DelBuff(i);
 			}
