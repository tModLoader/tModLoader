--- src/TerrariaNetCore/Terraria/Player.cs
+++ src/tModLoader/Terraria/Player.cs
@@ -35,10 +_,16 @@
 using Terraria.UI.Gamepad;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Exceptions;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
+using System.Linq;
+using LegacySoundStyle = Terraria.Audio.SoundStyle;
 
 namespace Terraria
 {
-	public class Player : Entity, IFixLoadedData
+	public partial class Player : Entity, IFixLoadedData
 	{
 		public static class BuilderAccToggleIDs
 		{
@@ -241,18 +_,28 @@
 
 			public static void PlayerConnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerConnect(playerIndex);
 			}
 
 			public static void PlayerDisconnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerDisconnect(playerIndex);
 			}
 
 			public static void EnterWorld(int playerIndex) {
+				Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Size={2}x{3}", Main.ActivePlayerFileData.Name, Main.ActivePlayerFileData.IsCloudSave, Main.maxTilesX, Main.maxTilesY);
+				Interface.ResetData();
 				if (Hooks.OnEnterWorld != null)
 					Hooks.OnEnterWorld(Main.player[playerIndex]);
 
+				PlayerLoader.OnEnterWorld(playerIndex);
+
-				if (playerIndex == Main.myPlayer)
+				if (playerIndex == Main.myPlayer) {
 					Main.ToggleGameplayUpdates(state: true);
+
+					// Added by TML.
+					Social.Steam.SteamedWraps.BeginPlaytimeTracking();
+				}
 			}
 		}
 
@@ -453,7 +_,7 @@
 
 		public int emoteTime;
 		public CreativeUnlocksTracker creativeTracker;
-		private static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
+		internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
 		public OverheadMessage chatOverhead;
 		public SelectionRadial DpadRadial = new SelectionRadial();
 		public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);
@@ -462,7 +_,7 @@
 		public int HotbarOffset;
 		public bool GoingDownWithGrapple;
 		public byte spelunkerTimer;
-		public bool[] hideInfo = new bool[13];
+		public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];
 		public int[] builderAccStatus = new int[12] {
 			1,
 			0,
@@ -489,8 +_,8 @@
 		private static SlotId _insideBlizzardSound = SlotId.Invalid;
 		public string name = "";
 		public int taxMoney;
-		public int taxTimer;
+		public double taxTimer;
-		public static int taxRate = 3600;
+		public static double taxRate = 3600;
 		public int numberOfDeathsPVE;
 		public int numberOfDeathsPVP;
 		public static int crystalLeafDamage = 100;
@@ -580,10 +_,35 @@
 		public int ropeCount;
 		public int manaRegenBonus;
 		public float manaRegenDelayBonus;
+		/// <summary>
+		/// The current vanilla dash that the player is using.<br/>
+		/// The following values correspond to vanilla dashes:<br/>
+		/// 1 => Tabi / Master Ninja Gear<br/>
+		/// 2 => Shield of Cthulhu<br/>
+		/// 3 => Solar Flare armor set bonus<br/>
+		/// 4 => Unused, though a dash for this value DOES exist<br/>
+		/// 5 => Crystal Assassin set bonus<br/>
+		/// </summary>
 		public int dashType;
+		/// <summary>
+		/// The current vanilla dash that the player is VISIBLY using.<br/>
+		/// Unlike <see cref="dashType"/>, this does not update if a dash cannot currently be input.<br/>
+		/// </summary>
 		public int dash;
+		/// <summary>
+		/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br/>
+		/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br/>
+		/// </summary>
 		public int dashTime;
+		/// <summary>
+		/// The amount of time that has passed, in ticks, since this player last performed a dash.
+		/// </summary>
 		public int timeSinceLastDashStarted;
+		/// <summary>
+		/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br/>
+		/// For the first frame of any given dash, this is set to -1. After that frame has passsed, it is set to 20 ticks, or 1/3 of a second.<br/>
+		/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br/>
+		/// </summary>
 		public int dashDelay;
 		public int eocDash;
 		public int eocHit;
@@ -592,6 +_,23 @@
 		public int gem = -1;
 		public int gemCount;
 		public BitsByte ownedLargeGems;
+		/// <summary>
+		/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br/>
+		/// Defaults to 0, which denotes that the player does not currently have a flask active.<br/>
+		/// The following values correspond to vanilla flasks:<br/>
+		/// 1 => Flask of Venom (affected weapons proc Acid Venom on hit)<br/>
+		/// 2 => Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br/>
+		/// 3 => Flask of Fire (affected weapons proc On Fire! on hit)<br/>
+		/// 4 => Flask of Gold (affected weapons proc Midas on hit)<br/>
+		/// 5 => Flask of Ichor (affected weapons proc Ichor on hit)<br/>
+		/// 6 => Flask of Nanites (affected weapons proc Confused on hit)<br/>
+		/// 7 => Flask of Party (affected weapons sometimes release confetti explosions on hit)<br/>
+		/// 8 => Flask of Poison (affected weapons proc Poisoned on hit)<br/>
+		/// </summary>
+		// TO-DO:
+		// transform to int later, make proper flask effect system maybe?
+		// concrete use cases exist. just gotta find a way to make a system for 'em intuitive
+		// -thomas
 		public byte meleeEnchant;
 		public byte pulleyDir;
 		public bool pulley;
@@ -603,7 +_,13 @@
 		public int snowBallLauncherInteractionCooldown;
 		public bool iceSkate;
 		public bool carpet;
-		public int spikedBoots;
+		/// <summary>
+		/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br/>
+		/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br/>
+		/// A value of 1 causes the player to slowly slide down them while holding onto them.<br/>
+		/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
+		/// </summary>
+		public int spikedBoots; // tML: documentation added because this field can be a little tricky to understand at first glance
 		public int carpetFrame = -1;
 		public float carpetFrameCounter;
 		public bool canCarpet;
@@ -628,7 +_,7 @@
 		public byte oldLuckPotion;
 		public float endurance;
 		public float whipRangeMultiplier;
-		public float whipUseTimeMultiplier;
+		//public float whipUseTimeMultiplier;
 		public bool loveStruck;
 		public bool stinky;
 		public bool resistCold;
@@ -771,7 +_,7 @@
 		public bool poundRelease;
 		public float ghostFade;
 		public float ghostDir = 1f;
-		public const int maxBuffs = 44;
+		public static int MaxBuffs => 44 + BuffLoader.extraPlayerBuffCount;
 		public int[] buffType = new int[44];
 		public int[] buffTime = new int[44];
 		public bool[] buffImmune = new bool[355];
@@ -951,7 +_,7 @@
 		public int golferScoreAccumulated;
 		public int bartenderQuestLog;
 		public bool downedDD2EventAnyDifficulty;
-		public int armorPenetration;
+		internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);
 		public int statDefense;
 		public int statLifeMax = 100;
 		public int statLifeMax2 = 100;
@@ -1184,21 +_,25 @@
 		public bool parryDamageBuff;
 		public bool ballistaPanic;
 		public bool JustDroppedAnItem;
-		public int meleeCrit = 4;
-		public int magicCrit = 4;
-		public int rangedCrit = 4;
-		public float meleeDamage = 1f;
-		public float magicDamage = 1f;
-		public float rangedDamage = 1f;
-		public float rangedMultDamage = 1f;
-		public float arrowDamageAdditiveStack;
-		public float arrowDamage = 1f;
-		public float bulletDamage = 1f;
-		public float rocketDamage = 1f;
-		public float minionDamage = 1f;
-		public float minionKB;
-		public float meleeSpeed = 1f;
-		public float summonerWeaponSpeedBonus;
+		internal ref float allCrit => ref GetCritChance(DamageClass.Generic);
+		internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);
+		internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);
+		internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);
+		internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic);
+		internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);
+		internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);
+		internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);
+		//public float rangedMultDamage = 1;
+		private ref StatModifier arrowDamageAdditiveStack => ref arrowDamage;
+		public StatModifier arrowDamage = StatModifier.Default;
+		public StatModifier bulletDamage = StatModifier.Default;
+		public StatModifier rocketDamage = StatModifier.Default;
+		internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);
+		internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic);
+		internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;
+		internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);
+		internal float inverseMeleeSpeed => 1 / GetTotalAttackSpeed(DamageClass.Melee); // meleeSpeed is now a damage multiplier, so inverseMeleeSpeed is the useTime multiplier. By using GetTotalAttackSpeed we also incorporate anyone that adds attackSpeed to the Generic damage class
+		internal ref float summonerWeaponSpeedBonus => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);
 		public float moveSpeed = 1f;
 		public float pickSpeed = 1f;
 		public float wallSpeed = 1f;
@@ -1233,12 +_,30 @@
 		public bool oldAdjWater;
 		public bool oldAdjHoney;
 		public bool oldAdjLava;
-		public bool[] adjTile = new bool[693];
-		public bool[] oldAdjTile = new bool[693];
+		private bool[] _adjTile = new bool[TileLoader.TileCount];
+		public bool[] adjTile {
+			get {
+				if (_adjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _adjTile, TileLoader.TileCount);
+
+				return _adjTile;
+			}
+			set { _adjTile = value; }
+		}
+		private bool[] _oldAdjTile = new bool[TileLoader.TileCount];
+		public bool[] oldAdjTile {
+			get {
+				if (_oldAdjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
+
+				return _oldAdjTile;
+			}
+			set { _oldAdjTile = value; }
+		}
 		public static int defaultItemGrabRange = 42;
 		private static float itemGrabSpeed = 0.45f;
 		private static float itemGrabSpeedMax = 4f;
-		public byte hairDye;
+		public int hairDye; //TML: Changed from byte to int.
 		public Color hairDyeColor = Color.Transparent;
 		public float hairDyeVar;
 		public int skinDyePacked;
@@ -1496,7 +_,7 @@
 		private int[] unlitTorchY = new int[maxTorchAttacks];
 		private static int[] _torchAttackPosX = new int[400];
 		private static int[] _torchAttackPosY = new int[400];
-		public int ladyBugLuckTimeLeft;
+		public double ladyBugLuckTimeLeft;
 		public float luck;
 		public float luckMinimumCap = -0.7f;
 		public float luckMaximumCap = 1f;
@@ -2086,11 +_,13 @@
 			}
 		}
 
+		/*
 		public float bowEffectiveDamage => (rangedDamage / rangedMultDamage + arrowDamageAdditiveStack) * rangedMultDamage * arrowDamage;
 
 		public float gunEffectiveDamage => rangedDamage * bulletDamage;
 
 		public float specialistEffectiveDamage => rangedDamage * rocketDamage;
+		*/
 
 		public bool ShouldNotDraw {
 			get {
@@ -2147,7 +_,10 @@
 
 		public bool ItemTimeIsZero => itemTime == 0;
 
-		public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax - 1;
+		/// <summary>
+		/// Returns true if the item animation is in its first frame.
+		/// </summary>
+		public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax/* - 1*/; //TML: #2351
 
 		public float NormalizedLuck {
 			get {
@@ -2308,6 +_,7 @@
 		public void SetTalkNPC(int npcIndex, bool fromNet = false) {
 			talkNPC = npcIndex;
 			if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
+				// Gut feeling there is a to do on the above conditional
 				Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
 
 			if (talkNPC == -1)
@@ -2324,12 +_,12 @@
 			itemTimeMax = frames;
 		}
 
-		public void ApplyItemTime(Item sItem) {
-			SetItemTime(sItem.useTime);
-		}
+		public void ApplyItemTime(Item sItem, float multiplier = 1, bool? callUseItem = null) {
+			if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+				return;
 
-		public void ApplyItemTime(Item sItem, float multiplier) {
-			SetItemTime((int)((float)sItem.useTime * multiplier));
+			SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime * multiplier, this, sItem));
+			ItemUsesThisAnimation++;
 		}
 
 		public void SetDummyItemTime(int frames) {
@@ -2338,12 +_,13 @@
 			itemTimeMax = frames + 1;
 		}
 
-		private void SetItemAnimation(int frames) {
+		public void SetItemAnimation(int frames) {
 			itemAnimation = frames;
 			itemAnimationMax = frames;
 		}
 
-		private void ApplyItemAnimation(Item sItem) {
+		public void ApplyItemAnimation(Item sItem) {
+			/*
 			int num = 0;
 			if (sItem.autoReuse && sItem.reuseDelay == 0 && sItem.useTime <= sItem.useAnimation && sItem.shoot > 0 && sItem.useStyle == 5)
 				num = 1;
@@ -2360,6 +_,24 @@
 				SetItemAnimation(sItem.useAnimation + num);
 
 			reuseDelay = sItem.reuseDelay;
+			*/
+			
+			// TODO, just merge the tile/wall speed into TotalUseSpeedMultiplier?
+			if (sItem.createTile >= 0)
+				ApplyItemAnimation(sItem, tileSpeed);
+			else if (sItem.createWall >= 0)
+				ApplyItemAnimation(sItem, wallSpeed);
+			else
+				ApplyItemAnimation(sItem, 1);
+		}
+
+		public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null) {
+			ItemLoader.UseAnimation(sItem, this);
+
+			SetItemAnimation(CombinedHooks.TotalAnimationTime(sItem.useAnimation * multiplier, this, sItem));
+
+			reuseDelay = (int)((itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
+			ItemUsesThisAnimation = 0;
 		}
 
 		public void MatchItemTimeToItemAnimation() {
@@ -2711,7 +_,9 @@
 				Main.guideItem.position = base.Center;
 				Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
 				if (item.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+					Main.item[num] = item.Clone();
 					Main.item[num].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num, 1f);
@@ -2724,7 +_,9 @@
 				Main.reforgeItem.position = base.Center;
 				Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
 				if (item2.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num2 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+					Main.item[num2] = item2.Clone();
 					Main.item[num2].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num2, 1f);
@@ -2759,7 +_,9 @@
 				Main.mouseItem.position = base.Center;
 				Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
 				if (item3.stack > 0) {
+					//TODO: Replace with Item.DropItem?
 					int num3 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+					Main.item[num3] = item3.Clone();
 					Main.item[num3].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num3, 1f);
@@ -2860,7 +_,7 @@
 			if (buffImmune[type])
 				return -1;
 
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1 && buffType[i] == type)
 					return i;
 			}
@@ -2868,13 +_,20 @@
 			return -1;
 		}
 
+		/// <summary>
+		/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="BuffID"/> and modded buffs are typically retrieved using <see cref="ModContent.BuffType{T}"/>. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations, run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
+		/// </summary>
+		/// <param name="type">The buff type</param>
+		/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
+		/// <param name="quiet">If true, the network sync message is skipped.</param>
+		/// <param name="foodHack">unused</param>
 		public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false) {
 			if (buffImmune[type])
 				return;
 
 			bool flag = !quiet && Main.netMode == 1 && Main.pvpBuff[type] && Main.myPlayer != whoAmI;
 			if (!flag && BuffID.Sets.IsFedState[type]) {
-				for (int i = 0; i < 44; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (BuffID.Sets.IsFedState[buffType[i]])
 						DelBuff(i);
 				}
@@ -2899,7 +_,7 @@
 			int num = -1;
 			while (num == -1) {
 				int num2 = -1;
-				for (int i = 0; i < 44; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (!Main.debuff[buffType[i]]) {
 						num2 = i;
 						break;
@@ -2909,7 +_,7 @@
 				if (num2 == -1)
 					return false;
 
-				for (int j = num2; j < 44; j++) {
+				for (int j = num2; j < MaxBuffs; j++) {
 					if (buffType[j] == 0) {
 						num = j;
 						break;
@@ -2929,7 +_,7 @@
 			if (!Main.meleeBuff[type])
 				return;
 
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type && Main.meleeBuff[buffType[i]]) {
 					DelBuff(i);
 					i--;
@@ -2939,7 +_,7 @@
 
 		private void AddBuff_RemoveOldPetBuffsOfMatchingType(int type) {
 			if (Main.lightPet[type]) {
-				for (int i = 0; i < 44; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (Main.lightPet[buffType[i]])
 						DelBuff(i);
 				}
@@ -2948,7 +_,7 @@
 			if (!Main.vanityPet[type])
 				return;
 
-			for (int j = 0; j < 44; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (Main.vanityPet[buffType[j]])
 					DelBuff(j);
 			}
@@ -2956,11 +_,13 @@
 
 		private bool AddBuff_TryUpdatingExistingBuffTime(int type, int time) {
 			bool result = false;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type)
 					continue;
 
+				if (BuffLoader.ReApply(type, this, time, i)) {
+				}
-				if (type == 94) {
+				else if (type == 94) {
 					buffTime[i] += time;
 					if (buffTime[i] > manaSickTimeMax)
 						buffTime[i] = manaSickTimeMax;
@@ -2978,7 +_,7 @@
 
 		private int AddBuff_DetermineBuffTimeToAdd(int type, int time1) {
 			int num = time1;
-			if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80)) {
+			if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type]) {
 				float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
 				if (Main.GameModeInfo.IsJourneyMode) {
 					if (Main.masterMode)
@@ -2993,27 +_,39 @@
 			return num;
 		}
 
+		/// <summary>
+		/// Removes the buff at the provided index and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.ClearBuff"/> if you only know the buff type
+		/// </summary>
+		/// <param name="b">The index of the buff to remove.</param>
 		public void DelBuff(int b) {
 			buffTime[b] = 0;
 			buffType[b] = 0;
+			//single pass compactor (vanilla is n^2)
+			int packedIdx = 0;
-			for (int i = 0; i < 43; i++) {
+			for (int i = 0; i < MaxBuffs - 1; i++) {
-				if (buffTime[i] != 0 && buffType[i] != 0)
+				if (buffTime[i] == 0 || buffType[i] == 0)
 					continue;
 
-				for (int j = i + 1; j < 44; j++) {
-					if (buffTime[j] > 0 && buffType[j] > 0) {
-						buffTime[i] = buffTime[j];
-						buffType[i] = buffType[j];
-						buffTime[j] = 0;
-						buffType[j] = 0;
-						break;
-					}
+				if (packedIdx < i) {
+					buffTime[packedIdx] = buffTime[i];
+					buffType[packedIdx] = buffType[i];
+					buffTime[i] = 0;
+					buffType[i] = 0;
 				}
+
+				packedIdx++;
 			}
 		}
 
+		/// <summary>
+		/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.DelBuff(int)"/> if you only know the buff index
+		/// </summary>
+		/// <param name="type">The buff type</param>
 		public void ClearBuff(int type) {
+			if (type == 0)
+				return;
+
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] == type)
 					DelBuff(i);
 			}
@@ -3021,7 +_,7 @@
 
 		public int CountBuffs() {
 			int num = 0;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[num] > 0)
 					num++;
 			}
@@ -3076,7 +_,11 @@
 				if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0)
 					continue;
 
+				if(!CombinedHooks.CanUseItem(this, item))
+					continue;
+
-				int num4 = item.healLife - num;
+				//int num4 = item.healLife - num;
+				int num4 = GetHealLife(item, true) - num;
 				if (item.type == 227 && num4 < 0) {
 					num4 += 30;
 					if (num4 > 0)
@@ -3156,8 +_,8 @@
 			if (cursed || CCed || dead)
 				return;
 
-			LegacySoundStyle legacySoundStyle = null;
+			SoundStyle? legacySoundStyle = null;
-			if (CountBuffs() == 44)
+			if (CountBuffs() == MaxBuffs)
 				return;
 
 			Item item = QuickBuff_PickBestFoodItem();
@@ -3168,14 +_,14 @@
 					num = 3600;
 
 				AddBuff(item.buffType, num);
-				if (item.consumable) {
+				if (item.consumable && ItemLoader.ConsumeItem(item, this)) {
 					item.stack--;
 					if (item.stack <= 0)
 						item.TurnToAir();
 				}
 			}
 
-			if (CountBuffs() != 44) {
+			if (CountBuffs() != MaxBuffs) {
 				int num2 = 58;
 				if (useVoidBag())
 					num2 = 98;
@@ -3186,8 +_,14 @@
 						continue;
 
 					int num3 = item2.buffType;
-					bool flag = QuickBuff_ShouldBotherUsingThisBuff(num3);
+					bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num3);
 					if (item2.mana > 0 && flag) {
+						if (CheckMana(item2, -1, true, true))
+							manaRegenDelay = (int)maxRegenDelay;
+						else
+							flag = false;
+
+						/*
 						if (statMana >= (int)((float)item2.mana * manaCost)) {
 							manaRegenDelay = (int)maxRegenDelay;
 							statMana -= (int)((float)item2.mana * manaCost);
@@ -3195,6 +_,7 @@
 						else {
 							flag = false;
 						}
+						*/
 					}
 
 					if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
@@ -3215,19 +_,21 @@
 					if (!flag)
 						continue;
 
+					ItemLoader.UseItem(item2, this);
 					legacySoundStyle = item2.UseSound;
 					int num4 = item2.buffTime;
 					if (num4 == 0)
 						num4 = 3600;
 
 					AddBuff(num3, num4);
-					if (item2.consumable) {
+					if (item2.consumable && ItemLoader.ConsumeItem(item2, this)) {
 						item2.stack--;
+
 						if (item2.stack <= 0)
 							item2.TurnToAir();
 					}
 
-					if (CountBuffs() == 44)
+					if (CountBuffs() == MaxBuffs)
 						break;
 				}
 			}
@@ -3241,7 +_,7 @@
 		private Item QuickBuff_PickBestFoodItem() {
 			int num = 0;
 			Item item = null;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1) {
 					int num2 = QuickBuff_FindFoodPriority(buffType[i]);
 					if (num <= num2)
@@ -3291,7 +_,7 @@
 
 		private bool QuickBuff_ShouldBotherUsingThisBuff(int attemptedType) {
 			bool result = true;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (attemptedType == 27 && (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102)) {
 					result = false;
 					break;
@@ -3314,7 +_,7 @@
 			}
 
 			if (Main.lightPet[attemptedType] || Main.vanityPet[attemptedType]) {
-				for (int j = 0; j < 44; j++) {
+				for (int j = 0; j < MaxBuffs; j++) {
 					if (Main.lightPet[buffType[j]] && Main.lightPet[attemptedType])
 						result = false;
 
@@ -3338,6 +_,7 @@
 				if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this) && ItemCheck_CheckCanUse(item)) {
 					if (!QuickMinecartSnap()) {
 						mount.SetMount(item.mountType, this);
+						ItemLoader.UseItem(item, this);
 						if (item.UseSound != null)
 							SoundEngine.PlaySound(item.UseSound, base.Center);
 					}
@@ -3409,12 +_,12 @@
 
 		public Item QuickMount_GetItemToUse() {
 			Item item = null;
-			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
+			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType] && CombinedHooks.CanUseItem(this, miscEquips[3]))
 				item = miscEquips[3];
 
 			if (item == null) {
 				for (int i = 0; i < 58; i++) {
-					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType]) {
+					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType] && CombinedHooks.CanUseItem(this, inventory[i])) {
 						item = inventory[i];
 						break;
 					}
@@ -3474,7 +_,12 @@
 			if (item == null || !ItemCheck_CheckCanUse(item))
 				return;
 
+			bool? modCanGrapple = ProjectileLoader.CanUseGrapple(item.shoot, this);
+			if (modCanGrapple.HasValue) {
+				if (!modCanGrapple.Value)
+					item = null;
+			}
-			if (item.shoot == 73) {
+			else if (item.shoot == 73) {
 				int num2 = 0;
 				for (int i = 0; i < 1000; i++) {
 					if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && (Main.projectile[i].type == 73 || Main.projectile[i].type == 74))
@@ -3549,11 +_,21 @@
 			float shootSpeed = item.shootSpeed;
 			int damage = item.damage;
 			float knockBack = item.knockBack;
+			bool? modSingleHook = ProjectileLoader.SingleGrappleHook(num7, this);
+			bool modSingleHookFalse = modSingleHook.HasValue ? !modSingleHook.Value : false;
+			bool modSingleHookTrue = modSingleHook.HasValue ? modSingleHook.Value : false;
-			if (num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935) {
+			if ((num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935 || modSingleHookTrue) && !modSingleHookFalse) {
 				grappling[0] = -1;
 				grapCount = 0;
 				for (int num8 = 0; num8 < 1000; num8++) {
 					if (Main.projectile[num8].active && Main.projectile[num8].owner == whoAmI) {
+						bool? modSingleHook2 = ProjectileLoader.SingleGrappleHook(Main.projectile[num8].type, this);
+						if(modSingleHook2.HasValue) {
+							if (modSingleHook2.Value)
+								Main.projectile[num8].Kill();
+							continue;
+						}
+
 						switch (Main.projectile[num8].type) {
 							case 13:
 							case 230:
@@ -3645,6 +_,8 @@
 				}
 			}
 
+			ProjectileLoader.UseGrapple(this, ref num7);
+
 			Vector2 vector = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 			float num21 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
 			float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
@@ -3968,6 +_,11 @@
 			if (Main.myPlayer != whoAmI)
 				return;
 
+			OnHit_Inner(x, y, victim);
+			PlayerLoader.OnHitAnything(this, x, y, victim);
+		}
+				
+		private void OnHit_Inner(float x, float y, Entity victim) {
 			bool flag = victim is NPC && (((NPC)victim).type == 488 || ((NPC)victim).SpawnedFromStatue);
 			if (titaniumStormCooldown > 0)
 				flag = true;
@@ -4074,6 +_,9 @@
 		}
 
 		public void OpenPresent(int itemType) {
+			DropFromItem(itemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 			if (Main.rand.Next(15) == 0 && Main.hardMode) {
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 602);
@@ -4298,9 +_,12 @@
 						break;
 					}
 			}
+			*/
 		}
 
 		public void OpenLegacyPresent(int itemType) {
+			DropFromItem(itemType);
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 			int num = Main.rand.Next(14);
 			if (num == 0 && Main.hardMode) {
@@ -4315,18 +_,31 @@
 			}
 			else {
 				int number3 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 591, Main.rand.Next(20, 50));
+				// Extra patch context for the below.
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number3, 1f);
 			}
+			*/
 		}
 
+		// Return value added by TML.
-		public void QuickSpawnItem(IEntitySource source, int item, int stack = 1) {
+		public int QuickSpawnItem(IEntitySource source, int item, int stack = 1) {
 			int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
+
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
+
+			return number;
 		}
 
 		public void OpenBossBag(int type) {
+			DropFromItem(type);
+
+			if ((!ItemID.Sets.PreHardmodeLikeBossBag[type] || Main.tenthAnniversaryWorld)) {
+				TryGettingDevArmor(GetItemSource_OpenItem(type));
+			}
+
+			/*
 			GameModeData gameModeInfo = Main.GameModeInfo;
 			float strength = 1f;
 			if (gameModeInfo.IsJourneyMode) {
@@ -4898,15 +_,19 @@
 				}
 
 				int num15 = (int)value;
+				// Extra patch context for the below.
 				if (num15 < 1)
 					num15 = 1;
 
 				value -= (float)num15;
 				QuickSpawnItem(itemSource_OpenItem, 71, num15);
 			}
+			*/
 		}
 
-		private void TryGettingDevArmor(IEntitySource source) {
+		public void TryGettingDevArmor(IEntitySource source) {
+			ModLoader.Default.ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
+
 			if (Main.rand.Next(Main.tenthAnniversaryWorld ? 8 : 16) == 0) {
 				switch (Main.rand.Next(18)) {
 					case 0:
@@ -5027,6 +_,9 @@
 		}
 
 		public void OpenFishingCrate(int crateItemID) {
+			DropFromItem(crateItemID);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(crateItemID);
 			bool flag = ItemID.Sets.IsFishingCrateHardmode[crateItemID];
 			switch (crateItemID) {
@@ -6386,10 +_,12 @@
 						break;
 				}
 
+				// Extra patch context for the below.
 				int number72 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, type49, stack42);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number72, 1f);
 			}
+			*/
 		}
 
 		public int CountItem(int type, int stopCountingAt = 0) {
@@ -6417,7 +_,9 @@
 
 			for (int i = num; i != num2; i += num3) {
 				if (inventory[i].stack > 0 && inventory[i].type == type) {
+					if (ItemLoader.ConsumeItem(inventory[i], this))
-					inventory[i].stack--;
+						inventory[i].stack--;
+
 					if (inventory[i].stack <= 0)
 						inventory[i].SetDefaults();
 
@@ -6442,6 +_,9 @@
 		}
 
 		public void OpenShadowLockbox(int boxType) {
+			DropFromItem(boxType);
+
+			/*
 			bool flag = true;
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(boxType);
 			while (flag) {
@@ -6469,14 +_,19 @@
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 
 				if (Main.rand.Next(5) == 0) {
+				// Extra patch context for the below.
 					number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 5010, 1, noBroadcast: false, -1);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number, 1f);
 				}
 			}
+			*/
 		}
 
 		public void OpenLockBox(int lockboxItemType) {
+			DropFromItem(lockboxItemType);
+
+			/*
 			bool flag = true;
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(lockboxItemType);
 			while (flag) {
@@ -6510,15 +_,20 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 
+				// Extra patch context for the below.
 				if (Main.rand.Next(3) == 0) {
 					int number2 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 329, 1, noBroadcast: false, -1);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number2, 1f);
 				}
 			}
+			*/
 		}
 
 		public void OpenHerbBag(int bagType) {
+			DropFromItem(bagType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(bagType);
 			int num = Main.rand.Next(2, 5);
 			if (Main.rand.Next(3) == 0)
@@ -6572,23 +_,33 @@
 				if (Main.rand.Next(3) == 0)
 					num3 += Main.rand.Next(1, 5);
 
+				// Extra patch context for the below.
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, num2, num3);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
 		public void OpenCanofWorms(int sourceItemType) {
+			DropFromItem(sourceItemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 			QuickSpawnItem(itemSource_OpenItem, 2002, Main.rand.Next(5, 9));
 			if (Main.rand.Next(10) < 3)
 				QuickSpawnItem(itemSource_OpenItem, 3191, Main.rand.Next(1, 3));
 
+			// Extra patch context.
 			if (Main.rand.Next(20) == 0)
 				QuickSpawnItem(itemSource_OpenItem, 2895);
+			*/
 		}
 
 		public void OpenOyster(int sourceItemType) {
+			DropFromItem(sourceItemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 			if (Main.rand.Next(5) == 0) {
 				if (Main.rand.Next(15) == 0)
@@ -6597,12 +_,17 @@
 					QuickSpawnItem(itemSource_OpenItem, 4413);
 				else
 					QuickSpawnItem(itemSource_OpenItem, 4412);
+				// Extra patch context for the below.
 			}
 
 			QuickSpawnItem(itemSource_OpenItem, 4411);
+			*/
 		}
 
 		public void OpenGoodieBag(int itemType) {
+			DropFromItem(itemType);
+
+			/*
 			IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 			if (Main.rand.Next(150) == 0) {
 				int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1810);
@@ -6883,17 +_,22 @@
 						int number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1851);
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, number5, 1f);
+						// Extra patch context for the below.
 
 						number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1852);
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, number5, 1f);
 
+						// Extra patch context for the below.
 						break;
 					}
 			}
+			*/
 		}
 
 		public void UpdateDyes() {
+			// Extra patch context for the above.
+
 			cShieldFallback = -1;
 			cHead = (cBody = (cLegs = (cHandOn = (cHandOff = (cBack = (cFront = (cShoe = (cWaist = (cShield = (cNeck = (cFace = (cFaceHead = (cFaceFlower = (cBalloon = (cBalloon = (cWings = (cCarpet = (cFloatingTube = (cBackpack = (cTail = 0))))))))))))))))))));
 			cGrapple = (cMount = (cMinecart = (cPet = (cLight = (cYorai = (cPortableStool = (cUnicornHorn = (cAngelHalo = (cBeard = (cMinion = (cLeinShampoo = 0)))))))))));
@@ -6915,11 +_,12 @@
 					UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
 				}
 			}
+			PlayerLoader.UpdateDyes(this);
 
 			cYorai = cPet;
 		}
 
-		private void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem) {
+		internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem) {
 			if (armorItem.IsAir)
 				return;
 
@@ -6931,13 +_,13 @@
 			if (!num && flag)
 				return;
 
-			if (armorItem.handOnSlot > 0 && armorItem.handOnSlot < 24)
+			if (armorItem.handOnSlot > 0)
 				cHandOn = dyeItem.dye;
 
-			if (armorItem.handOffSlot > 0 && armorItem.handOffSlot < 16)
+			if (armorItem.handOffSlot > 0)
 				cHandOff = dyeItem.dye;
 
-			if (armorItem.backSlot > 0 && armorItem.backSlot < 37) {
+			if (armorItem.backSlot > 0) {
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
 					cBackpack = dyeItem.dye;
 				else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
@@ -6946,22 +_,22 @@
 					cBack = dyeItem.dye;
 			}
 
-			if (armorItem.frontSlot > 0 && armorItem.frontSlot < 13)
+			if (armorItem.frontSlot > 0)
 				cFront = dyeItem.dye;
 
-			if (armorItem.shoeSlot > 0 && armorItem.shoeSlot < 27)
+			if (armorItem.shoeSlot > 0)
 				cShoe = dyeItem.dye;
 
-			if (armorItem.waistSlot > 0 && armorItem.waistSlot < 17)
+			if (armorItem.waistSlot > 0)
 				cWaist = dyeItem.dye;
 
-			if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < 10)
+			if (armorItem.shieldSlot > 0)
 				cShield = dyeItem.dye;
 
-			if (armorItem.neckSlot > 0 && armorItem.neckSlot < 12)
+			if (armorItem.neckSlot > 0)
 				cNeck = dyeItem.dye;
 
-			if (armorItem.faceSlot > 0 && armorItem.faceSlot < 22) {
+			if (armorItem.faceSlot > 0) {
 				if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
 					cFaceHead = dyeItem.dye;
 				else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
@@ -6970,17 +_,17 @@
 					cFace = dyeItem.dye;
 			}
 
-			if (armorItem.beardSlot > 0 && armorItem.beardSlot < 5)
+			if (armorItem.beardSlot > 0)
 				cBeard = dyeItem.dye;
 
-			if (armorItem.balloonSlot > 0 && armorItem.balloonSlot < 20) {
+			if (armorItem.balloonSlot > 0) {
 				if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
 					cBalloonFront = dyeItem.dye;
 				else
 					cBalloon = dyeItem.dye;
 			}
 
-			if (armorItem.wingSlot > 0 && armorItem.wingSlot < 47)
+			if (armorItem.wingSlot > 0)
 				cWings = dyeItem.dye;
 
 			if (armorItem.type == 934)
@@ -7018,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public IEntitySource GetProjectileSource_Buff(int buffIndex) {
 			int buffId = buffType[buffIndex];
 			return new EntitySource_Buff(this, buffId, buffIndex);
@@ -7037,21 +_,51 @@
 		public IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 		public IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 		public IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => new EntitySource_OnHit_ByItemSourceID(this, victim, itemSourceId);
+		*/
+
+		// Internal redirects:
+		internal IEntitySource GetProjectileSource_Buff(int buffIndex) => GetSource_Buff(buffIndex);
+		internal IEntitySource GetProjectileSource_Item(Item item) => GetSource_ItemUse(item);
+		internal IEntitySource GetItemSource_OpenItem(int itemType) => GetSource_OpenItem(itemType);
+		internal IEntitySource GetItemSource_Death() => GetSource_Death();
+		internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId) => GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
+		internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => GetSource_OnHit(victim, context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId) => GetSource_OnHurt(attacker, context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_Accessory(Item item) => GetSource_Accessory(item);
+		internal IEntitySource GetProjectileSource_Misc(int projectileSourceId) => GetSource_Misc(context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+		internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => GetSource_OnHit(victim, context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId) => GetSource_FromThis(context: ProjectileSourceID.ToContextString(projectileSourceId));
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   Player.TML.Sources.cs (if exists);
 
 		public void UpdateBuffs(int i) {
+			/*
+			tML:
+			all accessories that previously used each class-specific crit field individually now use allCrit instead where appropriate
+			this allows them to automagically account for new classes, preventin' modders from havin' to do extra work for no reason
+			- thomas
+			*/
 			if (soulDrain > 0 && whoAmI == Main.myPlayer)
 				AddBuff(151, 2);
 
 			if (Main.dontStarveWorld)
 				UpdateStarvingState(withEmote: true);
 
-			for (int j = 0; j < 44; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (buffType[j] <= 0 || buffTime[j] <= 0)
 					continue;
 
 				if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
 					buffTime[j]--;
 
+				int originalIndex = j;
+
 				if (buffType[j] == 1) {
 					lavaImmune = true;
 					fireWalk = true;
@@ -7066,18 +_,31 @@
 					manaRegenDelayBonus += 0.5f;
 					manaRegenBonus += 10;
 				}
+				/*
 				else if (buffType[j] == 159 && inventory[selectedItem].melee) {
 					armorPenetration += 12;
 				}
+
+				tML:
+				commented out in favor of the below check for solely the Sharpening Station buff
+				this fixes the Sharpening Station's armor penetration bonus bein' able to be applied to non-melee weapons (most notably summons) by holdin' a melee weapon
+				- thomas
+				*/
+				else if (buffType[j] == 159) {
+					GetArmorPenetration(DamageClass.Melee) += 12;
+				}
 				else if (buffType[j] == 192) {
 					pickSpeed -= 0.2f;
 					moveSpeed += 0.2f;
 				}
 				else if (buffType[j] == 321) {
 					int num = 10;
+					allCrit += num;
+					/*
 					meleeCrit += num;
 					rangedCrit += num;
 					magicCrit += num;
+					*/
 					minionDamage += (float)num / 100f;
 				}
 				else if (buffType[j] == 2) {
@@ -7128,6 +_,7 @@
 				}
 				else if (buffType[j] == 16) {
 					archery = true;
+					arrowDamage *= 1.1f; // moved from PickAmmo, as StatModifier allows multiplicative buffs to be 'registered' alongside additive ones
 				}
 				else if (buffType[j] == 17) {
 					detectCreature = true;
@@ -7255,9 +_,12 @@
 					endurance += 0.1f;
 				}
 				else if (buffType[j] == 115) {
+					allCrit += 10;
+					/*
 					meleeCrit += 10;
 					rangedCrit += 10;
 					magicCrit += 10;
+					*/
 				}
 				else if (buffType[j] == 116) {
 					inferno = true;
@@ -7301,10 +_,13 @@
 					}
 				}
 				else if (buffType[j] == 117) {
+					allDamage += 0.1f;
+					/*
 					meleeDamage += 0.1f;
 					rangedDamage += 0.1f;
 					magicDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 				}
 				else if (buffType[j] == 119) {
 					loveStruck = true;
@@ -7349,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int m = 0; m < 44; m++) {
+							for (int m = 0; m < MaxBuffs; m++) {
 								if (buffType[m] >= 95 && buffType[m] <= 95 + num4 - 1) {
 									DelBuff(m);
 									m--;
@@ -7377,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int n = 0; n < 44; n++) {
+							for (int n = 0; n < MaxBuffs; n++) {
 								if (buffType[n] >= 170 && buffType[n] <= 170 + num5 - 1) {
 									DelBuff(n);
 									n--;
@@ -7401,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num7 = 0; num7 < 44; num7++) {
+							for (int num7 = 0; num7 < MaxBuffs; num7++) {
 								if (buffType[num7] >= 98 && buffType[num7] <= 98 + num6 - 1) {
 									DelBuff(num7);
 									num7--;
@@ -7431,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num10 = 0; num10 < 44; num10++) {
+							for (int num10 = 0; num10 < MaxBuffs; num10++) {
 								if (buffType[num10] >= 176 && buffType[num10] <= 178 + num9 - 1) {
 									DelBuff(num10);
 									num10--;
@@ -7456,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num13 = 0; num13 < 44; num13++) {
+							for (int num13 = 0; num13 < MaxBuffs; num13++) {
 								if (buffType[num13] >= 173 && buffType[num13] <= 175 + num12 - 1) {
 									DelBuff(num13);
 									num13--;
@@ -7483,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num16 = 0; num16 < 44; num16++) {
+							for (int num16 = 0; num16 < MaxBuffs; num16++) {
 								if (buffType[num16] >= 179 && buffType[num16] <= 181 + num15 - 1) {
 									DelBuff(num16);
 									num16--;
@@ -7500,10 +_,13 @@
 					}
 
 					float num17 = 0.15f * (float)nebulaLevelDamage;
+					allDamage += num17;
+					/*
 					meleeDamage += num17;
 					rangedDamage += num17;
 					magicDamage += num17;
 					minionDamage += num17;
+					*/
 				}
 				else if (buffType[j] == 62) {
 					if ((double)statLife <= (double)statLifeMax2 * 0.5) {
@@ -8191,10 +_,13 @@
 						}
 					}
 
+					allDamage += 0.2f;
+					/*
 					meleeDamage += 0.2f;
 					magicDamage += 0.2f;
 					rangedDamage += 0.2f;
 					minionDamage += 0.2f;
+					*/
 				}
 				else if (buffType[j] == 41) {
 					buffTime[j] = 18000;
@@ -8612,14 +_,20 @@
 				else if (buffType[j] == 26) {
 					wellFed = true;
 					statDefense += 2;
+					allCrit += 2;
+					allDamage += 0.05f;
+					/*
 					meleeCrit += 2;
 					meleeDamage += 0.05f;
+					*/
 					meleeSpeed += 0.05f;
+					/*
 					magicCrit += 2;
 					magicDamage += 0.05f;
 					rangedCrit += 2;
 					rangedDamage += 0.05f;
 					minionDamage += 0.05f;
+					*/
 					minionKB += 0.5f;
 					moveSpeed += 0.2f;
 					pickSpeed -= 0.05f;
@@ -8627,14 +_,20 @@
 				else if (buffType[j] == 206) {
 					wellFed = true;
 					statDefense += 3;
+					allCrit += 3;
+					allDamage += 0.075f;
+					/*
 					meleeCrit += 3;
 					meleeDamage += 0.075f;
+					*/
 					meleeSpeed += 0.075f;
+					/*
 					magicCrit += 3;
 					magicDamage += 0.075f;
 					rangedCrit += 3;
 					rangedDamage += 0.075f;
 					minionDamage += 0.075f;
+					*/
 					minionKB += 0.75f;
 					moveSpeed += 0.3f;
 					pickSpeed -= 0.1f;
@@ -8642,14 +_,18 @@
 				else if (buffType[j] == 207) {
 					wellFed = true;
 					statDefense += 4;
+					//meleeCrit += 4;
-					meleeCrit += 4;
+					allCrit += 4;
-					meleeDamage += 0.1f;
+					allDamage += 0.1f;
+					//meleeDamage += 0.1f;
 					meleeSpeed += 0.1f;
+					/*
 					magicCrit += 4;
 					magicDamage += 0.1f;
 					rangedCrit += 4;
 					rangedDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 					minionKB += 1f;
 					moveSpeed += 0.4f;
 					pickSpeed -= 0.15f;
@@ -8657,28 +_,40 @@
 				else if (buffType[j] == 333) {
 					hungry = true;
 					statDefense -= 2;
+					allCrit -= 2;
+					allDamage -= 0.05f;
+					/*
 					meleeCrit -= 2;
 					meleeDamage -= 0.05f;
+					*/
 					meleeSpeed -= 0.05f;
+					/*
 					magicCrit -= 2;
 					magicDamage -= 0.05f;
 					rangedCrit -= 2;
 					rangedDamage -= 0.05f;
 					minionDamage -= 0.05f;
+					*/
 					minionKB -= 0.5f;
 					pickSpeed += 0.05f;
 				}
 				else if (buffType[j] == 334) {
 					starving = true;
 					statDefense -= 4;
+					allCrit -= 4;
+					allDamage -= 0.1f;
+					/*
 					meleeCrit -= 4;
 					meleeDamage -= 0.1f;
+					*/
 					meleeSpeed -= 0.1f;
+					/*
 					magicCrit -= 4;
 					magicDamage -= 0.1f;
 					rangedCrit -= 4;
 					rangedDamage -= 0.1f;
 					minionDamage -= 0.1f;
+					*/
 					minionKB -= 1f;
 					pickSpeed += 0.15f;
 				}
@@ -8709,6 +_,8 @@
 				else if (buffType[j] == 79) {
 					meleeEnchant = 8;
 				}
+				if (j == originalIndex)
+					BuffLoader.Update(buffType[j], this, ref j);
 			}
 
 			UpdateHungerBuffs();
@@ -8732,7 +_,7 @@
 		}
 
 		public void UpdateHungerBuffs() {
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] <= 0 || buffTime[i] <= 0)
 					continue;
 
@@ -8773,7 +_,7 @@
 				return;
 
 			bool flag = false;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] > 0 && BuffID.Sets.IsFedState[buffType[i]]) {
 					flag = true;
 					break;
@@ -9256,6 +_,7 @@
 			bool flag = false;
 			for (int j = 0; j < 58; j++) {
 				int type = inventory[j].type;
+				ItemLoader.UpdateInventory(inventory[j], this);
 				RefreshInfoAccsFromItemType(type);
 				RefreshMechanicalAccsFromItemType(type);
 				if (type == 4743)
@@ -9281,7 +_,8 @@
 			if (flag) {
 				for (int l = 0; l < 40; l++) {
 					int type2 = bank4.item[l].type;
-					if (type2 < 0 || type2 > 5456 || ItemID.Sets.WorksInVoidBag[type2]) {
+					if (ItemID.Sets.WorksInVoidBag[type2]) {
+						ItemLoader.UpdateInventory(bank4.item[l], this);
 						RefreshInfoAccsFromItemType(type2);
 						RefreshMechanicalAccsFromItemType(type2);
 					}
@@ -9296,8 +_,14 @@
 
 			for (int m = 3; m < 10; m++) {
 				if (IsItemSlotUnlockedAndUsable(m))
-					ApplyEquipFunctional(m, armor[m]);
+					ApplyEquipFunctional(armor[m], hideVisibleAccessory[m]);
 			}
+
+
+			PlayerLoader.UpdateEquips(this);
+
+			if (kbGlove)
+				GetKnockback(DamageClass.Melee) *= 2f;
 
 			if (accFishingBobber)
 				fishingSkill += 10;
@@ -9306,14 +_,18 @@
 				lifeRegen += 2;
 				statDefense += 4;
 				meleeSpeed += 0.1f;
+				allDamage += 0.1f;
+				allCrit += 2;
+				/*
 				meleeDamage += 0.1f;
 				meleeCrit += 2;
 				rangedDamage += 0.1f;
 				rangedCrit += 2;
 				magicDamage += 0.1f;
 				magicCrit += 2;
+				*/
 				pickSpeed -= 0.15f;
-				minionDamage += 0.1f;
+				//minionDamage += 0.1f;
 				minionKB += 0.5f;
 			}
 
@@ -9322,6 +_,7 @@
 				maxTurrets++;
 			}
 
+			/* wing loop is merged into ApplyEquipFunctional
 			for (int n = 3; n < 10; n++) {
 				if (armor[n].wingSlot > 0 && IsItemSlotUnlockedAndUsable(n)) {
 					if (!hideVisibleAccessory[n] || (velocity.Y != 0f && !mount.Active))
@@ -9330,6 +_,7 @@
 					wingsLogic = armor[n].wingSlot;
 				}
 			}
+			*/
 
 			for (int num = 13; num < 20; num++) {
 				if (IsItemSlotUnlockedAndUsable(num))
@@ -9438,7 +_,7 @@
 			}
 		}
 
-		private void GrantArmorBenefits(Item armorPiece) {
+		public void GrantArmorBenefits(Item armorPiece) {
 			int type = armorPiece.type;
 			RefreshInfoAccsFromItemType(type);
 			RefreshMechanicalAccsFromItemType(type);
@@ -9612,6 +_,9 @@
 				armorPenetration += 5;
 
 			if (armorPiece.type == 2277) {
+				allDamage += 0.05f;
+				allCrit += 5;
+				/*
 				magicDamage += 0.05f;
 				meleeDamage += 0.05f;
 				rangedDamage += 0.05f;
@@ -9619,6 +_,7 @@
 				magicCrit += 5;
 				rangedCrit += 5;
 				meleeCrit += 5;
+				*/
 				meleeSpeed += 0.1f;
 				moveSpeed += 0.1f;
 			}
@@ -9633,9 +_,12 @@
 				nightVision = true;
 
 			if (armorPiece.type == 256 || armorPiece.type == 257 || armorPiece.type == 258) {
+				allCrit += 3;
+				/*
 				rangedCrit += 3;
 				meleeCrit += 3;
 				magicCrit += 3;
+				*/
 			}
 
 			if (armorPiece.type == 3374)
@@ -9686,10 +_,13 @@
 			}
 
 			if (armorPiece.type == 792 || armorPiece.type == 793 || armorPiece.type == 794) {
+				allDamage += 0.02f;
+				/*
 				meleeDamage += 0.03f;
 				rangedDamage += 0.03f;
 				magicDamage += 0.03f;
 				minionDamage += 0.03f;
+				*/
 			}
 
 			if (armorPiece.type == 231)
@@ -9718,16 +_,22 @@
 			}
 
 			if (armorPiece.type == 374) {
+				allCrit += 5;
+				/*
 				magicCrit += 5;
 				meleeCrit += 5;
 				rangedCrit += 5;
+				*/
 			}
 
 			if (armorPiece.type == 375) {
+				allDamage += 0.03f;
+				/*
 				rangedDamage += 0.03f;
 				meleeDamage += 0.03f;
 				magicDamage += 0.03f;
 				minionDamage += 0.03f;
+				*/
 				moveSpeed += 0.1f;
 			}
 
@@ -9747,16 +_,22 @@
 			}
 
 			if (armorPiece.type == 379) {
+				allDamage += 0.07f;
+				/*
 				rangedDamage += 0.07f;
 				meleeDamage += 0.07f;
 				magicDamage += 0.07f;
 				minionDamage += 0.07f;
+				*/
 			}
 
 			if (armorPiece.type == 380) {
+				allCrit += 10;
+				/*
 				magicCrit += 10;
 				meleeCrit += 10;
 				rangedCrit += 10;
+				*/
 			}
 
 			if (armorPiece.type >= 2367 && armorPiece.type <= 2369)
@@ -9779,16 +_,22 @@
 			}
 
 			if (armorPiece.type == 403) {
+				allDamage += 0.08f;
+				/*
 				rangedDamage += 0.08f;
 				meleeDamage += 0.08f;
 				magicDamage += 0.08f;
 				minionDamage += 0.08f;
+				*/
 			}
 
 			if (armorPiece.type == 404) {
+				allCrit += 7;
+				/*
 				magicCrit += 7;
 				meleeCrit += 7;
 				rangedCrit += 7;
+				*/
 				moveSpeed += 0.05f;
 			}
 
@@ -9809,6 +_,9 @@
 			}
 
 			if (armorPiece.type == 1208) {
+				allDamage += 0.03f;
+				allCrit += 2;
+				/*
 				meleeDamage += 0.03f;
 				rangedDamage += 0.03f;
 				magicDamage += 0.03f;
@@ -9816,9 +_,13 @@
 				magicCrit += 2;
 				meleeCrit += 2;
 				rangedCrit += 2;
+					*/
 			}
 
 			if (armorPiece.type == 1209) {
+				allDamage += 0.02f;
+				allCrit += 1;
+				/*
 				meleeDamage += 0.02f;
 				rangedDamage += 0.02f;
 				magicDamage += 0.02f;
@@ -9826,6 +_,7 @@
 				magicCrit++;
 				meleeCrit++;
 				rangedCrit++;
+				*/
 			}
 
 			if (armorPiece.type == 1210) {
@@ -9845,9 +_,12 @@
 			}
 
 			if (armorPiece.type == 1213) {
+				allCrit += 6;
+				/*
 				magicCrit += 6;
 				meleeCrit += 6;
 				rangedCrit += 6;
+				*/
 			}
 
 			if (armorPiece.type == 1214) {
@@ -9876,6 +_,9 @@
 			}
 
 			if (armorPiece.type == 1218) {
+				allDamage += 0.04f;
+				allCrit += 3;
+				/*
 				meleeDamage += 0.04f;
 				rangedDamage += 0.04f;
 				magicDamage += 0.04f;
@@ -9883,9 +_,13 @@
 				magicCrit += 3;
 				meleeCrit += 3;
 				rangedCrit += 3;
+				*/
 			}
 
 			if (armorPiece.type == 1219) {
+				allDamage += 0.03f;
+				allCrit += 3;
+				/*
 				meleeDamage += 0.03f;
 				rangedDamage += 0.03f;
 				magicDamage += 0.03f;
@@ -9893,6 +_,7 @@
 				magicCrit += 3;
 				meleeCrit += 3;
 				rangedCrit += 3;
+				*/
 				moveSpeed += 0.06f;
 			}
 
@@ -9919,31 +_,43 @@
 			}
 
 			if (armorPiece.type == 551 || armorPiece.type == 4900) {
+				allCrit += 7;
+				/*
 				magicCrit += 7;
 				meleeCrit += 7;
 				rangedCrit += 7;
+				*/
 			}
 
 			if (armorPiece.type == 552 || armorPiece.type == 4901) {
+				allDamage += 0.07f;
+				/*
 				rangedDamage += 0.07f;
 				meleeDamage += 0.07f;
 				magicDamage += 0.07f;
 				minionDamage += 0.07f;
+				*/
 				moveSpeed += 0.08f;
 			}
 
 			if (armorPiece.type == 4982) {
+				allCrit += 5;
+				/*
 				rangedCrit += 5;
 				meleeCrit += 5;
 				magicCrit += 5;
+				*/
 				manaCost -= 0.1f;
 			}
 
 			if (armorPiece.type == 4983) {
+				allDamage += 0.05f;
+				/*
 				rangedDamage += 0.05f;
 				meleeDamage += 0.05f;
 				magicDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 				huntressAmmoCost90 = true;
 			}
 
@@ -9969,6 +_,9 @@
 			}
 
 			if (armorPiece.type == 1004) {
+				allDamage += 0.05f;
+				allCrit += 7;
+				/*
 				meleeDamage += 0.05f;
 				magicDamage += 0.05f;
 				rangedDamage += 0.05f;
@@ -9976,12 +_,16 @@
 				magicCrit += 7;
 				meleeCrit += 7;
 				rangedCrit += 7;
+				*/
 			}
 
 			if (armorPiece.type == 1005) {
+				allCrit += 8;
+				/*
 				magicCrit += 8;
 				meleeCrit += 8;
 				rangedCrit += 8;
+				*/
 				moveSpeed += 0.05f;
 			}
 
@@ -10245,9 +_,10 @@
 				maxMinions++;
 				minionDamage += 0.11f;
 			}
+			ItemLoader.UpdateEquip(armorPiece, this);
 		}
 
-		private void GrantPrefixBenefits(Item item) {
+		public void GrantPrefixBenefits(Item item) {
 			if (item.prefix == 62)
 				statDefense++;
 
@@ -10264,43 +_,61 @@
 				statManaMax2 += 20;
 
 			if (item.prefix == 67) {
+				allCrit += 2;
+				/*
 				meleeCrit += 2;
 				rangedCrit += 2;
 				magicCrit += 2;
+				*/
 			}
 
 			if (item.prefix == 68) {
+				allCrit += 4;
+				/*
 				meleeCrit += 4;
 				rangedCrit += 4;
 				magicCrit += 4;
+				*/
 			}
 
 			if (item.prefix == 69) {
+				allDamage += 0.01f;
+				/*
 				meleeDamage += 0.01f;
 				rangedDamage += 0.01f;
 				magicDamage += 0.01f;
 				minionDamage += 0.01f;
+				*/
 			}
 
 			if (item.prefix == 70) {
+				allDamage += 0.02f;
+				/*
 				meleeDamage += 0.02f;
 				rangedDamage += 0.02f;
 				magicDamage += 0.02f;
 				minionDamage += 0.02f;
+				*/
 			}
 
 			if (item.prefix == 71) {
+				allDamage += 0.03f;
+				/*
 				meleeDamage += 0.03f;
 				rangedDamage += 0.03f;
 				magicDamage += 0.03f;
 				minionDamage += 0.03f;
+				*/
 			}
 
 			if (item.prefix == 72) {
+				allDamage += 0.04f;
+				/*
 				meleeDamage += 0.04f;
 				rangedDamage += 0.04f;
 				magicDamage += 0.04f;
 				minionDamage += 0.04f;
+				*/
 			}
 
 			if (item.prefix == 73)
@@ -10326,6 +_,8 @@
 
 			if (item.prefix == 80)
 				meleeSpeed += 0.04f;
+
+			// TODO: PrefixLoader.GrantPrefixBenefits(item)
 		}
 
 		private void SpawnHallucination(Item item) {
@@ -10459,6 +_,10 @@
 		}
 
 		private void ApplyEquipVanity(int itemSlot, Item currentItem) {
+			ApplyEquipVanity(currentItem); //remove itemSlot parameter and make public so mods can call from their own accessory slots
+		}
+
+		public void ApplyEquipVanity(Item currentItem) {
 			int type = currentItem.type;
 			if (currentItem.wingSlot > 0)
 				wings = currentItem.wingSlot;
@@ -10514,6 +_,8 @@
 
 			UpdateBootVisualEffects(currentItem);
 			UpdateFishingBobber(currentItem);
+
+			ItemLoader.UpdateVanity(currentItem, this);
 		}
 
 		private void DoEyebrellaRainEffect() {
@@ -10537,8 +_,12 @@
 			return ArmorIDs.Wing.Sets.Stats[wingID];
 		}
 
-		private void ApplyEquipFunctional(int itemSlot, Item currentItem) {
-			if (currentItem.expertOnly && !Main.expertMode)
+		// made public and itemSlot parameter removed, so mods can call this method from their own accessory slots
+		public void ApplyEquipFunctional(Item currentItem, bool hideVisual) {
+			int itemSlot = 0;
+			bool[] hideVisibleAccessory = { hideVisual };
+
+			if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
 				return;
 
 			if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
@@ -10669,6 +_,9 @@
 
 			if (currentItem.type == 3015) {
 				aggro -= 400;
+				allDamage += 0.05f;
+				allCrit += 5;
+				/*
 				meleeCrit += 5;
 				magicCrit += 5;
 				rangedCrit += 5;
@@ -10676,6 +_,7 @@
 				magicDamage += 0.05f;
 				rangedDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 			}
 
 			if (currentItem.type == 3016)
@@ -10910,6 +_,9 @@
 			}
 
 			if (currentItem.type == 1301) {
+				allDamage += 0.1f;
+				allCrit += 8;
+				/*
 				meleeCrit += 8;
 				rangedCrit += 8;
 				magicCrit += 8;
@@ -10917,6 +_,7 @@
 				rangedDamage += 0.1f;
 				magicDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (currentItem.type == 111)
@@ -10959,9 +_,12 @@
 			}
 
 			if (currentItem.type == 1248) {
+				allCrit += 10;
+				/*
 				meleeCrit += 10;
 				rangedCrit += 10;
 				magicCrit += 10;
+				*/
 			}
 
 			if (currentItem.type == 854)
@@ -11099,7 +_,7 @@
 			if (currentItem.type == 861) {
 				accMerman = true;
 				wolfAcc = true;
-				if (hideVisibleAccessory[itemSlot]) {
+					if (hideVisibleAccessory[itemSlot]) {
 					hideMerman = true;
 					hideWolf = true;
 				}
@@ -11366,10 +_,7 @@
 				minionDamage += 0.15f;
 
 			if (currentItem.type == 935) {
-				magicDamage += 0.12f;
+				allDamage += 0.12f;
-				meleeDamage += 0.12f;
-				rangedDamage += 0.12f;
-				minionDamage += 0.12f;
 			}
 
 			if (currentItem.wingSlot != -1)
@@ -11498,13 +_,24 @@
 				manaCost -= 0.08f;
 			}
 
+			if (currentItem.wingSlot > 0) {
+				if (!hideVisibleAccessory[itemSlot] || velocity.Y != 0f && !mount.Active)
+					wings = currentItem.wingSlot;
+
+				wingsLogic = currentItem.wingSlot;
+				equippedWings = currentItem;
+			}
+
+			ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
+
+			// Vanilla: Return early if sounds are not relevant
 			if (Main.myPlayer != whoAmI)
 				return;
 
 			if (currentItem.type == 5104 || currentItem.type == 5105) {
 				ApplyWilsonBeard(currentItem);
 			}
-			else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0 && Main.curMusic <= 92) {
+			else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0) {
 				SoundEngine.PlaySound(SoundID.Item166, base.Center);
 				int num3 = -1;
 				if (Main.curMusic == 1)
@@ -11670,10 +_,12 @@
 					currentItem.SetDefaults(5112);
 				else if (Main.curMusic == 91)
 					currentItem.SetDefaults(5362);
-				else if (Main.curMusic > 13)
+				else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(1596 + Main.curMusic - 14);
-				else if (num3 != -1)
+				else if (num3 != -1 && Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(num3 + 562);
+				else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out int modMusicBoxType))
+					currentItem.SetDefaults(modMusicBoxType);
 			}
 
 			ApplyMusicBox(currentItem);
@@ -11882,6 +_,9 @@
 			if (currentItem.type == 5362)
 				Main.musicBox2 = 87;
 
+			if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out int modMusicBox))
+				Main.musicBox2 = modMusicBox;
+
 			Main.musicBoxNotModifiedByVolume = Main.musicBox2;
 		}
 
@@ -11919,10 +_,13 @@
 
 			if (head == 112 && body == 75 && legs == 64) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
+				allDamage += 0.1f;
+				/*
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
 				rangedDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (head == 180 && body == 182 && legs == 122) {
@@ -11980,7 +_,7 @@
 					beetleCounter += 200f;
 
 				if (num != beetleOrbs && beetleOrbs > 0) {
-					for (int j = 0; j < 44; j++) {
+					for (int j = 0; j < MaxBuffs; j++) {
 						if (buffType[j] >= 98 && buffType[j] <= 100 && buffType[j] != 97 + num)
 							DelBuff(j);
 					}
@@ -11993,7 +_,7 @@
 				int num5 = 180;
 				if (beetleCounter >= (float)num5) {
 					if (beetleOrbs > 0 && beetleOrbs < 3) {
-						for (int k = 0; k < 44; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] >= 95 && buffType[k] <= 96)
 								DelBuff(k);
 						}
@@ -12140,7 +_,7 @@
 				AddBuff(60, 18000);
 			}
 			else if (crystalLeaf) {
-				for (int n = 0; n < 44; n++) {
+				for (int n = 0; n < MaxBuffs; n++) {
 					if (buffType[n] == 60)
 						DelBuff(n);
 				}
@@ -12252,6 +_,9 @@
 
 			if (head == 261 && body == 230 && legs == 213) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
+				allDamage += 0.1f;
+				allCrit += 10;
+				/*
 				rangedDamage += 0.1f;
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
@@ -12259,6 +_,7 @@
 				rangedCrit += 10;
 				meleeCrit += 10;
 				magicCrit += 10;
+				*/
 				dashType = 5;
 			}
 
@@ -12293,7 +_,7 @@
 				int num9 = 180;
 				if (solarCounter >= num9) {
 					if (solarShields > 0 && solarShields < 3) {
-						for (int num10 = 0; num10 < 44; num10++) {
+						for (int num10 = 0; num10 < MaxBuffs; num10++) {
 							if (buffType[num10] >= 170 && buffType[num10] <= 171)
 								DelBuff(num10);
 						}
@@ -12444,10 +_,12 @@
 				whipRangeMultiplier += 0.3f;
 				float num17 = 1.15f;
 				float num18 = 1f / num17;
-				whipUseTimeMultiplier *= num18;
+				summonerWeaponSpeedBonus += num17; // tML: Obsidian armor changed to additive.
 			}
 
 			ApplyArmorSoundAndDustChanges();
+
+			ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
 		}
 
 		public void UpdateSocialShadow() {
@@ -12782,6 +_,10 @@
 
 			bool flag9 = point.Y > Main.maxTilesY - 320;
 			bool flag10 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
+
+			// TODO: Are these flags a problem?
+			LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
+
 			ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, value4 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, value3 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, value2 - new Vector2(0f, 10f));
@@ -12935,6 +_,7 @@
 				}
 			}
 
+			ZonePurity = InZonePurity();
 			if (!dead) {
 				Point point2 = base.Center.ToTileCoordinates();
 				if (WorldGen.InWorld(point2.X, point2.Y, 1)) {
@@ -12968,6 +_,7 @@
 			else {
 				_funkytownAchievementCheckCooldown = 100;
 			}
+			LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
 		}
 
 		private void TrySpawningFaelings() {
@@ -13004,6 +_,13 @@
 		}
 
 		public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear) {
+			fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
+			hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
+			hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
+			backHairDraw = hair >= 0 && ArmorIDs.Head.Sets.DrawBackHair[hair];
+			drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
+
+			/*
 			fullHair = (hatHair = (hideHair = (drawsBackHairWithoutHeadgear = false)));
 			switch (head) {
 				case 0:
@@ -13124,6 +_,7 @@
 			backHairDraw = (num > 50 && (num < 56 || num > 63) && (num < 74 || num > 77) && (num < 88 || num > 89) && num != 100 && num != 104 && num != 112 && num < 116);
 			if (num == 133 || num == 134 || num == 146 || num == 162 || num == 6)
 				backHairDraw = true;
+			*/
 		}
 
 		public void UpdateDead() {
@@ -13138,6 +_,7 @@
 			ResetFloorFlags();
 			wings = 0;
 			wingsLogic = 0;
+			equippedWings = null;
 			ResetVisibleAccessories();
 			poisoned = false;
 			venom = false;
@@ -13184,7 +_,8 @@
 			leinforsHair = false;
 			overrideFishingBobber = -1;
 			gravDir = 1f;
+			PlayerLoader.UpdateDead(this);
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]]) {
 					buffTime[i] = 0;
 					buffType[i] = 0;
@@ -13380,6 +_,16 @@
 						toolStrategy = 5;
 				}
 
+				int modSelect = TileLoader.AutoSelect(tX, tY, this);
+
+				if (modSelect >= 0) {
+					if (nonTorch == -1)
+						nonTorch = selectedItem;
+
+					selectedItem = modSelect;
+					return;
+				}
+
 				SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
 				_lastSmartCursorToolStrategy = toolStrategy;
 			}
@@ -13420,7 +_,7 @@
 							SmartSelect_SelectItem(i);
 							return;
 						}
-						if (type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776)
+						if (ItemID.Sets.Glowsticks[type])
 							SmartSelect_SelectItem(i);
 						break;
 					case 1:
@@ -13442,16 +_,16 @@
 						}
 						break;
 					case 4:
-						if (inventory[i].type != 282 && inventory[i].type != 286 && inventory[i].type != 3002 && inventory[i].type != 3112 && inventory[i].type != 4776 && inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type]) {
+						if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type]) {
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
 						}
-						if ((type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776) && wetTile) {
+						if (ItemID.Sets.Glowsticks[type] && wetTile) {
 							SmartSelect_SelectItem(i);
 							return;
 						}
@@ -13464,6 +_,9 @@
 								}
 							}
 
+							if (!flag && !ItemLoader.NeedsAmmo(inventory[i], this))
+								flag = true;
+
 							if (flag) {
 								SmartSelect_SelectItem(i);
 								return;
@@ -13479,7 +_,7 @@
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
@@ -13506,6 +_,7 @@
 							case 3002:
 							case 3112:
 							case 4776:
+							case int thisType when ItemID.Sets.Glowsticks[thisType]:
 								SmartSelect_SelectItem(i);
 								return;
 						}
@@ -13693,6 +_,13 @@
 					if (tile == null)
 						return;
 
+					if (tile.type > TileID.Count) {
+						if (tile.active() && TileID.Sets.Torch[tile.type])
+							NearbyModTorch.Add(tile.type);
+
+						continue;
+					}
+
 					if (!tile.active() || tile.type != 4 || tile.frameX < 0 || tile.frameY < 0)
 						continue;
 
@@ -13776,7 +_,12 @@
 					NetMessage.SendData(4, -1, -1, null, whoAmI);
 
 				if (numberOfTorchAttacksMade >= 95) {
+					/*
 					int number = Item.NewItem(new EntitySource_ByItemSourceId(this, 6), (int)position.X, (int)position.Y, width, height, 5043);
+					*/
+
+					int number = Item.NewItem(new EntitySource_TorchGod(this, Context: "TorchGod_FavorLoot"), (int)position.X, (int)position.Y, width, height, 5043);
+
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number, 1f);
 				}
@@ -13806,7 +_,13 @@
 					float num10 = velocity.Length();
 					velocity.Normalize();
 					velocity *= num7;
+
+					/*
 					int num11 = Projectile.NewProjectile(GetProjectileSource_Misc(10), vector, velocity, 949, num8, 1f, whoAmI, num9, num10);
+					*/
+
+					int num11 = Projectile.NewProjectile(new EntitySource_TorchGod(this, Context: "TorchGod_Projectile"), vector, velocity, 949, num8, 1f, whoAmI, num9, num10);
+
 					Main.projectile[num11].ai[0] = num9;
 					Main.projectile[num11].ai[1] = num10;
 					Main.projectile[num11].netUpdate = true;
@@ -13823,6 +_,9 @@
 			if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < 24)
 				nearbyTorch[inventory[selectedItem].placeStyle] = true;
 
+			if (TileLoader.GetTile(inventory[selectedItem].createTile) is ModTile modTile && TileID.Sets.Torch[modTile.Type])
+				NearbyModTorch.Add(modTile.Type);
+
 			float num = 0f;
 			float num2 = 0f;
 			if (!ZoneDungeon && !ZoneLihzhardTemple) {
@@ -13899,6 +_,7 @@
 				}
 			}
 
+			TileLoader.ModifyTorchLuck(this, ref num2, ref num);
 			if (num2 >= 1f)
 				torchLuck += 1f;
 			else if (num2 > 0f)
@@ -13915,6 +_,7 @@
 			for (int i = 0; i < 24; i++) {
 				nearbyTorch[i] = false;
 			}
+			NearbyModTorch.Clear();
 
 			if (torchLuck < 0f)
 				torchLuck = 0f;
@@ -14040,7 +_,7 @@
 			arcticDivingGear = false;
 			noBuilding = false;
 			strongBees = false;
-			armorPenetration = 0;
+			// armorPenetration = 0;
 			ashWoodBonus = false;
 			shroomiteStealth = false;
 			statDefense = 0;
@@ -14051,6 +_,7 @@
 			canFloatInWater = false;
 			lifeRegen = 0;
 			manaCost = 1f;
+			/* individual class stats handled by ResetDamageClassData
 			meleeSpeed = 1f;
 			meleeDamage = 1f;
 			rangedDamage = 1f;
@@ -14061,6 +_,7 @@
 			meleeCrit = 4;
 			rangedCrit = 4;
 			magicCrit = 4;
+			*/
 			hasFootball = false;
 			drawingFootball = false;
 			minionKB = 0f;
@@ -14101,18 +_,27 @@
 
 			honeyCombItem = null;
 			gravControl2 = false;
+			PlayerLoader.ModifyMaxStats(this);
 			statLifeMax2 = statLifeMax;
 			statManaMax2 = statManaMax;
 			chloroAmmoCost80 = false;
 			huntressAmmoCost90 = false;
 			ammoCost80 = false;
 			ammoCost75 = false;
+			ThrownCost50 = false;
+			ThrownCost33 = false;
+			ThrownVelocity = 1f;
 			manaRegenBuff = false;
 			hasCreditsSceneMusicBox = false;
+			arrowDamage = StatModifier.Default;
+			bulletDamage = StatModifier.Default;
+			rocketDamage = StatModifier.Default;
+			/*
 			arrowDamage = 1f;
 			arrowDamageAdditiveStack = 0f;
 			bulletDamage = 1f;
 			rocketDamage = 1f;
+			*/
 			coolWhipBuff = false;
 			yoraiz0rEye = 0;
 			yoraiz0rDarkness = false;
@@ -14197,7 +_,7 @@
 
 			endurance = 0f;
 			whipRangeMultiplier = 1f;
-			whipUseTimeMultiplier = 1f;
+			//whipUseTimeMultiplier = 1f;
 			calmed = false;
 			beetleOrbs = 0;
 			beetleBuff = false;
@@ -14371,6 +_,7 @@
 			slowOgreSpit = false;
 			wings = 0;
 			wingsLogic = 0;
+			equippedWings = null;
 			wingTimeMax = 0;
 			brokenArmor = false;
 			silence = false;
@@ -14481,17 +_,19 @@
 				}
 			}
 
+			ResetDamageClassData();
 			mount.CheckMountBuff(this);
+			PlayerLoader.ResetEffects(this);
 		}
 
 		private void UpdateLadyBugLuckTime() {
 			if (ladyBugLuckTimeLeft > 0) {
-				ladyBugLuckTimeLeft -= Main.dayRate;
+				ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
 				if (ladyBugLuckTimeLeft < 0)
 					ladyBugLuckTimeLeft = 0;
 			}
 			else if (ladyBugLuckTimeLeft < 0) {
-				ladyBugLuckTimeLeft += Main.dayRate;
+				ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
 				if (ladyBugLuckTimeLeft > 0)
 					ladyBugLuckTimeLeft = 0;
 			}
@@ -14661,6 +_,7 @@
 				lifeRegen -= 100;
 			}
 
+			PlayerLoader.UpdateBadLifeRegen(this);
 			if (honey && lifeRegen < 0) {
 				lifeRegen += 4;
 				if (lifeRegen > 0)
@@ -14731,6 +_,7 @@
 			if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
 				lifeRegen += 2;
 
+			PlayerLoader.UpdateLifeRegen(this);
 			if (bleed)
 				lifeRegenTime = 0f;
 
@@ -14798,6 +_,7 @@
 			if (rabid)
 				num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
 
+			PlayerLoader.NaturalLifeRegen(this, ref num5);
 			float num7 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
 			num5 *= num7;
 			lifeRegen += (int)Math.Round(num5);
@@ -14989,8 +_,8 @@
 
 		public void UpdateJumpHeight() {
 			if (mount.Active) {
-				jumpHeight = mount.JumpHeight(velocity.X);
+				jumpHeight = mount.JumpHeight(this, velocity.X);
-				jumpSpeed = mount.JumpSpeed(velocity.X);
+				jumpSpeed = mount.JumpSpeed(this, velocity.X);
 			}
 			else {
 				if (jumpBoost) {
@@ -15288,7 +_,7 @@
 						direction = -1;
 				}
 				else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange) {
-					direction = -1;
+					direction = -1 ;
 				}
 
 				if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly()) {
@@ -15403,7 +_,7 @@
 				if (flag4)
 					num5 = 30;
 
-				float damage = (float)num5 * minionDamage;
+				float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
 				float knockback = 10f;
 				if (flag4)
 					knockback = 7f;
@@ -15420,7 +_,7 @@
 
 				rect2.Width = 2;
 				rect2.Inflate(6, 12);
-				float damage2 = 100f * minionDamage;
+				float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
 				float knockback2 = 12f;
 				int nPCImmuneTime2 = 30;
 				int playerImmuneTime2 = 6;
@@ -15434,7 +_,7 @@
 
 				rect3.Width = 2;
 				rect3.Inflate(6, 12);
-				float damage3 = 120f * minionDamage;
+				float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
 				float knockback3 = 12f;
 				int nPCImmuneTime3 = 30;
 				int playerImmuneTime3 = 6;
@@ -15448,7 +_,7 @@
 
 				rect4.Width = 2;
 				rect4.Inflate(6, 12);
-				float damage4 = 90f * minionDamage;
+				float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
 				float knockback4 = 10f;
 				int nPCImmuneTime4 = 30;
 				int playerImmuneTime4 = 6;
@@ -15462,7 +_,7 @@
 
 				rect5.Width = 2;
 				rect5.Inflate(6, 12);
-				float damage5 = 40f * minionDamage;
+				float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 				float knockback5 = 10f;
 				int nPCImmuneTime5 = 30;
 				int playerImmuneTime5 = 12;
@@ -15499,7 +_,10 @@
 				num -= height;
 
 			if (runSoundDelay == 0 && velocity.Y == 0f) {
+				/*
 				SoundEngine.PlaySound(hermesStepSound.SoundType, (int)position.X, (int)position.Y, hermesStepSound.SoundStyle);
+				*/
+				SoundEngine.PlaySound(hermesStepSound.Style, position);
 				runSoundDelay = hermesStepSound.IntendedCooldown;
 			}
 
@@ -15639,7 +_,7 @@
 			}
 
 			if (num != 0) {
-				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
 				for (int i = 0; i < num2; i++) {
 					WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
 				}
@@ -15685,7 +_,9 @@
 				damage = ((!Main.expertMode) ? ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].NormalDamageDealt)) : ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].ExpertDamageDealt)));
 
 			OnHit(npc.Center.X, npc.Center.Y, npc);
+
+			// TODO: should armorPenetration be passed in to this function? Class specific armor penetration bonuses are currently ignored
-			damage += npc.checkArmorPenetration(armorPenetration, 0f);
+			damage += npc.checkArmorPenetration((int)armorPenetration, 0);
 			NPCKillAttempt attempt = new NPCKillAttempt(npc);
 			int dmg = (int)npc.StrikeNPC(damage, knockback, direction, crit);
 			if (accDreamCatcher)
@@ -15745,7 +_,7 @@
 
 					Rectangle rect2 = nPC.getRect();
 					if (rect.Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(base.position, width, height, nPC.position, nPC.width, nPC.height))) {
-						float num = 40f * minionDamage;
+						float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 						float knockback = 5f;
 						int direction = base.direction;
 						if (velocity.X < 0f)
@@ -16147,16 +_,17 @@
 
 						Rectangle rect = nPC.getRect();
 						if (rectangle.Intersects(rect) && (nPC.noTileCollide || CanHit(nPC))) {
-							float num = 30f * meleeDamage;
-							float num2 = 9f;
+							float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
+							float num2 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 							bool crit = false;
+							/*
 							if (kbGlove)
 								num2 *= 2f;
 
 							if (kbBuff)
 								num2 *= 1.5f;
-
-							if (Main.rand.Next(100) < meleeCrit)
+							*/
+							if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 								crit = true;
 
 							int num3 = base.direction;
@@ -16197,16 +_,17 @@
 							ConsumeSolarFlare();
 						}
 
-						float num4 = 150f * meleeDamage;
-						float num5 = 9f;
+						float num4 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
+						float num5 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 						bool crit2 = false;
+						/*
 						if (kbGlove)
 							num5 *= 2f;
 
 						if (kbBuff)
 							num5 *= 1.5f;
-
-						if (Main.rand.Next(100) < meleeCrit)
+						*/
+						if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 							crit2 = true;
 
 						int direction = base.direction;
@@ -16443,6 +_,15 @@
 			solarDashConsumedFlare = false;
 		}
 
+		/*
+		TO-DO:
+		- make public, as it has little reason to be private and could be of great help to those makin' modded dashes
+		- properly explain how to use this in the context of programmin' a modded dash (use ExampleShield for this; see below)
+		- make ExampleShield use this, and simplify it accordingly (it currently has way too many movin' parts that require extra upkeep, for way too little payoff)
+
+		I'll do all this in an upcomin' PR if nobody else does
+		-thomas
+		*/
 		private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null) {
 			dir = 0;
 			dashing = false;
@@ -16736,8 +_,10 @@
 				float num5 = 0.1f;
 				if (wingsLogic == 26) {
 					num2 = 0.75f;
+					//patch file: num2, num5
 					num5 = 0.15f;
 					num4 = 1f;
+					//patch file: num, num3, num4
 					num3 = 2.5f;
 					num = 0.125f;
 				}
@@ -16834,6 +_,7 @@
 						num = 0.15f;
 				}
 
+				ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
 				velocity.Y -= num * gravDir;
 				if (gravDir == 1f) {
 					if (velocity.Y > 0f)
@@ -17138,7 +_,7 @@
 						Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
 						RemoveAllGrapplingHooks();
 						int num4 = 13;
-						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode))
+						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
 							num4 = miscEquips[2].mountType;
 
 						int num5 = height + Mount.GetHeightBoost(num4);
@@ -17210,6 +_,11 @@
 				Projectile projectile = Main.projectile[grappling[i]];
 				if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
 					continue;
+				int type = projectile.type;
+				bool useAiType = projectile.ModProjectile != null && projectile.ModProjectile.AIType > 0;
+				if (useAiType) {
+					projectile.type = projectile.ModProjectile.AIType;
+				}
 
 				num += projectile.position.X + (float)(projectile.width / 2);
 				num2 += projectile.position.Y + (float)(projectile.height / 2);
@@ -17251,6 +_,10 @@
 					if (value2.X != 0f)
 						preferredPlayerDirectionToSet = Math.Sign(value2.X);
 				}
+				if (useAiType) {
+					projectile.type = type;
+				}
+				ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num2);
 			}
 
 			if (num3 == 0) {
@@ -17275,13 +_,14 @@
 			if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
 				num9 = 16f;
 
+			ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num9);
 			float num10 = num8;
 			num10 = ((!(num8 > num9)) ? 1f : (num9 / num8));
 			preferedPlayerVelocityX *= num10;
 			preferedPlayerVelocityY *= num10;
 		}
 
-		private void RefreshMovementAbilities(bool doubleJumps = true) {
+		public void RefreshMovementAbilities(bool doubleJumps = true) { //Made public, because this is useful
 			wingTime = wingTimeMax;
 			rocketTime = rocketTimeMax;
 			rocketDelay = 0;
@@ -18062,10 +_,10 @@
 			if (gravDir == -1f)
 				num2 = (int)(position.Y - 0.1f) / 16;
 
-			Tile floorTile = GetFloorTile(num, num2);
+			Tile? floorTile = GetFloorTile(num, num2);
 			int num3 = -1;
 			if (floorTile != null)
-				num3 = floorTile.type;
+				num3 = floorTile.Value.type;
 
 			if (num3 <= -1) {
 				ResetFloorFlags();
@@ -18073,18 +_,21 @@
 			}
 
 			sticky = (num3 == 229);
-			slippy = IsTileIceSkateSlippery(floorTile);
+			slippy = TileID.Sets.IceSkateSlippery[num3];
 			slippy2 = (num3 == 197);
 			powerrun = (num3 == 198);
 			runningOnSand = (TileID.Sets.Conversion.Sand[num3] || TileID.Sets.Conversion.Sandstone[num3] || TileID.Sets.Conversion.HardenedSand[num3]);
 			if (num3 == 666 && whoAmI == Main.myPlayer)
 				AddBuff(120, 180);
 
+
+			TileLoader.FloorVisuals(num3, this);
+
 			if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
 				num3 = -1;
 
 			if (!wet && !mount.Cart)
-				MakeFloorDust(Falling, num3, floorTile.color());
+				MakeFloorDust(Falling, num3, floorTile.Value.color());
 		}
 
 		public void ResetFloorFlags() {
@@ -18095,8 +_,8 @@
 			runningOnSand = false;
 		}
 
-		public static Tile GetFloorTile(int x, int y) {
+		public static Tile? GetFloorTile(int x, int y) {
-			Tile result = null;
+			Tile? result = null;
 			if (Main.tile[x - 1, y] == null)
 				Main.tile[x - 1, y] = new Tile();
 
@@ -18140,7 +_,7 @@
 					MovementVector = movementVector
 				}, whoAmI);
 			}
-
+			if (TileLoader.HasWalkDust(type)) { } else
 			if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && type != 666)
 				return;
 
@@ -18226,6 +_,7 @@
 
 				if (num3 == 53 && Main.rand.Next(3) != 0)
 					flag2 = false;
+				// Patch context: num3 & flag2
 
 				Color newColor = default(Color);
 				if (type == 193)
@@ -18237,6 +_,7 @@
 				if (type == 460)
 					newColor = new Color(100, 150, 130, 100);
 
+				TileLoader.WalkDust(type, ref num3, ref flag2, ref newColor);
 				if (!Falling) {
 					float num4 = Math.Abs(velocity.X) / 3f;
 					if ((float)Main.rand.Next(100) > num4 * 100f)
@@ -18495,6 +_,8 @@
 		}
 
 		public void Update(int i) {
+			using var _currentPlr = new Main.CurrentPlayerOverride(this);
+
 			if (i == Main.myPlayer && Main.netMode != 2)
 				LockOnHelper.Update();
 
@@ -18616,6 +_,7 @@
 			if (whoAmI != Main.myPlayer) {
 				int num2 = (int)(base.position.X + (float)(width / 2)) / 16;
 				int num3 = (int)(base.position.Y + (float)(height / 2)) / 16;
+				/*
 				if (!WorldGen.InWorld(num2, num3, 4))
 					flag = true;
 				else if (Main.tile[num2, num3] == null)
@@ -18628,6 +_,9 @@
 					flag = true;
 				else if (Main.tile[num2, num3 + 3] == null)
 					flag = true;
+				*/
+				if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num2 - 3, num3 - 3, num2 + 3, num3 + 3))
+					flag = true;
 
 				if (flag) {
 					outOfRange = true;
@@ -18661,6 +_,7 @@
 
 			UpdateHairDyeDust();
 			UpdateMiscCounter();
+			PlayerLoader.PreUpdate(this);
 			infernoCounter++;
 			if (infernoCounter >= 180)
 				infernoCounter = 0;
@@ -19016,6 +_,7 @@
 					}
 
 					controlDownHold = (holdDownCardinalTimer[0] >= 45);
+					PlayerLoader.SetControls(this);
 					if (controlInv) {
 						if (releaseInventory)
 							ToggleInv();
@@ -19155,7 +_,10 @@
 							CaptureManager.Instance.Scrolling();
 						}
 						else if (!flag8) {
+							if (PlayerInput.MouseInModdedUI.Count > 0) {
+								//Do nothing
+							}
-							if (!Main.playerInventory) {
+							else if (!Main.playerInventory) {
 								HandleHotbar();
 							}
 							else {
@@ -19199,6 +_,7 @@
 										Main.focusRecipe = 0;
 								}
 							}
+							PlayerInput.MouseInModdedUI.Clear();
 						}
 					}
 					else {
@@ -19364,11 +_,14 @@
 						}
 					}
 
+					/*
 					bool flag11 = false;
 					for (int num23 = 3; num23 < 10; num23++) {
 						if (armor[num23].stack > 0 && armor[num23].wingSlot > -1)
 							flag11 = true;
 					}
+					*/
+					bool flag11 = equippedWings != null;
 
 					if (stoned) {
 						int num24 = (int)(((float)num18 * gravDir - 2f) * 20f);
@@ -19500,9 +_,17 @@
 			else
 				afkCounter = 0;
 
+			/*
 			meleeCrit += inventory[selectedItem].crit;
 			magicCrit += inventory[selectedItem].crit;
 			rangedCrit += inventory[selectedItem].crit;
+
+			tML:
+			this, right here, is the principal cause of crit chance bein' a massive pain in the ass
+			by commentin' this out, your critical strike chance for the vanilla "three" classes capable of crits will no longer be modified based on your current weapon
+			this fixes a number of issues related to tooltip crit displays, and while it isn't the primary fix for crit swap, it definitely contributes to it
+			- thomas
+			*/
 			if (whoAmI == Main.myPlayer) {
 				Main.musicBox2 = -1;
 				if (Main.SceneMetrics.WaterCandleCount > 0)
@@ -19536,12 +_,17 @@
 					AddBuff(194, 2, quiet: false);
 			}
 
+			PlayerLoader.PreUpdateBuffs(this);
-			for (int num26 = 0; num26 < 355; num26++) {
+			for (int num26 = 0; num26 < BuffLoader.BuffCount; num26++) {
 				buffImmune[num26] = false;
 			}
 
 			UpdateProjectileCaches(i);
 			UpdateBuffs(i);
+			PlayerLoader.PostUpdateBuffs(this);
+			if (kbBuff)
+				allKB *= 1.5f;
+
 			if (whoAmI == Main.myPlayer) {
 				if (!onFire && !poisoned)
 					trapDebuffSource = false;
@@ -19579,7 +_,7 @@
 			hideWolf = false;
 			forceWerewolf = false;
 			if (whoAmI == Main.myPlayer) {
-				for (int num27 = 0; num27 < 44; num27++) {
+				for (int num27 = 0; num27 < MaxBuffs; num27++) {
 					if (buffType[num27] > 0 && buffTime[num27] <= 0)
 						DelBuff(num27);
 				}
@@ -19641,6 +_,7 @@
 
 			UpdateArmorLights();
 			UpdateArmorSets(i);
+			PlayerLoader.PostUpdateEquips(this); // TODO, move down?
 			if (maxTurretsOld != maxTurrets) {
 				UpdateMaxTurrets();
 				maxTurretsOld = maxTurrets;
@@ -19688,8 +_,11 @@
 
 				meleeDamage += (1f - stealth) * 3f;
 				meleeCrit += (int)((1f - stealth) * 30f);
+				GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
+				/*
 				if (meleeCrit > 100)
-					meleeCrit = 100;
+					meleeCrit = new Modifier(100);
+				*/
 
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
@@ -19721,6 +_,7 @@
 
 				rangedDamage += (1f - stealth) * 0.6f;
 				rangedCrit += (int)((1f - stealth) * 10f);
+				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
 					stealthTimer--;
@@ -19740,6 +_,7 @@
 
 					rangedDamage += (1f - stealth) * 0.8f;
 					rangedCrit += (int)((1f - stealth) * 20f);
+					GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 					aggro -= (int)((1f - stealth) * 1200f);
 					accRunSpeed *= 0.3f;
 					maxRunSpeed *= 0.3f;
@@ -19787,9 +_,13 @@
 			if (manaSick)
 				magicDamage *= 1f - manaSickReduction;
 
+			/*
 			float num32 = meleeSpeed - 1f;
 			num32 *= ItemID.Sets.BonusMeleeSpeedMultiplier[inventory[selectedItem].type];
 			meleeSpeed = 1f + num32;
+
+			tML: attack speed multipliers now applied in Player.GetWeaponAttackSpeed
+			*/
 			if (tileSpeed > 3f)
 				tileSpeed = 3f;
 
@@ -19798,8 +_,11 @@
 				wallSpeed = 3f;
 
 			wallSpeed = 1f / wallSpeed;
+			// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+			/*
 			if (statManaMax2 > 400)
 				statManaMax2 = 400;
+			*/
 
 			if (statDefense < 0)
 				statDefense = 0;
@@ -19837,6 +_,7 @@
 				pickSpeed = 0.3f;
 
 			CapAttackSpeeds();
+			PlayerLoader.PostUpdateMiscEffects(this);
 			UpdateLifeRegen();
 			soulDrain = 0;
 			UpdateManaRegen();
@@ -19849,7 +_,7 @@
 			runAcceleration *= moveSpeed;
 			maxRunSpeed *= moveSpeed;
 			UpdateJumpHeight();
-			for (int num33 = 0; num33 < 44; num33++) {
+			for (int num33 = 0; num33 < MaxBuffs; num33++) {
 				if (buffType[num33] > 0 && buffTime[num33] > 0 && buffImmune[buffType[num33]])
 					DelBuff(num33);
 			}
@@ -19861,11 +_,14 @@
 				statDefense /= 2;
 
 			if (witheredWeapon) {
+				allDamage *= 0.5f;
+				/*
 				meleeDamage *= 0.5f;
 				rangedDamage *= 0.5f;
 				magicDamage *= 0.5f;
 				minionDamage *= 0.5f;
 				rangedMultDamage *= 0.5f;
+				*/
 			}
 
 			lastTileRangeX = tileRangeX;
@@ -20385,6 +_,7 @@
 						mount.UpdateDrill(this, controlUp, controlDown);
 				}
 
+				PlayerLoader.PostUpdateRunSpeeds(this);
 				HorizontalMovement();
 				if (forcedGravity > 0) {
 					gravDir = -1f;
@@ -20474,12 +_,13 @@
 					CancelAllJumpVisualEffects();
 				}
 				else {
+					bool isCustomWings = ItemLoader.WingUpdate(this, flag20);
 					if (flag20) {
 						WingAirVisuals();
 						WingMovement();
 					}
 
-					WingFrame(flag20);
+					WingFrame(flag20, isCustomWings);
 					if (wingsLogic > 0 && rocketBoots != 0 && base.velocity.Y != 0f && rocketTime != 0) {
 						int num45 = 6;
 						int num46 = rocketTime * num45;
@@ -20490,7 +_,7 @@
 						rocketTime = 0;
 					}
 
-					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45) {
+					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45 && !isCustomWings) {
 						bool flag21 = wingFrame == 3;
 						if (wings == 43 || wings == 44)
 							flag21 = (wingFrame == 4);
@@ -20743,7 +_,7 @@
 											wingFrame = 0;
 									}
 								}
-								else if (wings != 22 && wings != 28) {
+								else if (wings != 22 && wings != 28 && !isCustomWings) {
 									if (wings == 30) {
 										wingFrameCounter++;
 										int num62 = 5;
@@ -20956,7 +_,7 @@
 				}
 
 				if (flag22 && Main.myPlayer == whoAmI) {
-					for (int num78 = 0; num78 < 44; num78++) {
+					for (int num78 = 0; num78 < MaxBuffs; num78++) {
 						if (buffType[num78] == 38)
 							DelBuff(num78);
 					}
@@ -21047,14 +_,17 @@
 
 					for (int num79 = 0; num79 < 200; num79++) {
 						if (Main.npc[num79].active && !Main.npc[num79].dontTakeDamage && !Main.npc[num79].friendly && Main.npc[num79].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num79]) && rectangle2.Intersects(new Rectangle((int)Main.npc[num79].position.X, (int)Main.npc[num79].position.Y, Main.npc[num79].width, Main.npc[num79].height))) {
+							/*
 							float num80 = meleeCrit;
 							if (num80 < (float)rangedCrit)
 								num80 = rangedCrit;
 
 							if (num80 < (float)magicCrit)
 								num80 = magicCrit;
-
+							*/
 							bool crit = false;
+							// potentially bad for performance
+							float num80 = DamageClassLoader.DamageClasses.Select(t => GetTotalCritChance(t)).Max();
 							if ((float)Main.rand.Next(1, 101) <= num80)
 								crit = true;
 
@@ -21200,7 +_,7 @@
 
 			if (num84) {
 				if ((onFire || onFire3) && !lavaWet) {
-					for (int num87 = 0; num87 < 44; num87++) {
+					for (int num87 = 0; num87 < MaxBuffs; num87++) {
 						int num88 = buffType[num87];
 						if (num88 == 24 || num88 == 323)
 							DelBuff(num87);
@@ -21512,6 +_,7 @@
 			if (vortexDebuff)
 				base.velocity.Y = base.velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
 
+			PlayerLoader.PreUpdateMovement(this);
 			if (tongued) {
 				base.position += base.velocity;
 				flag29 = false;
@@ -21600,11 +_,12 @@
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
-
+			// More patch context.
 			grappling[0] = -1;
 			grapCount = 0;
 			UpdateReleaseUseTile();
 			UpdateAdvancedShadows();
+			PlayerLoader.PostUpdate(this);
 		}
 
 		private void TryToShimmerUnstuck() {
@@ -21752,9 +_,11 @@
 		}
 
 		private void CapAttackSpeeds() {
+			/*
 			float num = meleeSpeed;
 			meleeSpeed = TurnAttackSpeedToUseTimeMultiplier(num);
 			summonerWeaponSpeedBonus = TurnAttackSpeedToUseTimeMultiplier(num + summonerWeaponSpeedBonus);
+			*/
 		}
 
 		private float TurnAttackSpeedToUseTimeMultiplier(float speed) {
@@ -21844,6 +_,9 @@
 		}
 
 		public void RecalculateLuck() {
+			if (!PlayerLoader.PreModifyLuck(this, ref luck))
+				goto skipVanillaLuck;
+
 			luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
 			luck += (float)(int)luckPotion * 0.1f;
 			if (usedGalaxyPearl)
@@ -21857,6 +_,9 @@
 
 			luck += equipmentBasedLuckBonus;
 			luck += CalculateCoinLuck();
+
+			skipVanillaLuck:
+			PlayerLoader.ModifyLuck(this, ref luck);
 		}
 
 		public static int GetMouseScrollDelta() => PlayerInput.ScrollWheelDelta / 120;
@@ -21963,6 +_,8 @@
 
 			if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
 				runSlowdown *= 6f;
+
+			ItemLoader.HorizontalWingSpeeds(this);
 		}
 
 		private void RocketBootVisuals() {
@@ -22076,7 +_,7 @@
 			}
 		}
 
-		public void WingFrame(bool wingFlap) {
+		public void WingFrame(bool wingFlap, bool isCustomWings = false) {
 			bool flag = wingsLogic != wings;
 			if (wings == 4) {
 				if (wingFlap || jump > 0) {
@@ -22717,6 +_,8 @@
 				num27 = 3;
 			}
 
+			if (isCustomWings) return;
+
 			if (wings == 32)
 				num27 = 3;
 
@@ -23077,7 +_,7 @@
 			if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
 				r = new Rectangle(chestPointX * 16, chestPointY * 16, 32, 32);
 
-			if (tile.type == 88)
+			if (TileID.Sets.BasicDresser[tile.type])
 				r = new Rectangle(chestPointX * 16, chestPointY * 16, 48, 32);
 
 			if (tile.type == 29)
@@ -23291,6 +_,9 @@
 						break;
 				}
 
+				if (!NPCLoader.CanHitPlayer(Main.npc[i], this, ref specialHitSetter) || !PlayerLoader.CanBeHitByNPC(this, Main.npc[i], ref specialHitSetter))
+					continue;
+
 				if ((specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
 					continue;
 
@@ -23330,6 +_,10 @@
 					if (specialHitSetter >= 0)
 						flag3 = (hurtCooldowns[specialHitSetter] == 0);
 
+					bool crit = false;
+					NPCLoader.ModifyHitPlayer(Main.npc[i], this, ref num4, ref crit);
+					PlayerLoader.ModifyHitByNPC(this, Main.npc[i], ref num4, ref crit);
+
 					if (whoAmI == Main.myPlayer && num2 > 0f && flag3 && !Main.npc[i].dontTakeDamage) {
 						int num6 = (int)((float)num4 * num2);
 						if (num6 > 1000)
@@ -23351,8 +_,15 @@
 					if (resistCold && Main.npc[i].coldDamage)
 						num4 = (int)((float)num4 * 0.7f);
 
-					if (flag && Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter) > 0.0 && !dead && !flag2)
-						StatusFromNPC(Main.npc[i]);
+					if (flag) { //TODO, what is this flag?
+						int realDamage = (int)Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter);
+
+						if (realDamage > 0 && !dead && !flag2)
+							StatusFromNPC(Main.npc[i]);
+
+						NPCLoader.OnHitPlayer(Main.npc[i], this, realDamage, crit);
+						PlayerLoader.OnHitByNPC(this, Main.npc[i], realDamage, crit);
+					}
 
 					if (num) {
 						GiveImmuneTimeForCollisionAttack(longInvince ? 60 : 30);
@@ -23430,6 +_,8 @@
 		}
 
 		public void ItemCheck_ManageRightClickFeatures() {
+			//ItemLoader.AltFunctionUse(this.inventory[this.selectedItem], this)
+			// TODO, reintegrate AltFunctionUse
 			bool flag = selectedItem != 58 && controlUseTile && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
 			bool flag2 = flag;
 			if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
@@ -23555,6 +_,11 @@
 				controlUseItem = true;
 			}
 
+			if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this)) {
+				altFunctionUse = 1;
+				controlUseItem = true;
+			}
+
 			if (!controlUseItem && altFunctionUse == 1)
 				altFunctionUse = 0;
 
@@ -23712,6 +_,9 @@
 		}
 
 		public void ScrollHotbar(int Offset) {
+			//disable hotbar scrolling when using auto select
+			//previously it only worked when scrolling between 0 and 9, and made the sound
+			if (selectedItem >= 10) return;
 			Offset = ClampHotbarOffset(Offset);
 			selectedItem += Offset;
 			if (Offset != 0) {
@@ -23957,6 +_,8 @@
 					cursorItemIconID = -1;
 				}
 			}
+
+			TileLoader.MouseOverFar(myX, myY);
 		}
 
 		private void TileInteractionsUse(int myX, int myY) {
@@ -24034,7 +_,7 @@
 					Wiring.HitSwitch(myX, myY);
 					NetMessage.SendData(59, -1, -1, null, myX, myY);
 				}
-				else if (Main.tile[myX, myY].type == 139) {
+				else if (Main.tile[myX, myY].type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY])) {
 					flag2 = true;
 					SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
 					WorldGen.SwitchMB(myX, myY);
@@ -24158,7 +_,7 @@
 					flag2 = true;
 					GamepadEnableGrappleCooldown();
 				}
-				else if (Main.tile[myX, myY].type == 4 || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90)) {
+				else if (TileID.Sets.Torch[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90) || TileID.Sets.CanDropFromRightClick[Main.tile[myX, myY].type]) {
 					WorldGen.KillTile(myX, myY);
 					if (Main.netMode == 1)
 						NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
@@ -24478,7 +_,8 @@
 					if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss) {
 						for (int m = 0; m < 58; m++) {
 							if (inventory[m].type == 1293) {
+								if (ItemLoader.ConsumeItem(inventory[m], this))
-								inventory[m].stack--;
+									inventory[m].stack--;
 								if (inventory[m].stack <= 0)
 									inventory[m].SetDefaults();
 
@@ -24496,7 +_,7 @@
 							NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
 					}
 				}
-				else if (Main.tile[myX, myY].type == 10) {
+				else if (TileLoader.IsClosedDoor(Main.tile[myX, myY])) {
 					flag2 = true;
 					if (WorldGen.IsLockedDoor(myX, myY)) {
 						int num43 = 1141;
@@ -24504,13 +_,16 @@
 						for (int n = 0; n < 58; n++) {
 							if (inventory[n].type == num43 && inventory[n].stack > 0) {
 								flag9 = true;
+								if (ItemLoader.ConsumeItem(inventory[n], this))
-								inventory[n].stack--;
+									inventory[n].stack--;
 								if (inventory[n].stack <= 0)
 									inventory[n] = new Item();
 
 								WorldGen.UnlockDoor(myX, myY);
 								if (Main.netMode == 1)
 									NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
+
+								break;
 							}
 						}
 
@@ -24540,7 +_,7 @@
 						}
 					}
 				}
-				else if (Main.tile[myX, myY].type == 11) {
+				else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0) {
 					flag2 = true;
 					if (WorldGen.CloseDoor(myX, myY))
 						NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
@@ -24712,7 +_,7 @@
 					if (flag12)
 						NetMessage.SendTileSquare(-1, num62, num63, 2, 2);
 				}
-				else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
+				else if ((TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) && Main.tile[myX, myY].type < TileID.Count) {
 					flag2 = true;
 					Main.mouseRightRelease = false;
 					int num68 = 0;
@@ -24754,7 +_,7 @@
 						editedChestName = false;
 					}
 
-					bool flag13 = Chest.IsLocked(Main.tile[num69, num70]);
+					bool flag13 = Chest.IsLocked(num69, num70);
 					if (Main.netMode == 1 && num68 == 0 && !flag13) {
 						if (num69 == chestX && num70 == chestY && chest != -1) {
 							chest = -1;
@@ -24824,7 +_,9 @@
 
 											flag15 = true;
 											if (flag16) {
+												if (ItemLoader.ConsumeItem(inventory[num76], this))
-												inventory[num76].stack--;
+													inventory[num76].stack--;
+
 												if (inventory[num76].stack <= 0)
 													inventory[num76] = new Item();
 											}
@@ -24898,13 +_,17 @@
 					if (flag17)
 						LaunchMinecartHook(myX, myY);
 				}
+
+				if (TileLoader.RightClick(myX, myY))
+					flag2 = true;
+				// todo check out this flag2. return? "this.releaseUseTile = false;"
 			}
 
 			if (flag2)
 				tileInteractionHappened = true;
 		}
 
-		private static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
+		public static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
 			short frameX = Main.tile[myX, myY].frameX;
 			bool flag = frameX / 72 == 1;
 			bool flag2 = frameX % 72 < 36;
@@ -25045,7 +_,14 @@
 				StopPettingAnimal();
 		}
 
+		/// <summary>
+		/// Handles boilerplate for gamepad and UI when opening or closing a container.
+		/// <br/>Sets <see cref="Player.chestX"/>, and <see cref="Player.chestY"/>, and <see cref="Player.chest"/> to the given coordinates.
+		/// </summary>
+		/// <param name="x">The top-left X coordinate of the container.</param>
+		/// <param name="y">The top-left Y coordinate of the container.</param>
+		/// <param name="newChest">The container index in <see cref="Main.chest"/> if opening, or -1 if closing.</param>
-		private void OpenChest(int x, int y, int newChest) {
+		public void OpenChest(int x, int y, int newChest) {
 			if (chest != -1 && Main.myPlayer == whoAmI) {
 				for (int i = 0; i < 40; i++) {
 					ItemSlot.SetGlow(i, -1f, chest: true);
@@ -25924,7 +_,7 @@
 				cursorItemIconID = 3747;
 			}
 
-			if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && (inventory[selectedItem].type == 424 || inventory[selectedItem].type == 1103 || inventory[selectedItem].type == 2339 || inventory[selectedItem].type == 2338 || inventory[selectedItem].type == 2337)) {
+			if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1) {
 				noThrow = 2;
 				cursorItemIconEnabled = true;
 				cursorItemIconID = inventory[selectedItem].type;
@@ -26522,6 +_,8 @@
 				cursorItemIconEnabled = false;
 				cursorItemIconID = 0;
 			}
+
+			TileLoader.MouseOver(myX, myY);
 		}
 
 		public Color ChatColor() {
@@ -26655,11 +_,21 @@
 				if (!item.active || item.shimmerTime != 0f || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item) || (item.shimmered && !((double)item.velocity.Length() < 0.2)))
 					continue;
 
+				if (!ItemLoader.CanPickup(item, this))
+					continue;
+
 				int itemGrabRange = GetItemGrabRange(item);
 				Rectangle hitbox = item.Hitbox;
 				if (base.Hitbox.Intersects(hitbox)) {
-					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0))
+					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0)) {
+						if (!ItemLoader.OnPickup(Main.item[j], this)) {
+							Main.item[j] = new Item();
+							if (Main.netMode == 1)
+								NetMessage.SendData(21, -1, -1, null, j);
+							continue;
+						}
 						item = PickupItem(i, j, item);
+					}
 				}
 				else {
 					if (!new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2).Intersects(hitbox))
@@ -26673,6 +_,7 @@
 						if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 							flag = true;
 
+						if (ItemLoader.GrabStyle(item, this)) {} else
 						if (flag)
 							PullItem_Pickup(item, 7f, 1);
 						else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
@@ -26789,6 +_,11 @@
 			return itemToPickUp;
 		}
 
+		/// <summary>
+		/// Heals the player for a certain amount.
+		/// </summary>
+		/// <param name="player">The player to heal.</param>
+		/// <param name="amount">The amount to heal the player by.</param>
 		public void Heal(int amount) {
 			statLife += amount;
 			if (Main.myPlayer == whoAmI)
@@ -26798,6 +_,12 @@
 				statLife = statLifeMax2;
 		}
 
+		/// <summary>
+		/// Fetches the range at which the given item begins to gravitate towards the player.<br/>
+		/// This range, referred to as item grab range, is measured in pixels.
+		/// </summary>
+		/// <param name="item">The item whose grab range is being evaluated.</param>
+		/// <returns>The item grab range of the player, in pixels.</returns>
 		public int GetItemGrabRange(Item item) {
 			int num = defaultItemGrabRange;
 			if (goldRing && item.IsACoin)
@@ -26824,6 +_,7 @@
 			if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 				num += 240;
 
+			ItemLoader.GrabRange(item, this, ref num);
 			return num;
 		}
 
@@ -27244,7 +_,7 @@
 				num2 += 4;
 			}
 
-			for (int i = 0; i < 693; i++) {
+			for (int i = 0; i < adjTile.Length; i++) {
 				oldAdjTile[i] = adjTile[i];
 				adjTile[i] = false;
 			}
@@ -27285,15 +_,17 @@
 								alchemyTable = true;
 								break;
 						}
+
+						TileLoader.AdjTiles(this, Main.tile[j, k].type);
 					}
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
 						adjWater = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
 						adjHoney = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
 						adjLava = true;
 				}
 			}
@@ -27302,7 +_,7 @@
 				return;
 
 			bool flag = false;
-			for (int l = 0; l < 693; l++) {
+			for (int l = 0; l < adjTile.Length; l++) {
 				if (oldAdjTile[l] != adjTile[l]) {
 					flag = true;
 					break;
@@ -27380,8 +_,9 @@
 			if (armor[12].legSlot >= 0)
 				legs = armor[12].legSlot;
 
-			if (!dead)
+			if (!dead) {
 				UpdateVisibleAccessories();
+			}
 
 			wearsRobe = false;
 			bool somethingSpecial = false;
@@ -27518,9 +_,14 @@
 				SetArmorEffectVisuals(this);
 			}
 
+			/*
 			hermesStepSound.SoundType = 17;
 			hermesStepSound.SoundStyle = -1;
+			*/
+			hermesStepSound.Style = SoundID.Run;
+			
 			hermesStepSound.IntendedCooldown = 9;
+
 			if (head == 99 && body == 65 && legs == 54)
 				turtleArmor = true;
 
@@ -27529,8 +_,12 @@
 
 			ApplyArmorSoundAndDustChanges();
 			if (legs == 140) {
+				/*
 				hermesStepSound.SoundType = 2;
 				hermesStepSound.SoundStyle = 24;
+				*/
+				hermesStepSound.Style = SoundID.Item24;
+
 				hermesStepSound.IntendedCooldown = 6;
 			}
 
@@ -27540,6 +_,7 @@
 				faceHead = -1;
 			}
 
+			ItemLoader.PreUpdateVanitySet(this);
 			if (head > 0 && face > 0) {
 				if (ArmorIDs.Face.Sets.OverrideHelmet[face]) {
 					head = -1;
@@ -27575,6 +_,9 @@
 				obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
 			}
 
+			//TODO: Do these hooks go inside or outside the conditional?
+			PlayerLoader.FrameEffects(this);
+			EquipLoader.EquipFrameEffects(this);
 			if (!isDisplayDollOrInanimate) {
 				if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0) {
 					int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
@@ -27699,6 +_,7 @@
 			Item.GetDrawHitbox(HeldItem.type, this);
 			bool flag3 = CanVisuallyHoldItem(HeldItem);
 			bool flag4 = HeldItem.type != 4952;
+			ItemLoader.UpdateVanitySet(this);
 			if (mount.Active) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * 6;
@@ -27915,6 +_,8 @@
 						}
 					}
 				}
+
+				ItemLoader.UseItemFrame(inventory[selectedItem], this);
 			}
 			else if (pulley) {
 				if (pulleyDir == 2)
@@ -28051,6 +_,10 @@
 				reference9.Y = 0;
 			}
 
+			if (flag3 && itemAnimation <= 0) {
+				ItemLoader.HoldItemFrame(inventory[selectedItem], this);
+			}
+
 			if (legs == 140) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
@@ -28166,6 +_,7 @@
 		}
 
 		private void UpdateVisibleAccessories() {
+			/*
 			for (int i = 3; i < 10; i++) {
 				if (!IsItemSlotUnlockedAndUsable(i))
 					continue;
@@ -28204,6 +_,24 @@
 						UpdateVisibleAccessory(j, item2);
 				}
 			}
+			*/
+			for (int i = 3; i < 10; i++) {
+				if (!IsItemSlotUnlockedAndUsable(i))
+					continue;
+
+				UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
+			}
+
+			PlayerLoader.UpdateVisibleAccessories(this);
+
+			for (int i = 13; i < 20; i++) {
+				if (!IsItemSlotUnlockedAndUsable(i))
+					continue;
+
+				UpdateVisibleAccessory(i, armor[i]);
+			}
+
+			PlayerLoader.UpdateVisibleVanityAccessories(this);
 
 			int type = HeldItem.type;
 			if (type == 4760 && ownedProjectileCounts[866] < 1) {
@@ -28212,7 +_,7 @@
 			}
 		}
 
-		private bool ItemIsVisuallyIncompatible(Item item) {
+		public bool ItemIsVisuallyIncompatible(Item item) {
 			if (compositeBackArm.enabled && item.shieldSlot > 0)
 				return true;
 
@@ -28238,7 +_,7 @@
 			return false;
 		}
 
-		private void UpdateVisibleAccessory(int itemSlot, Item item) {
+		public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false) {
 			if (item.stringColor > 0)
 				stringColor = item.stringColor;
 
@@ -28304,8 +_,15 @@
 			if (item.wingSlot > 0)
 				wings = item.wingSlot;
 
-			if (item.type == 3580)
-				yoraiz0rEye = itemSlot - 2;
+			if (item.type == 3580) {
+				if (modded) {
+					// Treat similar to expert/master mode slots
+					yoraiz0rEye = 5 + itemSlot - 2;
+				}
+				else {
+					yoraiz0rEye = itemSlot - 2;
+				}
+			}
 
 			if (item.type == 3581)
 				yoraiz0rDarkness = true;
@@ -28460,6 +_,8 @@
 			if (drawPlayer.head == 267)
 				yoraiz0rDarkness = true;
 
+			ItemLoader.ArmorSetShadows(drawPlayer);
+			// TODO, rename to this? SetArmorEffectVisuals
 			if (drawPlayer.stoned || drawPlayer.stealth != 1f) {
 				armorEffectDrawOutlines = false;
 				armorEffectDrawShadow = false;
@@ -28654,10 +_,12 @@
 					case 232:
 						if (!male)
 							num2 = 233;
+						// Patch context
 						break;
 				}
 			}
 
+			ItemLoader.SetMatch(armorSlotRequested, num, male, ref num2, ref somethingSpecial);
 			return num2;
 		}
 
@@ -28837,6 +_,9 @@
 				}
 
 				immune = true;
+				if (dead)
+					PlayerLoader.OnRespawn(this);
+
 				dead = false;
 				immuneTime = 0;
 			}
@@ -29049,7 +_,7 @@
 			if (whoAmI != Main.myPlayer)
 				return;
 
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] > 0 && buffType[i] == 59)
 					DelBuff(i);
 			}
@@ -29115,6 +_,7 @@
 				NetMessage.SendData(62, -1, -1, null, whoAmI, 1f);
 		}
 
+		//TODO: what does this method accomplish? Just determining frost and bone armor?
 		public void ApplyArmorSoundAndDustChanges() {
 			int num = armor[0].headSlot;
 			int num2 = armor[1].bodySlot;
@@ -29182,6 +_,12 @@
 					}
 				}
 
+				bool customDamage = false;
+				bool playSound = true;
+				bool genGore = true;
+				if (!PlayerLoader.PreHurt(this, pvp, quiet, ref Damage, ref hitDirection, ref Crit, ref customDamage, ref playSound, ref genGore, ref damageSource, ref cooldownCounter))
+					return 0.0;
+
 				if (whoAmI == Main.myPlayer && panic)
 					AddBuff(63, 480);
 
@@ -29193,7 +_,7 @@
 					NetMessage.SendData(84, -1, -1, null, whoAmI);
 
 				int num = Damage;
-				double num2 = Main.CalculateDamagePlayersTake(num, statDefense);
+				double num2 = customDamage ? num : Main.CalculateDamagePlayersTake(num, statDefense);
 				if (Crit)
 					num *= 2;
 
@@ -29219,8 +_,18 @@
 						}
 					}
 
+					if (channel && inventory[selectedItem].InterruptChannelOnHurt) {
+						channel = false;
+					}
+
+					if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt) {
+						channel = false;
+						itemAnimation = 0;
+						itemAnimationMax = 0;
+					}
+
 					if (invis) {
-						for (int k = 0; k < 44; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] == 10)
 								DelBuff(k);
 						}
@@ -29242,7 +_,7 @@
 							if (damageSource.TryGetCausingEntity(out entity))
 								spawnSource = GetProjectileSource_OnHurt(entity, 1);
 
-							int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)(150f * meleeDamage), 15f, Main.myPlayer);
+							int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)GetTotalDamage(DamageClass.Melee).ApplyTo(150f), 15f, Main.myPlayer);
 							Main.projectile[num4].netUpdate = true;
 							Main.projectile[num4].Kill();
 						}
@@ -29252,7 +_,7 @@
 						float num5 = 0.15f * (float)beetleOrbs;
 						num2 = (int)((double)(1f - num5) * num2);
 						beetleOrbs--;
-						for (int l = 0; l < 44; l++) {
+						for (int l = 0; l < MaxBuffs; l++) {
 							if (buffType[l] >= 95 && buffType[l] <= 97)
 								DelBuff(l);
 						}
@@ -29344,6 +_,8 @@
 						Projectile.NewProjectile(GetProjectileSource_Accessory(brainOfConfusionItem), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
 					}
 
+					//TODO: Is 'num2' correct? Ensure and add patch context.
+					PlayerLoader.Hurt(this, pvp, quiet, num2, hitDirection, Crit, cooldownCounter);
 					if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet) {
 						if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart))
 							NetMessage.SendData(13, -1, -1, null, whoAmI);
@@ -29476,6 +_,7 @@
 						fallStart = (int)(position.Y / 16f);
 					}
 
+					if (!playSound) {} else
 					if (stoned)
 						SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
 					else if (mount.Active && mount.Type == 52)
@@ -29493,6 +_,10 @@
 
 					eyeHelper.BlinkBecausePlayerGotHurt();
 					if (statLife > 0) {
+						if (!genGore)
+							goto PostGore;
+
+						// Context: The patch that defines postGore used num2.
 						double num24 = num2 / (double)statLifeMax2 * 100.0;
 						float num25 = 2 * hitDirection;
 						float num26 = 0f;
@@ -29517,6 +_,10 @@
 								Dust.NewDust(position, width, height, 5, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
 							}
 						}
+
+						PostGore:
+
+						PlayerLoader.PostHurt(this, pvp, quiet, num2, hitDirection, Crit, cooldownCounter);
 					}
 					else {
 						statLife = 0;
@@ -29566,6 +_,13 @@
 				if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
 					FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
 
+				string moddedPlayerPathName = Path.ChangeExtension(Main.playerPathName, ".tplr");
+				if (FileUtilities.Exists(moddedPlayerPathName, isCloudSave))
+					FileUtilities.Delete(moddedPlayerPathName, isCloudSave);
+
+				if (FileUtilities.Exists(moddedPlayerPathName + ".bak", isCloudSave))
+					FileUtilities.Delete(moddedPlayerPathName + ".bak", isCloudSave);
+
 				Main.ActivePlayerFileData = new PlayerFileData();
 			}
 		}
@@ -29575,6 +_,11 @@
 				return;
 
 			StopVanityActions();
+			bool playSound = true;
+			bool genGore = true;
+			if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
+				return;
+
 			if (pvp)
 				pvpDeath = true;
 
@@ -29675,12 +_,15 @@
 			headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
-			if (stoned) {
+			if (stoned || !genGore) {
 				headPosition = Vector2.Zero;
 				bodyPosition = Vector2.Zero;
 				legPosition = Vector2.Zero;
 			}
 
+			if (!genGore)
+				goto postGore; //goto minimizes diff file size
+
 			for (int l = 0; l < 100; l++) {
 				if (stoned) {
 					Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
@@ -29698,9 +_,11 @@
 				}
 			}
 
+			postGore:
 			mount.Dismount(this);
 			dead = true;
 			respawnTimer = GetRespawnTime(pvp);
+			PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
 			immuneAlpha = 0;
 			if (!ChildSafety.Disabled)
 				immuneAlpha = 255;
@@ -29820,6 +_,9 @@
 			if (newItem.uniqueStack && HasItem(newItem.type))
 				return new ItemSpaceStatus(CanTakeItem: false);
 
+			if (ItemLoader.ItemSpace(newItem, this))
+				return new ItemSpaceStatus(CanTakeItem: true);
+
 			int num = 50;
 			if (newItem.IsACoin)
 				num = 54;
@@ -29867,7 +_,8 @@
 			if (theSlot.type == 0)
 				return true;
 
-			if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			//if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot) && ItemLoader.CanStack(theSlot, theItemToAccept))
 				return true;
 
 			return false;
@@ -29901,6 +_,22 @@
 				if (inventory[i].type <= 0 || inventory[i].stack >= inventory[i].maxStack || !newItem.IsTheSameAs(inventory[i]))
 					continue;
 
+				if (!ItemLoader.TryStackItems(inventory[i], newItem, out int numTransfered))
+					continue;
+
+				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
+				if (!settings.NoText)
+					PopupText.NewText(PopupTextContext.RegularItemPickup, inventory[i], numTransfered);
+
+				DoCoins(i);
+				if (plr == Main.myPlayer)
+					Recipe.FindRecipes();
+
+				settings.HandlePostAction(inventory[i]);
+				if (newItem.stack <= 0)
+					return newItem;
+
+				/* TML: #OnStackHook
 				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 				if (newItem.stack + inventory[i].stack <= inventory[i].maxStack) {
 					inventory[i].stack += newItem.stack;
@@ -29920,6 +_,7 @@
 					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, inventory[i].maxStack - inventory[i].stack);
 
 				inventory[i].stack = inventory[i].maxStack;
+				*/
 				DoCoins(i);
 				if (plr == Main.myPlayer)
 					Recipe.FindRecipes();
@@ -30035,12 +_,25 @@
 		}
 
 		private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i) {
+			//if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
 			if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
+				if (!ItemLoader.TryStackItems(inv[i], returnItem, out int numTransfered))
+					return false;
+
 				if (newItem.IsACoin)
 					SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 				else
 					SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+				if (!settings.NoText)
+					PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, numTransfered, noStack: false, settings.LongText);
+
+				AchievementsHelper.NotifyItemPickup(this, returnItem);
+				settings.HandlePostAction(inv[i]);
+				if (returnItem.stack <= 0)
+					return true;
+
+				/* TML: #OnStackHook
 				if (returnItem.stack + inv[i].stack <= inv[i].maxStack) {
 					inv[i].stack += returnItem.stack;
 					if (!settings.NoText)
@@ -30058,19 +_,38 @@
 
 				inv[i].stack = inv[i].maxStack;
 				settings.HandlePostAction(inv[i]);
+				*/
 			}
 
 			return false;
 		}
 
 		private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i) {
+			//if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
 			if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
+				if (!ItemLoader.TryStackItems(inventory[i], returnItem, out int numTransfered))
+					return false;
+
 				if (newItem.IsACoin)
 					SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 				else
 					SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+				DoCoins(i);
+				if (plr == Main.myPlayer)
+					Recipe.FindRecipes();
+
+				if (!settings.NoText)
+					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered, noStack: false, settings.LongText);
+
+				AchievementsHelper.NotifyItemPickup(this, returnItem);
+				settings.HandlePostAction(inventory[i]);
+				if (returnItem.stack <= 0)
+					return true;
+
+				/* TML: #OnStackHook
 				if (returnItem.stack + inventory[i].stack <= inventory[i].maxStack) {
+
 					inventory[i].stack += returnItem.stack;
 					if (!settings.NoText)
 						PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, returnItem.stack, noStack: false, settings.LongText);
@@ -30095,6 +_,7 @@
 					Recipe.FindRecipes();
 
 				settings.HandlePostAction(inventory[i]);
+				*/
 			}
 
 			return false;
@@ -30175,6 +_,8 @@
 				return;
 
 			bool flag = true;
+			flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
+
 			if (TileReplacementEnabled)
 				flag = PlaceThing_TryReplacingWalls(flag);
 
@@ -30183,6 +_,7 @@
 
 			WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
 			if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall) {
+				WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 				ApplyItemTime(inventory[selectedItem], wallSpeed);
 				if (Main.netMode == 1)
 					NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
@@ -30241,7 +_,8 @@
 
 				WorldGen.PlaceWall(num, num2, createWall);
 				if (Main.tile[num, num2].wall == createWall) {
+					if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
-					inventory[selectedItem].stack--;
+						inventory[selectedItem].stack--;
 					if (inventory[selectedItem].stack == 0)
 						inventory[selectedItem].SetDefaults();
 
@@ -30366,9 +_,12 @@
 				if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
 					return false;
 
+				if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
+					return false;
+
 				if (0 == 0) {
 					if (hitReplace.AddDamage(num, pickaxeDamage) < 100) {
-						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
 						for (int i = 0; i < num2; i++) {
 							WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
 						}
@@ -30569,8 +_,11 @@
 				PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
 				PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
 				PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, tileToCreate);
+				// Extra context.
 				if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
 					Main.blockMouse = true;
+
+				TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 			}
 
 			return data;
@@ -30848,7 +_,8 @@
 					int num7 = FindItem(849);
 					if (num7 > -1 && WorldGen.PlaceActuator(num5, num6)) {
 						NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
+						if (ItemLoader.ConsumeItem(inventory[num7], this))
-						inventory[num7].stack--;
+							inventory[num7].stack--;
 						if (inventory[num7].stack <= 0)
 							inventory[num7].SetDefaults();
 					}
@@ -31235,7 +_,7 @@
 				if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
 					canPlace = true;
 			}
-			else if (inventory[selectedItem].createTile == 4 || inventory[selectedItem].createTile == 136) {
+			else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136) {
 				if (Main.tile[tileTargetX, tileTargetY].wall > 0) {
 					canPlace = true;
 				}
@@ -31890,7 +_,8 @@
 			byte paint = targetItem.paint;
 			if (paintingAWall) {
 				if (Main.tile[x, y].wallColor() != paint && WorldGen.paintWall(x, y, paint, broadCast: true)) {
+					if (ItemLoader.ConsumeItem(targetItem, this))
-					targetItem.stack--;
+						targetItem.stack--;
 					if (targetItem.stack <= 0)
 						targetItem.SetDefaults();
 
@@ -31899,7 +_,8 @@
 				}
 			}
 			else if (Main.tile[x, y].color() != paint && WorldGen.paintTile(x, y, paint, broadCast: true)) {
+				if (ItemLoader.ConsumeItem(targetItem, this))
-				targetItem.stack--;
+					targetItem.stack--;
 				if (targetItem.stack <= 0)
 					targetItem.SetDefaults();
 
@@ -31953,13 +_,13 @@
 			int num6 = -1;
 			int num7 = 1;
 			switch (extractType) {
-				case 1:
+				case ItemID.DesertFossil:
 					num /= 3;
 					num2 *= 2;
 					num3 = 20;
 					num4 = 10;
 					break;
-				case 2:
+				case ItemID.OldShoe:
 					num = -1;
 					num2 = -1;
 					num3 = -1;
@@ -31967,7 +_,7 @@
 					num5 = 1;
 					num7 = -1;
 					break;
-				case 3:
+				case ItemID.LavaMoss:
 					num = -1;
 					num2 = -1;
 					num3 = -1;
@@ -32337,6 +_,8 @@
 					num9 += Main.rand.Next(0, 6);
 			}
 
+			ItemLoader.ExtractinatorUse(ref num8, ref num9, extractType, extractinatorBlockType);
+
 			if (num8 > 0)
 				DropItemFromExtractinator(num8, num9);
 		}
@@ -32439,8 +_,8 @@
 
 		public PlayerFishingConditions GetFishingConditions() {
 			PlayerFishingConditions result = default(PlayerFishingConditions);
-			Fishing_GetBestFishingPole(out result.PolePower, out result.PoleItemType);
-			Fishing_GetBait(out result.BaitPower, out result.BaitItemType);
+			Fishing_GetBestFishingPole(out result.Pole);
+			Fishing_GetBait(out result.Bait);
 			if (result.BaitItemType == 2673)
 				return result;
 
@@ -32458,12 +_,12 @@
 				num += 5;
 
 			int num2 = result.BaitPower + result.PolePower + fishingSkill + num;
-			result.LevelMultipliers = Fishing_GetPowerMultiplier();
+			result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
 			result.FinalFishingLevel = (int)((float)num2 * result.LevelMultipliers);
 			return result;
 		}
 
-		private static float Fishing_GetPowerMultiplier() {
+		private float Fishing_GetPowerMultiplier(Item pole, Item bait) {
 			float num = 1f;
 			if (Main.raining)
 				num *= 1.2f;
@@ -32495,21 +_,20 @@
 			if (Main.bloodMoon)
 				num *= 1.1f;
 
+			PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
 			return num;
 		}
 
-		private void Fishing_GetBait(out int baitPower, out int baitType) {
-			baitPower = 0;
-			baitType = 0;
+		private void Fishing_GetBait(out Item bait) {
+			bait = null;
 			for (int i = 54; i < 58; i++) {
 				if (inventory[i].stack > 0 && inventory[i].bait > 0) {
-					baitPower = inventory[i].bait;
-					baitType = inventory[i].type;
+					bait = inventory[i];
 					break;
 				}
 			}
 
-			if (baitPower != 0 || baitType != 0)
+			if (bait != null)
 				return;
 
 			int num = 0;
@@ -32525,20 +_,17 @@
 				return;
 			}
 
-			baitPower = inventory[num].bait;
-			baitType = inventory[num].type;
+			bait = inventory[num];
 		}
 
-		private void Fishing_GetBestFishingPole(out int fishingPolePower, out int fishingPoleType) {
-			fishingPolePower = inventory[selectedItem].fishingPole;
-			fishingPoleType = inventory[selectedItem].type;
-			if (fishingPolePower != 0)
+		private void Fishing_GetBestFishingPole(out Item pole) {
+			pole = inventory[selectedItem];
+			if (pole.fishingPole != 0)
 				return;
 
 			for (int i = 0; i < 58; i++) {
-				if (inventory[i].fishingPole > fishingPolePower) {
+				if (inventory[i].fishingPole > pole.fishingPole) {
-					fishingPolePower = inventory[i].fishingPole;
+					pole = inventory[i];
-					fishingPoleType = inventory[i].type;
 				}
 			}
 		}
@@ -32562,7 +_,8 @@
 		public void TakeUnityPotion() {
 			for (int i = 0; i < 58; i++) {
 				if (inventory[i].type == 2997 && inventory[i].stack > 0) {
+					if (ItemLoader.ConsumeItem(inventory[i], this))
-					inventory[i].stack--;
+						inventory[i].stack--;
 					if (inventory[i].stack <= 0)
 						inventory[i].SetDefaults();
 
@@ -32586,7 +_,8 @@
 				return;
 			}
 
+			if (ItemLoader.ConsumeItem(bank4.item[num], this))
-			bank4.item[num].stack--;
+				bank4.item[num].stack--;
 			if (bank4.item[num].stack <= 0)
 				bank4.item[num].SetDefaults();
 		}
@@ -32761,11 +_,20 @@
 			return TextureAssets.Item[type].Frame();
 		}
 
+		/// <summary>
+		/// Used to determine what the overall scale of an item should be.<br></br>
+		/// <see cref="CombinedHooks.ModifyItemScale"/> is called here.
+		/// </summary>
+		/// <param name="item">The item to fetch the adjusted scale of.</param>
+		/// <returns>
+		/// The final scale of the item, after the Titan Glove effect and all modded calculations.
+		/// </returns>
 		public float GetAdjustedItemScale(Item item) {
 			float scale = item.scale;
 			if (item.melee)
 				ApplyMeleeScale(ref scale);
 
+			CombinedHooks.ModifyItemScale(this, item, ref scale);
 			return scale;
 		}
 
@@ -32786,6 +_,13 @@
 		}
 
 		public void ItemCheck() {
+			if (PlayerLoader.PreItemCheck(this))
+				ItemCheck_Inner();
+
+			PlayerLoader.PostItemCheck(this);
+		}
+
+		private void ItemCheck_Inner() {
 			if (CCed) {
 				channel = false;
 				itemAnimation = (itemAnimationMax = 0);
@@ -32800,10 +_,10 @@
 					controlUseItem = true;
 
 				if (!cursorItemIconEnabled && item.stack > 0 && item.fishingPole > 0) {
-					Fishing_GetBait(out int _, out int baitType);
-					if (baitType > 0) {
+					Fishing_GetBait(out var bait);
+					if (bait != null) {
 						cursorItemIconEnabled = true;
-						cursorItemIconID = baitType;
+						cursorItemIconID = bait.type;
 						cursorItemIconPush = 6;
 					}
 				}
@@ -32831,6 +_,54 @@
 				}
 			}
 
+			// #2351
+			// tML is motivated to bring the itemAnimation and itemTime counters to parity, fixing desync bugs with autoReuse items and providing clearer behaviour
+			//
+			// the flow of this method has changed as follows
+			// VANILLA:
+			// 1. Reuse delay is applied
+			// 2. Item animation is applied if button is pressed
+			// 3. Item animation is reduced
+			// 4. 'releaseUseItem' is set
+			// 5. Item time is reduced
+			// 6. Hold / Use styles are invoked
+			// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+			// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+			// 
+			// TML:
+			// 1. Item animation is reduced
+			// 2. Item time is reduced
+			// 3. Reuse delay is applied
+			// 4. Item animation is applied if button is pressed
+			// 5. 'releaseUseItem' is set
+			// 6. Hold / Use styles are invoked
+			// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+			// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+			//
+			// At the end of ItemCheck:
+			//   VANILLA: itemAnimation goes from itemAnimationMax-1 to 0, before it can restart
+			//   TML:     itemAnimation goes from itemAnimationMax to 1, before it can restart
+			//
+			//   VANILLA: If the item has autoReuse, then it can restart at itemAnimation = 1, making the actual animation one frame shorter than expected.
+			//            If a reusuable item has equal itemAnimation and itemTime, the animation will be faster, and they will start to fire at different times
+			//
+			//   TML:     ItemCheck_HandleMPItemAnimation unnecessary. Animation times for modded items as written. See Item.ApplyItemAnimationCompensations
+			//
+			//   VANILLA: All items which don't have autoReuse get 1 frame where itemAnimation == 0, this is often used to despawn projectiles
+			//   TML:     There will be no frame with itemAnimation == 0 if an item is 'reused immediately', via autoReuse, knockbackGlove, or perfect click timing.
+			//            bound projectiles should despawn in the frame of itemAnimation <= 1, after doing damage.
+			//            Player.ItemAnimationEndingOrEnded has been made for this purpose but its use is not recommended due to potential for multiplayer desync.
+			//            Better to have ai counters for projectile lifetime set to itemAnimationMax on spawn
+			//
+			//   VANILLA: hitbox calulation and duration is based on an itemAnimation value between itemAnimationMax-1 and 1, resulting in itemAnimationMax-1 frames of hitbox
+			//   TML:     hitbox lasts the same length as itemAnimation, slightly more backswing (rotation) in the first frame
+			//
+			//   VANILLA: itemTime goes from itemTimeMax to 1, before it can restart, 0 means not using item
+			//   TML:     no change
+
+			goto DecrementItemAnimation;
+
+			ReuseDelayAndAnimationStart:
 			ItemCheck_HandleMount();
 			int weaponDamage = GetWeaponDamage(item);
 			ItemCheck_HandleMPItemAnimation(item);
@@ -32872,7 +_,7 @@
 				if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
 					mount.SetMount(item.mountType, this);
 
-				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag2 && whoAmI == Main.myPlayer && item.shoot >= 0 && item.shoot < 1022 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
+				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag2 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
 					FreeUpPetsAndMinions(item);
 
 				if (flag2)
@@ -32886,6 +_,9 @@
 			if (!flag3)
 				channel = false;
 
+			goto ReleaseUseItem;
+
+			DecrementItemAnimation:
 			Item item2 = (itemAnimation > 0) ? lastVisualizedSelectedItem : item;
 			Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
 			compositeFrontArm.enabled = false;
@@ -32907,8 +_,13 @@
 				if (itemAnimation == 0 && whoAmI == Main.myPlayer)
 					PlayerInput.TryEndingFastUse();
 			}
+			goto DecrementItemTime;
 
+			ReleaseUseItem:
 			releaseUseItem = !controlUseItem;
+			goto HoldAndUseStyle;
+			
+			DecrementItemTime:
 			if (itemTime > 0) {
 				itemTime--;
 				if (ItemTimeIsZero && whoAmI == Main.myPlayer && !JustDroppedAnItem) {
@@ -32918,6 +_,11 @@
 				}
 			}
 
+			goto ReuseDelayAndAnimationStart;
+
+			HoldAndUseStyle:
+			ItemLoader.HoldItem(item, this);
+
 			if (itemAnimation > 0)
 				ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 			else
@@ -32927,14 +_,17 @@
 				ItemCheck_EmitHeldItemLight(item);
 				ItemCheck_EmitFoodParticles(item);
 				ItemCheck_EmitDrinkParticles(item);
-				if (whoAmI == Main.myPlayer)
+				if (whoAmI == Main.myPlayer || true) // TML attempts to make ApplyItemTime calls run on remote players, so this check is removed. #ItemTimeOnAllClients
 					ItemCheck_OwnerOnlyCode(ref context, item, weaponDamage, drawHitbox);
 
 				if (ItemTimeIsZero && itemAnimation > 0) {
+					if (ItemLoader.UseItem(item, this) == true)
+						ApplyItemTime(item, callUseItem: false);
+
 					if (item.hairDye >= 0) {
 						ApplyItemTime(item);
 						if (whoAmI == Main.myPlayer) {
-							hairDye = (byte)item.hairDye;
+							hairDye = item.hairDye;
 							NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 					}
@@ -33047,7 +_,7 @@
 					if (ItemTimeIsZero) {
 						ApplyItemTime(item);
 					}
-					else if (itemTime == item.useTime / 2) {
+					else if (itemTime == itemTimeMax / 2) {
 						for (int l = 0; l < 70; l++) {
 							Dust.NewDust(base.position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
 						}
@@ -33171,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -33197,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -33212,7 +_,7 @@
 						else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
 							NetMessage.SendData(73);
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -33228,11 +_,11 @@
 								NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 					else {
-						float num10 = item.useTime;
+						float num10 = itemTimeMax;
 						num10 = (num10 - (float)itemTime) / num10;
 						float num11 = 44f;
 						float num12 = (float)Math.PI * 3f;
@@ -33266,11 +_,12 @@
 				}
 
 				if (whoAmI == Main.myPlayer) {
-					if (!dontConsumeWand && itemTime == (int)((float)item.useTime * tileSpeed) && item.tileWand > 0) {
+					if (itemTimeMax != 0 && item.tileWand > 0 && !dontConsumeWand && itemTime == itemTimeMax) {
 						int tileWand = item.tileWand;
 						for (int num15 = 0; num15 < 58; num15++) {
 							if (tileWand == inventory[num15].type && inventory[num15].stack > 0) {
+								if (ItemLoader.ConsumeItem(inventory[num15], this))
-								inventory[num15].stack--;
+									inventory[num15].stack--;
 								if (inventory[num15].stack <= 0)
 									inventory[num15] = new Item();
 
@@ -33302,7 +_,7 @@
 						if (flag6.HasValue)
 							flag5 = flag6.Value;
 
-						if (flag5) {
+						if (flag5 && ItemLoader.ConsumeItem(item, this)) {
 							if (item.stack > 0)
 								item.stack--;
 
@@ -33329,6 +_,12 @@
 			if (Main.myPlayer == whoAmI && itemAnimation == 0) {
 				Tile targetTile = Main.tile[tileTargetX, tileTargetY];
 				FigureOutWhatToPlace(targetTile, sItem, out int tileToCreate, out int previewPlaceStyle, out bool? overrideCanPlace, out int? forcedRandom);
+				if (tileToCreate == TileID.Saplings) {
+					Tile soil = Main.tile[tileTargetX, tileTargetY + 1];
+					if (soil.active())
+						TileLoader.SaplingGrowthType(soil.type, ref tileToCreate, ref previewPlaceStyle);
+				}
+
 				if ((!overrideCanPlace.HasValue || overrideCanPlace.Value) && TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle))
 					TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out TileObject _, onlyCheck: true, forcedRandom);
 			}
@@ -33377,13 +_,15 @@
 				_spawnMuramasaCut = true;
 
 			if (type == 3852) {
+				/* handled by Item.useLimitPerAnimation
 				if (itemAnimation < itemAnimationMax - 12)
 					flag = false;
+				*/
 
 				if (altFunctionUse == 2 && !ItemAnimationJustStarted)
 					flag = false;
 			}
-
+			/* Eventide and nightglow handled by Item.useLimitPerAnimation. Zenith use limit didn't do anything anyway
 			if (type == 4956 && itemAnimation < itemAnimationMax - 3 * sItem.useTime)
 				flag = false;
 
@@ -33392,10 +_,15 @@
 
 			if (type == 4953 && itemAnimation < itemAnimationMax - 10)
 				flag = false;
+			*/
 
 			if (type == 5451 && ownedProjectileCounts[1020] > 0)
 				flag = false;
 
+			// Added by TML
+			if (sItem.useLimitPerAnimation != null && ItemUsesThisAnimation >= sItem.useLimitPerAnimation.Value)
+				flag = false;
+
 			ItemCheck_TurretAltFeatureUse(sItem, flag);
 			ItemCheck_MinionAltFeatureUse(sItem, flag);
 			bool flag2 = itemAnimation > 0 && ItemTimeIsZero && flag;
@@ -33405,6 +_,10 @@
 			if (sItem.shoot > 0 && flag2)
 				ItemCheck_Shoot(whoAmI, sItem, weaponDamage);
 
+			// Added by TML. #ItemTimeOnAllClients - TODO: item time application with these item types
+			if (whoAmI != Main.myPlayer)
+				return;
+
 			ItemCheck_UseWiringTools(sItem);
 			ItemCheck_UseLawnMower(sItem);
 			ItemCheck_PlayInstruments(sItem);
@@ -33455,7 +_,7 @@
 				Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, vector.X, vector.Y, 532, 25, 5f, whoAmI);
 			}
 
-			if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && sItem.type != 1991 && sItem.type != 3183 && sItem.type != 4821 && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
+			if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && !ItemID.Sets.CatchingTool[sItem.type] && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
 				return;
 
 			ItemCheck_GetMeleeHitbox(sItem, heldItemFrame, out bool dontAttack, out Rectangle itemRectangle);
@@ -33463,7 +_,7 @@
 				return;
 
 			itemRectangle = ItemCheck_EmitUseVisuals(sItem, itemRectangle);
-			if (Main.myPlayer == whoAmI && (sItem.type == 1991 || sItem.type == 3183 || sItem.type == 4821))
+			if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[sItem.type])
 				itemRectangle = ItemCheck_CatchCritters(sItem, itemRectangle);
 
 			if (sItem.type == 3183 || sItem.type == 4821) {
@@ -33473,7 +_,8 @@
 
 			if (sItem.damage > 0) {
 				UpdateMeleeHitCooldowns();
-				float knockBack = sItem.knockBack;
+				float knockBack = GetWeaponKnockback(sItem, sItem.knockBack);
+				/*
 				float num = 1f;
 				if (kbGlove)
 					num += 1f;
@@ -33484,6 +_,7 @@
 				knockBack *= num;
 				if (inventory[selectedItem].type == 3106)
 					knockBack += knockBack * (1f - stealth);
+				*/
 
 				bool[] shouldIgnore2 = ItemCheck_GetTileCutIgnoreList(sItem);
 				ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore2);
@@ -33767,11 +_,18 @@
 				if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !itemRectangle.Intersects(player.Hitbox) || !CanHit(player))
 					continue;
 
+				if (!ItemLoader.CanHitPvp(sItem, this, player) || !PlayerLoader.CanHitPvp(this, sItem, player))
+					continue; //TODO: PvP crit hook?
+
 				bool flag = false;
 				if (Main.rand.Next(1, 101) <= 10)
 					flag = true;
 
 				int num = Main.DamageVar(damage, luck);
+
+				ItemLoader.ModifyHitPvp(sItem, this, player, ref num, ref flag);
+				PlayerLoader.ModifyHitPvp(this, sItem, player, ref num, ref flag);
+
 				StatusToPlayerPvP(sItem.type, i);
 				OnHit(player.Center.X, player.Center.Y, player);
 				PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayer(whoAmI);
@@ -33810,12 +_,17 @@
 					}
 				}
 
+				// Extra context
+
 				if (inventory[selectedItem].type == 3106) {
 					stealth = 1f;
 					if (Main.netMode == 1)
 						NetMessage.SendData(84, -1, -1, null, whoAmI);
 				}
 
+				ItemLoader.OnHitPvp(sItem, this, Main.player[i], num2, flag);
+				PlayerLoader.OnHitPvp(this, sItem, Main.player[i], num2, flag);
+
 				if (Main.netMode != 0)
 					NetMessage.SendPlayerHurt(i, playerDeathReason, num, direction, flag, pvp: true, -1);
 
@@ -33918,6 +_,15 @@
 					TakeDamageFromJellyfish(npcIndex);
 			}
 			else {
+				// TODO: should this be able to bypass the conditions above?
+				// https://github.com/tModLoader/tModLoader/pull/2984
+				bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, nPC);
+				if (modCanHit is false)
+					return;
+
+				if (modCanHit is true)
+					goto skipVanillaHitChecks;
+
 				if (nPC.friendly && (nPC.type != 22 || !killGuide) && (nPC.type != 54 || !killClothier) && (!nPC.isLikeATownNPC || sItem.type != 5129))
 					return;
 
@@ -33934,6 +_,7 @@
 				if (!flag || (!nPC.noTileCollide && !CanHit(nPC)))
 					return;
 
+				skipVanillaHitChecks:
 				int num = originalDamage;
 				bool flag3 = false;
 				int weaponCrit = GetWeaponCrit(sItem);
@@ -34012,13 +_,23 @@
 					ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.FlyMeal, settings3, whoAmI);
 				}
 
+
+				ItemLoader.ModifyHitNPC(sItem, this, nPC, ref num6, ref knockBack, ref flag3);
+				NPCLoader.ModifyHitByItem(nPC, this, sItem, ref num6, ref knockBack, ref flag3);
+				PlayerLoader.ModifyHitNPC(this, sItem, nPC, ref num6, ref knockBack, ref flag3);
+
 				StatusToNPC(sItem.type, npcIndex);
 				if (nPC.life > 5)
 					OnHit(nPC.Center.X, nPC.Center.Y, nPC);
 
-				num6 += nPC.checkArmorPenetration(armorPenetration, armorPenetrationPercent);
+				num6 += nPC.checkArmorPenetration(GetWeaponArmorPenetration(sItem), armorPenetrationPercent);
 				NPCKillAttempt attempt = new NPCKillAttempt(nPC);
 				int dmgDone = (int)nPC.StrikeNPC(num6, knockBack, direction, flag3);
+
+				ItemLoader.OnHitNPC(sItem, this, nPC, dmgDone, knockBack, flag3);
+				NPCLoader.OnHitByItem(nPC, this, sItem, dmgDone, knockBack, flag3);
+				PlayerLoader.OnHitNPC(this, sItem, nPC, dmgDone, knockBack, flag3);
+
 				ApplyNPCOnHitEffects(sItem, itemRectangle, num, knockBack, npcIndex, num6, dmgDone);
 				int num7 = Item.NPCtoBanner(nPC.BannerID());
 				if (num7 >= 0)
@@ -34283,11 +_,13 @@
 		}
 
 		private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle) {
-			bool flag = sItem.type == 3183 || sItem.type == 4821;
+			//bool flag = sItem.type == 3183 || sItem.type == 4821; // effectively replaced by ItemID.Sets.LavaproofCatchingTool
 			for (int i = 0; i < 200; i++) {
 				if (!Main.npc[i].active || Main.npc[i].catchItem <= 0)
 					continue;
 
+				NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
+				/*
 				Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
 				if (!itemRectangle.Intersects(value))
 					continue;
@@ -34303,6 +_,7 @@
 				else {
 					NPC.CatchNPC(i, whoAmI);
 				}
+				*/
 			}
 
 			return itemRectangle;
@@ -34609,6 +_,9 @@
 				Main.dust[num29].velocity.Y *= 2f;
 			}
 
+			ItemLoader.MeleeEffects(sItem, this, itemRectangle);
+			PlayerLoader.MeleeEffects(this, sItem, itemRectangle);
+
 			return itemRectangle;
 		}
 
@@ -34687,6 +_,7 @@
 				}
 			}
 
+			ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
 			if (sItem.type == 1450 && Main.rand.Next(3) == 0) {
 				int num3 = -1;
 				float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
@@ -34785,40 +_,78 @@
 			releaseUseItem = false;
 		}
 
+		public void UseManaMaxIncreasingItem(int increase) {
+			// Failsafe.  Might not be needed?
+			if (increase < 0)
+				increase = 0;
+
+			statManaMax += increase;
+			statManaMax2 += increase;
+			statMana += increase;
+
+			if (Main.myPlayer == whoAmI)
+				ManaEffect(increase);
+		}
+
 		private void ItemCheck_UseManaCrystal(Item sItem) {
-			if (sItem.type == 109 && itemAnimation > 0 && statManaMax < 200 && ItemTimeIsZero) {
+			if (sItem.type == 109 && itemAnimation > 0 && ConsumedManaCrystals < ManaCrystalMax && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+				/*
 				statManaMax += 20;
 				statManaMax2 += 20;
 				statMana += 20;
 				if (Main.myPlayer == whoAmI)
 					ManaEffect(20);
+				*/
+				UseManaMaxIncreasingItem(20);
+				ConsumedManaCrystals++;
 
 				AchievementsHelper.HandleSpecialEvent(this, 1);
 			}
 		}
 
+		public void UseHealthMaxIncreasingItem(int increase) {
+			// Failsafe.  Might not be needed?
+			if (increase < 0)
+				increase = 0;
+
+			statLifeMax += increase;
+			statLifeMax2 += increase;
+			statLife += increase;
+
+			if (Main.myPlayer == whoAmI)
+				HealEffect(increase);
+		}
+
 		private void ItemCheck_UseLifeFruit(Item sItem) {
-			if (sItem.type == 1291 && itemAnimation > 0 && statLifeMax >= 400 && statLifeMax < 500 && ItemTimeIsZero) {
+			if (sItem.type == 1291 && itemAnimation > 0 && ConsumedLifeCrystals == LifeCrystalMax && ConsumedLifeFruit < LifeFruitMax && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+				/*
 				statLifeMax += 5;
 				statLifeMax2 += 5;
 				statLife += 5;
 				if (Main.myPlayer == whoAmI)
 					HealEffect(5);
+				*/
+				UseHealthMaxIncreasingItem(5);
+				ConsumedLifeFruit++;
 
 				AchievementsHelper.HandleSpecialEvent(this, 2);
 			}
 		}
 
 		private void ItemCheck_UseLifeCrystal(Item sItem) {
-			if (sItem.type == 29 && itemAnimation > 0 && statLifeMax < 400 && ItemTimeIsZero) {
+			if (sItem.type == 29 && itemAnimation > 0 && ConsumedLifeCrystals < LifeCrystalMax && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+				/*
 				statLifeMax += 20;
 				statLifeMax2 += 20;
 				statLife += 20;
 				if (Main.myPlayer == whoAmI)
 					HealEffect(20);
+				*/
+				UseHealthMaxIncreasingItem(20);
+				ConsumedLifeCrystals++;
 
 				AchievementsHelper.HandleSpecialEvent(this, 0);
 			}
@@ -35031,7 +_,7 @@
 
 			if (toolTime == 0 && itemAnimation > 0 && controlUseItem) {
 				Tile tile = Main.tile[tileTargetX, tileTargetY];
-				if (!tile.active() || IsTilePoundable(tile))
+				if (!tile.active() || IsTilePoundable(tile) && !TileID.Sets.CanBeSloped[tile.type])
 					poundRelease = false;
 			}
 
@@ -35080,6 +_,9 @@
 			if (Main.tileHammer[tile.type]) {
 				canHitWalls = false;
 				if (sItem.hammer > 0) {
+					if (TileLoader.GetTile(tile.type) is ModTile modTile)
+						num2 += (int)(sItem.hammer / modTile.MineResist);
+					else
 					num2 += sItem.hammer;
 					if (!WorldGen.CanKillTile(x, y))
 						num2 = 0;
@@ -35110,10 +_,16 @@
 				}
 			}
 			else if (Main.tileAxe[tile.type]) {
+				if (TileLoader.GetTile(tile.type) is ModTile modTile) {
+					num2 += (int)(sItem.axe / modTile.MineResist);
+					goto skipVanillAxePower;
+				}
+
 				num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
 				if (Main.getGoodWorld)
 					num2 = (int)((double)num2 * 1.3);
 
+				skipVanillAxePower:
 				if (sItem.axe > 0) {
 					AchievementsHelper.CurrentlyMining = true;
 					if (!WorldGen.CanKillTile(x, y))
@@ -35305,7 +_,11 @@
 
 		private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y) {
 			Tile tile = Main.tile[x, y];
-			if (sItem.hammer > 0 && tile.active() && (Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442) && poundRelease) {
+
+			bool canTrySloping = sItem.hammer > 0 && tile.active() && poundRelease;
+			bool vanillaSloping = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
+
+			if (canTrySloping && (vanillaSloping || TileID.Sets.CanBeSloped[tile.type])) {
 				hitWall = false;
 				ApplyItemTime(sItem);
 				int damageAmount = 100;
@@ -35317,7 +_,10 @@
 					if (!poundRelease)
 						return;
 
+					if (TileLoader.Slope(x, y, Main.tile[x, y].type)) {
+						; // Nothing!
+					}
-					if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
+					else if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
 						if (tile.halfBrick()) {
 							WorldGen.PoundTile(x, y);
 							if (Main.netMode == 1)
@@ -35938,7 +_,8 @@
 				}
 
 				if (num3 >= 0 && WorldGen.PlaceWire(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num3], this))
-					inventory[num3].stack--;
+						inventory[num3].stack--;
 					if (inventory[num3].stack <= 0)
 						inventory[num3].SetDefaults();
 
@@ -35956,7 +_,8 @@
 				}
 
 				if (num4 >= 0 && WorldGen.PlaceWire2(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num4], this))
-					inventory[num4].stack--;
+						inventory[num4].stack--;
 					if (inventory[num4].stack <= 0)
 						inventory[num4].SetDefaults();
 
@@ -35975,7 +_,8 @@
 				}
 
 				if (num5 >= 0 && WorldGen.PlaceWire3(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num5], this))
-					inventory[num5].stack--;
+						inventory[num5].stack--;
 					if (inventory[num5].stack <= 0)
 						inventory[num5].SetDefaults();
 
@@ -35994,7 +_,8 @@
 				}
 
 				if (num6 >= 0 && WorldGen.PlaceWire4(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num6], this))
-					inventory[num6].stack--;
+						inventory[num6].stack--;
 					if (inventory[num6].stack <= 0)
 						inventory[num6].SetDefaults();
 
@@ -36027,7 +_,8 @@
 			else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2)) {
 				ApplyItemTime(sItem);
 				NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
+				if (ItemLoader.ConsumeItem(sItem, this))
-				sItem.stack--;
+					sItem.stack--;
 				if (sItem.stack <= 0)
 					sItem.SetDefaults();
 			}
@@ -36115,9 +_,13 @@
 		}
 
 		private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage) {
+			if (!CombinedHooks.CanShoot(this, sItem))
+				return;
+
 			int projToShoot = sItem.shoot;
 			float speed = sItem.shootSpeed;
 			int damage = sItem.damage;
+			/*
 			if (sItem.melee) {
 				switch (projToShoot) {
 					default:
@@ -36133,6 +_,16 @@
 						break;
 				}
 			}
+			*/
+			if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
+				speed /= inverseMeleeSpeed;
+
+			// Copied as-is from 1.3
+			if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f) {
+				speed *= ThrownVelocity;
+				if (speed > 16f)
+					speed = 16f;
+			}
 
 			bool canShoot = false;
 			int Damage = weaponDamage;
@@ -36186,6 +_,12 @@
 			if (!canShoot)
 				return;
 
+			// Added by TML. #ItemTimeOnAllClients
+			if (whoAmI != Main.myPlayer) {
+				ApplyItemTime(sItem);
+				return;
+			}
+
 			KnockBack = GetWeaponKnockback(sItem, KnockBack);
 			IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
 			if (projToShoot == 228)
@@ -36332,6 +_,13 @@
 				num3 = vector4.Y;
 			}
 
+			goto DirtBallShoot;
+			ShootHook:
+			Vector2 velocity = new Vector2(num2, num3);
+			CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
+			num2 = velocity.X;
+			num3 = velocity.Y;
+
 			if (sItem.useStyle == 5) {
 				if (sItem.type == 3029) {
 					Vector2 vector5 = new Vector2(num2, num3);
@@ -36367,6 +_,11 @@
 				NetMessage.SendData(41, -1, -1, null, whoAmI);
 			}
 
+			if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
+				return;
+
+			goto ShootProj;
+			DirtBallShoot:
 			if (projToShoot == 17) {
 				pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
 				pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
@@ -36375,6 +_,8 @@
 
 				LimitPointToPlayerReachableArea(ref pointPoisition);
 			}
+			goto ShootHook;
+			ShootProj:
 
 			if (projToShoot == 76) {
 				projToShoot += Main.rand.Next(3);
@@ -37925,6 +_,9 @@
 				return;
 			}
 
+			if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
+				return;
+
 			for (int num = 19; num >= 0; num--) {
 				if (IsItemSlotUnlockedAndUsable(num)) {
 					_ = num % 10;
@@ -37957,6 +_,11 @@
 		private void ItemCheck_MinionAltFeatureUse(Item sItem, bool cShoot) {
 			if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+
+				// Added by TML. #ItemTimeOnAllClients
+				if (whoAmI != Main.myPlayer)
+					return;
+
 				MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
 			}
 		}
@@ -37966,6 +_,11 @@
 				return;
 
 			ApplyItemTime(sItem);
+
+			// Added by TML. #ItemTimeOnAllClients
+			if (whoAmI != Main.myPlayer)
+				return;
+
 			for (int i = 0; i < 1000; i++) {
 				Projectile projectile = Main.projectile[i];
 				if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
@@ -38291,6 +_,11 @@
 		}
 
 		private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.HoldStyle(sItem, this, heldItemFrame);
+		}
+
+		private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (isPettingAnimal) {
 				int num = miscCounter % 14 / 7;
 				CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
@@ -38550,10 +_,13 @@
 				SetCompositeArmBack(enabled: true, stretch6, (float)Math.PI * -3f / 5f * (float)direction);
 				FlipItemLocationAndRotationForGravity();
 			}
+			//else if (!Main.dedServ) { // Added by TML.
+			//	ItemLoader.UseStyle(sItem, this);
+			//}
 		}
 
 		private void ItemCheck_ApplyManaRegenDelay(Item sItem) {
-			if (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))
+ 			if (GetManaCost(sItem) > 0)
 				manaRegenDelay = (int)maxRegenDelay;
 		}
 
@@ -38614,6 +_,10 @@
 		}
 
 		public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.UseStyle(sItem, this, heldItemFrame);
+		}
+		public void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (Main.dedServ)
 				return;
 
@@ -39357,8 +_,8 @@
 		}
 
 		private void ApplyLifeAndOrMana(Item item) {
-			int num = item.healLife;
-			int healMana = item.healMana;
+			int num = GetHealLife(item, true);
+			int healMana = GetHealMana(item, true);
 			if (item.type == 3001) {
 				int healLife = item.healLife;
 				int num2 = 120;
@@ -39397,6 +_,9 @@
 		}
 
 		private bool ItemCheck_CheckCanUse(Item sItem) {
+			if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
+				return false;
+
 			int whoAmI = base.whoAmI;
 			bool flag = true;
 			int num = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
@@ -39746,7 +_,7 @@
 			if (baitTypeUsed == 2673)
 				flag = true;
 
-			if (flag) {
+			if (CombinedHooks.CanConsumeBait(this, item) ?? flag) {
 				if (item.type == 4361 || item.type == 4362)
 					NPC.LadyBugKilled(base.Center, item.type == 4362);
 
@@ -39788,6 +_,11 @@
 			if (sItem.type == 3006)
 				flag2 = true;
 
+			if (sItem.type != ItemID.MedusaHead /*3269*/ && !CheckMana(sItem, pay:!flag2))
+				canUse = false;
+
+			return canUse; //TODO: Explain this in a comment.
+
 			if (sItem.type != 3269 && (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))) {
 				if (statMana >= num) {
 					if (!flag2)
@@ -39953,6 +_,13 @@
 		}
 
 		private void ItemCheck_HandleMPItemAnimation(Item sItem) {
+			// Firstly, in vanilla, autoReuse items go from itemAnimation == 1 to itemAnimationMax-1 here, skipping the frame where itemAnimation == 0
+			//   this prevents the item flickering out while being auto-reused, and prevents other control inputs that can happen on that 'frame where item is not in use' like useTurn
+			//   but has the side-effect that autoReuse items are one frame shorter. tML fixes the itemAnimation counter, see the comments near the top of ItemCheck_Inner (#2351)
+			//
+			// Secondly, we don't need to play the shoot-sound and ensure hold-out animation looping for remote players because Shoot logic now runs remote side in tML (#ItemTimeOnAllClients)
+
+			/*
 			if (sItem.autoReuse && !noItems) {
 				releaseUseItem = true;
 				if (itemAnimation == 1 && sItem.stack > 0) {
@@ -39962,28 +_,46 @@
 						itemAnimation = 0;
 				}
 			}
+			*/
 
 			TryAllowingItemReuse(sItem);
 		}
 
 		private void TryAllowingItemReuse(Item sItem) {
+			if (CanAutoReuseItem(sItem))
+				releaseUseItem = true;
+		}
+		
+		public bool CanAutoReuseItem(Item sItem) {
+			if (CombinedHooks.CanAutoReuseItem(this, sItem) is bool autoReuse)
+				return autoReuse;
+
-			bool flag = false;
+			//bool flag = false;
+			bool flag = sItem.autoReuse;
 			if (autoReuseGlove) {
+				/*
 				flag |= (sItem.melee && sItem.type != 3030);
 				flag |= (sItem.summon && ItemID.Sets.SummonerWeaponThatScalesWithAttackSpeed[sItem.type]);
+				*/
+				flag |= sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed);
 			}
 
 			if (autoReuseAllWeapons && sItem.damage > 0 && (!sItem.channel || !channel))
 				flag = true;
 
+			/*
 			if (flag)
 				releaseUseItem = true;
+			*/
+			
+			return flag;
 		}
 
 		private void ItemCheck_HandleMount() {
 			if (!mount.Active)
 				return;
 
+			MountLoader.UseAbility(this, Vector2.Zero, false);
 			if (whoAmI == Main.myPlayer && gravDir == -1f) {
 				mount.Dismount(this);
 			}
@@ -40168,7 +_,7 @@
 				if (num == 2)
 					num = 102;
 
-				for (int i = 0; i < 44; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102) {
 						DelBuff(i);
 						i--;
@@ -40337,7 +_,11 @@
 			}
 		}
 
+		// tML-specific overload that exists for consistency with other GetWeaponXYZ methods
+		public float GetWeaponKnockback(Item sItem) => GetWeaponKnockback(sItem, sItem.knockBack);
+
-		public float GetWeaponKnockback(Item sItem, float KnockBack) {
+		public float GetWeaponKnockback(Item sItem, float baseKnockback) {
+			/*
 			if (sItem.summon)
 				KnockBack += minionKB;
 
@@ -40352,11 +_,15 @@
 
 			if (sItem.ranged && setVortex)
 				KnockBack *= 1f + (1f - stealth) * 0.5f;
+			*/
 
-			return KnockBack;
+			StatModifier modifier = GetTotalKnockback(sItem.DamageType);
+			CombinedHooks.ModifyWeaponKnockback(this, sItem, ref modifier);
+			return Math.Max(0f, modifier.ApplyTo(baseKnockback));
 		}
 
 		public int GetWeaponCrit(Item sItem) {
+			/*
 			if (sItem.melee)
 				return meleeCrit;
 
@@ -40367,9 +_,16 @@
 				return magicCrit;
 
 			return 0;
+			*/
+
+			// TODO: Should ModifyWeaponCrit be float?
+			float crit = sItem.crit + GetTotalCritChance(sItem.DamageType);
+			CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
+			return (int)(crit + 5E-06f);
 		}
 
-		public int GetWeaponDamage(Item sItem) {
+		public int GetWeaponDamage(Item sItem, bool forTooltip = false) {
+			/*
 			int num = sItem.damage;
 			if (num > 0) {
 				if (sItem.melee) {
@@ -40400,9 +_,34 @@
 			}
 
 			return num;
+			*/
+
+			StatModifier modifier = GetTotalDamage(sItem.DamageType);
+
+			if (AmmoID.Sets.IsArrow[sItem.useAmmo])
+				modifier = modifier.CombineWith(arrowDamage);
+
+			if (AmmoID.Sets.IsBullet[sItem.useAmmo])
+				modifier = modifier.CombineWith(bulletDamage);
+
+			if (AmmoID.Sets.IsRocket[sItem.useAmmo])
+				modifier = modifier.CombineWith(rocketDamage);
+
+			CombinedHooks.ModifyWeaponDamage(this, sItem, ref modifier);
+			int baseDamage = forTooltip ? (int)(sItem.damage * ItemID.Sets.ToolTipDamageMultiplier[sItem.type]) : sItem.damage;
+			return Math.Max(0, (int)(modifier.ApplyTo(baseDamage) + 5E-06f));
 		}
 
+		/// <summary>
+		/// Whether or not the player has ammunition available for the given weapon.
+		/// </summary>
+		/// <param name="sItem">The weapon for which to try to find ammunition.</param>
+		/// <returns>True if the player has ammo available; false otherwise.</returns>
+		public bool HasAmmo(Item sItem) => HasAmmo(sItem, canUse: true);
+
-		public bool HasAmmo(Item sItem, bool canUse) {
+		internal bool HasAmmo(Item sItem, bool canUse) {
+			return sItem.useAmmo == 0 || ChooseAmmo(sItem) != null || !ItemLoader.NeedsAmmo(sItem, this);
+			/*
 			if (sItem.useAmmo > 0) {
 				canUse = false;
 				for (int i = 0; i < 58; i++) {
@@ -40414,6 +_,7 @@
 			}
 
 			return canUse;
+			*/
 		}
 
 		private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId) {
@@ -40424,14 +_,52 @@
 			return false;
 		}
 
-		public void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int Damage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false) {
-			Item item = new Item();
+		/// <summary>
+		/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
+		/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
+		/// </summary>
+		/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
+		/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
+		/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
+		/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+		/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+		/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
+		/// <param name="dontConsume">
+		/// Whether or not ammo consumption logic should be called upon.<br></br>
+		/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
+		/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
+		/// </param>
+		/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
+		public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false) {
+			projToShoot = weapon.shoot;
+			speed = weapon.shootSpeed;
+			damage = GetWeaponDamage(weapon);
+			knockBack = GetWeaponKnockback(weapon);
+			bool canShoot = false;
+			PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
+			if (!canShoot) {
+				projToShoot = 0;
+				return false;
+			}
+
+			return true;
+		}
+
+		/// <summary>
+		/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
+		/// </summary>
+		/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
+		/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
+		public Item ChooseAmmo(Item weapon) {
+			var sItem = weapon;
+			Item item = null;
 			bool flag = false;
-			usedAmmoItemId = 0;
+			bool canShoot = false;
+
 			if (sItem.useAmmo == AmmoID.Coin) {
 				for (int i = 0; i < 4; i++) {
 					int num = 50 + i;
-					if (inventory[num].ammo == sItem.useAmmo && inventory[num].stack > 0) {
+					if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[i], this)) {
 						item = inventory[num];
 						canShoot = true;
 						flag = true;
@@ -40441,7 +_,7 @@
 			}
 
 			for (int j = 54; j < 58; j++) {
-				if (inventory[j].ammo == sItem.useAmmo && inventory[j].stack > 0) {
+				if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[j], this)) {
 					item = inventory[j];
 					canShoot = true;
 					flag = true;
@@ -40451,7 +_,7 @@
 
 			if (!flag) {
 				for (int k = 0; k < 54; k++) {
-					if (inventory[k].ammo == sItem.useAmmo && inventory[k].stack > 0) {
+					if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[k], this)) {
 						item = inventory[k];
 						canShoot = true;
 						break;
@@ -40459,10 +_,39 @@
 				}
 			}
 
+			return item;
+		}
+
+		internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false) {
+			usedAmmoItemId = 0;
+			Item item = ChooseAmmo(sItem);
+			canShoot = item != null;
+
+			bool shootWithNoAmmo = false;
+			if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this)) {
+				item = ContentSamples.ItemsByType[sItem.useAmmo];
+				if (item.ammo == sItem.useAmmo)
+					canShoot = shootWithNoAmmo = true;
+			}
+
 			if (!canShoot)
 				return;
 
 			usedAmmoItemId = item.type;
+
+			StatModifier ammoDamage = GetTotalDamage(item.DamageType);
+			if (AmmoID.Sets.IsArrow[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(arrowDamage);
+
+			if (AmmoID.Sets.IsBullet[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(bulletDamage);
+
+			if (AmmoID.Sets.IsRocket[item.ammo])
+				ammoDamage = ammoDamage.CombineWith(rocketDamage);
+
+			ammoDamage.Base = 0;
+			ammoDamage.Flat = totalDamage;
+
 			int pickedProjectileId = -1;
 			if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
 				projToShoot = pickedProjectileId;
@@ -40495,15 +_,15 @@
 			if (projToShoot == 42) {
 				if (item.type == 370) {
 					projToShoot = 65;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 				else if (item.type == 408) {
 					projToShoot = 68;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 				else if (item.type == 1246) {
 					projToShoot = 354;
-					Damage += 5;
+					ammoDamage.Flat += 5;
 				}
 			}
 
@@ -40512,7 +_,7 @@
 
 			if (hasMoltenQuiver && projToShoot == 1) {
 				projToShoot = 2;
-				Damage += 2;
+				ammoDamage.Flat += 2;
 			}
 
 			speed += item.shootSpeed;
@@ -40521,6 +_,7 @@
 				speed *= 1.1f;
 			}
 
+			/*
 			if (item.ranged) {
 				if (item.damage > 0)
 					Damage += (int)((float)item.damage * rangedDamage);
@@ -40528,6 +_,7 @@
 			else {
 				Damage += item.damage;
 			}
+			*/
 
 			if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery) {
 				if (speed < 20f) {
@@ -40536,11 +_,62 @@
 						speed = 20f;
 				}
 
+				// archery potion buff moved into arrowDamage stat modifier
-				Damage = (int)((double)Damage * 1.1);
+				// Damage = (int)((double)Damage * 1.1);
 			}
 
 			KnockBack += item.knockBack;
+
+			ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref ammoDamage, ref KnockBack);
+			totalDamage = (int)(ammoDamage.ApplyTo(item.damage) + 5E-06f);
+
+			if (!dontConsume && !shootWithNoAmmo && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot)) {
+				CombinedHooks.OnConsumeAmmo(this, sItem, item);
+				item.stack--;
+				if (item.stack <= 0) {
+					item.active = false;
+					item.TurnToAir();
+				}
+			}
+		}
+
+		/// <summary>
+		/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
+		/// </summary>
+		/// <param name="weapon">The weapon attempting to consume the ammo.</param>
+		/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
+		/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
+		/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
+		public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot) {
+			Item sItem = weapon;
+			Item item = ammo;
+			/*
+			TODO:
+			the current approach to ammo consumption hooks demands that vanilla conservation chances still be allowed to factor in
+			while this is fine for some, for others, it may be preferable to be able to guarantee ammo consumption if it should happen
+			for this, two approaches exist. each has their ups and downs:
+			1 - CanConsumeAmmo to nullable, return given value if it exists
+			2 - separate hook for forced ammo consumption. returns false by default, return true to bypass all vanilla conservation chances
+
+			post-May-freeze, will decide on one and make changes accordingly
+			- thomas
+			*/
+			if (!CombinedHooks.CanConsumeAmmo(this, sItem, item))
+				return true;
+
+			if (sItem.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
+				return true;
+
+			if (sItem.consumeAmmoOnLastShotOnly) {
+				int useTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
+				bool isLastShot = itemAnimation <= useTime || // not enough time to shoot again
+					sItem.useLimitPerAnimation != null && ItemUsesThisAnimation == sItem.useLimitPerAnimation - 1; // this shot hits the limit
+
+				if (!isLastShot)
+					return true;
+			}
+
-			bool flag2 = dontConsume;
+			bool flag2 = false;
 			if (sItem.type == 3475 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
@@ -40553,7 +_,7 @@
 			if (sItem.type == 5134 && Main.rand.Next(3) == 0)
 				flag2 = true;
 
-			if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && Main.rand.Next(5) == 0)
+			if (magicQuiver && AmmoID.Sets.IsArrow[sItem.useAmmo] && Main.rand.Next(5) == 0)
 				flag2 = true;
 
 			if (ammoBox && Main.rand.Next(5) == 0)
@@ -40580,11 +_,13 @@
 			if (sItem.type == 1553 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
+			/* Clockwork Assault Rifle + Eventide. Handled by consumeAmmoOnLastShotOnly.
 			if (sItem.type == 434 && !ItemAnimationJustStarted)
 				flag2 = true;
 
-			if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
+			if (sItem.type == 4953 && itemAnimation >= sItem.useAnimation - 8)
 				flag2 = true;
+			*/
 
 			if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
 				flag2 = true;
@@ -40598,9 +_,19 @@
 			if (ammoCost75 && Main.rand.Next(4) == 0)
 				flag2 = true;
 
+			// Copied as-is from 1.3
+			if (item.CountsAsClass(DamageClass.Throwing)) {
+				if (ThrownCost50 && Main.rand.Next(100) < 50)
+					flag2 = true;
+
+				if (ThrownCost33 && Main.rand.Next(100) < 33)
+					flag2 = true;
+			}
+
 			if (Main.remixWorld && sItem.type == 1319 && Main.rand.Next(2) == 0)
 				flag2 = true;
 
+			/* Flamethrower + Elf Melter (handled by consumeAmmoOnFirstShotOnly) + Clentaminator (handled by consumeAmmoOnFirstShotOnly)
 			if (projToShoot == 85 && itemAnimation < itemAnimationMax - sItem.useTime)
 				flag2 = true;
 
@@ -40614,6 +_,9 @@
 					item.TurnToAir();
 				}
 			}
+			*/
+
+			return flag2;
 		}
 
 		public void GetOtherPlayersPickTile(int x, int y, int pickDamage) {
@@ -40649,7 +_,7 @@
 						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
 					}
 
-					if (Main.tile[x, y].type == 21)
+					if (Main.tile[x, y].type == 21 || Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type])
 						NetMessage.SendData(34, -1, -1, null, 1, x, y);
 
 					if (Main.tile[x, y].type == 467)
@@ -40657,6 +_,14 @@
 
 					if (Main.tile[x, y].type == 88)
 						NetMessage.SendData(34, -1, -1, null, 3, x, y);
+
+					if (Main.tile[x, y].type >= TileID.Count) {
+						if (TileID.Sets.BasicChest[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type, 0);
+
+						if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type, 0);
+					}
 				}
 				else {
 					bool flag = Main.tile[x, y].active();
@@ -40731,6 +_,9 @@
 			if (Main.tileNoFail[tileTarget.type])
 				num = 100;
 
+			if (TileLoader.GetTile(tileTarget.type) is ModTile modTile)
+				num += (int)(pickPower / modTile.MineResist);
+			else
 			num = ((!Main.tileDungeon[tileTarget.type] && tileTarget.type != 25 && tileTarget.type != 58 && tileTarget.type != 117 && tileTarget.type != 203) ? ((tileTarget.type == 85) ? ((!Main.getGoodWorld) ? (num + pickPower / 3) : (num + pickPower / 4)) : ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2))) : (num + pickPower / 2));
 			if (tileTarget.type == 211 && pickPower < 200)
 				num = 0;
@@ -40786,6 +_,9 @@
 			else if (tileTarget.type == 223 && pickPower < 150) {
 				num = 0;
 			}
+			else {
+				TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
+			}
 
 			if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
 				num += pickPower;
@@ -41091,15 +_,42 @@
 
 		public void DropItems() {
 			IEntitySource itemSource_Death = GetItemSource_Death();
+
+			var startInventory = PlayerLoader.GetStartingItems(this, DropItems_GetDefaults().Where(item => !item.IsAir), true);
+			var startCounts = new Dictionary<int, int>();
+
+			foreach (Item item in startInventory) {
+				if (!startCounts.ContainsKey(item.netID))
+					startCounts[item.netID] = 0;
+
+				startCounts[item.netID] += item.stack;
+			}
+
+			startCounts[ModContent.ItemType<ModLoader.Default.StartBag>()] = 1;
+
+			//TML: Drop code for modded accessory Slots, should run prior to dropping other items in case conditions are used based on player's current equips
+			AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
+
 			for (int i = 0; i < 59; i++) {
 				if (inventory[i].stack > 0) {
 					bool flag = true;
 					int type = inventory[i].type;
+					/*
 					if ((uint)(type - 3506) <= 1u || type == 3509)
 						flag = false;
 
 					if (flag)
 						TryDroppingSingleItem(itemSource_Death, inventory[i]);
+					*/
+					Item itemToDrop = inventory[i];
+					if (startCounts.TryGetValue(type, out int startCount)) {
+						int n = Math.Min(itemToDrop.stack, startCount);
+						itemToDrop.stack -= n;
+						startCounts[type] -= n;
+					}
+					
+					if (itemToDrop.stack > 0)
+						TryDroppingSingleItem(itemSource_Death, itemToDrop);
 				}
 
 				inventory[i].TurnToAir();
@@ -41121,12 +_,26 @@
 				loadouts[type].TryDroppingItems(this, itemSource_Death);
 			}
 
+			DropItems_End(startInventory);
+		}
+		private IEnumerable<Item> DropItems_GetDefaults() { //Split by tML.
+			var inventory = new Item[this.inventory.Length];
+
+			for (int i = 0; i < inventory.Length; i++) {
+				inventory[i] = new Item();
+			}
+
 			inventory[0].SetDefaults(3507);
 			inventory[0].Prefix(-1);
 			inventory[1].SetDefaults(3509);
 			inventory[1].Prefix(-1);
 			inventory[2].SetDefaults(3506);
 			inventory[2].Prefix(-1);
+
+			return inventory;
+		}
+		private void DropItems_End(IList<Item> startInventory) { //Split by tML.
+			PlayerLoader.SetStartInventory(this, startInventory);
 			Main.mouseItem.TurnToAir();
 		}
 
@@ -41141,6 +_,8 @@
 				obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 				obj.noGrabDelay = 100;
 				obj.newAndShiny = false;
+				obj.ModItem = theItem.ModItem;
+				obj.globalItems = theItem.globalItems;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num);
 			}
@@ -41200,6 +_,7 @@
 			player.zone5 = zone5;
 			player.voidVaultInfo = voidVaultInfo;
 			player.luck = luck;
+			BiomeLoader.CopyCustomBiomesTo(this, player);
 			player.extraAccessory = extraAccessory;
 			player.MinionRestTargetPoint = MinionRestTargetPoint;
 			player.MinionAttackTargetNPC = MinionAttackTargetNPC;
@@ -41256,13 +_,14 @@
 
 			CloneLoadouts(player);
 			player.trashItem = trashItem.Clone();
-			for (int j = 0; j < 44; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				player.buffType[j] = buffType[j];
 				player.buffTime[j] = buffTime[j];
 			}
 
 			DpadRadial.CopyTo(player.DpadRadial);
 			CircularRadial.CopyTo(player.CircularRadial);
+			PlayerLoader.clientClone(this, player);
 			return player;
 		}
 
@@ -41309,7 +_,7 @@
 			if (Main.tile[x, y - 1] == null)
 				return false;
 
-			if (!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != 79)
+			if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
 				return false;
 
 			for (int i = x - 1; i <= x + 1; i++) {
@@ -41429,7 +_,12 @@
 				}
 			}
 			catch (Exception exception) {
-				FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path);
+				FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path); // IO Exception
+
+				if (!Main.gameMenu)
+					WorldGen.SaveAndQuit();
+
+				Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{exception}", Main.menuMode);
 				throw;
 			}
 		}
@@ -41444,24 +_,46 @@
 			if (string.IsNullOrEmpty(path))
 				return;
 
+			/* tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
 			if (FileUtilities.Exists(path, isCloudSave))
 				FileUtilities.Copy(path, path + ".bak", isCloudSave);
+			*/
 
+			byte[] bytes;
 			RijndaelManaged rijndaelManaged = new RijndaelManaged();
-			using (Stream stream = isCloudSave ? ((Stream)new MemoryStream(2000)) : ((Stream)new FileStream(path, FileMode.Create))) {
+			using (Stream stream = (Stream)new MemoryStream(2000)) {
 				using (CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write)) {
 					using (BinaryWriter binaryWriter = new BinaryWriter(cryptoStream)) {
+						PlayerLoader.PreSavePlayer(player);
+
 						binaryWriter.Write(276);
 						playerFile.Metadata.Write(binaryWriter);
 						Serialize(playerFile, player, binaryWriter);
 						binaryWriter.Flush();
 						cryptoStream.FlushFinalBlock();
 						stream.Flush();
+
+						/* tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
 						if (isCloudSave && SocialAPI.Cloud != null)
 							SocialAPI.Cloud.Write(playerFile.Path, ((MemoryStream)stream).ToArray());
+						*/
+						bytes = ((MemoryStream)stream).ToArray();
+
+						PlayerLoader.PostSavePlayer(player); // For native data only
 					}
 				}
 			}
+
+			// tML - Delay vanilla saving until modded data is serialized (in case of exceptions)
+			var tag = PlayerIO.SaveData(player);
+
+			BackupIO.Player.ArchivePlayer(path, isCloudSave);
+			if (FileUtilities.Exists(path, isCloudSave))
+				FileUtilities.Copy(path, path + ".bak", isCloudSave);
+
+			FileUtilities.WriteAllBytes(path, bytes, isCloudSave);
+
+			PlayerIO.Save(tag, path, isCloudSave);
 		}
 
 		private static void Serialize(PlayerFileData playerFile, Player newPlayer, BinaryWriter fileIO) {
@@ -41469,7 +_,7 @@
 			fileIO.Write(newPlayer.difficulty);
 			fileIO.Write(playerFile.GetPlayTime().Ticks);
 			fileIO.Write(newPlayer.hair);
-			fileIO.Write(newPlayer.hairDye);
+			PlayerIO.WriteByteVanillaHairDye(newPlayer.hairDye, fileIO);
 			BitsByte bb = (byte)0;
 			for (int i = 0; i < 8; i++) {
 				bb[i] = newPlayer.hideVisibleAccessory[i];
@@ -41485,9 +_,11 @@
 			fileIO.Write(newPlayer.hideMisc);
 			fileIO.Write((byte)newPlayer.skinVariant);
 			fileIO.Write(newPlayer.statLife);
-			fileIO.Write(newPlayer.statLifeMax);
+			// Keep the player state valid with vanilla (#HealthManaAPI)
+			// Any modifications to statLifeMax/statManaMax by mods can just be done during runtime
+			fileIO.Write(100 + newPlayer.ConsumedLifeCrystals * 20 + newPlayer.ConsumedLifeFruit * 5);
 			fileIO.Write(newPlayer.statMana);
-			fileIO.Write(newPlayer.statManaMax);
+			fileIO.Write(20 + newPlayer.ConsumedManaCrystals * 20);
 			fileIO.Write(newPlayer.extraAccessory);
 			fileIO.Write(newPlayer.unlockedBiomeTorches);
 			fileIO.Write(newPlayer.UsingBiomeTorches);
@@ -41524,57 +_,57 @@
 			fileIO.Write(newPlayer.shoeColor.G);
 			fileIO.Write(newPlayer.shoeColor.B);
 			for (int k = 0; k < newPlayer.armor.Length; k++) {
-				fileIO.Write(newPlayer.armor[k].netID);
-				fileIO.Write(newPlayer.armor[k].prefix);
+				ItemIO.WriteVanillaID(newPlayer.armor[k], fileIO);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.armor[k], fileIO);
 			}
 
 			for (int l = 0; l < newPlayer.dye.Length; l++) {
-				fileIO.Write(newPlayer.dye[l].netID);
-				fileIO.Write(newPlayer.dye[l].prefix);
+				ItemIO.WriteVanillaID(newPlayer.dye[l], fileIO);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.dye[l], fileIO);
 			}
 
 			for (int m = 0; m < 58; m++) {
-				fileIO.Write(newPlayer.inventory[m].netID);
+				ItemIO.WriteVanillaID(newPlayer.inventory[m], fileIO);
 				fileIO.Write(newPlayer.inventory[m].stack);
-				fileIO.Write(newPlayer.inventory[m].prefix);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.inventory[m], fileIO);
 				fileIO.Write(newPlayer.inventory[m].favorited);
 			}
 
 			for (int n = 0; n < newPlayer.miscEquips.Length; n++) {
-				fileIO.Write(newPlayer.miscEquips[n].netID);
-				fileIO.Write(newPlayer.miscEquips[n].prefix);
-				fileIO.Write(newPlayer.miscDyes[n].netID);
-				fileIO.Write(newPlayer.miscDyes[n].prefix);
+				ItemIO.WriteVanillaID(newPlayer.miscEquips[n], fileIO);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.miscEquips[n], fileIO);
+				ItemIO.WriteVanillaID(newPlayer.miscDyes[n], fileIO);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.miscDyes[n], fileIO);
 			}
 
 			for (int num = 0; num < 40; num++) {
-				fileIO.Write(newPlayer.bank.item[num].netID);
+				ItemIO.WriteVanillaID(newPlayer.bank.item[num], fileIO);
 				fileIO.Write(newPlayer.bank.item[num].stack);
-				fileIO.Write(newPlayer.bank.item[num].prefix);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.bank.item[num], fileIO);
 			}
 
 			for (int num2 = 0; num2 < 40; num2++) {
-				fileIO.Write(newPlayer.bank2.item[num2].netID);
+				ItemIO.WriteVanillaID(newPlayer.bank2.item[num2], fileIO);
 				fileIO.Write(newPlayer.bank2.item[num2].stack);
-				fileIO.Write(newPlayer.bank2.item[num2].prefix);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.bank2.item[num2], fileIO);
 			}
 
 			for (int num3 = 0; num3 < 40; num3++) {
-				fileIO.Write(newPlayer.bank3.item[num3].netID);
+				ItemIO.WriteVanillaID(newPlayer.bank3.item[num3], fileIO);
 				fileIO.Write(newPlayer.bank3.item[num3].stack);
-				fileIO.Write(newPlayer.bank3.item[num3].prefix);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.bank3.item[num3], fileIO);
 			}
 
 			for (int num4 = 0; num4 < 40; num4++) {
-				fileIO.Write(newPlayer.bank4.item[num4].netID);
+				ItemIO.WriteVanillaID(newPlayer.bank4.item[num4], fileIO);
 				fileIO.Write(newPlayer.bank4.item[num4].stack);
-				fileIO.Write(newPlayer.bank4.item[num4].prefix);
+				ItemIO.WriteByteVanillaPrefix(newPlayer.bank4.item[num4], fileIO);
 				fileIO.Write(newPlayer.bank4.item[num4].favorited);
 			}
 
 			fileIO.Write(newPlayer.voidVaultInfo);
 			for (int num5 = 0; num5 < 44; num5++) {
-				if (Main.buffNoSave[newPlayer.buffType[num5]]) {
+				if (true || Main.buffNoSave[newPlayer.buffType[num5]]) {// don't save buffs to vanilla player
 					fileIO.Write(0);
 					fileIO.Write(0);
 				}
@@ -41597,7 +_,7 @@
 			}
 
 			fileIO.Write(newPlayer.hbLocked);
-			for (int num7 = 0; num7 < newPlayer.hideInfo.Length; num7++) {
+			for (int num7 = 0; num7 < 13; num7++) {
 				fileIO.Write(newPlayer.hideInfo[num7]);
 			}
 
@@ -41733,6 +_,8 @@
 
 			Player player = new Player();
 			bool gotToReadName = false;
+			using var _currentPlr = new Main.CurrentPlayerOverride(player);
+
 			try {
 				RijndaelManaged rijndaelManaged = new RijndaelManaged();
 				rijndaelManaged.Padding = PaddingMode.None;
@@ -41762,6 +_,9 @@
 				playerFileData.Player = player;
 				return playerFileData;
 			}
+			catch (CustomModDataException e) {
+				playerFileData.customDataFail = e;
+			}
 			catch {
 			}
 
@@ -41784,11 +_,18 @@
 			_visualCloneStream.Seek(0L, SeekOrigin.Begin);
 			Serialize(_visualCloneDummyData, this, _visualCloneWriter);
 			_visualCloneStream.Seek(0L, SeekOrigin.Begin);
-			Deserialize(_visualCloneDummyData, player, _visualCloneReader, 276, out bool _);
+			Deserialize(_visualCloneDummyData, player, _visualCloneReader, PlayerIO.SaveData(this), 276, out bool _);
 			return player;
 		}
 
 		private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, int release, out bool gotToReadName) {
+			if (!PlayerIO.TryLoadData(data.Path, data.IsCloudSave, out var tag))
+				tag = null;
+
+			Deserialize(data, newPlayer, fileIO, tag, release, out gotToReadName);
+		}
+
+		private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, TagCompound modData, int release, out bool gotToReadName) {
 			gotToReadName = false;
 			newPlayer.name = fileIO.ReadString();
 			gotToReadName = true;
@@ -41852,11 +_,20 @@
 
 			newPlayer.statMana = fileIO.ReadInt32();
 			newPlayer.statManaMax = fileIO.ReadInt32();
+							
 			if (newPlayer.statManaMax > 200)
 				newPlayer.statManaMax = 200;
 
+			// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+			/*
 			if (newPlayer.statMana > 400)
 				newPlayer.statMana = 400;
+			*/
+
+			// Clamping of the values happens automatically
+			newPlayer.ConsumedLifeCrystals = (newPlayer.statLifeMax - 100) / 20;
+			newPlayer.ConsumedLifeFruit = (newPlayer.statLifeMax - 400) / 5;
+			newPlayer.ConsumedManaCrystals = (newPlayer.statManaMax - 20) / 20;
 
 			if (release >= 125)
 				newPlayer.extraAccessory = fileIO.ReadBoolean();
@@ -42256,6 +_,9 @@
 				}
 			}
 
+			if (modData != null)
+				PlayerIO.Load(newPlayer, modData);
+
 			LoadPlayer_LastMinuteFixes(newPlayer);
 		}
 
@@ -42312,7 +_,25 @@
 
 		private static void LoadPlayer_LastMinuteFixes(Player newPlayer) {
 			newPlayer.skinVariant = (int)MathHelper.Clamp(newPlayer.skinVariant, 0f, 11f);
+
 			for (int i = 3; i < 10; i++) {
+				LoadPlayer_LastMinuteFixes(newPlayer, newPlayer.armor[i]);
+			}
+
+			var modSlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
+			for (int i = 0; i < modSlotPlayer.SlotCount; i++) {
+				LoadPlayer_LastMinuteFixes(newPlayer, modSlotPlayer.exAccessorySlot[i]);
+			}
+
+			LoadPlayer_Finish(newPlayer);
+		}
+
+		private static void LoadPlayer_LastMinuteFixes(Player newPlayer, Item item) {
+			var armor = newPlayer.armor;
+			newPlayer.armor = new[] {item};
+			int i = 0;
+
+			{
 				int type = newPlayer.armor[i].type;
 				if (type == 908 || type == 5000)
 					newPlayer.lavaMax += 420;
@@ -42320,8 +_,10 @@
 				if (type == 906 || type == 4038 || type == 3999 || type == 4003)
 					newPlayer.lavaMax += 420;
 
-				if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0)
+				if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0) {
 					newPlayer.wingsLogic = newPlayer.armor[i].wingSlot;
+					newPlayer.equippedWings = newPlayer.armor[i];
+				}
 
 				if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
 					newPlayer.noFallDmg = true;
@@ -42332,7 +_,12 @@
 				newPlayer.lavaTime = newPlayer.lavaMax;
 			}
 
+			newPlayer.armor = armor;
+		}
+
+		private static void LoadPlayer_Finish(Player newPlayer) {
 			newPlayer.FixLoadedData();
+			newPlayer.ResetEffects(); // Added by tML, makes sure player is ready to go!
 		}
 
 		public static PlayerFileData GetFileData(string file, bool cloudSave) {
@@ -42342,12 +_,17 @@
 			PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
 			if (playerFileData.Player != null) {
 				if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1) {
+					CustomModDataException customDataFail = playerFileData.customDataFail;
-					if (FileUtilities.Exists(file + ".bak", cloudSave))
+					if (FileUtilities.Exists(file + ".bak", cloudSave)) {
 						FileUtilities.Move(file + ".bak", file, cloudSave);
+						PlayerIO.LoadBackup(file, cloudSave);
+					}
 
 					playerFileData = LoadPlayer(file, cloudSave);
 					if (playerFileData.Player == null)
 						return null;
+
+					playerFileData.customDataFail = customDataFail;
 				}
 
 				return playerFileData;
@@ -42472,6 +_,14 @@
 		}
 
 		public Player() {
+			ResetDamageClassData();
+			buffType = new int[MaxBuffs];
+			buffTime = new int[MaxBuffs];
+			buffImmune = new bool[BuffLoader.BuffCount]; // TODO: Move all these patches to field initializers.
+			ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
+			npcTypeNoAggro = new bool[NPCLoader.NPCCount];
+			PlayerLoader.SetupPlayer(this);
+			LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
 			width = 20;
 			height = 42;
 			name = string.Empty;
@@ -42519,7 +_,8 @@
 			usedGalaxyPearl = false;
 			usedGummyWorm = false;
 			usedAmbrosia = false;
+			PlayerLoader.ModifyMaxStats(this);
-			for (int n = 0; n < 693; n++) {
+			for (int n = 0; n < adjTile.Length; n++) {
 				adjTile[n] = false;
 				oldAdjTile[n] = false;
 			}
@@ -42769,11 +_,29 @@
 			int questsDone = anglerQuestsFinished;
 			float anglerRewardRarityMultiplier = GetAnglerRewardRarityMultiplier(questsDone);
 			anglerRewardRarityMultiplier *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
+			
+			List<Item> rewardItems = new List<Item>();
+			
 			GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
-			GetAnglerReward_MainReward(source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
+			GetAnglerReward_MainReward(rewardItems, source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
-			GetAnglerReward_Decoration(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+			GetAnglerReward_Decoration(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-			GetAnglerReward_Money(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+			GetAnglerReward_Money(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-			GetAnglerReward_Bait(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+			GetAnglerReward_Bait(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+			
+			PlayerLoader.AnglerQuestReward(this, anglerRewardRarityMultiplier, rewardItems);
+
+			foreach (Item rewardItem in rewardItems) {
+				rewardItem.position = Center;
+				
+				Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
+				
+				if (getItem.stack > 0) {
+					int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
+					
+					if (Main.netMode == 1)
+						NetMessage.SendData(21, -1, -1, null, number, 1f);
+				}
+			}
 		}
 
 		public static float GetAnglerRewardRarityMultiplier(int questsDone) {
@@ -42782,7 +_,7 @@
 			return num * 0.9f;
 		}
 
-		private void GetAnglerReward_MainReward(IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings) {
 			Item item = new Item();
 			item.type = 0;
 			switch (questsDone) {
@@ -42917,6 +_,8 @@
 					}
 			}
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -42924,11 +_,14 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 
 			if (item.type == 2417) {
 				Item item3 = new Item();
 				Item item4 = new Item();
 				item3.SetDefaults(2418);
+				rewardItems.Add(item3);
+				/*
 				item3.position = base.Center;
 				item2 = GetItem(whoAmI, item3, anglerRewardSettings);
 				if (item2.stack > 0) {
@@ -42936,15 +_,20 @@
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number2, 1f);
 				}
+				*/
 
 				item4.SetDefaults(2419);
+				rewardItems.Add(item4);
+				/*
 				item4.position = base.Center;
 				item2 = GetItem(whoAmI, item4, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number3 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number3, 1f);
 				}
+				*/
 			}
 			else {
 				if (item.type != 2498)
@@ -42953,26 +_,34 @@
 				Item item5 = new Item();
 				Item item6 = new Item();
 				item5.SetDefaults(2499);
+				rewardItems.Add(item5);
+				/*
 				item5.position = base.Center;
 				item2 = GetItem(whoAmI, item5, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number4 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number4, 1f);
 				}
+				*/
 
 				item6.SetDefaults(2500);
+				rewardItems.Add(item6);
+				/*
 				item6.position = base.Center;
 				item2 = GetItem(whoAmI, item6, anglerRewardSettings);
+
 				if (item2.stack > 0) {
 					int number5 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, number5, 1f);
 				}
+				*/
 			}
 		}
 
-		private void GetAnglerReward_Decoration(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_Decoration(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			float value = 1f - rarityReduction;
 			int num = 100;
 			float num2 = MathHelper.Lerp(value, 1f, Math.Min(1f, (float)questsDone / (float)num));
@@ -43043,6 +_,8 @@
 			}
 
 			item.SetDefaults(defaults);
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 			if (item2.stack > 0) {
@@ -43050,9 +_,10 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
-		private void GetAnglerReward_Bait(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			if (Main.rand.Next((int)(100f * rarityReduction)) > 50)
 				return;
 
@@ -43082,6 +_,8 @@
 			if (Main.rand.Next(250) <= questsDone)
 				item.stack++;
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 			if (item2.stack > 0) {
@@ -43089,9 +_,10 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
-		private void GetAnglerReward_Money(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
+		private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings) {
 			Item item = new Item();
 			int num = (questsDone + 50) / 2;
 			num = (int)((float)(num * Main.rand.Next(50, 201)) * 0.015f);
@@ -43124,6 +_,8 @@
 				item.stack = num;
 			}
 
+			rewardItems.Add(item);
+			/*
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -43131,6 +_,7 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			*/
 		}
 
 		public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, float totalChance, out bool botheredRollingForADrop, out int itemIdToDrop) {
@@ -43274,13 +_,17 @@
 					list.Add(3556);
 				}
 
+				// Extra patch context.
 				if (NPC.downedMoonlord)
 					list.Add(3024);
 			}
 
+			PlayerLoader.GetDyeTraderReward(this, list);
+
 			num = list[Main.rand.Next(list.Count)];
 			Item item = new Item();
 			item.SetDefaults(num);
+			// Extra patch context.
 			item.stack = 6;
 			item.position = base.Center;
 			Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
@@ -43323,7 +_,7 @@
 		public bool ConsumeSolarFlare() {
 			if (setSolar && solarShields > 0) {
 				solarShields--;
-				for (int i = 0; i < 44; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] >= 170 && buffType[i] <= 172)
 						DelBuff(i);
 				}
@@ -43443,7 +_,7 @@
 				}
 			}
 
-			int damage = (int)(20f * (1f + magicDamage + minionDamage - 2f));
+			int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
 			IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
 			_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
 		}
@@ -43562,7 +_,7 @@
 				return;
 
 			int timeToAdd = 480;
-			for (int i = 0; i < 44; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] >= type && buffType[i] < type + 3)
 					DelBuff(i);
 			}
