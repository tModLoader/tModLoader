--- src/Terraria/Terraria/Player.cs
+++ src/tModLoader/Terraria/Player.cs
@@ -34,10 +_,15 @@
 using Terraria.UI.Gamepad;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Exceptions;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
+using System.Linq;
 
 namespace Terraria
 {
-	public class Player : Entity
+	public partial class Player : Entity
 	{
 		public static class BuilderAccToggleIDs
 		{
@@ -186,15 +_,21 @@
 
 			public static void PlayerConnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerConnect(playerIndex);
 			}
 
 			public static void PlayerDisconnect(int playerIndex) {
 				PressurePlateHelper.ResetPlayer(playerIndex);
+				PlayerLoader.PlayerDisconnect(playerIndex);
 			}
 
 			public static void EnterWorld(int playerIndex) {
+				Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}", Main.ActivePlayerFileData.Name, Main.ActivePlayerFileData.IsCloudSave);
+				Interface.ResetData();
 				if (Hooks.OnEnterWorld != null)
 					Hooks.OnEnterWorld(Main.player[playerIndex]);
+
+				PlayerLoader.OnEnterWorld(playerIndex);
 			}
 		}
 
@@ -394,7 +_,7 @@
 
 		public int emoteTime;
 		public CreativeUnlocksTracker creativeTracker;
-		private static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
+		internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
 		public OverheadMessage chatOverhead;
 		public SelectionRadial DpadRadial = new SelectionRadial();
 		public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);
@@ -403,7 +_,7 @@
 		public int HotbarOffset;
 		public bool GoingDownWithGrapple;
 		public byte spelunkerTimer;
-		public bool[] hideInfo = new bool[13];
+		public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];
 		public int[] builderAccStatus = new int[12] {
 			1,
 			0,
@@ -438,7 +_,7 @@
 		public Vector2 lastDeathPostion;
 		public DateTime lastDeathTime;
 		public bool showLastDeath;
-		public int extraAccessorySlots = 2;
+		private int extraAccessorySlots; //unused vanilla field, noob trap
 		public bool extraAccessory;
 		private bool dontConsumeWand;
 		public int tankPet = -1;
@@ -694,7 +_,7 @@
 		public bool poundRelease;
 		public float ghostFade;
 		public float ghostDir = 1f;
-		public const int maxBuffs = 22;
+		public static int MaxBuffs => 22 + BuffLoader.extraPlayerBuffCount;
 		public int[] buffType = new int[22];
 		public int[] buffTime = new int[22];
 		public bool[] buffImmune = new bool[327];
@@ -1059,18 +_,21 @@
 		public bool parryDamageBuff;
 		public bool ballistaPanic;
 		public bool JustDroppedAnItem;
-		public int meleeCrit = 4;
-		public int magicCrit = 4;
-		public int rangedCrit = 4;
-		public float meleeDamage = 1f;
-		public float magicDamage = 1f;
-		public float rangedDamage = 1f;
-		public float bulletDamage = 1f;
-		public float arrowDamage = 1f;
-		public float rocketDamage = 1f;
-		public float minionDamage = 1f;
-		public float minionKB;
-		public float meleeSpeed = 1f;
+		internal ref int allCrit => ref GetCritChance(DamageClass.Generic);
+		internal ref int meleeCrit => ref GetCritChance(DamageClass.Melee);
+		internal ref int magicCrit => ref GetCritChance(DamageClass.Magic);
+		internal ref int rangedCrit => ref GetCritChance(DamageClass.Ranged);
+		internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic);
+		internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);
+		internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);
+		internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);
+		public StatModifier bulletDamage = StatModifier.One;
+		public StatModifier arrowDamage = StatModifier.One;
+		public StatModifier rocketDamage = StatModifier.One;
+		internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);
+		internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic);
+		public float minionKB = 0f;
+		public float meleeSpeed;
 		public float moveSpeed = 1f;
 		public float pickSpeed = 1f;
 		public float wallSpeed = 1f;
@@ -1105,12 +_,30 @@
 		public bool oldAdjWater;
 		public bool oldAdjHoney;
 		public bool oldAdjLava;
-		public bool[] adjTile = new bool[624];
-		public bool[] oldAdjTile = new bool[624];
+		private bool[] _adjTile = new bool[TileLoader.TileCount];
+		public bool[] adjTile {
+			get {
+				if (_adjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _adjTile, TileLoader.TileCount);
+
+				return _adjTile;
+			}
+			set { _adjTile = value; }
+		}
+		private bool[] _oldAdjTile = new bool[TileLoader.TileCount];
+		public bool[] oldAdjTile {
+			get {
+				if (_oldAdjTile.Length != TileLoader.TileCount)
+					Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
+
+				return _oldAdjTile;
+			}
+			set { _oldAdjTile = value; }
+		}
 		public static int defaultItemGrabRange = 42;
 		private static float itemGrabSpeed = 0.45f;
 		private static float itemGrabSpeedMax = 4f;
-		public byte hairDye;
+		public int hairDye; //TML: Changed from byte to int.
 		public Color hairDyeColor = Color.Transparent;
 		public float hairDyeVar;
 		public int skinDyePacked;
@@ -2034,6 +_,7 @@
 		public void SetTalkNPC(int npcIndex, bool fromNet = false) {
 			talkNPC = npcIndex;
 			if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
+				// Gut feeling there is a to do on the above conditional
 				Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
 
 			if (talkNPC == -1)
@@ -2050,12 +_,18 @@
 			itemTimeMax = frames;
 		}
 
-		public void ApplyItemTime(Item sItem) {
-			SetItemTime(sItem.useTime);
+		public void ApplyItemTime(Item sItem, bool? callUseItem = null) {
+			if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+				return;
+			
+			SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime, this, sItem));
 		}
 
-		public void ApplyItemTime(Item sItem, float multiplier) {
-			SetItemTime((int)((float)sItem.useTime * multiplier));
+		public void ApplyItemTime(Item sItem, float multiplier, bool? callUseItem = null) {
+			if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+				return;
+			
+			SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime * multiplier, this, sItem));
 		}
 
 		public void SetDummyItemTime(int frames) {
@@ -2064,39 +_,41 @@
 			itemTimeMax = frames + 1;
 		}
 
-		private void SetItemAnimation(int frames) {
+		public void SetItemAnimation(int frames) {
 			itemAnimation = frames;
 			itemAnimationMax = frames;
 		}
 
-		private void ApplyItemAnimation(Item sItem, float multiplier, int itemReuseDelay = 0) {
-			SetItemAnimation((int)((float)sItem.useAnimation * multiplier));
-			reuseDelay = itemReuseDelay;
+		public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null) {
+			ItemLoader.UseAnimation(sItem, this);
+
+			SetItemAnimation(CombinedHooks.TotalAnimationTime(sItem.useAnimation * multiplier, this, sItem));
+
+			reuseDelay = (int)((itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
 		}
 
-		private void ApplyItemAnimation(Item sItem) {
+		public void ApplyItemAnimation(Item sItem) {
 			if (sItem.melee) {
-				SetItemAnimation((int)((float)sItem.useAnimation * meleeSpeed));
+				ApplyItemAnimation(sItem, meleeSpeed);
 				return;
 			}
 
 			if (sItem.summon && ItemID.Sets.SummonerWeaponThatScalesWithAttackSpeed[sItem.type]) {
-				SetItemAnimation((int)((float)sItem.useAnimation * meleeSpeed * whipUseTimeMultiplier));
+				ApplyItemAnimation(sItem, meleeSpeed * whipUseTimeMultiplier);
 				return;
 			}
 
 			if (sItem.createTile >= 0) {
-				SetItemAnimation((int)((float)sItem.useAnimation * tileSpeed));
+				ApplyItemAnimation(sItem, tileSpeed);
 				return;
 			}
 
 			if (sItem.createWall >= 0) {
-				SetItemAnimation((int)((float)sItem.useAnimation * wallSpeed));
+				ApplyItemAnimation(sItem, wallSpeed);
 				return;
 			}
 
-			SetItemAnimation(sItem.useAnimation);
-			reuseDelay = sItem.reuseDelay;
+			ApplyItemAnimation(sItem, 1f);
 		}
 
 		public bool InOpposingTeam(Player otherPlayer) {
@@ -2409,6 +_,7 @@
 				Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
 				if (item.stack > 0) {
 					int num = Item.NewItem((int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+					Main.item[num] = item.Clone();
 					Main.item[num].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num, 1f);
@@ -2422,6 +_,7 @@
 				Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
 				if (item2.stack > 0) {
 					int num2 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+					Main.item[num2] = item2.Clone();
 					Main.item[num2].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num2, 1f);
@@ -2457,6 +_,7 @@
 				Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
 				if (item3.stack > 0) {
 					int num3 = Item.NewItem((int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+					Main.item[num3] = item3.Clone();
 					Main.item[num3].newAndShiny = false;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num3, 1f);
@@ -2550,11 +_,13 @@
 			}
 		}
 
+		public bool HasBuff(int type) => FindBuffIndex(type) != -1;
+
 		public int FindBuffIndex(int type) {
 			if (buffImmune[type])
 				return -1;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1 && buffType[i] == type)
 					return i;
 			}
@@ -2567,7 +_,7 @@
 				return;
 
 			if (BuffID.Sets.IsWellFed[type]) {
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (BuffID.Sets.IsWellFed[buffType[i]])
 						DelBuff(i);
 				}
@@ -2588,7 +_,7 @@
 			int num = -1;
 			while (num == -1) {
 				int num2 = -1;
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (!Main.debuff[buffType[i]]) {
 						num2 = i;
 						break;
@@ -2598,7 +_,7 @@
 				if (num2 == -1)
 					return false;
 
-				for (int j = num2; j < 22; j++) {
+				for (int j = num2; j < MaxBuffs; j++) {
 					if (buffType[j] == 0) {
 						num = j;
 						break;
@@ -2618,7 +_,7 @@
 			if (!Main.meleeBuff[type])
 				return;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type && Main.meleeBuff[buffType[i]]) {
 					DelBuff(i);
 					i--;
@@ -2628,7 +_,7 @@
 
 		private void AddBuff_RemoveOldPetBuffsOfMatchingType(int type) {
 			if (Main.lightPet[type]) {
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (Main.lightPet[buffType[i]])
 						DelBuff(i);
 				}
@@ -2637,7 +_,7 @@
 			if (!Main.vanityPet[type])
 				return;
 
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (Main.vanityPet[buffType[j]])
 					DelBuff(j);
 			}
@@ -2645,11 +_,13 @@
 
 		private bool AddBuff_TryUpdatingExistingBuffTime(int type, int time) {
 			bool result = false;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] != type)
 					continue;
 
+				if (BuffLoader.ReApply(type, this, time, i)) {
+				}
-				if (type == 94) {
+				else if (type == 94) {
 					buffTime[i] += time;
 					if (buffTime[i] > manaSickTimeMax)
 						buffTime[i] = manaSickTimeMax;
@@ -2667,7 +_,7 @@
 
 		private int AddBuff_DetermineBuffTimeToAdd(int type, int time1) {
 			int num = time1;
-			if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80)) {
+			if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80 || BuffLoader.LongerExpertDebuff(type))) {
 				float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
 				if (Main.GameModeInfo.IsJourneyMode) {
 					if (Main.masterMode)
@@ -2685,24 +_,28 @@
 		public void DelBuff(int b) {
 			buffTime[b] = 0;
 			buffType[b] = 0;
+			//single pass compactor (vanilla is n^2)
+			int packedIdx = 0;
-			for (int i = 0; i < 21; i++) {
+			for (int i = 0; i < MaxBuffs - 1; i++) {
-				if (buffTime[i] != 0 && buffType[i] != 0)
+				if (buffTime[i] == 0 || buffType[i] == 0)
 					continue;
 
-				for (int j = i + 1; j < 22; j++) {
-					if (buffTime[j] > 0 && buffType[j] > 0) {
-						buffTime[i] = buffTime[j];
-						buffType[i] = buffType[j];
-						buffTime[j] = 0;
-						buffType[j] = 0;
-						break;
-					}
+				if (packedIdx < i) {
+					buffTime[packedIdx] = buffTime[i];
+					buffType[packedIdx] = buffType[i];
+					buffTime[i] = 0;
+					buffType[i] = 0;
 				}
+
+				packedIdx++;
 			}
 		}
 
 		public void ClearBuff(int type) {
+			if (type == 0)
+				return;
+
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] == type)
 					DelBuff(i);
 			}
@@ -2710,7 +_,7 @@
 
 		public int CountBuffs() {
 			int num = 0;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[num] > 0)
 					num++;
 			}
@@ -2718,6 +_,20 @@
 			return num;
 		}
 
+		public int GetHealLife(Item item, bool quickHeal = false) {
+			int healValue = item.healLife;
+			ItemLoader.GetHealLife(item, this, quickHeal, ref healValue);
+			PlayerLoader.GetHealLife(this, item, quickHeal, ref healValue);
+			return healValue > 0 ? healValue : 0;
+		}
+
+		public int GetHealMana(Item item, bool quickHeal = false) {
+			int healValue = item.healMana;
+			ItemLoader.GetHealMana(item, this, quickHeal, ref healValue);
+			PlayerLoader.GetHealMana(this, item, quickHeal, ref healValue);
+			return healValue > 0 ? healValue : 0;
+		}
+
 		public void QuickHeal() {
 			if (cursed || CCed || dead || statLife == statLifeMax2 || potionDelay > 0)
 				return;
@@ -2742,24 +_,29 @@
 				}
 			}
 
+			ItemLoader.UseItem(item, this);
+			int healLife = GetHealLife(item, true);
+			int healMana = GetHealMana(item, true);
-			statLife += item.healLife;
+			statLife += healLife;
-			statMana += item.healMana;
+			statMana += healMana;
 			if (statLife > statLifeMax2)
 				statLife = statLifeMax2;
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
 
-			if (item.healLife > 0 && Main.myPlayer == whoAmI)
-				HealEffect(item.healLife);
+			if (healLife > 0 && Main.myPlayer == whoAmI)
+				HealEffect(healLife, true);
 
-			if (item.healMana > 0) {
+			if (healMana > 0) {
 				AddBuff(94, manaSickTime);
 				if (Main.myPlayer == whoAmI)
-					ManaEffect(item.healMana);
+					ManaEffect(healMana);
 			}
 
+			if (ItemLoader.ConsumeItem(item, this))
-			item.stack--;
+				item.stack--;
+
 			if (item.stack <= 0)
 				item.TurnToAir();
 
@@ -2773,9 +_,12 @@
 			for (int i = 0; i < 58; i++) {
 				Item item = inventory[i];
 				if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0)
+					continue;				
+				
+				if(!CombinedHooks.CanUseItem(this, item))
 					continue;
 
-				int num3 = item.healLife - num;
+				int num3 = GetHealLife(item, true) - num;
 				if (item.type == 227 && num3 < 0) {
 					num3 += 30;
 					if (num3 > 0)
@@ -2804,7 +_,7 @@
 			int num = 0;
 			while (true) {
 				if (num < 58) {
-					if (inventory[num].stack > 0 && inventory[num].type > 0 && inventory[num].healMana > 0 && (potionDelay == 0 || !inventory[num].potion))
+					if (inventory[num].stack > 0 && inventory[num].type > 0 && inventory[num].healMana > 0 && (potionDelay == 0 || !inventory[num].potion) && CombinedHooks.CanUseItem(this, inventory[num]))
 						break;
 
 					num++;
@@ -2830,24 +_,29 @@
 				}
 			}
 
-			statLife += inventory[num].healLife;
-			statMana += inventory[num].healMana;
+			ItemLoader.UseItem(inventory[num], this);
+			int healLife = GetHealLife(inventory[num], true);
+			int healMana = GetHealMana(inventory[num], true);
+			statLife += healLife;
+			statMana += healMana;
 			if (statLife > statLifeMax2)
 				statLife = statLifeMax2;
 
 			if (statMana > statManaMax2)
 				statMana = statManaMax2;
 
-			if (inventory[num].healLife > 0 && Main.myPlayer == whoAmI)
-				HealEffect(inventory[num].healLife);
+			if (healLife > 0 && Main.myPlayer == whoAmI)
+				HealEffect(healLife, true);
 
-			if (inventory[num].healMana > 0) {
+			if (healMana > 0) {
 				AddBuff(94, manaSickTime);
 				if (Main.myPlayer == whoAmI)
-					ManaEffect(inventory[num].healMana);
+					ManaEffect(healMana);
 			}
 
+			if (ItemLoader.ConsumeItem(inventory[num], this))
-			inventory[num].stack--;
+				inventory[num].stack--;
+
 			if (inventory[num].stack <= 0)
 				inventory[num].TurnToAir();
 
@@ -2856,7 +_,7 @@
 
 		public Item QuickMana_GetItemToUse() {
 			for (int i = 0; i < 58; i++) {
-				if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion))
+				if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion) && CombinedHooks.CanUseItem(this, inventory[i]))
 					return inventory[i];
 			}
 
@@ -2867,8 +_,8 @@
 			if (cursed || CCed || dead)
 				return;
 
-			LegacySoundStyle legacySoundStyle = null;
+			SoundStyle legacySoundStyle = null;
-			if (CountBuffs() == 22)
+			if (CountBuffs() == MaxBuffs)
 				return;
 
 			Item item = QuickBuff_PickBestFoodItem();
@@ -2879,22 +_,26 @@
 					num = 3600;
 
 				AddBuff(item.buffType, num);
-				if (item.consumable) {
+				if (item.consumable && ItemLoader.ConsumeItem(item, this)) {
 					item.stack--;
 					if (item.stack <= 0)
 						item.TurnToAir();
 				}
 			}
 
-			if (CountBuffs() != 22) {
+			if (CountBuffs() != MaxBuffs) {
 				for (int i = 0; i < 58; i++) {
 					Item item2 = inventory[i];
 					if (item2.stack <= 0 || item2.type <= 0 || item2.buffType <= 0 || item2.summon)
 						continue;
 
 					int num2 = item2.buffType;
-					bool flag = QuickBuff_ShouldBotherUsingThisBuff(num2);
+					bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num2);
 					if (item2.mana > 0 && flag) {
+						if (CheckMana(item2, -1, true, true))
+							manaRegenDelay = (int)maxRegenDelay;
+
+						goto SkipManaCode;
 						if (statMana >= (int)((float)item2.mana * manaCost)) {
 							manaRegenDelay = (int)maxRegenDelay;
 							statMana -= (int)((float)item2.mana * manaCost);
@@ -2904,6 +_,7 @@
 						}
 					}
 
+					SkipManaCode:
 					if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
 						flag = false;
 
@@ -2922,19 +_,21 @@
 					if (!flag)
 						continue;
 
+					ItemLoader.UseItem(item2, this);
 					legacySoundStyle = item2.UseSound;
 					int num3 = item2.buffTime;
 					if (num3 == 0)
 						num3 = 3600;
 
 					AddBuff(num2, num3);
-					if (item2.consumable) {
+					if (item2.consumable && ItemLoader.ConsumeItem(item2, this)) {
 						item2.stack--;
+
 						if (item2.stack <= 0)
 							item2.TurnToAir();
 					}
 
-					if (CountBuffs() == 22)
+					if (CountBuffs() == MaxBuffs)
 						break;
 				}
 			}
@@ -2948,7 +_,7 @@
 		private Item QuickBuff_PickBestFoodItem() {
 			int num = 0;
 			Item item = null;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] >= 1) {
 					int num2 = QuickBuff_FindFoodPriority(buffType[i]);
 					if (num <= num2)
@@ -2985,7 +_,7 @@
 
 		private bool QuickBuff_ShouldBotherUsingThisBuff(int attemptedType) {
 			bool result = true;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (attemptedType == 27 && (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102)) {
 					result = false;
 					break;
@@ -3008,7 +_,7 @@
 			}
 
 			if (Main.lightPet[attemptedType] || Main.vanityPet[attemptedType]) {
-				for (int j = 0; j < 22; j++) {
+				for (int j = 0; j < MaxBuffs; j++) {
 					if (Main.lightPet[buffType[j]] && Main.lightPet[attemptedType])
 						result = false;
 
@@ -3032,6 +_,7 @@
 				if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this)) {
 					if (!QuickMinecartSnap()) {
 						mount.SetMount(item.mountType, this);
+						ItemLoader.UseItem(item, this);
 						if (item.UseSound != null)
 							SoundEngine.PlaySound(item.UseSound, base.Center);
 					}
@@ -3103,12 +_,12 @@
 
 		public Item QuickMount_GetItemToUse() {
 			Item item = null;
-			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
+			if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType] && CombinedHooks.CanUseItem(this, miscEquips[3]))
 				item = miscEquips[3];
 
 			if (item == null) {
 				for (int i = 0; i < 58; i++) {
-					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType]) {
+					if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType] && CombinedHooks.CanUseItem(this, inventory[i])) {
 						item = inventory[i];
 						break;
 					}
@@ -3168,7 +_,12 @@
 			if (item == null)
 				return;
 
+			bool? modCanGrapple = ProjectileLoader.CanUseGrapple(item.shoot, this);
+			if (modCanGrapple.HasValue) {
+				if (!modCanGrapple.Value)
+					item = null;
+			}
-			if (item.shoot == 73) {
+			else if (item.shoot == 73) {
 				int num2 = 0;
 				for (int i = 0; i < 1000; i++) {
 					if (Main.projectile[i].active && Main.projectile[i].owner == Main.myPlayer && (Main.projectile[i].type == 73 || Main.projectile[i].type == 74))
@@ -3243,11 +_,21 @@
 			float shootSpeed = item.shootSpeed;
 			int damage = item.damage;
 			float knockBack = item.knockBack;
+			bool? modSingleHook = ProjectileLoader.SingleGrappleHook(num7, this);
+			bool modSingleHookFalse = modSingleHook.HasValue ? !modSingleHook.Value : false;
+			bool modSingleHookTrue = modSingleHook.HasValue ? modSingleHook.Value : false;
-			if (num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935) {
+			if ((num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935 || modSingleHookTrue) && !modSingleHookFalse) {
 				grappling[0] = -1;
 				grapCount = 0;
 				for (int num8 = 0; num8 < 1000; num8++) {
 					if (Main.projectile[num8].active && Main.projectile[num8].owner == whoAmI) {
+						bool? modSingleHook2 = ProjectileLoader.SingleGrappleHook(Main.projectile[num8].type, this);
+						if(modSingleHook2.HasValue) {
+							if (modSingleHook2.Value)
+								Main.projectile[num8].Kill();
+							continue;
+						}
+
 						switch (Main.projectile[num8].type) {
 							case 13:
 							case 230:
@@ -3339,6 +_,8 @@
 				}
 			}
 
+			ProjectileLoader.UseGrapple(this, ref num7);
+
 			Vector2 vector = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 			float num21 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
 			float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
@@ -3691,7 +_,7 @@
 			}
 
 			if (!crystalLeaf || petalTimer != 0)
-				return;
+				goto End;
 
 			_ = inventory[selectedItem].type;
 			int num5 = 0;
@@ -3704,7 +_,7 @@
 					continue;
 				}
 
-				return;
+				goto End;
 			}
 
 			petalTimer = 50;
@@ -3716,9 +_,17 @@
 			num6 *= num8;
 			num7 *= num8;
 			Projectile.NewProjectile(GetProjectileSource_SetBonus(6), Main.projectile[num5].Center.X - 4f, Main.projectile[num5].Center.Y, num6, num7, 227, crystalLeafDamage, crystalLeafKB, whoAmI);
+
+			End:
+
+			PlayerLoader.OnHitAnything(this, x, y, victim);
 		}
 
 		public void openPresent() {
+			if (!ItemLoader.PreOpenVanillaBag("present", this, 0))
+				return;
+
+			ItemLoader.OpenVanillaBag("present", this, 0);
 			if (Main.rand.Next(15) == 0 && Main.hardMode) {
 				int number = Item.NewItem((int)position.X, (int)position.Y, width, height, 602);
 				if (Main.netMode == 1)
@@ -3942,7 +_,31 @@
 						break;
 					}
 			}
+			NPCLoader.blockLoot.Clear(); // clear blockloot
+			// TODO: return statements above probably break this.
 		}
+
+		/// <summary>
+		/// Will spawn an item like QuickSpawnItem, but clones it (handy when you need to retain item infos)
+		/// </summary>
+		/// <param name="item">The item you want to be cloned</param>
+		/// <param name="stack">The stack to give the item. Note that this will override maxStack if it's higher.</param>
+		public void QuickSpawnClonedItem(Item item, int stack = 1) {
+			int index = Item.NewItem((int)position.X, (int)position.Y, width, height, item.type, stack, false, -1, false, false);
+			Main.item[index] = item.Clone();
+			Main.item[index].whoAmI = index;
+			Main.item[index].position = position;
+			if (stack != Main.item[index].stack)
+				Main.item[index].stack = stack;
+
+			// Sync the item for mp
+			if (Main.netMode == NetmodeID.MultiplayerClient)
+				NetMessage.SendData(MessageID.SyncItem, -1, -1, null, index, 1f, 0f, 0f, 0, 0, 0);
+		}
+
+		public void QuickSpawnItem(Item item, int stack = 1) {
+			QuickSpawnItem(item.type, stack);
+ 		}
 
 		public void QuickSpawnItem(int item, int stack = 1) {
 			int number = Item.NewItem((int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
@@ -3951,6 +_,10 @@
 		}
 
 		public void OpenBossBag(int type) {
+			if (!ItemLoader.PreOpenVanillaBag("bossBag", this, type))
+				return;
+
+			ItemLoader.OpenVanillaBag("bossBag", this, type);
 			switch (type) {
 				case 3318: {
 						if (Main.tenthAnniversaryWorld)
@@ -4411,8 +_,11 @@
 			if (type == 4957)
 				num11 = 657;
 
+			ItemLoader.OpenBossBag(type, this, ref num11);
-			if (num11 <= 0)
+			if (num11 <= 0) {
+				NPCLoader.blockLoot.Clear(); // clear blockloot
 				return;
+			}
 
 			NPC nPC = new NPC();
 			nPC.SetDefaults(num11);
@@ -4459,9 +_,12 @@
 				value -= (float)num15;
 				QuickSpawnItem(71, num15);
 			}
+			NPCLoader.blockLoot.Clear(); // clear blockloot
 		}
 
-		private void TryGettingDevArmor() {
+		public void TryGettingDevArmor() {
+			ModLoader.Default.ModLoaderMod.TryGettingPatreonOrDevArmor(this);
+
 			if (Main.rand.Next(Main.tenthAnniversaryWorld ? 10 : 20) == 0) {
 				switch (Main.rand.Next(18)) {
 					case 0:
@@ -4582,6 +_,10 @@
 		}
 
 		public void OpenFishingCrate(int crateItemID) {
+			if (!ItemLoader.PreOpenVanillaBag("crate", this, crateItemID))
+				return;
+
+			ItemLoader.OpenVanillaBag("crate", this, crateItemID);
 			bool flag = ItemID.Sets.IsFishingCrateHardmode[crateItemID];
 			switch (crateItemID) {
 				case 2334:
@@ -5870,6 +_,8 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number66, 1f);
 			}
+
+			NPCLoader.blockLoot.Clear(); // clear blockloot
 		}
 
 		public int CountItem(int type, int stopCountingAt = 0) {
@@ -5897,7 +_,9 @@
 
 			for (int i = num; i != num2; i += num3) {
 				if (inventory[i].stack > 0 && inventory[i].type == type) {
+					if (ItemLoader.ConsumeItem(inventory[i], this))
-					inventory[i].stack--;
+						inventory[i].stack--;
+
 					if (inventory[i].stack <= 0)
 						inventory[i].SetDefaults();
 
@@ -5941,6 +_,10 @@
 		}
 
 		public void OpenLockBox() {
+			if (!ItemLoader.PreOpenVanillaBag("lockBox", this, 0))
+				return;
+
+			ItemLoader.OpenVanillaBag("lockBox", this, 0);
 			bool flag = true;
 			while (flag) {
 				flag = false;
@@ -5979,9 +_,15 @@
 						NetMessage.SendData(21, -1, -1, null, number2, 1f);
 				}
 			}
+
+			NPCLoader.blockLoot.Clear(); // clear blockloot
 		}
 
 		public void OpenHerbBag() {
+			if (!ItemLoader.PreOpenVanillaBag("herbBag", this, 0))
+				return;
+
+			ItemLoader.OpenVanillaBag("herbBag", this, 0);
 			int num = Main.rand.Next(2, 5);
 			if (Main.rand.Next(3) == 0)
 				num++;
@@ -6038,6 +_,7 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
+			NPCLoader.blockLoot.Clear(); // clear blockloot
 		}
 
 		public void OpenCanofWorms() {
@@ -6071,6 +_,10 @@
 		}
 
 		public void OpenGoodieBag() {
+			if (!ItemLoader.PreOpenVanillaBag("goodieBag", this, 0))
+				return;
+
+			ItemLoader.OpenVanillaBag("goodieBag", this, 0);
 			if (Main.rand.Next(150) == 0) {
 				int number = Item.NewItem((int)position.X, (int)position.Y, width, height, 1810);
 				if (Main.netMode == 1)
@@ -6358,6 +_,7 @@
 						break;
 					}
 			}
+			NPCLoader.blockLoot.Clear(); // clear blockloot
 		}
 
 		public void UpdateDyes() {
@@ -6398,13 +_,13 @@
 			if (!num && flag)
 				return;
 
-			if (armorItem.handOnSlot > 0 && armorItem.handOnSlot < 23)
+			if (armorItem.handOnSlot > 0)
 				cHandOn = dyeItem.dye;
 
-			if (armorItem.handOffSlot > 0 && armorItem.handOffSlot < 15)
+			if (armorItem.handOffSlot > 0)
 				cHandOff = dyeItem.dye;
 
-			if (armorItem.backSlot > 0 && armorItem.backSlot < 35) {
+			if (armorItem.backSlot > 0) {
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
 					cBackpack = dyeItem.dye;
 				else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
@@ -6413,22 +_,22 @@
 					cBack = dyeItem.dye;
 			}
 
-			if (armorItem.frontSlot > 0 && armorItem.frontSlot < 12)
+			if (armorItem.frontSlot > 0)
 				cFront = dyeItem.dye;
 
-			if (armorItem.shoeSlot > 0 && armorItem.shoeSlot < 27)
+			if (armorItem.shoeSlot > 0)
 				cShoe = dyeItem.dye;
 
-			if (armorItem.waistSlot > 0 && armorItem.waistSlot < 17)
+			if (armorItem.waistSlot > 0)
 				cWaist = dyeItem.dye;
 
-			if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < 10)
+			if (armorItem.shieldSlot > 0)
 				cShield = dyeItem.dye;
 
-			if (armorItem.neckSlot > 0 && armorItem.neckSlot < 11)
+			if (armorItem.neckSlot > 0)
 				cNeck = dyeItem.dye;
 
-			if (armorItem.faceSlot > 0 && armorItem.faceSlot < 19) {
+			if (armorItem.faceSlot > 0) {
 				if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
 					cFaceHead = dyeItem.dye;
 				else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
@@ -6437,14 +_,14 @@
 					cFace = dyeItem.dye;
 			}
 
-			if (armorItem.balloonSlot > 0 && armorItem.balloonSlot < 19) {
+			if (armorItem.balloonSlot > 0) {
 				if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
 					cBalloonFront = dyeItem.dye;
 				else
 					cBalloon = dyeItem.dye;
 			}
 
-			if (armorItem.wingSlot > 0 && armorItem.wingSlot < 47)
+			if (armorItem.wingSlot > 0)
 				cWings = dyeItem.dye;
 
 			if (armorItem.type == 934)
@@ -6501,13 +_,14 @@
 			if (soulDrain > 0 && whoAmI == Main.myPlayer)
 				AddBuff(151, 2);
 
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				if (buffType[j] <= 0 || buffTime[j] <= 0)
 					continue;
 
 				if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
 					buffTime[j]--;
 
+				int originalIndex = j;
 				if (buffType[j] == 1) {
 					lavaImmune = true;
 					fireWalk = true;
@@ -6530,9 +_,12 @@
 				}
 				else if (buffType[j] == 321) {
 					int num = 10;
+					allCrit += num;
+					/*
 					meleeCrit += num;
 					rangedCrit += num;
 					magicCrit += num;
+					*/
 					minionDamage += (float)num / 100f;
 				}
 				else if (buffType[j] == 2) {
@@ -6580,6 +_,7 @@
 				}
 				else if (buffType[j] == 16) {
 					archery = true;
+					arrowDamage *= 1.2f; // moved from PickAmmo, as StatModifier allows multiplicative buffs to be 'registered' before additive ones
 				}
 				else if (buffType[j] == 17) {
 					detectCreature = true;
@@ -6704,9 +_,12 @@
 					endurance += 0.1f;
 				}
 				else if (buffType[j] == 115) {
+					allCrit += 10;
+					/*
 					meleeCrit += 10;
 					rangedCrit += 10;
 					magicCrit += 10;
+					*/
 				}
 				else if (buffType[j] == 116) {
 					inferno = true;
@@ -6750,10 +_,13 @@
 					}
 				}
 				else if (buffType[j] == 117) {
+					allDamage += 0.1f;
+					/*
 					meleeDamage += 0.1f;
 					rangedDamage += 0.1f;
 					magicDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 				}
 				else if (buffType[j] == 119) {
 					loveStruck = true;
@@ -6798,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int m = 0; m < 22; m++) {
+							for (int m = 0; m < MaxBuffs; m++) {
 								if (buffType[m] >= 95 && buffType[m] <= 95 + num4 - 1) {
 									DelBuff(m);
 									m--;
@@ -6826,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int n = 0; n < 22; n++) {
+							for (int n = 0; n < MaxBuffs; n++) {
 								if (buffType[n] >= 170 && buffType[n] <= 170 + num5 - 1) {
 									DelBuff(n);
 									n--;
@@ -6850,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num7 = 0; num7 < 22; num7++) {
+							for (int num7 = 0; num7 < MaxBuffs; num7++) {
 								if (buffType[num7] >= 98 && buffType[num7] <= 98 + num6 - 1) {
 									DelBuff(num7);
 									num7--;
@@ -6880,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num10 = 0; num10 < 22; num10++) {
+							for (int num10 = 0; num10 < MaxBuffs; num10++) {
 								if (buffType[num10] >= 176 && buffType[num10] <= 178 + num9 - 1) {
 									DelBuff(num10);
 									num10--;
@@ -6905,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num13 = 0; num13 < 22; num13++) {
+							for (int num13 = 0; num13 < MaxBuffs; num13++) {
 								if (buffType[num13] >= 173 && buffType[num13] <= 175 + num12 - 1) {
 									DelBuff(num13);
 									num13--;
@@ -6932,7 +_,7 @@
 							j--;
 						}
 						else {
-							for (int num16 = 0; num16 < 22; num16++) {
+							for (int num16 = 0; num16 < MaxBuffs; num16++) {
 								if (buffType[num16] >= 179 && buffType[num16] <= 181 + num15 - 1) {
 									DelBuff(num16);
 									num16--;
@@ -6949,10 +_,13 @@
 					}
 
 					float num17 = 0.15f * (float)nebulaLevelDamage;
+					allDamage += num17;
+					/*
 					meleeDamage += num17;
 					rangedDamage += num17;
 					magicDamage += num17;
 					minionDamage += num17;
+					*/
 				}
 				else if (buffType[j] == 62) {
 					if ((double)statLife <= (double)statLifeMax2 * 0.5) {
@@ -7583,10 +_,13 @@
 						}
 					}
 
+					allDamage += 0.2f;
+					/*
 					meleeDamage += 0.2f;
 					magicDamage += 0.2f;
 					rangedDamage += 0.2f;
 					minionDamage += 0.2f;
+					*/
 				}
 				else if (buffType[j] == 41) {
 					buffTime[j] = 18000;
@@ -7972,14 +_,20 @@
 				else if (buffType[j] == 26) {
 					wellFed = true;
 					statDefense += 2;
+					allCrit += 2;
+					allDamage += 0.05f;
+					/*
 					meleeCrit += 2;
 					meleeDamage += 0.05f;
+					*/
 					meleeSpeed += 0.05f;
+					/*
 					magicCrit += 2;
 					magicDamage += 0.05f;
 					rangedCrit += 2;
 					rangedDamage += 0.05f;
 					minionDamage += 0.05f;
+					*/
 					minionKB += 0.5f;
 					moveSpeed += 0.2f;
 					pickSpeed -= 0.05f;
@@ -7987,14 +_,20 @@
 				else if (buffType[j] == 206) {
 					wellFed = true;
 					statDefense += 3;
+					allCrit += 3;
+					allDamage += 0.075f;
+					/*
 					meleeCrit += 3;
 					meleeDamage += 0.075f;
+					*/
 					meleeSpeed += 0.075f;
+					/*
 					magicCrit += 3;
 					magicDamage += 0.075f;
 					rangedCrit += 3;
 					rangedDamage += 0.075f;
 					minionDamage += 0.075f;
+					*/
 					minionKB += 0.75f;
 					moveSpeed += 0.3f;
 					pickSpeed -= 0.1f;
@@ -8002,14 +_,18 @@
 				else if (buffType[j] == 207) {
 					wellFed = true;
 					statDefense += 4;
+					//meleeCrit += 4;
-					meleeCrit += 4;
+					allCrit += 4;
-					meleeDamage += 0.1f;
+					allDamage += 0.1f;
+					//meleeDamage += 0.1f;
 					meleeSpeed += 0.1f;
+					/*
 					magicCrit += 4;
 					magicDamage += 0.1f;
 					rangedCrit += 4;
 					rangedDamage += 0.1f;
 					minionDamage += 0.1f;
+					*/
 					minionKB += 1f;
 					moveSpeed += 0.4f;
 					pickSpeed -= 0.15f;
@@ -8038,6 +_,8 @@
 				else if (buffType[j] == 79) {
 					meleeEnchant = 8;
 				}
+				if (j == originalIndex)
+					BuffLoader.Update(buffType[j], this, ref j);
 			}
 
 			if (whoAmI == Main.myPlayer && luckPotion != oldLuckPotion) {
@@ -8308,12 +_,19 @@
 			}
 		}
 
-		public void UpdateEquips(int i) {
+		//public void UpdateEquips(int i) {
+		public void VanillaPreUpdateInventory() {
 			if (inventory[selectedItem].type == 277 && (!mount.Active || !mount.Cart))
 				trident = true;
+		}
 
+		public void VanillaUpdateInventory(Item item) {
+			/*
 			for (int j = 0; j < 58; j++) {
 				int type = inventory[j].type;
+			*/
+			{
+				int type = item.type;
 				if ((type == 15 || type == 707) && accWatch < 1)
 					accWatch = 1;
 
@@ -8385,13 +_,21 @@
 
 				if (type == 4743)
 					hasFootball = true;
+
+				ItemLoader.UpdateInventory(item, this);
 			}
 
+		}
+
+		public void VanillaPostUpdateInventory() {
 			if (inventory[58].type == 4743)
 				hasFootball = true;
+		}
 
+		public void VanillaUpdateEquip(Item item) {
+			Item[] armor = {item};
-			for (int k = 0; k < 10; k++) {
+			for (int k = 0; k < 1; k++) {
-				if (!IsAValidEquipmentSlotForIteration(k) || (armor[k].expertOnly && !Main.expertMode))
+				if ((armor[k].expertOnly && !Main.expertMode) || (armor[k].masterOnly && !Main.masterMode))
 					continue;
 
 				int type2 = armor[k].type;
@@ -8613,6 +_,9 @@
 					armorPenetration += 5;
 
 				if (armor[k].type == 2277) {
+					allDamage += 0.05f;
+					allCrit += 5;
+					/*
 					magicDamage += 0.05f;
 					meleeDamage += 0.05f;
 					rangedDamage += 0.05f;
@@ -8620,6 +_,7 @@
 					magicCrit += 5;
 					rangedCrit += 5;
 					meleeCrit += 5;
+					*/
 					meleeSpeed += 0.1f;
 					moveSpeed += 0.1f;
 				}
@@ -8634,9 +_,12 @@
 					nightVision = true;
 
 				if (armor[k].type == 256 || armor[k].type == 257 || armor[k].type == 258) {
+					allCrit += 3;
+					/*
 					rangedCrit += 3;
 					meleeCrit += 3;
 					magicCrit += 3;
+					*/
 				}
 
 				if (armor[k].type == 3374)
@@ -8681,10 +_,13 @@
 					meleeSpeed += 0.07f;
 
 				if (armor[k].type == 792 || armor[k].type == 793 || armor[k].type == 794) {
+					allDamage += 0.02f;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
+					*/
 				}
 
 				if (armor[k].type == 231)
@@ -8713,16 +_,22 @@
 				}
 
 				if (armor[k].type == 374) {
+					allCrit += 5;
+					/*
 					magicCrit += 5;
 					meleeCrit += 5;
 					rangedCrit += 5;
+					*/
 				}
 
 				if (armor[k].type == 375) {
+					allDamage += 0.03f;
+					/*
 					rangedDamage += 0.03f;
 					meleeDamage += 0.03f;
 					magicDamage += 0.03f;
 					minionDamage += 0.03f;
+					*/
 					moveSpeed += 0.1f;
 				}
 
@@ -8742,16 +_,22 @@
 				}
 
 				if (armor[k].type == 379) {
+					allDamage += 0.07f;
+					/*
 					rangedDamage += 0.07f;
 					meleeDamage += 0.07f;
 					magicDamage += 0.07f;
 					minionDamage += 0.07f;
+					*/
 				}
 
 				if (armor[k].type == 380) {
+					allCrit += 10;
+					/*
 					magicCrit += 10;
 					meleeCrit += 10;
 					rangedCrit += 10;
+					*/
 				}
 
 				if (armor[k].type >= 2367 && armor[k].type <= 2369)
@@ -8774,16 +_,22 @@
 				}
 
 				if (armor[k].type == 403) {
+					allDamage += 0.08f;
+					/*
 					rangedDamage += 0.08f;
 					meleeDamage += 0.08f;
 					magicDamage += 0.08f;
 					minionDamage += 0.08f;
+					*/
 				}
 
 				if (armor[k].type == 404) {
+					allCrit += 7;
+					/*
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 					moveSpeed += 0.05f;
 				}
 
@@ -8804,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1208) {
+					allDamage += 0.03f;
+					allCrit += 2;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
@@ -8811,16 +_,21 @@
 					magicCrit += 2;
 					meleeCrit += 2;
 					rangedCrit += 2;
+					*/
 				}
 
 				if (armor[k].type == 1209) {
+					allDamage += 0.02f;
+					allCrit += 1;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
-					magicCrit++;
-					meleeCrit++;
-					rangedCrit++;
+					magicCrit += 1;
+					meleeCrit += 1;
+					rangedCrit += 1;
+					*/
 				}
 
 				if (armor[k].type == 1210) {
@@ -8840,9 +_,12 @@
 				}
 
 				if (armor[k].type == 1213) {
+					allCrit += 6;
+					/*
 					magicCrit += 6;
 					meleeCrit += 6;
 					rangedCrit += 6;
+					*/
 				}
 
 				if (armor[k].type == 1214)
@@ -8866,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1218) {
+					allDamage += 0.04f;
+					allCrit += 3;
+					/*
 					meleeDamage += 0.04f;
 					rangedDamage += 0.04f;
 					magicDamage += 0.04f;
@@ -8873,9 +_,13 @@
 					magicCrit += 3;
 					meleeCrit += 3;
 					rangedCrit += 3;
+					*/
 				}
 
 				if (armor[k].type == 1219) {
+					allDamage += 0.03f;
+					allCrit += 3;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
@@ -8883,6 +_,7 @@
 					magicCrit += 3;
 					meleeCrit += 3;
 					rangedCrit += 3;
+					*/
 					moveSpeed += 0.06f;
 				}
 
@@ -8909,31 +_,43 @@
 				}
 
 				if (armor[k].type == 551 || armor[k].type == 4900) {
+					allCrit += 7;
+					/*
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 				}
 
 				if (armor[k].type == 552 || armor[k].type == 4901) {
+					allDamage += 0.07f;
+					/*
 					rangedDamage += 0.07f;
 					meleeDamage += 0.07f;
 					magicDamage += 0.07f;
 					minionDamage += 0.07f;
+					*/
 					moveSpeed += 0.08f;
 				}
 
 				if (armor[k].type == 4982) {
+					allCrit += 5;
+					/*
 					rangedCrit += 5;
 					meleeCrit += 5;
 					magicCrit += 5;
+					*/
 					manaCost -= 0.1f;
 				}
 
 				if (armor[k].type == 4983) {
+					allDamage += 0.05f;
+					/*
 					rangedDamage += 0.05f;
 					meleeDamage += 0.05f;
 					magicDamage += 0.05f;
 					minionDamage += 0.05f;
+					*/
 					huntressAmmoCost90 = true;
 				}
 
@@ -8959,6 +_,9 @@
 				}
 
 				if (armor[k].type == 1004) {
+					allDamage += 0.05f;
+					allCrit += 7;
+					/*
 					meleeDamage += 0.05f;
 					magicDamage += 0.05f;
 					rangedDamage += 0.05f;
@@ -8966,12 +_,16 @@
 					magicCrit += 7;
 					meleeCrit += 7;
 					rangedCrit += 7;
+					*/
 				}
 
 				if (armor[k].type == 1005) {
+					allCrit += 8;
+					/*
 					magicCrit += 8;
 					meleeCrit += 8;
 					rangedCrit += 8;
+					*/
 					moveSpeed += 0.05f;
 				}
 
@@ -9239,43 +_,61 @@
 					statManaMax2 += 20;
 
 				if (armor[k].prefix == 67) {
+					allCrit += 2;
+					/*
 					meleeCrit += 2;
 					rangedCrit += 2;
 					magicCrit += 2;
+					*/
 				}
 
 				if (armor[k].prefix == 68) {
+					allCrit += 4;
+					/*
 					meleeCrit += 4;
 					rangedCrit += 4;
 					magicCrit += 4;
+					*/
 				}
 
 				if (armor[k].prefix == 69) {
+					allDamage += 0.01f;
+					/*
 					meleeDamage += 0.01f;
 					rangedDamage += 0.01f;
 					magicDamage += 0.01f;
 					minionDamage += 0.01f;
+					*/
 				}
 
 				if (armor[k].prefix == 70) {
+					allDamage += 0.02f;
+					/*
 					meleeDamage += 0.02f;
 					rangedDamage += 0.02f;
 					magicDamage += 0.02f;
 					minionDamage += 0.02f;
+					*/
 				}
 
 				if (armor[k].prefix == 71) {
+					allDamage += 0.03f;
+					/*
 					meleeDamage += 0.03f;
 					rangedDamage += 0.03f;
 					magicDamage += 0.03f;
 					minionDamage += 0.03f;
+					*/
 				}
 
 				if (armor[k].prefix == 72) {
+					allDamage += 0.04f;
+					/*
 					meleeDamage += 0.04f;
 					rangedDamage += 0.04f;
 					magicDamage += 0.04f;
 					minionDamage += 0.04f;
+					*/
 				}
 
 				if (armor[k].prefix == 73)
@@ -9301,6 +_,22 @@
 
 				if (armor[k].prefix == 80)
 					meleeSpeed += 0.04f;
+
+				ItemLoader.UpdateEquip(armor[k], this);
+			}
+		}
+
+		public void UpdateEquips(int i)
+		{
+			VanillaPreUpdateInventory();
+			for (int j = 0; j < 58; j++) {
+				VanillaUpdateInventory(inventory[j]);
+			}
+			VanillaPostUpdateInventory();
+
+			for (int k = 0; k < 10; k++) {
+				if (IsAValidEquipmentSlotForIteration(k))
+					VanillaUpdateEquip(armor[k]);
 			}
 
 			equippedAnyWallSpeedAcc = false;
@@ -9311,21 +_,30 @@
 
 			for (int l = 3; l < 10; l++) {
 				if (IsAValidEquipmentSlotForIteration(l))
-					ApplyEquipFunctional(l, armor[l]);
+					ApplyEquipFunctional(armor[l], hideVisibleAccessory[l]);
 			}
 
+			PlayerLoader.UpdateEquips(this);
+
+			if (kbGlove)
+				GetKnockback(DamageClass.Melee) *= 2f;
+			
 			if (skyStoneEffects) {
 				lifeRegen += 2;
 				statDefense += 4;
 				meleeSpeed += 0.1f;
+				allDamage += 0.1f;
+				allCrit += 2;
+				/*
 				meleeDamage += 0.1f;
 				meleeCrit += 2;
 				rangedDamage += 0.1f;
 				rangedCrit += 2;
 				magicDamage += 0.1f;
 				magicCrit += 2;
+				*/
 				pickSpeed -= 0.15f;
-				minionDamage += 0.1f;
+				//minionDamage += 0.1f;
 				minionKB += 0.5f;
 			}
 
@@ -9334,6 +_,7 @@
 				maxTurrets++;
 			}
 
+			/* wing loop is merged into ApplyEquipFunctional
 			for (int m = 3; m < 10; m++) {
 				if (armor[m].wingSlot > 0 && IsAValidEquipmentSlotForIteration(m)) {
 					if (!hideVisibleAccessory[m] || (velocity.Y != 0f && !mount.Active))
@@ -9342,12 +_,15 @@
 					wingsLogic = armor[m].wingSlot;
 				}
 			}
+			*/
 
 			for (int n = 13; n < 20; n++) {
 				if (IsAValidEquipmentSlotForIteration(n))
 					ApplyEquipVanity(n, armor[n]);
 			}
 
+			PlayerLoader.UpdateVanityAccessories(this);
+
 			if (wet && ShouldFloatInWater)
 				accFlipper = true;
 
@@ -9519,6 +_,10 @@
 		}
 
 		private void ApplyEquipVanity(int itemSlot, Item currentItem) {
+			ApplyEquipVanity(currentItem); //remove itemSlot parameter and make public so mods can call from their own accessory slots
+		}
+
+		public void ApplyEquipVanity(Item currentItem) {
 			int type = currentItem.type;
 			if (currentItem.wingSlot > 0)
 				wings = currentItem.wingSlot;
@@ -9540,6 +_,8 @@
 				ApplyMusicBox(currentItem);
 
 			UpdateBootVisualEffects(currentItem);
+
+			ItemLoader.UpdateVanity(currentItem, this);
 		}
 
 		private WingStats GetWingStats(int wingID) {
@@ -9549,8 +_,12 @@
 			return ArmorIDs.Wing.Sets.Stats[wingID];
 		}
 
-		private void ApplyEquipFunctional(int itemSlot, Item currentItem) {
-			if (currentItem.expertOnly && !Main.expertMode)
+		// made public and itemSlot parameter removed, so mods can call this method from their own accessory slots
+		public void ApplyEquipFunctional(Item currentItem, bool hideVisual) {
+			int itemSlot = 0;
+			bool[] hideVisibleAccessory = { hideVisual };
+
+			if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
 				return;
 
 			if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
@@ -9669,6 +_,9 @@
 
 			if (currentItem.type == 3015) {
 				aggro -= 400;
+				allDamage += 0.05f;
+				allCrit += 5;
+				/*
 				meleeCrit += 5;
 				magicCrit += 5;
 				rangedCrit += 5;
@@ -9676,6 +_,7 @@
 				magicDamage += 0.05f;
 				rangedDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 			}
 
 			if (currentItem.type == 3016)
@@ -9860,6 +_,9 @@
 			}
 
 			if (currentItem.type == 1301) {
+				allDamage += 0.1f;
+				allCrit += 8;
+				/*
 				meleeCrit += 8;
 				rangedCrit += 8;
 				magicCrit += 8;
@@ -9867,6 +_,7 @@
 				rangedDamage += 0.1f;
 				magicDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (currentItem.type == 111)
@@ -9909,9 +_,12 @@
 			}
 
 			if (currentItem.type == 1248) {
+				allCrit += 10;
+				/*
 				meleeCrit += 10;
 				rangedCrit += 10;
 				magicCrit += 10;
+				*/
 			}
 
 			if (currentItem.type == 854)
@@ -10043,7 +_,7 @@
 			if (currentItem.type == 861) {
 				accMerman = true;
 				wolfAcc = true;
-				if (hideVisibleAccessory[itemSlot]) {
+					if (hideVisibleAccessory[itemSlot]) {
 					hideMerman = true;
 					hideWolf = true;
 				}
@@ -10295,10 +_,7 @@
 				minionDamage += 0.15f;
 
 			if (currentItem.type == 935) {
-				magicDamage += 0.12f;
+				allDamage += 0.12f;
-				meleeDamage += 0.12f;
-				rangedDamage += 0.12f;
-				minionDamage += 0.12f;
 			}
 
 			if (currentItem.wingSlot != -1)
@@ -10415,9 +_,9 @@
 			}
 
 			if (Main.myPlayer != whoAmI)
-				return;
+				return; // TODO: double check wings logic, etc.
 
-			if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0 && Main.curMusic <= 90) {
+			if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0) {
 				SoundEngine.PlaySound(SoundID.Item166, base.Center);
 				int num3 = -1;
 				if (Main.curMusic == 1)
@@ -10579,13 +_,26 @@
 					currentItem.SetDefaults(5040);
 				else if (Main.curMusic == 89)
 					currentItem.SetDefaults(5044);
-				else if (Main.curMusic > 13)
+				else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(1596 + Main.curMusic - 14);
 				else if (num3 != -1)
+					;//Silence
+				else if (Main.curMusic < Main.maxMusic)
 					currentItem.SetDefaults(num3 + 562);
+				else if (SoundLoader.musicToItem.TryGetValue(Main.curMusic, out int modMusicBoxType))
+					currentItem.SetDefaults(modMusicBoxType);
 			}
 
 			ApplyMusicBox(currentItem);
+
+			if (currentItem.wingSlot > 0) {
+				if (!hideVisibleAccessory[itemSlot] || velocity.Y != 0f && !mount.Active)
+					wings = currentItem.wingSlot;
+
+				wingsLogic = currentItem.wingSlot;
+			}
+
+			ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
 		}
 
 		private void ApplyMusicBox(Item currentItem) {
@@ -10772,6 +_,9 @@
 			if (currentItem.type == 5044)
 				Main.musicBox2 = 85;
 
+			if (SoundLoader.itemToMusic.TryGetValue(currentItem.type, out int modMusicBox))
+				Main.musicBox2 = modMusicBox;
+
 			Main.musicBoxNotModifiedByVolume = Main.musicBox2;
 		}
 
@@ -10804,10 +_,13 @@
 
 			if (head == 112 && body == 75 && legs == 64) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
+				allDamage += 0.1f;
+				/*
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
 				rangedDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 
 			if (head == 180 && body == 182 && legs == 122) {
@@ -10865,7 +_,7 @@
 					beetleCounter += 200f;
 
 				if (num != beetleOrbs && beetleOrbs > 0) {
-					for (int j = 0; j < 22; j++) {
+					for (int j = 0; j < MaxBuffs; j++) {
 						if (buffType[j] >= 98 && buffType[j] <= 100 && buffType[j] != 97 + num)
 							DelBuff(j);
 					}
@@ -10878,7 +_,7 @@
 				int num5 = 180;
 				if (beetleCounter >= (float)num5) {
 					if (beetleOrbs > 0 && beetleOrbs < 3) {
-						for (int k = 0; k < 22; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] >= 95 && buffType[k] <= 96)
 								DelBuff(k);
 						}
@@ -11019,7 +_,7 @@
 				AddBuff(60, 18000);
 			}
 			else if (crystalLeaf) {
-				for (int n = 0; n < 22; n++) {
+				for (int n = 0; n < MaxBuffs; n++) {
 					if (buffType[n] == 60)
 						DelBuff(n);
 				}
@@ -11126,6 +_,9 @@
 
 			if (head == 261 && body == 230 && legs == 213) {
 				setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
+				allDamage += 0.1f;
+				allCrit += 10;
+				/*
 				rangedDamage += 0.1f;
 				meleeDamage += 0.1f;
 				magicDamage += 0.1f;
@@ -11133,6 +_,7 @@
 				rangedCrit += 10;
 				meleeCrit += 10;
 				magicCrit += 10;
+				*/
 				dashType = 5;
 			}
 
@@ -11166,7 +_,7 @@
 				int num9 = 180;
 				if (solarCounter >= num9) {
 					if (solarShields > 0 && solarShields < 3) {
-						for (int num10 = 0; num10 < 22; num10++) {
+						for (int num10 = 0; num10 < MaxBuffs; num10++) {
 							if (buffType[num10] >= 170 && buffType[num10] <= 171)
 								DelBuff(num10);
 						}
@@ -11318,6 +_,8 @@
 			}
 
 			ApplyArmorSoundAndDustChanges();
+
+			ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
 		}
 
 		public void UpdateSocialShadow() {
@@ -11415,6 +_,11 @@
 		}
 
 		public int GetPrimaryBiome() {
+			int modID = LoaderManager.Get<BiomeLoader>().GetPrimaryModBiome(this, out var priority);
+
+			if (priority >= SceneEffectPriority.BiomeHigh)
+				return modID;
+			
 			if (ZoneDungeon)
 				return 8;
 
@@ -11424,6 +_,9 @@
 			if (ZoneCrimson)
 				return 10;
 
+			if (priority >= SceneEffectPriority.BiomeMedium)
+				return modID;
+
 			if (ZoneGlowshroom)
 				return 7;
 
@@ -11436,6 +_,9 @@
 			if (ZoneSnow)
 				return 2;
 
+			if (priority >= SceneEffectPriority.BiomeLow)
+				return modID;
+
 			if (ZoneBeach)
 				return 5;
 
@@ -11578,6 +_,8 @@
 			bool flag6 = ZoneRain && ZoneSnow;
 			bool flag7 = point.Y > Main.maxTilesY - 320;
 			bool flag8 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
+			// TODO, are these flags a problem?
+			LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
 			ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, value4 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, value3 - new Vector2(0f, 10f));
 			ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, value2 - new Vector2(0f, 10f));
@@ -11716,6 +_,8 @@
 				}
 			}
 
+			ZonePurity = InZonePurity();
+			LoaderManager.Get<BiomeLoader>().PostUpdateBiome(this);
 			if (!dead) {
 				Point point2 = base.Center.ToTileCoordinates();
 				if (WorldGen.InWorld(point2.X, point2.Y, 1)) {
@@ -11746,6 +_,7 @@
 			else {
 				_funkytownAchievementCheckCooldown = 100;
 			}
+			LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
 		}
 
 		public void ManageSpecialBiomeVisuals(string biomeName, bool inZone, Vector2 activationSource = default(Vector2)) {
@@ -11941,8 +_,9 @@
 			hasGingerBeard = false;
 			hasRainbowCursor = false;
 			leinforsHair = false;
+			PlayerLoader.UpdateDead(this);
 			gravDir = 1f;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]]) {
 					buffTime[i] = 0;
 					buffType[i] = 0;
@@ -12134,6 +_,15 @@
 						toolStrategy = 5;
 				}
 
+				int modSelect = TileLoader.AutoSelect(tX, tY, this);
+				if (modSelect >= 0) {
+					if (nonTorch == -1)
+						nonTorch = selectedItem;
+
+					selectedItem = modSelect;
+					return;
+				}
+
 				SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
 				_lastSmartCursorToolStrategy = toolStrategy;
 			}
@@ -12174,7 +_,7 @@
 							SmartSelect_SelectItem(i);
 							return;
 						}
-						if (type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776)
+						if (ItemID.Sets.Glowsticks[type])
 							SmartSelect_SelectItem(i);
 						break;
 					case 1:
@@ -12196,16 +_,16 @@
 						}
 						break;
 					case 4:
-						if (inventory[i].type != 282 && inventory[i].type != 286 && inventory[i].type != 3002 && inventory[i].type != 3112 && inventory[i].type != 4776 && inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type]) {
+						if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type]) {
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
 						}
-						if ((type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776) && wetTile) {
+						if (ItemID.Sets.Glowsticks[type] && wetTile) {
 							SmartSelect_SelectItem(i);
 							return;
 						}
@@ -12233,7 +_,7 @@
 							if (nonTorch == -1)
 								nonTorch = selectedItem;
 
-							if (inventory[selectedItem].createTile != 4)
+							if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 								selectedItem = i;
 
 							break;
@@ -12260,6 +_,7 @@
 							case 3002:
 							case 3112:
 							case 4776:
+							case int thisType when ItemID.Sets.Glowsticks[thisType]:
 								SmartSelect_SelectItem(i);
 								return;
 						}
@@ -12439,6 +_,13 @@
 					if (tile == null)
 						return;
 
+					if (tile.type > TileID.Count) {
+						if (tile.active() && TileID.Sets.Torch[tile.type])
+							NearbyModTorch.Add(tile.type);
+
+						continue;
+					}
+
 					if (!tile.active() || tile.type != 4)
 						continue;
 
@@ -12607,6 +_,9 @@
 			if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < 22)
 				nearbyTorch[inventory[selectedItem].placeStyle] = true;
 
+			if (TileLoader.GetTile(inventory[selectedItem].createTile) is ModTile modTile && TileID.Sets.Torch[modTile.Type])
+				NearbyModTorch.Add(modTile.Type);
+
 			float num = 0f;
 			float num2 = 0f;
 			if (!ZoneDungeon && !ZoneLihzhardTemple) {
@@ -12676,6 +_,7 @@
 				}
 			}
 
+			TileLoader.ModifyTorchLuck(this, ref num2, ref num);
 			if (num2 >= 1f)
 				torchLuck += 1f;
 			else if (num2 > 0f)
@@ -12692,6 +_,7 @@
 			for (int i = 0; i < 22; i++) {
 				nearbyTorch[i] = false;
 			}
+			NearbyModTorch.Clear();
 
 			if (torchLuck < 0f)
 				torchLuck = 0f;
@@ -12763,6 +_,9 @@
 			lifeRegen = 0;
 			manaCost = 1f;
 			meleeSpeed = 1f;
+			allDamage = StatModifier.One;
+			allCrit = 4;
+			/* individual class damage handled by ResetDamageClassData
 			meleeDamage = 1f;
 			rangedDamage = 1f;
 			magicDamage = 1f;
@@ -12770,8 +_,10 @@
 			meleeCrit = 4;
 			rangedCrit = 4;
 			magicCrit = 4;
+			*/
 			hasFootball = false;
 			drawingFootball = false;
+			allKB = StatModifier.One;
 			minionKB = 0f;
 			moveSpeed = 1f;
 			boneArmor = false;
@@ -12814,9 +_,14 @@
 			ammoCost75 = false;
 			manaRegenBuff = false;
 			hasCreditsSceneMusicBox = false;
+			arrowDamage = StatModifier.One;
+			bulletDamage = StatModifier.One;
+			rocketDamage = StatModifier.One;
+			/*
 			arrowDamage = 1f;
 			bulletDamage = 1f;
 			rocketDamage = 1f;
+			*/
 			coolWhipBuff = false;
 			yoraiz0rEye = 0;
 			yoraiz0rDarkness = false;
@@ -13145,7 +_,9 @@
 				}
 			}
 
+			ResetDamageClassData();
 			mount.CheckMountBuff(this);
+			PlayerLoader.ResetEffects(this);
 		}
 
 		private void UpdateLadyBugLuckTime() {
@@ -13286,6 +_,7 @@
 				lifeRegen -= 100;
 			}
 
+			PlayerLoader.UpdateBadLifeRegen(this);
 			if (honey && lifeRegen < 0) {
 				lifeRegen += 4;
 				if (lifeRegen > 0)
@@ -13330,6 +_,7 @@
 			if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
 				lifeRegen += 2;
 
+			PlayerLoader.UpdateLifeRegen(this);
 			if (bleed)
 				lifeRegenTime = 0;
 
@@ -13394,6 +_,7 @@
 			if (rabid)
 				num2 = ((!shinyStone) ? (num2 / 2f) : (num2 * 0.75f));
 
+			PlayerLoader.NaturalLifeRegen(this, ref num2);
 			float num4 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
 			num2 *= num4;
 			lifeRegen += (int)Math.Round(num2);
@@ -13559,8 +_,8 @@
 
 		public void UpdateJumpHeight() {
 			if (mount.Active) {
-				jumpHeight = mount.JumpHeight(velocity.X);
+				jumpHeight = mount.JumpHeight(this, velocity.X);
-				jumpSpeed = mount.JumpSpeed(velocity.X);
+				jumpSpeed = mount.JumpSpeed(this, velocity.X);
 			}
 			else {
 				if (jumpBoost) {
@@ -13753,7 +_,7 @@
 					velocity.X = maxRunSpeed;
 				}
 			}
-
+			
 			if (controlLeft && velocity.X > 0f - maxRunSpeed) {
 				if (!mount.Active || !mount.Cart || velocity.Y == 0f) {
 					if (velocity.X > runSlowdown)
@@ -13858,7 +_,7 @@
 						direction = -1;
 				}
 				else if ((itemAnimation == 0 || inventory[selectedItem].useTurn) && mount.AllowDirectionChange) {
-					direction = -1;
+					direction = -1 ;
 				}
 
 				if (velocity.Y == 0f || wingsLogic > 0 || mount.CanFly()) {
@@ -13973,7 +_,7 @@
 				if (flag4)
 					num5 = 30;
 
-				float damage = (float)num5 * minionDamage;
+				float damage = (float)num5 * minionDamage.Additive;
 				float knockback = 10f;
 				if (flag4)
 					knockback = 7f;
@@ -13990,7 +_,7 @@
 
 				rect2.Width = 2;
 				rect2.Inflate(6, 12);
-				float damage2 = 100f * minionDamage;
+				float damage2 = 100f * minionDamage.Additive;
 				float knockback2 = 12f;
 				int nPCImmuneTime2 = 30;
 				int playerImmuneTime2 = 6;
@@ -14004,7 +_,7 @@
 
 				rect3.Width = 2;
 				rect3.Inflate(6, 12);
-				float damage3 = 120f * minionDamage;
+				float damage3 = 120f * minionDamage.Additive;
 				float knockback3 = 12f;
 				int nPCImmuneTime3 = 30;
 				int playerImmuneTime3 = 6;
@@ -14018,7 +_,7 @@
 
 				rect4.Width = 2;
 				rect4.Inflate(6, 12);
-				float damage4 = 90f * minionDamage;
+				float damage4 = 90f * minionDamage.Additive;
 				float knockback4 = 10f;
 				int nPCImmuneTime4 = 30;
 				int playerImmuneTime4 = 6;
@@ -14198,7 +_,7 @@
 			}
 
 			if (num != 0) {
-				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+				int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
 				for (int i = 0; i < num2; i++) {
 					WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
 				}
@@ -14293,7 +_,7 @@
 
 					Rectangle rect2 = nPC.getRect();
 					if (rect.Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(base.position, width, height, nPC.position, nPC.width, nPC.height))) {
-						float num = 40f * minionDamage;
+						float num = 40f * minionDamage.Additive;
 						float knockback = 5f;
 						int direction = base.direction;
 						if (velocity.X < 0f)
@@ -14695,16 +_,18 @@
 
 						Rectangle rect = nPC.getRect();
 						if (rectangle.Intersects(rect) && (nPC.noTileCollide || CanHit(nPC))) {
-							float num = 30f * meleeDamage;
+							float num = 30f * allDamage.CombineWith(meleeDamage);
 							float num2 = 9f;
+							num2 *= allKB.CombineWith(GetKnockback(DamageClass.Melee));
 							bool crit = false;
+							/*
 							if (kbGlove)
 								num2 *= 2f;
 
 							if (kbBuff)
 								num2 *= 1.5f;
-
-							if (Main.rand.Next(100) < meleeCrit)
+							*/
+							if (Main.rand.Next(100) < (allCrit + meleeCrit))
 								crit = true;
 
 							int num3 = base.direction;
@@ -14745,16 +_,18 @@
 							ConsumeSolarFlare();
 						}
 
-						float num4 = 150f * meleeDamage;
+						float num4 = 150f * allDamage.CombineWith(meleeDamage);
 						float num5 = 9f;
+						num5 *= allKB.CombineWith(GetKnockback(DamageClass.Melee));
 						bool crit2 = false;
+						/*
 						if (kbGlove)
 							num5 *= 2f;
 
 						if (kbBuff)
 							num5 *= 1.5f;
-
-						if (Main.rand.Next(100) < meleeCrit)
+						*/
+						if (Main.rand.Next(100) < (allCrit + meleeCrit))
 							crit2 = true;
 
 						int direction = base.direction;
@@ -15284,8 +_,10 @@
 				float num5 = 0.1f;
 				if (wingsLogic == 26) {
 					num2 = 0.75f;
+					//patch file: num2, num5
 					num5 = 0.15f;
 					num4 = 1f;
+					//patch file: num, num3, num4
 					num3 = 2.5f;
 					num = 0.125f;
 				}
@@ -15382,6 +_,7 @@
 						num = 0.15f;
 				}
 
+				ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
 				velocity.Y -= num * gravDir;
 				if (gravDir == 1f) {
 					if (velocity.Y > 0f)
@@ -15686,7 +_,7 @@
 						Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
 						RemoveAllGrapplingHooks();
 						int num4 = 13;
-						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode))
+						if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
 							num4 = miscEquips[2].mountType;
 
 						int num5 = height + Mount.GetHeightBoost(num4);
@@ -15758,6 +_,11 @@
 				Projectile projectile = Main.projectile[grappling[i]];
 				if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
 					continue;
+				int type = projectile.type;
+				bool useAiType = projectile.ModProjectile != null && projectile.ModProjectile.AIType > 0;
+				if (useAiType) {
+					projectile.type = projectile.ModProjectile.AIType;
+				}
 
 				num += projectile.position.X + (float)(projectile.width / 2);
 				num2 += projectile.position.Y + (float)(projectile.height / 2);
@@ -15799,6 +_,10 @@
 					if (value2.X != 0f)
 						preferredPlayerDirectionToSet = Math.Sign(value2.X);
 				}
+				if (useAiType) {
+					projectile.type = type;
+				}
+				ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num2);
 			}
 
 			if (num3 == 0) {
@@ -15823,13 +_,14 @@
 			if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
 				num9 = 16f;
 
+			ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num9);
 			float num10 = num8;
 			num10 = ((!(num8 > num9)) ? 1f : (num9 / num8));
 			preferedPlayerVelocityX *= num10;
 			preferedPlayerVelocityY *= num10;
 		}
 
-		private void RefreshMovementAbilities(bool doubleJumps = true) {
+		public void RefreshMovementAbilities(bool doubleJumps = true) { //Made public, because this is useful
 			wingTime = wingTimeMax;
 			rocketTime = rocketTimeMax;
 			rocketDelay = 0;
@@ -16460,6 +_,7 @@
 			slippy2 = (num3 == 197);
 			powerrun = (num3 == 198);
 			runningOnSand = (TileID.Sets.Conversion.Sand[num3] || TileID.Sets.Conversion.Sandstone[num3] || TileID.Sets.Conversion.HardenedSand[num3]);
+			TileLoader.FloorVisuals(num3, this);
 			if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
 				num3 = -1;
 
@@ -16497,7 +_,7 @@
 		}
 
 		private void MakeFloorDust(bool Falling, int type) {
-			if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460)
+			if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && !TileLoader.HasWalkDust(type))
 				return;
 
 			int num = 1;
@@ -16507,6 +_,7 @@
 			for (int i = 0; i < num; i++) {
 				bool flag = true;
 				int num2 = 76;
+				//patch file: type, num2, flag
 				if (type == 53)
 					num2 = 32;
 
@@ -16572,6 +_,7 @@
 
 				if (num2 == 53 && Main.rand.Next(3) != 0)
 					flag = false;
+				// Patch context: num2 & flag
 
 				Color newColor = default(Color);
 				if (type == 193)
@@ -16583,6 +_,7 @@
 				if (type == 460)
 					newColor = new Color(100, 150, 130, 100);
 
+				TileLoader.WalkDust(type, ref num2, ref flag, ref newColor);
 				if (!Falling) {
 					float num3 = Math.Abs(velocity.X) / 3f;
 					if ((float)Main.rand.Next(100) > num3 * 100f)
@@ -16961,6 +_,7 @@
 
 			UpdateHairDyeDust();
 			UpdateMiscCounter();
+			PlayerLoader.PreUpdate(this);
 			infernoCounter++;
 			if (infernoCounter >= 180)
 				infernoCounter = 0;
@@ -17314,6 +_,7 @@
 						}
 					}
 
+					PlayerLoader.SetControls(this);
 					if (controlInv) {
 						if (releaseInventory)
 							ToggleInv();
@@ -17453,7 +_,10 @@
 							CaptureManager.Instance.Scrolling();
 						}
 						else if (!flag8) {
+							if (PlayerInput.MouseInModdedUI.Count > 0) {
+								//Do nothing
+							}
-							if (!Main.playerInventory) {
+							else if (!Main.playerInventory) {
 								HandleHotbar();
 							}
 							else {
@@ -17497,6 +_,7 @@
 										Main.focusRecipe = 0;
 								}
 							}
+							PlayerInput.MouseInModdedUI.Clear();
 						}
 					}
 					else {
@@ -17685,12 +_,6 @@
 						}
 					}
 
-					bool flag12 = false;
-					for (int num23 = 3; num23 < 10; num23++) {
-						if (armor[num23].stack > 0 && armor[num23].wingSlot > -1)
-							flag12 = true;
-					}
-
 					if (stoned) {
 						int num24 = (int)(((float)num18 * gravDir - 2f) * 20f);
 						if (num24 > 0) {
@@ -17698,7 +_,7 @@
 							immune = false;
 						}
 					}
-					else if (((gravDir == 1f && num18 > num17) || (gravDir == -1f && num18 < -num17)) && !noFallDmg && !flag12) {
+					else if (((gravDir == 1f && num18 > num17) || (gravDir == -1f && num18 < -num17)) && !noFallDmg && wingsLogic == 0) {
 						immune = false;
 						int num25 = (int)((float)num18 * gravDir - (float)num17) * 10;
 						if (mount.Active)
@@ -17813,9 +_,11 @@
 			else
 				afkCounter = 0;
 
+			/*
 			meleeCrit += inventory[selectedItem].crit;
 			magicCrit += inventory[selectedItem].crit;
 			rangedCrit += inventory[selectedItem].crit;
+			*/
 			if (whoAmI == Main.myPlayer) {
 				Main.musicBox2 = -1;
 				if (Main.SceneMetrics.WaterCandleCount > 0)
@@ -17846,12 +_,14 @@
 					AddBuff(194, 2, quiet: false);
 			}
 
+			PlayerLoader.PreUpdateBuffs(this);
-			for (int num26 = 0; num26 < 327; num26++) {
+			for (int num26 = 0; num26 < BuffLoader.BuffCount; num26++) {
 				buffImmune[num26] = false;
 			}
 
 			UpdateProjectileCaches(i);
 			UpdateBuffs(i);
+			PlayerLoader.PostUpdateBuffs(this);
 			if (whoAmI == Main.myPlayer) {
 				if (!onFire && !poisoned)
 					trapDebuffSource = false;
@@ -17860,6 +_,9 @@
 				UpdatePetLight(i);
 			}
 
+			if (kbBuff)
+				allKB *= 1.5f;
+
 			UpdateLuckFactors();
 			RecalculateLuck();
 			if (luckNeedsSync && whoAmI == Main.myPlayer) {
@@ -17895,7 +_,7 @@
 			hideWolf = false;
 			forceWerewolf = false;
 			if (whoAmI == Main.myPlayer) {
-				for (int num27 = 0; num27 < 22; num27++) {
+				for (int num27 = 0; num27 < MaxBuffs; num27++) {
 					if (buffType[num27] > 0 && buffTime[num27] <= 0)
 						DelBuff(num27);
 				}
@@ -17948,6 +_,7 @@
 
 			UpdateArmorLights();
 			UpdateArmorSets(i);
+			PlayerLoader.PostUpdateEquips(this); // TODO, move down?
 			if (maxTurretsOld != maxTurrets) {
 				UpdateMaxTurrets();
 				maxTurretsOld = maxTurrets;
@@ -17995,8 +_,11 @@
 
 				meleeDamage += (1f - stealth) * 3f;
 				meleeCrit += (int)((1f - stealth) * 30f);
+				GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
+				/*
 				if (meleeCrit > 100)
-					meleeCrit = 100;
+					meleeCrit = new Modifier(100);
+				*/
 
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
@@ -18028,6 +_,7 @@
 
 				rangedDamage += (1f - stealth) * 0.6f;
 				rangedCrit += (int)((1f - stealth) * 10f);
+				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 				aggro -= (int)((1f - stealth) * 750f);
 				if (stealthTimer > 0)
 					stealthTimer--;
@@ -18047,6 +_,7 @@
 
 					rangedDamage += (1f - stealth) * 0.8f;
 					rangedCrit += (int)((1f - stealth) * 20f);
+					GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
 					aggro -= (int)((1f - stealth) * 1200f);
 					accRunSpeed *= 0.3f;
 					maxRunSpeed *= 0.3f;
@@ -18147,6 +_,7 @@
 			}
 
 			meleeSpeed = 1f / meleeSpeed;
+			PlayerLoader.PostUpdateMiscEffects(this);
 			UpdateLifeRegen();
 			soulDrain = 0;
 			UpdateManaRegen();
@@ -18159,7 +_,7 @@
 			runAcceleration *= moveSpeed;
 			maxRunSpeed *= moveSpeed;
 			UpdateJumpHeight();
-			for (int num33 = 0; num33 < 22; num33++) {
+			for (int num33 = 0; num33 < MaxBuffs; num33++) {
 				if (buffType[num33] > 0 && buffTime[num33] > 0 && buffImmune[buffType[num33]])
 					DelBuff(num33);
 			}
@@ -18171,10 +_,7 @@
 				statDefense /= 2;
 
 			if (witheredWeapon) {
-				meleeDamage *= 0.5f;
+				allDamage *= 0.5f;
-				rangedDamage *= 0.5f;
-				magicDamage *= 0.5f;
-				minionDamage *= 0.5f;
 			}
 
 			lastTileRangeX = tileRangeX;
@@ -18674,6 +_,7 @@
 						mount.UpdateDrill(this, controlUp, controlDown);
 				}
 
+				PlayerLoader.PostUpdateRunSpeeds(this);
 				HorizontalMovement();
 				if (gravControl) {
 					if (controlUp && releaseUp) {
@@ -18760,12 +_,13 @@
 					CancelAllJumpVisualEffects();
 				}
 				else {
+					bool isCustomWings = ItemLoader.WingUpdate(this, flag20);
 					if (flag20) {
 						WingAirVisuals();
 						WingMovement();
 					}
 
-					WingFrame(flag20);
+					WingFrame(flag20, isCustomWings);
 					if (wingsLogic > 0 && rocketBoots != 0 && base.velocity.Y != 0f && rocketTime != 0) {
 						int num45 = 6;
 						int num46 = rocketTime * num45;
@@ -18776,7 +_,7 @@
 						rocketTime = 0;
 					}
 
-					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45) {
+					if (flag20 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45 && !isCustomWings) {
 						bool flag21 = wingFrame == 3;
 						if (wings == 43 || wings == 44)
 							flag21 = (wingFrame == 4);
@@ -19029,7 +_,7 @@
 											wingFrame = 0;
 									}
 								}
-								else if (wings != 22 && wings != 28) {
+								else if (wings != 22 && wings != 28 && !isCustomWings) {
 									if (wings == 30) {
 										wingFrameCounter++;
 										int num62 = 5;
@@ -19236,7 +_,7 @@
 				}
 
 				if (flag22 && Main.myPlayer == whoAmI) {
-					for (int num79 = 0; num79 < 22; num79++) {
+					for (int num79 = 0; num79 < MaxBuffs; num79++) {
 						if (buffType[num79] == 38)
 							DelBuff(num79);
 					}
@@ -19309,15 +_,17 @@
 					Rectangle rectangle2 = new Rectangle((int)base.position.X, (int)base.position.Y, width, height);
 					for (int num80 = 0; num80 < 200; num80++) {
 						if (Main.npc[num80].active && !Main.npc[num80].dontTakeDamage && !Main.npc[num80].friendly && Main.npc[num80].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num80]) && rectangle2.Intersects(new Rectangle((int)Main.npc[num80].position.X, (int)Main.npc[num80].position.Y, Main.npc[num80].width, Main.npc[num80].height))) {
+							/*
 							float num81 = meleeCrit;
 							if (num81 < (float)rangedCrit)
 								num81 = rangedCrit;
 
 							if (num81 < (float)magicCrit)
 								num81 = magicCrit;
-
+							*/
+							// congrats, minecarts now crit based on generic crit (which is probably what the above logic was trying to emulate)
 							bool crit = false;
-							if ((float)Main.rand.Next(1, 101) <= num81)
+							if ((float)Main.rand.Next(1, 101) <= allCrit)
 								crit = true;
 
 							float currentSpeed = Math.Abs(base.velocity.X) / maxRunSpeed;
@@ -19447,7 +_,7 @@
 
 			if (num83) {
 				if ((onFire || onFire3) && !lavaWet) {
-					for (int num84 = 0; num84 < 22; num84++) {
+					for (int num84 = 0; num84 < MaxBuffs; num84++) {
 						int num85 = buffType[num84];
 						if (num85 == 24 || num85 == 323)
 							DelBuff(num84);
@@ -19694,6 +_,7 @@
 			if (vortexDebuff)
 				base.velocity.Y = base.velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
 
+			PlayerLoader.PreUpdateMovement(this);
 			if (tongued) {
 				base.position += base.velocity;
 				flag28 = false;
@@ -19784,6 +_,7 @@
 			grapCount = 0;
 			UpdateReleaseUseTile();
 			UpdateAdvancedShadows();
+			PlayerLoader.PostUpdate(this);
 		}
 
 		private void UpdateControlHolds() {
@@ -19819,6 +_,9 @@
 		}
 
 		public void RecalculateLuck() {
+			if (!PlayerLoader.PreModifyLuck(this, ref luck))
+				goto skipVanillaLuck;
+
 			luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
 			luck += (float)(int)luckPotion * 0.1f;
 			if (LanternNight.LanternsUp)
@@ -19826,6 +_,9 @@
 
 			if (HasGardenGnomeNearby)
 				luck += 0.2f;
+
+			skipVanillaLuck:
+			PlayerLoader.ModifyLuck(this, ref luck);
 		}
 
 		private static int GetMouseScrollDelta() => PlayerInput.ScrollWheelDelta / 120;
@@ -19924,6 +_,8 @@
 
 			if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
 				runSlowdown *= 6f;
+			
+			ItemLoader.HorizontalWingSpeeds(this);
 		}
 
 		private void RocketBootVisuals() {
@@ -20030,7 +_,7 @@
 			}
 		}
 
-		public void WingFrame(bool wingFlap) {
+		public void WingFrame(bool wingFlap, bool isCustomWings = false) {
 			bool flag = wingsLogic != wings;
 			if (wings == 4) {
 				if (wingFlap || jump > 0) {
@@ -20671,6 +_,8 @@
 				num27 = 3;
 			}
 
+			if (isCustomWings) return;
+
 			if (wings == 32)
 				num27 = 3;
 
@@ -21234,6 +_,9 @@
 						break;
 				}
 
+				if (!NPCLoader.CanHitPlayer(Main.npc[i], this, ref specialHitSetter) || !PlayerLoader.CanBeHitByNPC(this, Main.npc[i], ref specialHitSetter))
+					continue;
+
 				if ((specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
 					continue;
 
@@ -21269,6 +_,10 @@
 					if (num5 > 0 && HasNPCBannerBuff(num5))
 						num4 = ((!Main.expertMode) ? ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].NormalDamageReceived)) : ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].ExpertDamageReceived)));
 
+					bool crit = false;
+					NPCLoader.ModifyHitPlayer(Main.npc[i], this, ref num4, ref crit);
+					PlayerLoader.ModifyHitByNPC(this, Main.npc[i], ref num4, ref crit);
+					
 					if (whoAmI == Main.myPlayer && num2 > 0f && !immune && !Main.npc[i].dontTakeDamage) {
 						int num6 = (int)((float)num4 * num2);
 						if (num6 > 1000)
@@ -21290,8 +_,15 @@
 					if (resistCold && Main.npc[i].coldDamage)
 						num4 = (int)((float)num4 * 0.7f);
 
-					if (flag && Hurt(PlayerDeathReason.ByNPC(i), num4, num3, pvp: false, quiet: false, Crit: false, specialHitSetter) > 0.0 && !dead && !flag2)
-						StatusFromNPC(Main.npc[i]);
+					if (flag) { //TODO, what is this flag?
+						int realDamage = (int)Hurt(PlayerDeathReason.ByNPC(i), num4, num3, pvp: false, quiet: false, Crit: false, specialHitSetter);
+						
+						if (realDamage > 0 && !dead && !flag2)
+							StatusFromNPC(Main.npc[i]);
+							
+						NPCLoader.OnHitPlayer(Main.npc[i], this, realDamage, crit);
+						PlayerLoader.OnHitByNPC(this, Main.npc[i], realDamage, crit);
+					}
 
 					if (num) {
 						GiveImmuneTimeForCollisionAttack(longInvince ? 60 : 30);
@@ -21366,6 +_,8 @@
 		}
 
 		public void ItemCheck_ManageRightClickFeatures() {
+			//ItemLoader.AltFunctionUse(this.inventory[this.selectedItem], this)
+			// TODO, reintegrate AltFunctionUse
 			bool flag = selectedItem != 58 && controlUseTile && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
 			bool flag2 = flag;
 			if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
@@ -21412,6 +_,11 @@
 				controlUseItem = true;
 			}
 
+			if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this)) {
+				altFunctionUse = 1;
+				controlUseItem = true;
+			}
+
 			if (!controlUseItem && altFunctionUse == 1)
 				altFunctionUse = 0;
 
@@ -21570,6 +_,9 @@
 		}
 
 		public void ScrollHotbar(int Offset) {
+			//disable hotbar scrolling when using auto select
+			//previously it only worked when scrolling between 0 and 9, and made the sound
+			if (selectedItem >= 10) return;
 			Offset = ClampHotbarOffset(Offset);
 			selectedItem += Offset;
 			if (Offset != 0) {
@@ -21798,6 +_,8 @@
 					cursorItemIconID = -1;
 				}
 			}
+
+			TileLoader.MouseOverFar(myX, myY);
 		}
 
 		private void TileInteractionsUse(int myX, int myY) {
@@ -21813,7 +_,8 @@
 				bool flag3 = false;
 				for (int i = 0; i < 58; i++) {
 					if (inventory[i].type == 949 && inventory[i].stack > 0) {
+						if (ItemLoader.ConsumeItem(inventory[i], this))
-						inventory[i].stack--;
+							inventory[i].stack--;
 						if (inventory[i].stack <= 0)
 							inventory[i].SetDefaults();
 
@@ -21888,7 +_,7 @@
 					Wiring.HitSwitch(myX, myY);
 					NetMessage.SendData(59, -1, -1, null, myX, myY);
 				}
-				else if (Main.tile[myX, myY].type == 139) {
+				else if (Main.tile[myX, myY].type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY])) {
 					flag2 = true;
 					SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
 					WorldGen.SwitchMB(myX, myY);
@@ -22012,7 +_,7 @@
 					flag2 = true;
 					GamepadEnableGrappleCooldown();
 				}
-				else if (Main.tile[myX, myY].type == 4 || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90)) {
+				else if (TileID.Sets.Torch[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90) || TileID.Sets.CanDropFromRightClick[Main.tile[myX, myY].type]) {
 					WorldGen.KillTile(myX, myY);
 					if (Main.netMode == 1)
 						NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
@@ -22316,7 +_,8 @@
 					if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss) {
 						for (int n = 0; n < 58; n++) {
 							if (inventory[n].type == 1293) {
+								if (ItemLoader.ConsumeItem(inventory[n], this))
-								inventory[n].stack--;
+									inventory[n].stack--;
 								if (inventory[n].stack <= 0)
 									inventory[n].SetDefaults();
 
@@ -22334,19 +_,22 @@
 							NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
 					}
 				}
-				else if (Main.tile[myX, myY].type == 10) {
+				else if (Main.tile[myX, myY].type == TileID.ClosedDoor || TileLoader.OpenDoorID(Main.tile[myX, myY]) >= 0) {
 					flag2 = true;
 					if (WorldGen.IsLockedDoor(myX, myY)) {
 						int num43 = 1141;
 						for (int num44 = 0; num44 < 58; num44++) {
 							if (inventory[num44].type == num43 && inventory[num44].stack > 0) {
+								if (ItemLoader.ConsumeItem(inventory[num44], this))
-								inventory[num44].stack--;
+									inventory[num44].stack--;
 								if (inventory[num44].stack <= 0)
 									inventory[num44] = new Item();
 
 								WorldGen.UnlockDoor(myX, myY);
 								if (Main.netMode == 1)
 									NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
+
+								break;
 							}
 						}
 					}
@@ -22362,7 +_,7 @@
 						}
 					}
 				}
-				else if (Main.tile[myX, myY].type == 11) {
+				else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0) {
 					flag2 = true;
 					if (WorldGen.CloseDoor(myX, myY))
 						NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
@@ -22534,7 +_,7 @@
 					if (flag12)
 						NetMessage.SendTileSquare(-1, num62, num63, 2, 2);
 				}
-				else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
+				else if ((TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) && Main.tile[myX, myY].type < TileID.Count) {
 					flag2 = true;
 					Main.mouseRightRelease = false;
 					int num68 = 0;
@@ -22576,7 +_,7 @@
 						editedChestName = false;
 					}
 
-					bool flag13 = Chest.IsLocked(Main.tile[num69, num70]);
+					bool flag13 = Chest.IsLocked(num69, num70);
 					if (Main.netMode == 1 && num68 == 0 && !flag13) {
 						if (num69 == chestX && num70 == chestY && chest != -1) {
 							chest = -1;
@@ -22636,7 +_,9 @@
 												continue;
 
 											if (num72 != 329) {
+												if (ItemLoader.ConsumeItem(inventory[num75], this))
-												inventory[num75].stack--;
+													inventory[num75].stack--;
+
 												if (inventory[num75].stack <= 0)
 													inventory[num75] = new Item();
 											}
@@ -22694,13 +_,17 @@
 					if (flag15)
 						LaunchMinecartHook(myX, myY);
 				}
+
+				if (TileLoader.RightClick(myX, myY))
+					flag2 = true;
+				// todo check out this flag2. return? "this.releaseUseTile = false;"
 			}
 
 			if (flag2)
 				tileInteractionHappened = true;
 		}
 
-		private static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
+		public static bool IsHoveringOverABottomSideOfABed(int myX, int myY) {
 			short frameX = Main.tile[myX, myY].frameX;
 			bool flag = frameX / 72 == 1;
 			bool flag2 = frameX % 72 < 36;
@@ -23641,7 +_,7 @@
 				cursorItemIconID = 3747;
 			}
 
-			if (Main.tile[myX, myY].type == 219 && (inventory[selectedItem].type == 424 || inventory[selectedItem].type == 1103)) {
+			if (Main.tile[myX, myY].type == 219 && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1) {
 				noThrow = 2;
 				cursorItemIconEnabled = true;
 				cursorItemIconID = inventory[selectedItem].type;
@@ -24217,6 +_,8 @@
 				cursorItemIconEnabled = false;
 				cursorItemIconID = 0;
 			}
+
+			TileLoader.MouseOver(myX, myY);
 		}
 
 		public Color ChatColor() {
@@ -24350,11 +_,22 @@
 				if (!item.active || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item))
 					continue;
 
+				if (!ItemLoader.CanPickup(item, this))
+					continue;
+
 				int itemGrabRange = GetItemGrabRange(item);
+				ItemLoader.GrabRange(Main.item[j], this, ref itemGrabRange);
 				Rectangle hitbox = item.Hitbox;
 				if (base.Hitbox.Intersects(hitbox)) {
-					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0))
+					if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0)) {
+						if (!ItemLoader.OnPickup(Main.item[j], this)) {
+							Main.item[j] = new Item();
+							if (Main.netMode == 1)
+								NetMessage.SendData(21, -1, -1, null, j);
+							continue;
+						}
 						item = PickupItem(i, j, item);
+					}
 				}
 				else {
 					if (!new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2).Intersects(hitbox))
@@ -24363,7 +_,9 @@
 					ItemSpaceStatus status = ItemSpace(item);
 					if (CanPullItem(item, status)) {
 						item.beingGrabbed = true;
+						if (ItemLoader.GrabStyle(item, this)) {
+						}
-						if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
+						else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
 							PullItem_Pickup(item, 12f, 5);
 						else if (lifeMagnet && (item.type == 58 || item.type == 1734 || item.type == 1867))
 							PullItem_Pickup(item, 15f, 5);
@@ -24699,6 +_,36 @@
 			}
 		}
 
+		//TODO: Move to Player.TML.cs
+		public bool CanBuyItem(int price, int customCurrency = -1) {
+			if (customCurrency != -1)
+				return CustomCurrencyManager.BuyItem(this, price, customCurrency);
+
+			bool flag;
+			long num = Utils.CoinsCount(out flag, inventory, new int[] {
+				58,
+				57,
+				56,
+				55,
+				54
+			});
+
+			long num2 = Utils.CoinsCount(out flag, bank.item, new int[0]);
+			long num3 = Utils.CoinsCount(out flag, bank2.item, new int[0]);
+			long num4 = Utils.CoinsCount(out flag, bank3.item, new int[0]);
+			long num5 = Utils.CoinsCombineStacks(out flag, new long[] {
+				num,
+				num2,
+				num3,
+				num4
+			});
+
+			if (num5 < price)
+				return false;
+
+			return true;
+		}
+
 		public bool BuyItem(int price, int customCurrency = -1) {
 			if (customCurrency != -1)
 				return CustomCurrencyManager.BuyItem(this, price, customCurrency);
@@ -24916,7 +_,7 @@
 		public void AdjTiles() {
 			int num = 4;
 			int num2 = 3;
-			for (int i = 0; i < 624; i++) {
+			for (int i = 0; i < adjTile.Length; i++) {
 				oldAdjTile[i] = adjTile[i];
 				adjTile[i] = false;
 			}
@@ -24957,15 +_,17 @@
 								alchemyTable = true;
 								break;
 						}
+
+						TileLoader.AdjTiles(this, Main.tile[j, k].type);
 					}
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
 						adjWater = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
 						adjHoney = true;
 
-					if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1)
+					if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
 						adjLava = true;
 				}
 			}
@@ -24974,7 +_,7 @@
 				return;
 
 			bool flag = false;
-			for (int l = 0; l < 624; l++) {
+			for (int l = 0; l < adjTile.Length; l++) {
 				if (oldAdjTile[l] != adjTile[l]) {
 					flag = true;
 					break;
@@ -25201,6 +_,7 @@
 				faceHead = -1;
 			}
 
+			ItemLoader.PreUpdateVanitySet(this);
 			if (head > 0 && face > 0) {
 				if (ArmorIDs.Face.Sets.OverrideHelmet[face]) {
 					head = -1;
@@ -25236,6 +_,9 @@
 				obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
 			}
 
+			//TODO: Do these hooks go inside or outside the conditional?
+			PlayerLoader.FrameEffects(this);
+			EquipLoader.EquipFrameEffects(this);
 			if (!isDisplayDollOrInanimate) {
 				if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0) {
 					int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
@@ -25360,6 +_,7 @@
 			Item.GetDrawHitbox(HeldItem.type, this);
 			bool flag3 = CanVisuallyHoldItem(HeldItem);
 			bool flag4 = HeldItem.type != 4952;
+			ItemLoader.UpdateVanitySet(this);
 			if (mount.Active) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * 6;
@@ -25576,6 +_,8 @@
 						}
 					}
 				}
+
+				ItemLoader.UseItemFrame(inventory[selectedItem], this);
 			}
 			else if (pulley) {
 				if (pulleyDir == 2)
@@ -25709,6 +_,10 @@
 				reference9.Y = 0;
 			}
 
+			if (flag3 && itemAnimation <= 0) {
+				ItemLoader.HoldItemFrame(inventory[selectedItem], this);
+			}
+
 			if (legs == 140) {
 				legFrameCounter = 0.0;
 				legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
@@ -25834,7 +_,7 @@
 			}
 		}
 
-		private bool ItemIsVisuallyIncompatible(Item item) {
+		public bool ItemIsVisuallyIncompatible(Item item) {
 			if (compositeBackArm.enabled && item.shieldSlot > 0)
 				return true;
 
@@ -25860,6 +_,12 @@
 			return false;
 		}
 
+		/// <summary>
+		/// Won't work with yoraiz0rEye as effect needs target item slot.
+		/// </summary>
+		/// <param name="item"></param>
+		public void UpdateVisibleAccessory(Item item) => UpdateVisibleAccessory(-1, item);
+
 		private void UpdateVisibleAccessory(int itemSlot, Item item) {
 			if (item.stringColor > 0)
 				stringColor = item.stringColor;
@@ -26082,6 +_,8 @@
 			if (drawPlayer.head == 267)
 				yoraiz0rDarkness = true;
 
+			ItemLoader.ArmorSetShadows(drawPlayer);
+			// TODO, rename to this? SetArmorEffectVisuals
 			if (drawPlayer.stoned || drawPlayer.stealth != 1f) {
 				armorEffectDrawOutlines = false;
 				armorEffectDrawShadow = false;
@@ -26258,6 +_,7 @@
 				}
 			}
 
+			ItemLoader.SetMatch(armorslot, type, male, ref num, ref somethingSpecial);
 			return num;
 		}
 
@@ -26442,6 +_,9 @@
 				}
 
 				immune = true;
+				if (dead)
+					PlayerLoader.OnRespawn(this);
+
 				dead = false;
 				immuneTime = 0;
 			}
@@ -26638,7 +_,7 @@
 			if (whoAmI != Main.myPlayer)
 				return;
 
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffTime[i] > 0 && buffType[i] == 59)
 					DelBuff(i);
 			}
@@ -26761,6 +_,12 @@
 					return 0.0;
 				}
 
+				bool customDamage = false;
+				bool playSound = true;
+				bool genGore = true;
+				if (!PlayerLoader.PreHurt(this, pvp, quiet, ref Damage, ref hitDirection, ref Crit, ref customDamage, ref playSound, ref genGore, ref damageSource))
+					return 0.0;
+
 				if (whoAmI == Main.myPlayer && panic)
 					AddBuff(63, 480);
 
@@ -26772,7 +_,7 @@
 					NetMessage.SendData(84, -1, -1, null, whoAmI);
 
 				int num = Damage;
-				double num2 = Main.CalculateDamagePlayersTake(num, statDefense);
+				double num2 = customDamage ? num : Main.CalculateDamagePlayersTake(num, statDefense);
 				if (Crit)
 					num *= 2;
 
@@ -26799,7 +_,7 @@
 					}
 
 					if (invis) {
-						for (int k = 0; k < 22; k++) {
+						for (int k = 0; k < MaxBuffs; k++) {
 							if (buffType[k] == 10)
 								DelBuff(k);
 						}
@@ -26826,7 +_,7 @@
 						float num5 = 0.15f * (float)beetleOrbs;
 						num2 = (int)((double)(1f - num5) * num2);
 						beetleOrbs--;
-						for (int l = 0; l < 22; l++) {
+						for (int l = 0; l < MaxBuffs; l++) {
 							if (buffType[l] >= 95 && buffType[l] <= 97)
 								DelBuff(l);
 						}
@@ -26918,6 +_,8 @@
 						Projectile.NewProjectile(GetProjectileSource_Accessory(brainOfConfusionItem), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
 					}
 
+					//TODO: Is 'num2' correct? Ensure and add patch context.
+					PlayerLoader.Hurt(this, pvp, quiet, num2, hitDirection, Crit);
 					if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet) {
 						if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart))
 							NetMessage.SendData(13, -1, -1, null, whoAmI);
@@ -27051,6 +_,9 @@
 						fallStart = (int)(position.Y / 16f);
 					}
 
+					if (!playSound)
+						goto postSound; //gotos are ugly but minimize the diff file
+
 					if (stoned)
 						SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
 					else if ((wereWolf || forceWerewolf) && !hideWolf)
@@ -27065,7 +_,12 @@
 						SoundEngine.PlaySound(1, (int)position.X, (int)position.Y);
 
 					eyeHelper.BlinkBecausePlayerGotHurt();
+					postSound:
 					if (statLife > 0) {
+						if (!genGore)
+							goto postGore; //gotta minimize diff files
+
+						// Context: The patch that defines postGore used num2.
 						double num25 = num2 / (double)statLifeMax2 * 100.0;
 						float num26 = 2 * hitDirection;
 						float num27 = 0f;
@@ -27090,6 +_,9 @@
 								Dust.NewDust(position, width, height, 5, num26 + (float)hitDirection * num27 * Main.rand.NextFloat(), -2f);
 							}
 						}
+
+						postGore:
+						PlayerLoader.PostHurt(this, pvp, quiet, num2, hitDirection, Crit);
 					}
 					else {
 						statLife = 0;
@@ -27123,6 +_,11 @@
 				return;
 
 			StopVanityActions();
+			bool playSound = true;
+			bool genGore = true;
+			if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
+				return;
+
 			if (pvp)
 				pvpDeath = true;
 
@@ -27181,19 +_,24 @@
 				}
 			}
 
-			SoundEngine.PlaySound(5, (int)position.X, (int)position.Y);
+			if (playSound)
+				SoundEngine.PlaySound(5, (int)position.X, (int)position.Y, 1, 1f, 0f);
+
 			headVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			bodyVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			legVelocity.Y = (float)Main.rand.Next(-40, -10) * 0.1f;
 			headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 			legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
-			if (stoned) {
+			if (stoned || !genGore) {
 				headPosition = Vector2.Zero;
 				bodyPosition = Vector2.Zero;
 				legPosition = Vector2.Zero;
 			}
 
+			if (!genGore)
+				goto postGore; //goto minimizes diff file size
+
 			for (int j = 0; j < 100; j++) {
 				if (stoned) {
 					Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
@@ -27211,6 +_,7 @@
 				}
 			}
 
+			postGore:
 			mount.Dismount(this);
 			dead = true;
 			respawnTimer = 600;
@@ -27230,6 +_,7 @@
 			if (Main.expertMode)
 				respawnTimer = (int)((double)respawnTimer * 1.5);
 
+			PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
 			immuneAlpha = 0;
 			if (!ChildSafety.Disabled)
 				immuneAlpha = 255;
@@ -27306,6 +_,9 @@
 			if (newItem.uniqueStack && HasItem(newItem.type))
 				return new ItemSpaceStatus(CanTakeItem: false);
 
+			if (ItemLoader.ItemSpace(newItem, this))
+				return new ItemSpaceStatus(CanTakeItem: true);
+
 			int num = 50;
 			if (newItem.IsACoin)
 				num = 54;
@@ -27653,6 +_,8 @@
 				return;
 
 			bool flag = true;
+			flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
+
 			if (TileReplacementEnabled)
 				flag = PlaceThing_TryReplacingWalls(flag);
 
@@ -27661,6 +_,7 @@
 
 			WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
 			if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall) {
+				WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 				ApplyItemTime(inventory[selectedItem], wallSpeed);
 				if (Main.netMode == 1)
 					NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
@@ -27719,7 +_,8 @@
 
 				WorldGen.PlaceWall(num, num2, createWall);
 				if (Main.tile[num, num2].wall == createWall) {
+					if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
-					inventory[selectedItem].stack--;
+						inventory[selectedItem].stack--;
 					if (inventory[selectedItem].stack == 0)
 						inventory[selectedItem].SetDefaults();
 
@@ -27751,9 +_,18 @@
 				bool canPlace = false;
 				bool newObjectType = false;
 				TileObject objectData = default(TileObject);
+				if (!TileLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createTile)) {
+				}
-				if (TileObjectData.CustomPlace(createTile, inventory[selectedItem].placeStyle) && createTile != 82 && createTile != 227) {
+				else if (TileObjectData.CustomPlace(createTile, inventory[selectedItem].placeStyle) && createTile != 82 && createTile != 227) {
 					newObjectType = true;
-					canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, (ushort)inventory[selectedItem].createTile, inventory[selectedItem].placeStyle, direction, out objectData);
+					int hackCreateTile = inventory[selectedItem].createTile;
+					int hackPlaceStyle = inventory[selectedItem].placeStyle;
+					if (hackCreateTile == TileID.Saplings) {
+						Tile soil = Main.tile[tileTargetX, tileTargetY + 1];
+						if (soil.active())
+							TileLoader.SaplingGrowthType(soil.type, ref hackCreateTile, ref hackPlaceStyle);
+					}
+					canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, hackCreateTile, hackPlaceStyle, direction, out objectData, false);
 					PlaceThing_Tiles_BlockPlacementIfOverPlayers(ref canPlace, ref objectData);
 					PlaceThing_Tiles_BlockPlacementForRepeatedPigronatas(ref canPlace, ref objectData);
 					PlaceThing_Tiles_BlockPlacementForRepeatedPumpkins(ref canPlace, ref objectData);
@@ -27805,9 +_,12 @@
 				if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
 					return false;
 
+				if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
+					return false;
+
 				if (0 == 0) {
 					if (hitReplace.AddDamage(num, pickaxeDamage) < 100) {
-						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+						int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
 						for (int i = 0; i < num2; i++) {
 							WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
 						}
@@ -27977,6 +_,7 @@
 				PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches);
 				if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorEnabled)
 					Main.blockMouse = true;
+				TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 			}
 
 			return data;
@@ -28164,7 +_,8 @@
 					int num7 = FindItem(849);
 					if (num7 > -1 && WorldGen.PlaceActuator(num5, num6)) {
 						NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
+						if (ItemLoader.ConsumeItem(inventory[num7], this))
-						inventory[num7].stack--;
+							inventory[num7].stack--;
 						if (inventory[num7].stack <= 0)
 							inventory[num7].SetDefaults();
 					}
@@ -28529,7 +_,7 @@
 				if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
 					canPlace = true;
 			}
-			else if (inventory[selectedItem].createTile == 4 || inventory[selectedItem].createTile == 136) {
+			else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136) {
 				if (Main.tile[tileTargetX, tileTargetY].wall > 0) {
 					canPlace = true;
 				}
@@ -29056,7 +_,8 @@
 
 			if (paintingAWall) {
 				if (b != byte.MaxValue && Main.tile[x, y].wallColor() != b && WorldGen.paintWall(x, y, b, broadCast: true)) {
+					if (ItemLoader.ConsumeItem(item, this))
-					item.stack--;
+						item.stack--;
 					if (item.stack <= 0)
 						item.SetDefaults();
 
@@ -29065,7 +_,8 @@
 				}
 			}
 			else if (b != byte.MaxValue && Main.tile[x, y].color() != b && WorldGen.paintTile(x, y, b, broadCast: true)) {
+				if (ItemLoader.ConsumeItem(item, this))
-				item.stack--;
+					item.stack--;
 				if (item.stack <= 0)
 					item.SetDefaults();
 
@@ -29115,7 +_,7 @@
 			int num2 = 25;
 			int num3 = 50;
 			int num4 = -1;
-			if (extractType == 1) {
+			if (extractType == ItemID.DesertFossil) {
 				num /= 3;
 				num2 *= 2;
 				num3 = 20;
@@ -29358,6 +_,7 @@
 					num6 += Main.rand.Next(0, 6);
 			}
 
+			ItemLoader.ExtractinatorUse(ref num5, ref num6, extractType);
 			if (num5 > 0) {
 				Vector2 vector = Main.ReverseGravitySupport(Main.MouseScreen) + Main.screenPosition;
 				if (Main.SmartCursorEnabled || PlayerInput.UsingGamepad)
@@ -29452,8 +_,8 @@
 
 		public PlayerFishingConditions GetFishingConditions() {
 			PlayerFishingConditions result = default(PlayerFishingConditions);
-			Fishing_GetBestFishingPole(out result.PolePower, out result.PoleItemType);
-			Fishing_GetBait(out result.BaitPower, out result.BaitItemType);
+			Fishing_GetBestFishingPole(out result.Pole);
+			Fishing_GetBait(out result.Bait);
 			if (result.BaitItemType == 2673)
 				return result;
 
@@ -29461,12 +_,12 @@
 				return result;
 
 			int num = result.BaitPower + result.PolePower + fishingSkill;
-			result.LevelMultipliers = Fishing_GetPowerMultiplier();
+			result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
 			result.FinalFishingLevel = (int)((float)num * result.LevelMultipliers);
 			return result;
 		}
 
-		private static float Fishing_GetPowerMultiplier() {
+		private float Fishing_GetPowerMultiplier(Item pole, Item bait) {
 			float num = 1f;
 			if (Main.raining)
 				num *= 1.2f;
@@ -29498,21 +_,20 @@
 			if (Main.bloodMoon)
 				num *= 1.1f;
 
+			PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
 			return num;
 		}
 
-		private void Fishing_GetBait(out int baitPower, out int baitType) {
-			baitPower = 0;
-			baitType = 0;
+		private void Fishing_GetBait(out Item bait) {
+			bait = null;
 			for (int i = 54; i < 58; i++) {
 				if (inventory[i].stack > 0 && inventory[i].bait > 0) {
-					baitPower = inventory[i].bait;
-					baitType = inventory[i].type;
+					bait = inventory[i];
 					break;
 				}
 			}
 
-			if (baitPower != 0 || baitType != 0)
+			if (bait != null)
 				return;
 
 			int num = 0;
@@ -29528,20 +_,17 @@
 				return;
 			}
 
-			baitPower = inventory[num].bait;
-			baitType = inventory[num].type;
+			bait = inventory[num];
 		}
 
-		private void Fishing_GetBestFishingPole(out int fishingPolePower, out int fishingPoleType) {
-			fishingPolePower = inventory[selectedItem].fishingPole;
-			fishingPoleType = inventory[selectedItem].type;
-			if (fishingPolePower != 0)
+		private void Fishing_GetBestFishingPole(out Item pole) {
+			pole = inventory[selectedItem];
+			if (pole.fishingPole != 0)
 				return;
 
 			for (int i = 0; i < 58; i++) {
-				if (inventory[i].fishingPole > fishingPolePower) {
+				if (inventory[i].fishingPole > pole.fishingPole) {
-					fishingPolePower = inventory[i].fishingPole;
+					pole = inventory[i];
-					fishingPoleType = inventory[i].type;
 				}
 			}
 		}
@@ -29569,7 +_,8 @@
 				return;
 			}
 
+			if (ItemLoader.ConsumeItem(inventory[num], this))
-			inventory[num].stack--;
+				inventory[num].stack--;
 			if (inventory[num].stack <= 0)
 				inventory[num].SetDefaults();
 		}
@@ -29731,6 +_,9 @@
 		}
 
 		public Rectangle GetItemDrawFrame(int type) {
+			if(Main.dedServ)
+				return Rectangle.Empty;
+
 			Main.instance.LoadItem(type);
 			if (type == 75)
 				return TextureAssets.Item[type].Frame(1, 8);
@@ -29758,6 +_,12 @@
 		}
 
 		public void ItemCheck(int i) {
+			if (PlayerLoader.PreItemCheck(this))
+				ItemCheck_Inner(i);
+
+			PlayerLoader.PostItemCheck(this);
+		}
+		private void ItemCheck_Inner(int i) {
 			if (CCed) {
 				channel = false;
 				itemAnimation = (itemAnimationMax = 0);
@@ -29770,6 +_,37 @@
 			if (Main.myPlayer == i && PlayerInput.ShouldFastUseItem)
 				controlUseItem = true;
 
+			// https://github.com/tModLoader/tModLoader/pull/1437
+			//
+			// Here's a map of vanilla's execution order compared to TML's
+			//
+			// VANILLA:
+			// 1. Reuse delay is applied
+			// 2. Item animation is applied if button is pressed
+			// 3. Item animation is reduced
+			// 4. Hold / Use styles are invoked
+			// 5. Item time is reduced
+			// 6. Item logic applies item time
+			//
+			// TML:
+			// 1. Item animation is reduced
+			// 2. Item time is reduced
+			// 3. Reuse delay is applied
+			// 4. Item animation is applied if button is pressed
+			// 5. Item logic applies item time
+			// 6. Hold / Use styles are invoked
+			//
+			// Way more sane and way less confusing!
+
+			// Gotos are admittedly not the cleanest way of doing this but they're the most patch-friendly
+			// TLDR: this moves the blocks responsible for decrementing itemTime and itemAnimation to the start of the method
+			// This is done so that itemTime and itemAnimation cannot be decremented in the same tick as the one they're set in, which should fix a lot of use time issues
+			// -- ThomasThePencil
+
+			goto DecrementItemAnimation;
+
+			ItemCheckPart1:
+
 			ItemCheck_HandleMount();
 			int weaponDamage = GetWeaponDamage(item);
 			ItemCheck_HandleMPItemAnimation(item);
@@ -29783,8 +_,17 @@
 			if (itemAnimation == 0 && reuseDelay > 0)
 				ApplyReuseDelay();
 
-			if (Main.myPlayer == i && itemAnimation == 0 && TileObjectData.CustomPlace(item.createTile, item.placeStyle))
-				TileObject.CanPlace(tileTargetX, tileTargetY, item.createTile, item.placeStyle, direction, out TileObject _, onlyCheck: true);
+			if (Main.myPlayer == i && itemAnimation == 0 && TileObjectData.CustomPlace(item.createTile, item.placeStyle)) {
+				int hackCreateTile = item.createTile;
+				int hackPlaceStyle = item.placeStyle;
+				if (hackCreateTile == TileID.Saplings) {
+					Tile soil = Main.tile[tileTargetX, tileTargetY + 1];
+					if (soil.active())
+						TileLoader.SaplingGrowthType(soil.type, ref hackCreateTile, ref hackPlaceStyle);
+				}
+
+				TileObject.CanPlace(tileTargetX, tileTargetY, hackCreateTile, hackPlaceStyle, direction, out _, true);
+			}
 
 			if (itemAnimation == 0 && altFunctionUse == 2)
 				altFunctionUse = 0;
@@ -29813,7 +_,7 @@
 				if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
 					mount.SetMount(item.mountType, this);
 
-				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && item.shoot < 956 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
+				if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
 					FreeUpPetsAndMinions(item);
 
 				if (flag3)
@@ -29823,6 +_,10 @@
 			if (!controlUseItem)
 				channel = false;
 
+			goto ItemCheckPart2;
+
+			DecrementItemAnimation:
+
 			Item item2 = (itemAnimation > 0) ? lastVisualizedSelectedItem : item;
 			Rectangle drawHitbox = Item.GetDrawHitbox(item2.type, this);
 			compositeFrontArm.enabled = false;
@@ -29843,12 +_,24 @@
 				itemAnimation--;
 			}
 
+			goto DecrementItemTime;
+
+			HandleItemHolding:
+
+			ItemLoader.HoldItem(item, this);
+
 			if (itemAnimation > 0)
 				ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 			else
 				ItemCheck_ApplyHoldStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 
 			releaseUseItem = !controlUseItem;
+
+			return; // This is the end of our spaghetti trip!
+
+			// See the comment at DecrementItemAnimation for explanation
+			DecrementItemTime:
+
 			if (itemTime > 0) {
 				itemTime--;
 				if (ItemTimeIsZero && whoAmI == Main.myPlayer) {
@@ -29862,11 +_,17 @@
 				}
 			}
 
+			goto ItemCheckPart1;
+
+			ItemCheckPart2:
+
 			if (!JustDroppedAnItem) {
 				ItemCheck_EmitHeldItemLight(item);
 				ItemCheck_EmitFoodParticles(item);
 				ItemCheck_EmitDrinkParticles(item);
-				if (whoAmI == Main.myPlayer) {
+
+				// TML attempts to make ApplyItemTime calls run on remote players, so this check is removed.
+				if (whoAmI == Main.myPlayer || true) {
 					bool flag4 = true;
 					int type2 = item.type;
 					if ((type2 == 65 || type2 == 676 || type2 == 723 || type2 == 724 || type2 == 757 || type2 == 674 || type2 == 675 || type2 == 989 || type2 == 1226 || type2 == 1227) && itemAnimation != itemAnimationMax - 1)
@@ -29891,7 +_,7 @@
 
 					ItemCheck_TurretAltFeatureUse(item, flag4);
 					ItemCheck_MinionAltFeatureUse(item, flag4);
-					if (item.shoot > 0 && itemAnimation > 0 && ItemTimeIsZero && flag4)
+					if (item.shoot > 0 && itemAnimation > 0 && ItemTimeIsZero && flag4 && ItemLoader.CheckProjOnSwing(this, item))
 						ItemCheck_Shoot(i, item, weaponDamage);
 
 					ItemCheck_UseWiringTools(item);
@@ -29954,7 +_,8 @@
 
 						if (Main.myPlayer == i && item.damage > 0) {
 							int num = weaponDamage;
-							float knockBack = item.knockBack;
+							float knockBack = GetWeaponKnockback(item, item.knockBack);
+							/*
 							float num2 = 1f;
 							if (kbGlove)
 								num2 += 1f;
@@ -29965,6 +_,7 @@
 							knockBack *= num2;
 							if (inventory[selectedItem].type == 3106)
 								knockBack += knockBack * (1f - stealth);
+							*/
 
 							List<ushort> ignoreList2 = ItemCheck_GetTileCutIgnoreList(item);
 							ItemCheck_CutTiles(item, itemRectangle, ignoreList2);
@@ -29976,27 +_,32 @@
 				}
 
 				if (ItemTimeIsZero && itemAnimation > 0) {
+					if (ItemLoader.UseItem(item, this) == true)
+						ApplyItemTime(item, false);
+
 					if (item.hairDye >= 0) {
 						ApplyItemTime(item);
 						if (whoAmI == Main.myPlayer) {
-							hairDye = (byte)item.hairDye;
+							hairDye = item.hairDye;
 							NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 					}
 
 					if (item.healLife > 0) {
+						int healLife = GetHealLife(item);
-						statLife += item.healLife;
+						statLife += healLife;
 						ApplyItemTime(item);
-						if (Main.myPlayer == whoAmI)
-							HealEffect(item.healLife);
+						if (healLife > 0 && Main.myPlayer == whoAmI)
+							HealEffect(healLife, true);
 					}
 
 					if (item.healMana > 0) {
+						int healMana = GetHealMana(item);
-						statMana += item.healMana;
+						statMana += healMana;
 						ApplyItemTime(item);
-						if (Main.myPlayer == whoAmI) {
+						if (healMana > 0 && Main.myPlayer == whoAmI) {
 							AddBuff(94, manaSickTime);
-							ManaEffect(item.healMana);
+							ManaEffect(healMana);
 						}
 					}
 
@@ -30101,7 +_,7 @@
 					if (ItemTimeIsZero) {
 						ApplyItemTime(item);
 					}
-					else if (itemTime == item.useTime / 2) {
+					else if (itemTime == itemTimeMax / 2) {
 						for (int k = 0; k < 70; k++) {
 							Dust.NewDust(base.position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
 						}
@@ -30190,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30216,7 +_,7 @@
 							Main.dust[Dust.NewDust(base.position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30231,7 +_,7 @@
 						else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
 							NetMessage.SendData(73);
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 				}
@@ -30247,11 +_,11 @@
 								NetMessage.SendData(4, -1, -1, null, whoAmI);
 						}
 
-						if (item.stack > 0)
+						if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 							item.stack--;
 					}
 					else {
-						float num10 = item.useTime;
+						float num10 = itemTimeMax;
 						num10 = (num10 - (float)itemTime) / num10;
 						float num11 = 44f;
 						float num12 = (float)Math.PI * 3f;
@@ -30285,11 +_,12 @@
 				}
 
 				if (i == Main.myPlayer) {
-					if (!dontConsumeWand && itemTime == (int)((float)item.useTime * tileSpeed) && item.tileWand > 0) {
+					if (item.tileWand > 0 && !dontConsumeWand && itemTime == itemTimeMax) {
 						int tileWand = item.tileWand;
 						for (int num15 = 0; num15 < 58; num15++) {
 							if (tileWand == inventory[num15].type && inventory[num15].stack > 0) {
+								if (ItemLoader.ConsumeItem(inventory[num15], this))
-								inventory[num15].stack--;
+									inventory[num15].stack--;
 								if (inventory[num15].stack <= 0)
 									inventory[num15] = new Item();
 
@@ -30321,7 +_,7 @@
 						if (flag7.HasValue)
 							flag6 = flag7.Value;
 
-						if (flag6) {
+						if (flag6 && ItemLoader.ConsumeItem(item, this)) {
 							if (item.stack > 0)
 								item.stack--;
 
@@ -30342,6 +_,8 @@
 
 			if (itemAnimation == 0)
 				JustDroppedAnItem = false;
+
+			goto HandleItemHolding;
 		}
 
 		private void ItemCheck_EmitFoodParticles(Item sItem) {
@@ -30594,11 +_,18 @@
 				if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !itemRectangle.Intersects(player.Hitbox) || !CanHit(player))
 					continue;
 
+				if (!ItemLoader.CanHitPvp(sItem, this, player) || !PlayerLoader.CanHitPvp(this, sItem, player))
+					continue; //TODO: PvP crit hook?
+
 				bool flag = false;
 				if (Main.rand.Next(1, 101) <= 10)
 					flag = true;
 
 				int num = Main.DamageVar(damage, luck);
+
+				ItemLoader.ModifyHitPvp(sItem, this, player, ref num, ref flag);
+				PlayerLoader.ModifyHitPvp(this, sItem, player, ref num, ref flag);
+
 				StatusToPlayerPvP(sItem.type, i);
 				OnHit(player.Center.X, player.Center.Y, player);
 				PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayer(whoAmI);
@@ -30643,6 +_,8 @@
 				if (sItem.type == 1826 && Main.npc[i].value > 0f)
 					pumpkinSword(i, (int)((double)damage * 1.5), knockBack);
 
+				ItemLoader.OnHitPvp(sItem, this, Main.player[i], num2, flag);
+				PlayerLoader.OnHitPvp(this, sItem, Main.player[i], num2, flag);
 				if (Main.netMode != 0)
 					NetMessage.SendPlayerHurt(i, playerDeathReason, num, direction, flag, pvp: true, -1);
 
@@ -30657,11 +_,18 @@
 				if (!Main.npc[i].active || Main.npc[i].immune[whoAmI] != 0 || attackCD != 0)
 					continue;
 
+				bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, Main.npc[i]);
+
+				if (modCanHit == false) {
+					continue;
+				}
+
 				Main.npc[i].position += Main.npc[i].netOffset;
-				if (!Main.npc[i].dontTakeDamage && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[i])) {
-					if (!Main.npc[i].friendly || (Main.npc[i].type == 22 && killGuide) || (Main.npc[i].type == 54 && killClothier)) {
+				if (modCanHit == true || ((!Main.npc[i].dontTakeDamage && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[i])))) {
+					if (modCanHit == true || ((!Main.npc[i].friendly || (Main.npc[i].type == 22 && killGuide) || (Main.npc[i].type == 54 && killClothier)))) {
 						Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
+
-						if (itemRectangle.Intersects(value) && (Main.npc[i].noTileCollide || CanHit(Main.npc[i]))) {
+						if (modCanHit == true || (itemRectangle.Intersects(value) && (Main.npc[i].noTileCollide || CanHit(Main.npc[i])))) {
 							int num = originalDamage;
 							bool flag = false;
 							int weaponCrit = GetWeaponCrit(sItem);
@@ -30694,6 +_,11 @@
 							}
 
 							int num4 = Main.DamageVar(num, luck);
+
+							ItemLoader.ModifyHitNPC(sItem, this, Main.npc[i], ref num4, ref knockBack, ref flag);
+							NPCLoader.ModifyHitByItem(Main.npc[i], this, sItem, ref num4, ref knockBack, ref flag);
+							PlayerLoader.ModifyHitNPC(this, sItem, Main.npc[i], ref num4, ref knockBack, ref flag);
+
 							StatusToNPC(sItem.type, i);
 							if (Main.npc[i].life > 5)
 								OnHit(Main.npc[i].Center.X, Main.npc[i].Center.Y, Main.npc[i]);
@@ -30702,6 +_,11 @@
 								num4 += Main.npc[i].checkArmorPenetration(armorPenetration);
 
 							int dmgDone = (int)Main.npc[i].StrikeNPC(num4, knockBack, direction, flag);
+
+							ItemLoader.OnHitNPC(sItem, this, Main.npc[i], dmgDone, knockBack, flag);
+							NPCLoader.OnHitByItem(Main.npc[i], this, sItem, dmgDone, knockBack, flag);
+							PlayerLoader.OnHitNPC(this, sItem, Main.npc[i], dmgDone, knockBack, flag);
+
 							ApplyNPCOnHitEffects(sItem, itemRectangle, num, knockBack, i, num4, dmgDone);
 							int num5 = Item.NPCtoBanner(Main.npc[i].BannerID());
 							if (num5 >= 0)
@@ -31229,6 +_,9 @@
 				Main.dust[num30].velocity.Y *= 2f;
 			}
 
+			ItemLoader.MeleeEffects(sItem, this, itemRectangle);
+			PlayerLoader.MeleeEffects(this, sItem, itemRectangle);
+
 			return itemRectangle;
 		}
 
@@ -31285,6 +_,7 @@
 				}
 			}
 
+			ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
 			if (sItem.type == 1450 && Main.rand.Next(3) == 0) {
 				int num = -1;
 				float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
@@ -31596,7 +_,7 @@
 			if (Main.tileHammer[tile.type]) {
 				canHitWalls = false;
 				if (sItem.hammer > 0) {
-					num2 += sItem.hammer;
+					TileLoader.MineDamage(sItem.hammer, ref num2);
 					if (!WorldGen.CanKillTile(x, y))
 						num2 = 0;
 
@@ -31626,7 +_,10 @@
 				}
 			}
 			else if (Main.tileAxe[tile.type]) {
-				num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
+				if (tile.type == 80)
+					num2 += (int)(sItem.axe * 3 * 1.2f);
+				else
+					TileLoader.MineDamage(sItem.axe, ref num2);
 				if (sItem.axe > 0) {
 					AchievementsHelper.CurrentlyMining = true;
 					if (!WorldGen.CanKillTile(x, y))
@@ -31774,7 +_,9 @@
 					if (!poundRelease)
 						return;
 
+					if (TileLoader.Slope(x, y, Main.tile[x, y].type)) {
+					}
-					if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
+					else if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
 						if (tile.halfBrick()) {
 							WorldGen.PoundTile(x, y);
 							if (Main.netMode == 1)
@@ -32023,7 +_,7 @@
 			}
 		}
 
-		private bool IsTargetTileInItemRange(Item sItem) {
+		public bool IsTargetTileInItemRange(Item sItem) {
 			if (position.X / 16f - (float)tileRangeX - (float)sItem.tileBoost <= (float)tileTargetX && (position.X + (float)width) / 16f + (float)tileRangeX + (float)sItem.tileBoost - 1f >= (float)tileTargetX && position.Y / 16f - (float)tileRangeY - (float)sItem.tileBoost <= (float)tileTargetY)
 				return (position.Y + (float)height) / 16f + (float)tileRangeY + (float)sItem.tileBoost - 2f >= (float)tileTargetY;
 
@@ -32366,7 +_,8 @@
 				}
 
 				if (num3 >= 0 && WorldGen.PlaceWire(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num3], this))
-					inventory[num3].stack--;
+						inventory[num3].stack--;
 					if (inventory[num3].stack <= 0)
 						inventory[num3].SetDefaults();
 
@@ -32384,7 +_,8 @@
 				}
 
 				if (num4 >= 0 && WorldGen.PlaceWire2(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num4], this))
-					inventory[num4].stack--;
+						inventory[num4].stack--;
 					if (inventory[num4].stack <= 0)
 						inventory[num4].SetDefaults();
 
@@ -32403,7 +_,8 @@
 				}
 
 				if (num5 >= 0 && WorldGen.PlaceWire3(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num5], this))
-					inventory[num5].stack--;
+						inventory[num5].stack--;
 					if (inventory[num5].stack <= 0)
 						inventory[num5].SetDefaults();
 
@@ -32422,7 +_,8 @@
 				}
 
 				if (num6 >= 0 && WorldGen.PlaceWire4(num, num2)) {
+					if (ItemLoader.ConsumeItem(inventory[num6], this))
-					inventory[num6].stack--;
+						inventory[num6].stack--;
 					if (inventory[num6].stack <= 0)
 						inventory[num6].SetDefaults();
 
@@ -32455,7 +_,8 @@
 			else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2)) {
 				ApplyItemTime(sItem);
 				NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
+				if (ItemLoader.ConsumeItem(sItem, this))
-				sItem.stack--;
+					sItem.stack--;
 				if (sItem.stack <= 0)
 					sItem.SetDefaults();
 			}
@@ -32533,6 +_,9 @@
 		}
 
 		private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage) {
+			if (!CombinedHooks.CanShoot(this, sItem))
+				return;
+
 			int projToShoot = sItem.shoot;
 			float speed = sItem.shootSpeed;
 			int damage = sItem.damage;
@@ -32542,7 +_,9 @@
 			bool canShoot = false;
 			int Damage = weaponDamage;
 			float KnockBack = sItem.knockBack;
+
+			// WhoAmI check added by TML.
-			if (projToShoot == 13 || projToShoot == 32 || projToShoot == 315 || (projToShoot >= 230 && projToShoot <= 235) || projToShoot == 331) {
+			if (whoAmI == Main.myPlayer && (projToShoot == 13 || projToShoot == 32 || projToShoot == 315 || (projToShoot >= 230 && projToShoot <= 235) || projToShoot == 331)) {
 				grappling[0] = -1;
 				grapCount = 0;
 				for (int j = 0; j < 1000; j++) {
@@ -32612,6 +_,12 @@
 			}
 
 			if (canShoot) {
+				// Added by TML.
+				if (whoAmI != Main.myPlayer) {
+					ApplyItemTime(sItem);
+					return;
+				}
+
 				KnockBack = GetWeaponKnockback(sItem, KnockBack);
 				IProjectileSource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
 				if (projToShoot == 228)
@@ -32744,6 +_,13 @@
 					num3 = vector4.Y;
 				}
 
+				goto DirtBallShoot;
+				ShootHook:
+				Vector2 velocity = new Vector2(num2, num3);
+				CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
+				num2 = velocity.X;
+				num3 = velocity.Y;
+
 				if (sItem.useStyle == 5) {
 					if (sItem.type == 3029) {
 						Vector2 vector5 = new Vector2(num2, num3);
@@ -32780,6 +_,11 @@
 					NetMessage.SendData(41, -1, -1, null, whoAmI);
 				}
 
+				if (!CombinedHooks.Shoot(this, sItem, (ProjectileSource_Item_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
+					return;
+
+				goto ShootProj;
+				DirtBallShoot:
 				if (projToShoot == 17) {
 					pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
 					pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
@@ -32788,6 +_,8 @@
 
 					LimitPointToPlayerReachableArea(ref pointPoisition);
 				}
+				goto ShootHook;
+				ShootProj:
 
 				if (projToShoot == 76) {
 					projToShoot += Main.rand.Next(3);
@@ -33963,6 +_,10 @@
 				}
 			}
 			else if (sItem.useStyle == 5 || sItem.useStyle == 13) {
+				// Added by TML.
+				if (whoAmI != Main.myPlayer)
+					return;
+
 				itemRotation = 0f;
 				NetMessage.SendData(41, -1, -1, null, whoAmI);
 			}
@@ -33994,7 +_,7 @@
 			return startPos;
 		}
 
-		private int SpawnMinionOnCursor(IProjectileSource projectileSource, int ownerIndex, int minionProjectileId, int originalDamageNotScaledByMinionDamage, float KnockBack, Vector2 offsetFromCursor = default(Vector2), Vector2 velocityOnSpawn = default(Vector2)) {
+		public int SpawnMinionOnCursor(IProjectileSource projectileSource, int ownerIndex, int minionProjectileId, int originalDamageNotScaledByMinionDamage, float KnockBack, Vector2 offsetFromCursor = default(Vector2), Vector2 velocityOnSpawn = default(Vector2)) {
 			Vector2 pointPoisition = Main.MouseWorld;
 			pointPoisition += offsetFromCursor;
 			LimitPointToPlayerReachableArea(ref pointPoisition);
@@ -34164,6 +_,11 @@
 		private void ItemCheck_MinionAltFeatureUse(Item sItem, bool cShoot) {
 			if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero) {
 				ApplyItemTime(sItem);
+
+				// Added by TML.
+				if (whoAmI != Main.myPlayer)
+					return;
+
 				MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
 			}
 		}
@@ -34173,6 +_,11 @@
 				return;
 
 			ApplyItemTime(sItem);
+
+			// Added by TML.
+			if(whoAmI != Main.myPlayer)
+				return;
+
 			for (int i = 0; i < 1000; i++) {
 				Projectile projectile = Main.projectile[i];
 				if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
@@ -34485,6 +_,10 @@
 		}
 
 		private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.HoldStyle(sItem, this, heldItemFrame);
+		}
+		private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (isPettingAnimal) {
 				int num = miscCounter % 14 / 7;
 				CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
@@ -34727,10 +_,12 @@
 				SetCompositeArmBack(enabled: true, stretch6, (float)Math.PI * -3f / 5f * (float)direction);
 				FlipItemLocationAndRotationForGravity();
 			}
+			// else if(!Main.dedServ)
+				// ItemLoader.UseStyle(sItem, this);
 		}
 
 		private void ItemCheck_ApplyManaRegenDelay(Item sItem) {
-			if (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))
+ 			if (GetManaCost(sItem)>0)
 				manaRegenDelay = (int)maxRegenDelay;
 		}
 
@@ -34791,6 +_,10 @@
 		}
 
 		public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame) {
+			ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
+			ItemLoader.UseStyle(sItem, this, heldItemFrame);
+		}
+		public void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame) {
 			if (Main.dedServ)
 				return;
 
@@ -35514,6 +_,9 @@
 		}
 
 		private bool ItemCheck_CheckCanUse(Item sItem) {
+			if(!CombinedHooks.CanUseItem(this, sItem))
+				return false;
+
 			int whoAmI = base.whoAmI;
 			bool flag = true;
 			int num = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
@@ -35881,6 +_,11 @@
 			if (sItem.type == 3006)
 				flag2 = true;
 
+			if (sItem.type != ItemID.MedusaHead /*3269*/ && !CheckMana(sItem, pay:!flag2))
+				canUse = false;
+			
+			return canUse; //TODO: Explain this in a comment.
+			
 			if (sItem.type != 3269 && (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))) {
 				if (statMana >= num) {
 					if (!flag2)
@@ -36046,9 +_,19 @@
 		}
 
 		private void ItemCheck_HandleMPItemAnimation(Item sItem) {
+			//return;
+
 			if (sItem.autoReuse && !noItems) {
 				releaseUseItem = true;
+				
+				// The following lines of code have been removed because of the change in how remote players' items now work in multiplayer. 
+				// Remote players used to simulate using the items by just playing pretty much guessed animations.
+				// But now they instead run the logic the same way they would run locally, besides for authority-based exceptions.
+				// -- Mirsario
+
+				/*
 				if (itemAnimation == 1 && sItem.stack > 0) {
+					itemAnimation = 0;
 					if (sItem.shoot > 0 && whoAmI != Main.myPlayer && controlUseItem && sItem.useStyle == 5 && sItem.reuseDelay == 0) {
 						ApplyItemAnimation(sItem);
 						if (sItem.UseSound != null)
@@ -36058,6 +_,7 @@
 						itemAnimation = 0;
 					}
 				}
+				*/
 			}
 
 			TryAllowingItemReuse(sItem);
@@ -36078,6 +_,7 @@
 			if (!mount.Active)
 				return;
 
+			MountLoader.UseAbility(this, Vector2.Zero, false);
 			if (mount.Type == 8) {
 				noItems = true;
 				if (controlUseItem) {
@@ -36235,7 +_,7 @@
 				if (num == 2)
 					num = 102;
 
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] == 27 || buffType[i] == 101 || buffType[i] == 102) {
 						DelBuff(i);
 						i--;
@@ -36393,6 +_,7 @@
 		}
 
 		public float GetWeaponKnockback(Item sItem, float KnockBack) {
+			/*
 			if (sItem.summon)
 				KnockBack += minionKB;
 
@@ -36407,11 +_,25 @@
 
 			if (sItem.ranged && setVortex)
 				KnockBack *= 1f + (1f - stealth) * 0.5f;
-
-			return KnockBack;
+			*/
+
+			// implement minionKB as 'base damage'
+			KnockBack += minionKB * sItem.DamageType.GetCachedBenefitFrom(DamageClass.Summon);
+
+			StatModifier kbModifier = StatModifier.One;
+			var currentModifiers = damageData;
+			var scalings = sItem.DamageType.benefitsCache;
+			for (int i = 0; i < currentModifiers.Length; i++) {
+				kbModifier = kbModifier.CombineWith(currentModifiers[i].knockback.Scale(scalings[i]));
+			}
+
+			float flat = 0;
+			CombinedHooks.ModifyWeaponKnockback(this, sItem, ref kbModifier, ref flat);
+			return Math.Max(0, KnockBack * kbModifier + flat);
 		}
 
 		public int GetWeaponCrit(Item sItem) {
+			/*
 			if (sItem.melee)
 				return meleeCrit;
 
@@ -36422,9 +_,21 @@
 				return magicCrit;
 
 			return 0;
+			*/
+
+			int crit = sItem.crit;
+			var currentModifiers = damageData;
+			var scalings = sItem.DamageType.benefitsCache;
+			for (int i = 0; i < currentModifiers.Length; i++) {
+				crit += (int)(currentModifiers[i].critChance * scalings[i]);
+			}
+
+			CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
+			return crit;
 		}
 
 		public int GetWeaponDamage(Item sItem) {
+			/*
 			int num = sItem.damage;
 			if (num > 0) {
 				if (sItem.melee) {
@@ -36450,6 +_,29 @@
 			}
 
 			return num;
+			*/
+
+			StatModifier damage = StatModifier.One;
+			var currentModifiers = damageData;
+			var scalings = sItem.DamageType.benefitsCache;
+			for (int i = 0; i < currentModifiers.Length; i++) {
+				damage = damage.CombineWith(currentModifiers[i].damage.Scale(scalings[i]));
+			}
+
+			// TODO: use an ItemID.Sets for arrow/bullet/rocket
+			if (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake)
+				damage = damage.CombineWith(arrowDamage);
+
+			if (sItem.useAmmo == AmmoID.Bullet || sItem.useAmmo == AmmoID.CandyCorn)
+				damage = damage.CombineWith(bulletDamage);
+
+			if (sItem.useAmmo == AmmoID.Rocket || sItem.useAmmo == AmmoID.StyngerBolt || sItem.useAmmo == AmmoID.JackOLantern || sItem.useAmmo == AmmoID.NailFriendly)
+				damage = damage.CombineWith(rocketDamage);
+
+			float flat = 0f;
+			CombinedHooks.ModifyWeaponDamage(this, sItem, ref damage, ref flat);
+			int damageNum = (int)((sItem.damage * (float)damage) + flat);
+			return Math.Max(0, damageNum);
 		}
 
 		public bool HasAmmo(Item sItem, bool canUse) {
@@ -36516,8 +_,11 @@
 			int pickedProjectileId = -1;
 			if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
 				projToShoot = pickedProjectileId;
-			else if (sItem.type == 1946)
+			else if (sItem.type == 1946) {
 				projToShoot = 338 + item.type - 771;
+				if (projToShoot > ProjectileID.RocketSnowmanIV)
+					projToShoot = ProjectileID.RocketSnowmanIV;
+			}
 			else if (sItem.type == 3930)
 				projToShoot = 715 + item.type - AmmoID.Rocket;
 			else if (sItem.useAmmo == AmmoID.Rocket)
@@ -36572,8 +_,14 @@
 
 			speed += item.shootSpeed;
 			if (item.ranged) {
-				if (item.damage > 0)
-					Damage += (int)((float)item.damage * rangedDamage);
+				if (item.damage > 0) {
+					// determine damage multiplier using item base damage and apply to ammo
+					// equivalent to Damage *= (item.damage + sItem.damage) / sItem.damage
+					if (sItem.damage > 0) // coin gun fix.
+						Damage += (int)(item.damage * Damage / (float)sItem.damage);
+					else
+						Damage += item.damage;
+				}
 			}
 			else {
 				Damage += item.damage;
@@ -36585,11 +_,12 @@
 					if (speed > 20f)
 						speed = 20f;
 				}
-
-				Damage = (int)((double)Damage * 1.2);
+				// archery buff damage moved into UpdateBuffs
+				// Damage = (int)((double)Damage * 1.2);
 			}
 
 			KnockBack += item.knockBack;
+			ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref Damage, ref KnockBack);
 			bool flag2 = dontConsume;
 			if (sItem.type == 3475 && Main.rand.Next(3) != 0)
 				flag2 = true;
@@ -36627,10 +_,15 @@
 			if (sItem.type == 1553 && Main.rand.Next(3) != 0)
 				flag2 = true;
 
+			// Clockwork Assault Rifle.
+			// The offset of '-2' doesn't quite matter. The goal is to only use ammo on the first shot.
-			if (sItem.type == 434 && itemAnimation < sItem.useAnimation - 2)
+			//if (sItem.type == 434 && itemAnimation < sItem.useAnimation - 2)
+			if (sItem.type == 434 && itemAnimation < itemAnimationMax)
 				flag2 = true;
 
+			// Same as above.
-			if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
+			//if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
+			if (sItem.type == 4953 && itemAnimation < itemAnimationMax)
 				flag2 = true;
 
 			if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
@@ -36645,13 +_,20 @@
 			if (ammoCost75 && Main.rand.Next(4) == 0)
 				flag2 = true;
 
+			// Flamethrower.
+			// Unlike with Clockwork Assault Rifle, here we want to keep the feature-bug of Unreal modifier flamethrowers consuming 2 gel instead of 1 per click (less when holding.)
+			// So we just adjust the offset to be in-line with itemAnim changes.
+			//if (projToShoot == 85 && itemAnimation < itemAnimationMax - 6)
-			if (projToShoot == 85 && itemAnimation < itemAnimationMax - 6)
+			if (projToShoot == 85 && itemAnimation < itemAnimationMax - 5)
 				flag2 = true;
 
 			if ((projToShoot == 145 || projToShoot == 146 || projToShoot == 147 || projToShoot == 148 || projToShoot == 149) && itemAnimation < itemAnimationMax - 5)
 				flag2 = true;
 
+			flag2 |= !PlayerLoader.ConsumeAmmo(this, sItem, item) | !ItemLoader.ConsumeAmmo(sItem, item, this);
 			if (!flag2 && item.consumable) {
+				PlayerLoader.OnConsumeAmmo(this, sItem, item);
+				ItemLoader.OnConsumeAmmo(sItem, item, this);
 				item.stack--;
 				if (item.stack <= 0) {
 					item.active = false;
@@ -36693,7 +_,7 @@
 						NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
 					}
 
-					if (Main.tile[x, y].type == 21)
+					if (Main.tile[x, y].type == 21 || Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type])
 						NetMessage.SendData(34, -1, -1, null, 1, x, y);
 
 					if (Main.tile[x, y].type == 467)
@@ -36701,11 +_,20 @@
 
 					if (Main.tile[x, y].type == 88)
 						NetMessage.SendData(34, -1, -1, null, 3, x, y);
+
+					if (Main.tile[x, y].type >= TileID.Count) {
+						if (TileID.Sets.BasicChest[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type, 0);
+
+						if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
+							NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type, 0);
+					}
 				}
 				else {
 					bool num3 = Main.tile[x, y].active();
 					WorldGen.KillTile(x, y);
-					if (num3 && !Main.tile[x, y].active())
+
+					if (!Main.dedServ && num3 && !Main.tile[x, y].active())
 						AchievementsHelper.HandleMining();
 
 					if (Main.netMode == 1)
@@ -36775,7 +_,24 @@
 			if (Main.tileNoFail[tileTarget.type])
 				num = 100;
 
-			num = ((!Main.tileDungeon[tileTarget.type] && tileTarget.type != 25 && tileTarget.type != 58 && tileTarget.type != 117 && tileTarget.type != 203) ? ((tileTarget.type == 85) ? (num + pickPower / 3) : ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2))) : (num + pickPower / 2));
+			if(Main.tileDungeon[tileTarget.type] || tileTarget.type == 25 || tileTarget.type == 58 || tileTarget.type == 117 || tileTarget.type == 203)
+				num += pickPower / 2;
+			else if(tileTarget.type == 85)
+				num += pickPower / 3;
+			else if(tileTarget.type == 48 || tileTarget.type == 232)
+				num += pickPower * 2;
+			else if(tileTarget.type == 226)
+				num += pickPower / 4;
+			else if(tileTarget.type == 107 || tileTarget.type == 221)
+				num += pickPower / 2;
+			else if(tileTarget.type == 108 || tileTarget.type == 222)
+				num += pickPower / 3;
+			else if(tileTarget.type == 111 || tileTarget.type == 223)
+				num += pickPower / 4;
+			else if(tileTarget.type == 211)
+				num += pickPower / 5;
+			else
+				TileLoader.MineDamage(pickPower, ref num);
 			if (tileTarget.type == 211 && pickPower < 200)
 				num = 0;
 
@@ -36830,6 +_,9 @@
 			else if (tileTarget.type == 223 && pickPower < 150) {
 				num = 0;
 			}
+			else {
+				TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
+			}
 
 			if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
 				num += pickPower;
@@ -37121,24 +_,47 @@
 		}
 
 		public void DropItems() {
+			List<Item> startInventory = PlayerLoader.GetStartingItems(this, DropItems_GetDefaults().Where(item => !item.IsAir), true);
+			IDictionary<int, int> startCounts = new Dictionary<int, int>();
+
+			foreach (Item item in startInventory) {
+				if (!startCounts.ContainsKey(item.netID))
+					startCounts[item.netID] = 0;
+
+				startCounts[item.netID] += item.stack;
+			}
+
+			startCounts[ModContent.ItemType<ModLoader.Default.StartBag>()] = 1;
 			for (int i = 0; i < 59; i++) {
 				if (inventory[i].stack > 0) {
+					Item item = inventory[i];
 					bool flag = true;
-					if (inventory[i].type == 3507 || inventory[i].type == 3506 || inventory[i].type == 3509)
+					if (startCounts.TryGetValue(item.netID, out int startingCount) && startingCount >= item.stack)
 						flag = false;
 
 					if (flag) {
+						int stack = item.stack;
+						if (startCounts.ContainsKey(item.netID)) {
+							stack -= startCounts[item.netID];
+							startCounts[item.netID] = 0;
+						}
+
 						int num = Item.NewItem((int)position.X, (int)position.Y, width, height, inventory[i].type);
 						Main.item[num].netDefaults(inventory[i].netID);
 						Main.item[num].Prefix(inventory[i].prefix);
-						Main.item[num].stack = inventory[i].stack;
+						Main.item[num].stack = stack;
 						Main.item[num].velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
 						Main.item[num].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num].noGrabDelay = 100;
 						Main.item[num].newAndShiny = false;
+						Main.item[num].ModItem = item.ModItem;
+						Main.item[num].globalItems = item.globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num);
 					}
+					else if (item.stack > 0 && startCounts.ContainsKey(item.netID)) {
+						startCounts[item.netID] -= item.stack;
+					}
 				}
 
 				inventory[i].TurnToAir();
@@ -37152,6 +_,8 @@
 						Main.item[num2].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num2].noGrabDelay = 100;
 						Main.item[num2].newAndShiny = false;
+						Main.item[num2].ModItem = armor[i].ModItem;
+						Main.item[num2].globalItems = armor[i].globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num2);
 					}
@@ -37169,6 +_,8 @@
 						Main.item[num3].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num3].noGrabDelay = 100;
 						Main.item[num3].newAndShiny = false;
+						Main.item[num3].ModItem = dye[i].ModItem;
+						Main.item[num3].globalItems = dye[i].globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num3);
 					}
@@ -37186,6 +_,8 @@
 						Main.item[num4].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 						Main.item[num4].noGrabDelay = 100;
 						Main.item[num4].newAndShiny = false;
+						Main.item[num4].ModItem = miscEquips[i].ModItem;
+						Main.item[num4].globalItems = miscEquips[i].globalItems;
 						if (Main.netMode == 1)
 							NetMessage.SendData(21, -1, -1, null, num4);
 					}
@@ -37205,6 +_,8 @@
 					Main.item[num5].velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 					Main.item[num5].noGrabDelay = 100;
 					Main.item[num5].newAndShiny = false;
+					Main.item[num5].ModItem = miscDyes[i].ModItem;
+					Main.item[num5].globalItems = miscDyes[i].globalItems;
 					if (Main.netMode == 1)
 						NetMessage.SendData(21, -1, -1, null, num5);
 				}
@@ -37212,12 +_,26 @@
 				miscDyes[i].TurnToAir();
 			}
 
+			DropItems_End(startInventory);
+		}
+		private IEnumerable<Item> DropItems_GetDefaults() { //Split by tML.
+			var inventory = new Item[this.inventory.Length];
+
+			for (int i = 0; i < inventory.Length; i++) {
+				inventory[i] = new Item();
+			}
+
 			inventory[0].SetDefaults(3507);
 			inventory[0].Prefix(-1);
 			inventory[1].SetDefaults(3509);
 			inventory[1].Prefix(-1);
 			inventory[2].SetDefaults(3506);
 			inventory[2].Prefix(-1);
+
+			return inventory;
+		}
+		private void DropItems_End(IList<Item> startInventory) { //Split by tML.
+			PlayerLoader.SetStartInventory(this, startInventory);
 			Main.mouseItem.TurnToAir();
 		}
 
@@ -37272,6 +_,7 @@
 			player.zone4 = zone4;
 			player.voidVaultInfo = voidVaultInfo;
 			player.luck = luck;
+			BiomeLoader.CopyCustomBiomesTo(this, player);
 			player.extraAccessory = extraAccessory;
 			player.MinionRestTargetPoint = MinionRestTargetPoint;
 			player.MinionAttackTargetNPC = MinionAttackTargetNPC;
@@ -37322,13 +_,14 @@
 			}
 
 			player.trashItem = trashItem.Clone();
-			for (int j = 0; j < 22; j++) {
+			for (int j = 0; j < MaxBuffs; j++) {
 				player.buffType[j] = buffType[j];
 				player.buffTime[j] = buffTime[j];
 			}
 
 			DpadRadial.CopyTo(player.DpadRadial);
 			CircularRadial.CopyTo(player.CircularRadial);
+			PlayerLoader.clientClone(this, player);
 			return player;
 		}
 
@@ -37347,7 +_,7 @@
 			if (Main.tile[x, y - 1] == null)
 				return false;
 
-			if (!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != 79)
+			if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
 				return false;
 
 			for (int i = x - 1; i <= x + 1; i++) {
@@ -37479,6 +_,7 @@
 			if (path == null || path == "")
 				return;
 
+			BackupIO.Player.ArchivePlayer(path, isCloudSave);
 			if (FileUtilities.Exists(path, isCloudSave))
 				FileUtilities.Copy(path, path + ".bak", isCloudSave);
 
@@ -37486,13 +_,14 @@
 			using (Stream stream = isCloudSave ? ((Stream)new MemoryStream(2000)) : ((Stream)new FileStream(path, FileMode.Create))) {
 				using (CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write)) {
 					using (BinaryWriter binaryWriter = new BinaryWriter(cryptoStream)) {
+						PlayerLoader.PreSavePlayer(player);
 						binaryWriter.Write(238);
 						playerFile.Metadata.Write(binaryWriter);
 						binaryWriter.Write(player.name);
 						binaryWriter.Write(player.difficulty);
 						binaryWriter.Write(playerFile.GetPlayTime().Ticks);
 						binaryWriter.Write(player.hair);
-						binaryWriter.Write(player.hairDye);
+						PlayerIO.WriteByteVanillaHairDye(player.hairDye, binaryWriter);
 						BitsByte bb = (byte)0;
 						for (int i = 0; i < 8; i++) {
 							bb[i] = player.hideVisibleAccessory[i];
@@ -37538,63 +_,57 @@
 						binaryWriter.Write(player.shoeColor.G);
 						binaryWriter.Write(player.shoeColor.B);
 						for (int k = 0; k < player.armor.Length; k++) {
-							binaryWriter.Write(player.armor[k].netID);
-							binaryWriter.Write(player.armor[k].prefix);
+							ItemIO.WriteVanillaID(player.armor[k], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.armor[k], binaryWriter);
 						}
 
 						for (int l = 0; l < player.dye.Length; l++) {
-							binaryWriter.Write(player.dye[l].netID);
-							binaryWriter.Write(player.dye[l].prefix);
+							ItemIO.WriteVanillaID(player.dye[l], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.dye[l], binaryWriter);
 						}
 
 						for (int m = 0; m < 58; m++) {
-							binaryWriter.Write(player.inventory[m].netID);
+							ItemIO.WriteVanillaID(player.inventory[m], binaryWriter);
 							binaryWriter.Write(player.inventory[m].stack);
-							binaryWriter.Write(player.inventory[m].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.inventory[m], binaryWriter);
 							binaryWriter.Write(player.inventory[m].favorited);
 						}
 
 						for (int n = 0; n < player.miscEquips.Length; n++) {
-							binaryWriter.Write(player.miscEquips[n].netID);
-							binaryWriter.Write(player.miscEquips[n].prefix);
-							binaryWriter.Write(player.miscDyes[n].netID);
-							binaryWriter.Write(player.miscDyes[n].prefix);
+							ItemIO.WriteVanillaID(player.miscEquips[n], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.miscEquips[n], binaryWriter);
+							ItemIO.WriteVanillaID(player.miscDyes[n], binaryWriter);
+							ItemIO.WriteByteVanillaPrefix(player.miscDyes[n], binaryWriter);
 						}
 
 						for (int num = 0; num < 40; num++) {
-							binaryWriter.Write(player.bank.item[num].netID);
+							ItemIO.WriteVanillaID(player.bank.item[num], binaryWriter);
 							binaryWriter.Write(player.bank.item[num].stack);
-							binaryWriter.Write(player.bank.item[num].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank.item[num], binaryWriter);
 						}
 
 						for (int num2 = 0; num2 < 40; num2++) {
-							binaryWriter.Write(player.bank2.item[num2].netID);
+							ItemIO.WriteVanillaID(player.bank2.item[num2], binaryWriter);
 							binaryWriter.Write(player.bank2.item[num2].stack);
-							binaryWriter.Write(player.bank2.item[num2].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank2.item[num2], binaryWriter);
 						}
 
 						for (int num3 = 0; num3 < 40; num3++) {
-							binaryWriter.Write(player.bank3.item[num3].netID);
+							ItemIO.WriteVanillaID(player.bank3.item[num3], binaryWriter);
 							binaryWriter.Write(player.bank3.item[num3].stack);
-							binaryWriter.Write(player.bank3.item[num3].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank3.item[num3], binaryWriter);
 						}
 
 						for (int num4 = 0; num4 < 40; num4++) {
-							binaryWriter.Write(player.bank4.item[num4].netID);
+							ItemIO.WriteVanillaID(player.bank4.item[num4], binaryWriter);
 							binaryWriter.Write(player.bank4.item[num4].stack);
-							binaryWriter.Write(player.bank4.item[num4].prefix);
+							ItemIO.WriteByteVanillaPrefix(player.bank4.item[num4], binaryWriter);
 						}
 
 						binaryWriter.Write(player.voidVaultInfo);
 						for (int num5 = 0; num5 < 22; num5++) {
-							if (Main.buffNoSave[player.buffType[num5]]) {
-								binaryWriter.Write(0);
+							binaryWriter.Write(0);
-								binaryWriter.Write(0);
+							binaryWriter.Write(0);
-							}
-							else {
-								binaryWriter.Write(player.buffType[num5]);
-								binaryWriter.Write(player.buffTime[num5]);
-							}
 						}
 
 						for (int num6 = 0; num6 < 200; num6++) {
@@ -37610,7 +_,7 @@
 						}
 
 						binaryWriter.Write(player.hbLocked);
-						for (int num7 = 0; num7 < player.hideInfo.Length; num7++) {
+						for (int num7 = 0; num7 < 13; num7++) {
 							binaryWriter.Write(player.hideInfo[num7]);
 						}
 
@@ -37639,9 +_,13 @@
 						stream.Flush();
 						if (isCloudSave && SocialAPI.Cloud != null)
 							SocialAPI.Cloud.Write(playerFile.Path, ((MemoryStream)stream).ToArray());
+
+						PlayerLoader.PostSavePlayer(player);
 					}
 				}
 			}
+
+			PlayerIO.Save(player, path, isCloudSave);
 		}
 
 		private void SaveTemporaryItemSlotContents(BinaryWriter writer) {
@@ -38083,7 +_,7 @@
 							if (num >= 11) {
 								int num28 = 22;
 								if (num < 74)
-									num28 = 10;
+									num28 -= 12;
 
 								for (int num29 = 0; num29 < num28; num29++) {
 									player.buffType[num29] = binaryReader.ReadInt32();
@@ -38173,7 +_,7 @@
 							if (num >= 220)
 								CreativePowerManager.Instance.LoadToPlayer(player, binaryReader, num);
 
-							LoadPlayer_LastMinuteFixes(player);
+							LoadPlayer_LastMinuteFixes(player, playerFileData);
 						}
 					}
 				}
@@ -38183,6 +_,9 @@
 				playerFileData.Player = player;
 				return playerFileData;
 			}
+			catch (CustomModDataException e) {
+				playerFileData.customDataFail = e;
+			}
 			catch {
 			}
 
@@ -38213,8 +_,9 @@
 			}
 		}
 
-		private static void LoadPlayer_LastMinuteFixes(Player newPlayer) {
+		private static void LoadPlayer_LastMinuteFixes(Player newPlayer, PlayerFileData playerFileData) {
 			newPlayer.skinVariant = (int)MathHelper.Clamp(newPlayer.skinVariant, 0f, 11f);
+			PlayerIO.Load(newPlayer, playerFileData.Path, playerFileData.IsCloudSave);
 			for (int i = 3; i < 10; i++) {
 				int type = newPlayer.armor[i].type;
 				if (type == 908 || type == 4874 || type == 5000)
@@ -38231,6 +_,7 @@
 
 				newPlayer.lavaTime = newPlayer.lavaMax;
 			}
+			newPlayer.ResetEffects();
 		}
 
 		public static PlayerFileData GetFileData(string file, bool cloudSave) {
@@ -38240,12 +_,17 @@
 			PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
 			if (playerFileData.Player != null) {
 				if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1) {
+					CustomModDataException customDataFail = playerFileData.customDataFail;
-					if (FileUtilities.Exists(file + ".bak", cloudSave))
+					if (FileUtilities.Exists(file + ".bak", cloudSave)) {
 						FileUtilities.Move(file + ".bak", file, cloudSave);
+						PlayerIO.LoadBackup(file, cloudSave);
+					}
 
 					playerFileData = LoadPlayer(file, cloudSave);
 					if (playerFileData.Player == null)
 						return null;
+
+					playerFileData.customDataFail = customDataFail;
 				}
 
 				return playerFileData;
@@ -38296,6 +_,14 @@
 		}
 
 		public Player() {
+			ResetDamageClassData();
+			buffType = new int[MaxBuffs];
+			buffTime = new int[MaxBuffs];
+			buffImmune = new bool[BuffLoader.BuffCount]; // TODO: Move all these patches to field initializers.
+			ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
+			npcTypeNoAggro = new bool[NPCLoader.NPCCount];
+			PlayerLoader.SetupPlayer(this);
+			LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
 			width = 20;
 			height = 42;
 			name = string.Empty;
@@ -38336,7 +_,7 @@
 			grappling[0] = -1;
 			statManaMax = 20;
 			extraAccessory = false;
-			for (int n = 0; n < 624; n++) {
+			for (int n = 0; n < adjTile.Length; n++) {
 				adjTile[n] = false;
 				oldAdjTile[n] = false;
 			}
@@ -38564,6 +_,7 @@
 		}
 
 		public void GetAnglerReward() {
+			List<Item> rewardItems = new List<Item>();
 			Item item = new Item();
 			item.type = 0;
 			int num = anglerQuestsFinished;
@@ -38749,56 +_,23 @@
 					}
 			}
 
-			item.position = base.Center;
 			GetItemSettings nPCEntityToPlayerInventorySettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
-			Item item2 = GetItem(whoAmI, item, nPCEntityToPlayerInventorySettings);
-			if (item2.stack > 0) {
-				int number = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-				if (Main.netMode == 1)
-					NetMessage.SendData(21, -1, -1, null, number, 1f);
-			}
-
+			rewardItems.Add(item);
 			if (item.type == 2417) {
 				Item item3 = new Item();
 				Item item4 = new Item();
 				item3.SetDefaults(2418);
-				item3.position = base.Center;
-				item2 = GetItem(whoAmI, item3, nPCEntityToPlayerInventorySettings);
-				if (item2.stack > 0) {
-					int number2 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-					if (Main.netMode == 1)
-						NetMessage.SendData(21, -1, -1, null, number2, 1f);
-				}
-
+				rewardItems.Add(item3);
 				item4.SetDefaults(2419);
-				item4.position = base.Center;
-				item2 = GetItem(whoAmI, item4, nPCEntityToPlayerInventorySettings);
-				if (item2.stack > 0) {
-					int number3 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-					if (Main.netMode == 1)
-						NetMessage.SendData(21, -1, -1, null, number3, 1f);
-				}
+				rewardItems.Add(item4);
 			}
 			else if (item.type == 2498) {
 				Item item5 = new Item();
 				Item item6 = new Item();
 				item5.SetDefaults(2499);
-				item5.position = base.Center;
-				item2 = GetItem(whoAmI, item5, nPCEntityToPlayerInventorySettings);
-				if (item2.stack > 0) {
-					int number4 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-					if (Main.netMode == 1)
-						NetMessage.SendData(21, -1, -1, null, number4, 1f);
-				}
-
+				rewardItems.Add(item5);
 				item6.SetDefaults(2500);
-				item6.position = base.Center;
-				item2 = GetItem(whoAmI, item6, nPCEntityToPlayerInventorySettings);
-				if (item2.stack > 0) {
-					int number5 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-					if (Main.netMode == 1)
-						NetMessage.SendData(21, -1, -1, null, number5, 1f);
-				}
+				rewardItems.Add(item6);
 			}
 
 			Item item7 = new Item();
@@ -38830,16 +_,9 @@
 				item7.stack = num3;
 			}
 
-			item7.position = base.Center;
-			item2 = GetItem(whoAmI, item7, nPCEntityToPlayerInventorySettings);
-			if (item2.stack > 0) {
-				int number6 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
-				if (Main.netMode == 1)
-					NetMessage.SendData(21, -1, -1, null, number6, 1f);
-			}
-
+			rewardItems.Add(item7);
 			if (Main.rand.Next((int)(100f * num2)) > 50)
-				return;
+				goto postAnglerQuestCountCheck;
 
 			Item item8 = new Item();
 			if (Main.rand.Next((int)(15f * num2)) == 0)
@@ -38867,12 +_,18 @@
 			if (Main.rand.Next(250) <= num)
 				item8.stack++;
 
+			rewardItems.Add(item8);
+
+			postAnglerQuestCountCheck:
+			PlayerLoader.AnglerQuestReward(this, num2, rewardItems);
+			foreach (Item rewardItem in rewardItems) {
-			item8.position = base.Center;
+				rewardItem.position = Center;
-			item2 = GetItem(whoAmI, item8, GetItemSettings.NPCEntityToPlayerInventorySettings);
+				Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
-			if (item2.stack > 0) {
+				if (getItem.stack > 0) {
-				int number7 = Item.NewItem((int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
+					int number = Item.NewItem((int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
-				if (Main.netMode == 1)
+					if (Main.netMode == 1)
-					NetMessage.SendData(21, -1, -1, null, number7, 1f);
+						NetMessage.SendData(21, -1, -1, null, number, 1f);
+				}
 			}
 		}
 
@@ -39000,6 +_,7 @@
 					list.Add(3024);
 			}
 
+			PlayerLoader.GetDyeTraderReward(this, list);
 			num = list[Main.rand.Next(list.Count)];
 			Item item = new Item();
 			item.SetDefaults(num);
@@ -39013,6 +_,52 @@
 			}
 		}
 
+		public int GetManaCost(Item item) {
+			float reduce = manaCost;
+			float mult = 1;
+			if (spaceGun && (item.type == ItemID.SpaceGun || item.type == ItemID.ZapinatorGray && item.type == ItemID.ZapinatorOrange))
+				mult = 0;
+
+			if(item.type == ItemID.BookStaff && altFunctionUse == 2)
+				mult = 2;
+
+			CombinedHooks.ModifyManaCost(this, item, ref reduce, ref mult);
+			int mana = (int)(item.mana * reduce * mult);
+			return mana >= 0 ? mana : 0;
+		}
+
+		public bool CheckMana(Item item, int amount = -1, bool pay = false, bool blockQuickMana = false) {
+			if (amount <= -1)
+				amount = GetManaCost(item);
+
+			if (statMana >= amount) {
+				if (pay) {
+					CombinedHooks.OnConsumeMana(this, item, amount);
+					statMana -= amount;
+				}
+
+				return true;
+			}
+
+			if (blockQuickMana)
+				return false;
+
+			CombinedHooks.OnMissingMana(this, item, amount);
+			if (statMana < amount && manaFlower)
+				QuickMana();
+
+			if (statMana >= amount) {
+				if (pay) {
+					CombinedHooks.OnConsumeMana(this, item, amount);
+					statMana -= amount;
+				}
+
+				return true;
+			}
+
+			return false;
+		}
+
 		public bool CheckMana(int amount, bool pay = false, bool blockQuickMana = false) {
 			int num = (int)((float)amount * manaCost);
 			if (statMana >= num) {
@@ -39045,7 +_,7 @@
 		public bool ConsumeSolarFlare() {
 			if (setSolar && solarShields > 0) {
 				solarShields--;
-				for (int i = 0; i < 22; i++) {
+				for (int i = 0; i < MaxBuffs; i++) {
 					if (buffType[i] >= 170 && buffType[i] <= 172)
 						DelBuff(i);
 				}
@@ -39165,7 +_,7 @@
 				}
 			}
 
-			int damage = (int)(20f * (1f + magicDamage + minionDamage - 2f));
+			int damage = (int)(20f * (1f + (float)(allDamage.CombineWith(magicDamage)) + (float)(allDamage.CombineWith(minionDamage)) - 2f));
 			IProjectileSource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
 			_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
 		}
@@ -39284,7 +_,7 @@
 				return;
 
 			int timeToAdd = 480;
-			for (int i = 0; i < 22; i++) {
+			for (int i = 0; i < MaxBuffs; i++) {
 				if (buffType[i] >= type && buffType[i] < type + 3)
 					DelBuff(i);
 			}
