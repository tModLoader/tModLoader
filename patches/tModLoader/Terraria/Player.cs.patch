--- src/TerrariaNetCore/Terraria/Player.cs
+++ src/tModLoader/Terraria/Player.cs
@@ -1,6 +_,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Security.Cryptography;
 using System.Text;
 using Microsoft.Xna.Framework;
@@ -28,6 +_,10 @@
 using Terraria.ID;
 using Terraria.IO;
 using Terraria.Localization;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Exceptions;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
 using Terraria.ObjectData;
 using Terraria.Social;
 using Terraria.UI;
@@ -35,10 +_,11 @@
 using Terraria.UI.Gamepad;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using LegacySoundStyle = Terraria.Audio.SoundStyle;
 
 namespace Terraria;
 
-public class Player : Entity, IFixLoadedData
+public partial class Player : Entity, IFixLoadedData
 {
 	public static class BuilderAccToggleIDs
 	{
@@ -252,20 +_,33 @@
 		public static void PlayerConnect(int playerIndex)
 		{
 			PressurePlateHelper.ResetPlayer(playerIndex);
+
+			PlayerLoader.PlayerConnect(playerIndex);
 		}
 
 		public static void PlayerDisconnect(int playerIndex)
 		{
 			PressurePlateHelper.ResetPlayer(playerIndex);
+
+			PlayerLoader.PlayerDisconnect(playerIndex);
 		}
 
 		public static void EnterWorld(int playerIndex)
 		{
+			Logging.Terraria.InfoFormat("Entering world with player: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", Main.ActivePlayerFileData.Name, Main.ActivePlayerFileData.IsCloudSave, Main.maxTilesX, Main.maxTilesY, WorldGen.crimson.ToInt(), Main.GameMode);
+			Interface.ResetData();
+
 			if (Hooks.OnEnterWorld != null)
 				Hooks.OnEnterWorld(Main.player[playerIndex]);
 
+			PlayerLoader.OnEnterWorld(playerIndex);
+
-			if (playerIndex == Main.myPlayer)
+			if (playerIndex == Main.myPlayer) {
 				Main.ToggleGameplayUpdates(state: true);
+
+				// Added by TML.
+				Social.Steam.SteamedWraps.BeginPlaytimeTracking();
+			}
 		}
 	}
 
@@ -475,7 +_,7 @@
 
 	public int emoteTime;
 	public CreativeUnlocksTracker creativeTracker;
-	private static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
+	internal static byte[] ENCRYPTION_KEY = new UnicodeEncoding().GetBytes("h3y_gUyZ");
 	public OverheadMessage chatOverhead;
 	public SelectionRadial DpadRadial = new SelectionRadial();
 	public SelectionRadial CircularRadial = new SelectionRadial(SelectionRadial.SelectionMode.RadialCircular);
@@ -484,8 +_,8 @@
 	public int HotbarOffset;
 	public bool GoingDownWithGrapple;
 	public byte spelunkerTimer;
-	public bool[] hideInfo = new bool[13];
+	public bool[] hideInfo = new bool[InfoDisplayLoader.InfoDisplayCount];
-	public int[] builderAccStatus = new int[BuilderAccToggleIDs.Count];
+	public int[] builderAccStatus = new int[BuilderToggleLoader.BuilderToggleCount];
 	public long lostCoins;
 	public string lostCoinString = "";
 	public int soulDrain;
@@ -496,10 +_,18 @@
 	private static float _blizzardSoundVolume;
 	private static SlotId _strongBlizzardSound = SlotId.Invalid;
 	private static SlotId _insideBlizzardSound = SlotId.Invalid;
+
+	/// <summary>
+	/// This player's displayed name.
+	/// <br/> Usually capped at 20 characters.
+	/// </summary>
 	public string name = "";
 	public int taxMoney;
+
+	//TML: Both fields turned from int to double.
-	public int taxTimer;
+	public double taxTimer;
-	public static int taxRate = 3600;
+	public static double taxRate = 3600;
+
 	public int numberOfDeathsPVE;
 	public int numberOfDeathsPVP;
 	public static int crystalLeafDamage = 100;
@@ -589,20 +_,81 @@
 	public int ropeCount;
 	public int manaRegenBonus;
 	public float manaRegenDelayBonus;
+
+	/// <summary>
+	/// The current vanilla dash that the player is using.<br/>
+	/// The following values correspond to vanilla dashes:<br/>
+	/// 1 => Tabi / Master Ninja Gear<br/>
+	/// 2 => Shield of Cthulhu<br/>
+	/// 3 => Solar Flare armor set bonus<br/>
+	/// 4 => Unused, though a dash for this value DOES exist<br/>
+	/// 5 => Crystal Assassin set bonus<br/>
+	/// </summary>
 	public int dashType;
+
+	/// <summary>
+	/// The current vanilla dash that the player is VISIBLY using.<br/>
+	/// Unlike <see cref="dashType"/>, this does not update if a dash cannot currently be input.<br/>
+	/// </summary>
 	public int dash;
+
+	/// <summary>
+	/// The amount of time this player has left, in ticks, to input the second keystroke of a standard dash input (double-tap left/right).<br/>
+	/// For vanilla dashes, this window is 15 ticks, or a quarter of a second, in total.<br/>
+	/// </summary>
 	public int dashTime;
+
+	/// <summary>
+	/// The amount of time that has passed, in ticks, since this player last performed a dash.
+	/// </summary>
 	public int timeSinceLastDashStarted;
+
+	/// <summary>
+	/// The amount of time that has to pass, in ticks, before a new dash input will be registered.<br/>
+	/// For the first frame of any given dash, this is set to -1. After that frame has passed, it is set to 20 ticks, or 1/3 of a second.<br/>
+	/// For the Tabi dash, and when dashing into an enemy with the Shield of Cthulhu, this is set to 30 ticks, or 1/2 of a second, instead.<br/>
+	/// </summary>
 	public int dashDelay;
 	public int eocDash;
 	public int eocHit;
+	/// <summary>
+	/// Similar to <see cref="maxRunSpeed"/>, except this is usually set to a specific value for the active shoe accessory. If accRunSpeed ends up larger than maxRunSpeed, then sprint dust will spawn at high speeds. Basically, this exists to differentiate between sprinting ("run super fast") and running. 
+	/// <para/> Defaults to 3f. Accessories set this to specific values, resulting in the last equipped accessories to dictate the final value. Vanilla shoe accessories set this to <c>6f</c> (<see cref="ItemID.HermesBoots"/>) or <c>6.75</c> (<see cref="ItemID.LightningBoots"/>). This assignment should happen in <see cref="ModItem.UpdateEquip(Player)"/>.
+	/// <para/> This value is later multiplied by other effects in the same manner as <see cref="maxRunSpeed"/>. They are usually modified in tandem, but not always depending on the desired result. For example, asphalt triples maxRunSpeed but does not affect accRunSpeed, whereas Shadow Armor affects both equally.
+	/// <para/> These multiplicative adjustments should only be done in <see cref="ModPlayer.PostUpdateRunSpeeds"/> or <see cref="ModItem.HorizontalWingSpeeds"/> to correctly function.
+	/// <para/> When on a mount, all other modifiers are ignored and it is set to <see cref="Mount.DashSpeed"/>
+	/// </summary>
 	public float accRunSpeed;
 	public bool cordage;
 	public int gem = -1;
 	public int gemCount;
 	public BitsByte ownedLargeGems;
+
+	/// <summary>
+	/// The vanilla flask effect which the player currently has active; these affect all melee weapons and whips.<br/>
+	/// Defaults to 0, which denotes that the player does not currently have a flask active.<br/>
+	/// The following values correspond to vanilla flasks:<br/>
+	/// 1 => Flask of Venom (affected weapons proc Acid Venom on hit)<br/>
+	/// 2 => Flask of Cursed Flames (affected weapons proc Cursed Inferno on hit)<br/>
+	/// 3 => Flask of Fire (affected weapons proc On Fire! on hit)<br/>
+	/// 4 => Flask of Gold (affected weapons proc Midas on hit)<br/>
+	/// 5 => Flask of Ichor (affected weapons proc Ichor on hit)<br/>
+	/// 6 => Flask of Nanites (affected weapons proc Confused on hit)<br/>
+	/// 7 => Flask of Party (affected weapons sometimes release confetti explosions on hit)<br/>
+	/// 8 => Flask of Poison (affected weapons proc Poisoned on hit)<br/>
+	/// </summary>
+	// TODO:
+	// Transform to int later, make proper flask effect system maybe?
+	// Concrete use cases exist. Just gotta find a way to make a system for them intuitive.
+	// - Thomas
 	public byte meleeEnchant;
+	/// <summary>
+	/// While attached to a rope or similar tile (<see cref="pulley"/>), this value represents the how close to the rope the player is. A value of 1 means the player is centered on the rope, while a value of 2 represents that the player has nudged away from the rope but is still attached. <see cref="Entity.direction"/> is used still for the players direction.
+	/// </summary>
 	public byte pulleyDir;
+	/// <summary>
+	/// If true, the player is attached to a rope or similar tile.
+	/// </summary>
 	public bool pulley;
 	public int pulleyFrame;
 	public float pulleyFrameCounter;
@@ -610,8 +_,16 @@
 	public bool sliding;
 	public int slideDir;
 	public int snowBallLauncherInteractionCooldown;
+	/// <summary> Grant the player improved speed on ice and not breaking thin ice when falling onto it </summary>
 	public bool iceSkate;
 	public bool carpet;
+
+	/// <summary>
+	/// Used by the Shoe Spikes and Climbing Claws to allow for holding onto walls (of tiles, not to be confused with actual walls).<br/>
+	/// Defaults to 0. Any value higher than 0 allows the player to wall-jump.<br/>
+	/// A value of 1 causes the player to slowly slide down them while holding onto them.<br/>
+	/// A value of 2 or more doesn't give this limitation, allowing the player to stay holding onto a wall indefinitely.
+	/// </summary>
 	public int spikedBoots;
 	public int carpetFrame = -1;
 	public float carpetFrameCounter;
@@ -621,13 +_,22 @@
 	public int infernoCounter;
 	public int insanityShadowCooldown;
 	public int starCloakCooldown;
-	public bool sandStorm;
+	// Field added to make sandStorm rely on isPerformingJump_Sandstorm while still keeping vanilla behavior
+	private bool _sandStormLogicEnabled;
+	public bool sandStorm {
+		get => _sandStormLogicEnabled && GetJumpState<SandstormInABottleJump>().Active;
+		set => _sandStormLogicEnabled = value;
+	}
 	public bool crimsonRegen;
 	public bool ghostHeal;
 	public bool ghostHurt;
+	/// <summary> Player is on <see cref="TileID.HoneyBlock"/>. Affects movement parameters. </summary>
 	public bool sticky;
+	/// <summary> Player is on a <see cref="TileID.Sets.IceSkateSlippery"/> tile. Affects movement parameters. </summary>
 	public bool slippy;
+	/// <summary> Player is on <see cref="TileID.FrozenSlimeBlock"/>. Affects movement parameters. </summary>
 	public bool slippy2;
+	/// <summary> Player is on <see cref="TileID.Asphalt"/>. Affects movement parameters. </summary>
 	public bool powerrun;
 	public bool runningOnSand;
 	public bool flapSound;
@@ -635,11 +_,22 @@
 	public bool dangerSense;
 	public byte luckPotion;
 	public byte oldLuckPotion;
+
+	/// <summary>
+	/// The percent of damage this player should resist.
+	/// <br/> Has a soft cap of <c>1f</c>. Cannot reduce taken damage below <c>1</c>.
+	/// </summary>
 	public float endurance;
 	public float whipRangeMultiplier;
+	/*
 	public float whipUseTimeMultiplier;
+	*/
 	public bool loveStruck;
 	public bool stinky;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player will take 30% less damage from any NPC with <see cref="NPC.coldDamage"/> set and any projectile with <see cref="Projectile.coldDamage"/> set.
+	/// </summary>
 	public bool resistCold;
 	public bool electrified;
 	public bool dryadWard;
@@ -664,12 +_,28 @@
 	public int fishingSkill;
 	public bool cratePotion;
 	public bool sonarPotion;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player's fishing line will never break.
+	/// </summary>
 	public bool accFishingLine;
 	public bool accFishingBobber;
 	public bool accTackleBox;
 	public bool accLavaFishing;
+
+	/// <summary>
+	/// The maximum value of minions this player can have summoned at once.
+	/// <br/> A minion's value is stored as <see cref="Projectile.minionSlots"/>.
+	/// </summary>
 	public int maxMinions = 1;
+	/// <summary>
+	/// The current number of minions this player has summoned. Note that <see cref="slotsMinions"/> is how the minion limit is tracked, not this.
+	/// </summary>
 	public int numMinions;
+	/// <summary>
+	/// The current total value of minions this player has summoned. Used to limit active minions to <see cref="maxMinions"/>
+	/// <br/> A minion's value is stored as <see cref="Projectile.minionSlots"/>.
+	/// </summary>
 	public float slotsMinions;
 	public bool pygmy;
 	public bool raven;
@@ -731,6 +_,11 @@
 	public bool defendedByPaladin;
 	public bool hasPaladinShield;
 	public float[] speedSlice = new float[60];
+
+	/// <summary>
+	/// The sum of the <see cref="NPC.npcSlots"/> of all town NPCs near this player.
+	/// <br/> If <c><see cref="townNPCs"/> &gt; 2f</c>, then this player is in a town.
+	/// </summary>
 	public float townNPCs;
 	public double headFrameCounter;
 	public double bodyFrameCounter;
@@ -769,8 +_,16 @@
 	public const int miscSlotMount = 3;
 	public const int miscSlotHook = 4;
 	public const int SupportedMiscSlotCount = 5;
+	/// <summary>
+	/// The player's armor and accessories. Indexes 0-2 hold head, chest, and legs armor while 10-12 hold the respective social armor items. Indexes 3-9 hold the accessories and 13-19 hold the social accessory items. Modded accessory slots are stored separately.<br/><br/>
+	/// Generally speaking, modders <b>should not be accessing this array</b> to check for specific accessories, that is not how Terraria is designed and is not scalable, especially since modded accessory slots exist and each can have special logic. Modders should be using <see cref="ModItem.UpdateAccessory(Player, bool)"/> to set fields in a <see cref="ModPlayer"/> class, then use those values for gameplay effects. <see href="https://github.com/tModLoader/tModLoader/blob/1.4.4/ExampleMod/Old/SimpleModPlayer.cs">SimpleModPlayer.cs</see> shows the proper approach and explains this pattern.<br/><br/>
+	/// The corresponding dye items are found in <see cref="dye"/>. The player's inventory is <see cref="inventory"/>. For equipment, see <see cref="miscEquips"/> and <see cref="miscDyes"/>. <see cref="trashItem"/> is the trash slot.<br/><br/>
+	/// </summary>
 	public Item[] armor = new Item[20];
 	public Item[] dye = new Item[10];
+	/// <summary>
+	/// The player's equipment items. From indexes 0-4: Pet, Light Pet, Minecart, Mount, and Hook.
+	/// </summary>
 	public Item[] miscEquips = new Item[5];
 	public Item[] miscDyes = new Item[5];
 	public Item trashItem = new Item();
@@ -781,16 +_,48 @@
 	public bool poundRelease;
 	public float ghostFade;
 	public float ghostDir = 1f;
+
+	/*
 	public static readonly int maxBuffs = 44;
+	*/
+	internal static int maxBuffs => 44 + BuffLoader.extraPlayerBuffCount;
+	public static int MaxBuffs => maxBuffs;
+
+	/// <summary>
+	/// The <see cref="BuffID"/>s of all buffs this player has active.
+	/// <br/> A value of <c>0</c> means that buff slot is empty.
+	/// <br/> Buff times are stored with the same index in <see cref="buffTime"/>.
+	/// <br/> <see cref="AddBuff(int, int, bool, bool)"/>, <see cref="ClearBuff(int)"/>, and <see cref="DelBuff(int)"/> should be used to manipulate player buffs.
+	/// </summary>
 	public int[] buffType = new int[maxBuffs];
+
+	/// <summary>
+	/// The remaining durations in ticks of all buffs this player has active.
+	/// <br/> A value of <c>0</c> means that buff slot is empty.
+	/// <br/> Buff types are stored with the same index in <see cref="buffType"/>.
+	/// <br/> <see cref="AddBuff(int, int, bool, bool)"/>, <see cref="ClearBuff(int)"/>, and <see cref="DelBuff(int)"/> should be used to manipulate player buffs.
+	/// </summary>
 	public int[] buffTime = new int[maxBuffs];
+
+	/// <summary>
+	/// Indexed by <see cref="BuffID"/>. If <see langword="true"/> for a given <see cref="BuffID"/>, then this player cannot be inflicted with that buff.
+	/// <br/> Additionally, if the player is inflicted with that buff and becomes immune to it, the buff will be cleared.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public bool[] buffImmune = new bool[BuffID.Count];
+	/// <summary>
+	/// The index of the projectile (<see cref="Entity.whoAmI"/>) currently being "held" by the player as if it were an item. Set during projectile AI. Held projectiles will be drawn during player rendering over the player's arms.
+	/// <para/> When making a held projectile, make sure to test holding the projectile while moving up or down a single block obstacles and adjust <see cref="Player.RotatedRelativePoint"/>, <see cref="Player.gfxOffY"/> or <see cref="ProjectileID.Sets.HeldProjDoesNotUsePlayerGfxOffY"/> accordingly if the draw location is incorrect.
+	/// <para/> Defaults to -1.
+	/// </summary>
 	public int heldProj = -1;
 	public int breathCD;
 	public int breathMax = 200;
 	public int breath = 200;
 	public int lavaCD;
+	/// <summary> The max amount of lava immunity time (in ticks) the player can have. <see cref="ItemID.LavaCharm"/> and many other accessories add 420 do this, or 7 seconds. </summary>
 	public int lavaMax;
+	/// <summary> The remaining amount of lava immunity time (in ticks) the player has. </summary>
 	public int lavaTime;
 	public bool ignoreWater;
 	public bool armorEffectDrawShadow;
@@ -813,7 +_,16 @@
 	public bool isHatRackDoll;
 	public bool isFirstFractalAfterImage;
 	public float firstFractalAfterImageOpacity;
+
+	/// <summary>
+	/// The text that is shown on armor (<see cref="Item.wornArmor"/>) with an active set bonus.
+	/// </summary>
 	public string setBonus = "";
+	/// <summary>
+	/// The player's normal inventory. Indexes 0-9 hold the hotbar items, 10-49 the rest of the main inventory, 50-53 are coin slots, 54-57 are ammo slots. Index 58 is used to store the mouse item in some situations.<br/>
+	/// Additional inventories are found in <see cref="bank"/> (Piggy Bank), <see cref="bank2"/> (Safe), <see cref="bank3"/> (Defender's Forge), and <see cref="bank4"/> (Void Vault).
+	/// For armor and accessories, see <see cref="armor"/> and <see cref="dye"/>. For equipment, see <see cref="miscEquips"/> and <see cref="miscDyes"/>. <see cref="trashItem"/> is the trash slot.<br/>
+	/// </summary>
 	public Item[] inventory = new Item[59];
 	public bool[] inventoryChestStack = new bool[59];
 	public Item lastVisualizedSelectedItem;
@@ -836,6 +_,9 @@
 	public int fartKartCloudDelay;
 	public const int fartKartCloudDelayMax = 20;
 	public int nonTorch = -1;
+	/// <summary>
+	/// An offset from the actual position of the player that will be added to the draw position. Used to fake the effect of the player smoothly traveling up single block obstacles.
+	/// </summary>
 	public float gfxOffY;
 	public float stepSpeed = 1f;
 	public static bool deadForGood = false;
@@ -853,6 +_,7 @@
 	public int head = -1;
 	public int body = -1;
 	public int legs = -1;
+	/* sbyte -> int
 	public sbyte handon = -1;
 	public sbyte handoff = -1;
 	public sbyte back = -1;
@@ -869,6 +_,23 @@
 	public sbyte faceFlower = -1;
 	public sbyte balloonFront = -1;
 	public sbyte beard = -1;
+	*/
+	public int handon = -1;
+	public int handoff = -1;
+	public int back = -1;
+	public int front = -1;
+	public int shoe = -1;
+	public int waist = -1;
+	public int shield = -1;
+	public int neck = -1;
+	public int face = -1;
+	public int balloon = -1;
+	public int backpack = -1;
+	public int tail = -1;
+	public int faceHead = -1;
+	public int faceFlower = -1;
+	public int balloonFront = -1;
+	public int beard = -1;
 	public bool[] hideVisibleAccessory = new bool[10];
 	public BitsByte hideMisc = (byte)0;
 	public Rectangle headFrame;
@@ -943,7 +_,13 @@
 	public Vector2[] shadowOrigin = new Vector2[3];
 	public int[] shadowDirection = new int[3];
 	public int shadowCount;
+
+	/// <summary>
+	/// The percent of mana actually used when mana is consumed.
+	/// <br/> Cannot reduce an item's mana cost below <c>0</c>.
+	/// </summary>
 	public float manaCost = 1f;
+	/// <summary> Grants the player immunity from <see cref="TileID.Sets.TouchDamageHot"/> applying the <see cref="BuffID.Burning"/> buff. Given by <see cref="ItemID.ObsidianSkull"/> and many other items. </summary>
 	public bool fireWalk;
 	public bool channel;
 	public int step = -1;
@@ -961,23 +_,97 @@
 	public int golferScoreAccumulated;
 	public int bartenderQuestLog;
 	public bool downedDD2EventAnyDifficulty;
+
+	/*
 	public int armorPenetration;
-	public int statDefense;
+	*/
+	internal ref float armorPenetration => ref GetArmorPenetration(DamageClass.Generic);
+
+	/// <summary>
+	/// The defense value of this player.<br/>
+	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> teaches how player defense affects incoming damage alongside <see cref="DefenseEffectiveness"/>.<br/>
+	/// The value resets to 0 during <see cref="Player.ResetEffects"/> and is manipulated throughout <see cref="Player.Update(int)"/>.<br/>
+	/// If the final value is needed, <see cref="ModPlayer.PostUpdate"/> or anytime later is the best place. As such it is not recommended to manipulate the value during PostUpdate or at any time later for compatibility. Failure to follow this guideline will result in inconsistent behavior.<br/>
+	/// Due to this field being a <see cref="DefenseStat"/>, modders can freely add, subtract, multiply, and divide the value. The final result will properly account for all modifications applied.<br/>
+	/// </summary>
+	public DefenseStat statDefense; // changed from int
+	/// <summary>
+	/// Determines how effective the player's <see cref="statDefense"/> is at reducing incoming damage.<br/>
+	/// The <see href="https://terraria.wiki.gg/wiki/Defense#Players">Defense wiki page</see> explains the effect, shown in the wiki as "factor".<br/>
+	/// </summary>
+	public MultipliableFloat DefenseEffectiveness; // added by TML
+
+	/// <summary>
+	/// The maximum health this player can have without adjustment.
+	/// <br/> You should <strong>not</strong> modify this value. If you need to increase max health for equipment, modify <see cref="statLifeMax2"/>. If you need to increase max health for a permanent stat boost, use <see cref="ModPlayer.ModifyMaxStats(out StatModifier, out StatModifier)"/>.
+	/// </summary>
 	public int statLifeMax = 100;
+
+	/// <summary>
+	/// The maximum health this player can have, adjusted by buffs and equipment.
+	/// </summary>
 	public int statLifeMax2 = 100;
+
+	/// <summary>
+	/// The current health of this player. Capped at <see cref="statLifeMax2"/>.
+	/// <br/> If you increase this value, be sure to respect the cap.
+	/// </summary>
+	/// <remarks>
+	/// If you want to heal the player with the green text effect, use <see cref="Player.Heal(int)"/>.
+	/// <br/> If you want to hurt the player, use <see cref="Hurt(PlayerDeathReason, int, int, bool, bool, int, bool, float, float, float)"/>.
+	/// </remarks>
 	public int statLife = 100;
+
+	/// <summary>
+	/// The current mana of this player. Capped at <see cref="statManaMax2"/>.
+	/// <br/> If you increase this value, be sure to respect the cap.
+	/// </summary>
+	/// <remarks>
+	/// If you want to use mana, use <see cref="Player.CheckMana(Item, int, bool, bool)"/> or its overload.
+	/// </remarks>
 	public int statMana;
+
+	/// <summary>
+	/// The maximum mana this player can have without adjustment.
+	/// <br/> You should <strong>not</strong> modify this value. If you need to increase max mana for equipment, modify <see cref="statManaMax2"/>. If you need to increase max mana for a permanent stat boost, use <see cref="ModPlayer.ModifyMaxStats(out StatModifier, out StatModifier)"/>.
+	/// </summary>
 	public int statManaMax;
+
+	/// <summary>
+	/// The maximum mana this player can have, adjusted by buffs and equipment.
+	/// </summary>
 	public int statManaMax2;
+
+	/// <summary>
+	/// The rate of this player's life regeneration in health per tick, divided by <c>120</c>. To put it another way, it is health regeneration every 2 seconds. Used to implement the damage over time of debuffs and life regeneration accessories such as <see cref="ItemID.BandofRegeneration"/>.
+	/// <br/> For example, adding <c>10</c> to this value regenerates <c>10 / 120</c> = <c>1/6</c> health per tick, or 5 health per second.
+	/// <br/> Life regeneration is accumulated every tick in <see cref="lifeRegenCount"/>.
+	/// <br/> This value should be subtracted from in <see cref="ModPlayer.UpdateBadLifeRegen"/> and added to in <see cref="ModPlayer.UpdateLifeRegen"/>.
+	/// </summary>
 	public int lifeRegen;
+
+	/// <summary>
+	/// This player's accumulated life regeneration.
+	/// <br/> If this value reaches or exceeds <c>120</c>, the player gains <c><see cref="lifeRegenCount"/> / 120</c> health and this value decreases until it no longer exceeds <c>120</c>.
+	/// <br/> If this value reaches or exceeds <c>-120</c>, the player loses health in the same way.
+	/// <br/> In either case, text will appear above the player indicating the life regeneration or life loss.
+	/// </summary>
 	public int lifeRegenCount;
+
+	/// <summary>
+	/// How effective this player's natural life regeneration should be. Resets whenever the player is hurt, increases over time.
+	/// <br/> Certain effects increase this value to increase
+	/// </summary>
+	/// <remarks>
+	/// Use <see cref="ModPlayer.NaturalLifeRegen(ref float)"/> to directly modify natural life regeneration.
+	/// </remarks>
 	public float lifeRegenTime;
 	public int manaRegen;
 	public int manaRegenCount;
 	public float manaRegenDelay;
 	public bool manaRegenBuff;
 	public bool noKnockback;
-	private bool shimmerImmune;
+	public bool shimmerImmune;
 	public bool spaceGun;
 	public float gravDir = 1f;
 	public bool chloroAmmoCost80;
@@ -987,12 +_,17 @@
 	public int stickyBreak;
 	public bool magicQuiver;
 	public bool magmaStone;
+	/// <summary> Reduces damage from touching lava and halves the duration of lava inflicted <see cref="BuffID.OnFire"/>, such as given by <see cref="ItemID.ObsidianRose"/> and many other items. </summary>
 	public bool lavaRose;
 	public bool hasMoltenQuiver;
 	public int phantasmTime;
 	public bool ammoBox;
 	public bool ammoPotion;
 	public bool chaosState;
+
+	/// <summary>
+	/// If <see langword="true"/>, then the bees created by <see cref="honeyCombItem"/> have a chance to be stronger.
+	/// </summary>
 	public bool strongBees;
 	public bool sporeSac;
 	public bool shinyStone;
@@ -1019,7 +_,15 @@
 	public int overrideFishingBobber = -1;
 	public bool unlockedBiomeTorches;
 	public bool ateArtisanBread;
+
+	/// <summary>
+	/// If <see langword="true"/>, then this player has permanently buffed their minecarts. See <see cref="UsingSuperCart"/> for more info.
+	/// </summary>
 	public bool unlockedSuperCart;
+
+	/// <summary>
+	/// If <see langword="true"/>, then this player has the effects of the Super Cart enabled. See <see cref="UsingSuperCart"/> for more info.
+	/// </summary>
 	public bool enabledSuperCart = true;
 	public bool suspiciouslookingTentacle;
 	public bool crimsonHeart;
@@ -1053,6 +_,12 @@
 	public bool cartFlip;
 	public float trackBoost;
 	public Vector2 lastBoost = Vector2.Zero;
+
+	/// <summary>
+	/// This player's <see cref="Mount"/>.
+	/// <br/> <strong>Do not overwrite this value.</strong> Instead, call <see cref="Mount.SetMount(int, Player, bool)"/> or <see cref="Mount.Dismount(Player)"/> on it.
+	/// <para/> Check <see cref="Mount.Active"/> (via <c>Player.mount.Active</c>) to determine if the player is currently using a mount.
+	/// </summary>
 	public Mount mount;
 	public bool blackCat;
 	public bool spider;
@@ -1111,6 +_,7 @@
 	public bool coldDash;
 	public bool sailDash;
 	public bool desertDash;
+	/// <summary> Grants the player increased movement speed while running on sand </summary>
 	public bool desertBoots;
 	public bool eyeSpring;
 	public bool snowman;
@@ -1194,21 +_,73 @@
 	public bool parryDamageBuff;
 	public bool ballistaPanic;
 	public bool JustDroppedAnItem;
+	/*
 	public int meleeCrit = 4;
 	public int magicCrit = 4;
 	public int rangedCrit = 4;
+	*/
+	internal ref float allCrit => ref GetCritChance(DamageClass.Generic); //TML: New.
+	internal ref float meleeCrit => ref GetCritChance(DamageClass.Melee);
+	internal ref float magicCrit => ref GetCritChance(DamageClass.Magic);
+	internal ref float rangedCrit => ref GetCritChance(DamageClass.Ranged);
+
+	/*
 	public float meleeDamage = 1f;
 	public float magicDamage = 1f;
 	public float rangedDamage = 1f;
 	public float rangedMultDamage = 1f;
+	*/
+	internal ref StatModifier allDamage => ref GetDamage(DamageClass.Generic); //TML: New.
+	internal ref StatModifier meleeDamage => ref GetDamage(DamageClass.Melee);
+	internal ref StatModifier magicDamage => ref GetDamage(DamageClass.Magic);
+	internal ref StatModifier rangedDamage => ref GetDamage(DamageClass.Ranged);
+
+	/*
 	public float arrowDamageAdditiveStack;
+	*/
+	private ref StatModifier arrowDamageAdditiveStack => ref arrowDamage;
+
+	/*
 	public float arrowDamage = 1f;
 	public float bulletDamage = 1f;
 	public float rocketDamage = 1f;
 	public float minionDamage = 1f;
+	*/
+	public StatModifier arrowDamage = StatModifier.Default;
+	public StatModifier bulletDamage = StatModifier.Default;
+	public StatModifier specialistDamage = StatModifier.Default; // previously rocketDamage, Shroomite Helmet changed to use this.
+	internal ref StatModifier minionDamage => ref GetDamage(DamageClass.Summon);
+
+	/*
 	public float minionKB;
 	public float meleeSpeed = 1f;
+	*/
+	internal ref StatModifier allKB => ref GetKnockback(DamageClass.Generic); //TML: New.
+	internal ref float minionKB => ref GetKnockback(DamageClass.Summon).Base;
+	internal ref float meleeSpeed => ref GetAttackSpeed(DamageClass.Melee);
+	// TML: meleeSpeed is now a damage multiplier, so inverseMeleeSpeed is the useTime multiplier.
+	// By using GetTotalAttackSpeed we also incorporate anyone that adds attackSpeed to the Generic damage class.
+	internal float inverseMeleeSpeed => 1 / GetTotalAttackSpeed(DamageClass.Melee);
+
+	/*
 	public float summonerWeaponSpeedBonus;
+	*/
+	internal ref float summonerWeaponSpeedBonus => ref GetAttackSpeed(DamageClass.SummonMeleeSpeed);
+
+	// TML: Should these be StatModifiers?
+	/// <summary>
+	/// The multiplier on this player's <see cref="maxRunSpeed"/> and <see cref="runAcceleration"/>. This affects how quickly the player reaches max speed as well as the max speed itself.
+	/// This is typically modified in <see cref="ModBuff.Update(Player, ref int)"/>, <see cref="ModItem.UpdateEquip(Player)"/>, <see cref="ModItem.UpdateAccessory(Player, bool)"/>, or <see cref="ModPlayer.PostUpdateMiscEffects"/>. <see cref="ModPlayer.PostUpdateRunSpeeds"/> is too late to have any effect.
+	/// <para/> Defaults to 1f. Effects typically add to or subtract from this, typically expressed as "X% increased movement speed" in tooltips. Some examples:
+	/// <para/> Swiftness potion (<see cref="BuffID.Swiftness"/>): <c>+= 0.25f</c>
+	/// <br/> Webbed buff (<see cref="BuffID.Webbed"/>): <c>= 0f</c>
+	/// <br/> Titanium Leggings: <c>+= 0.06f</c>
+	/// <br/> Frostspark Boots: <c>+= 0.08f</c>
+	/// <para/> Some effects apply multiplicatively, these must be applied later on in the update process to work correctly, <see cref="ModPlayer.PostUpdateMiscEffects"/> or <see cref="ModPlayer.UpdateBadLifeRegen"/> are suitable places for this. Some examples:
+	/// <para/> Oozed buff (<see cref="slowOgreSpit"/>): <c>*= 1/3f</c>
+	/// <br/> Slow buff (<see cref="slow"/>): <c>*= 0.5f</c>
+	/// <br/> Chilled buff (<see cref="chilled"/>): <c>*= 0.75f</c>
+	/// </summary>
 	public float moveSpeed = 1f;
 	public float pickSpeed = 1f;
 	public float wallSpeed = 1f;
@@ -1231,24 +_,77 @@
 	public static int tileTargetY;
 	public static float defaultGravity = 0.4f;
 	public static int jumpHeight = 15;
+
+	/// <summary>
+	/// The speed, in pixels/tick, that this players jumps at.
+	/// </summary>
 	public static float jumpSpeed = 5.01f;
 	public float gravity = defaultGravity;
 	public float maxFallSpeed = 10f;
+
+	/// <summary>
+	/// The maximum speed, in pixels/tick, that this player can reach by just running. The acceleration to that speed is a separate stat (<see cref="runAcceleration"/>).
+	/// <para/> This should only be modified in <see cref="ModPlayer.PostUpdateRunSpeeds"/>, <see cref="ModItem.HorizontalWingSpeeds"/>, or <see cref="ExtraJump.UpdateHorizontalSpeeds(Player)"/> to correctly function. <see cref="accRunSpeed"/> is commonly adjusted in tandem if suitable.
+	/// <para/> Defaults to 3f, which is then multiplied by <see cref="moveSpeed"/>. Effects typically multiply this by some factor. Some examples:
+	/// <para/> On ice with Ice Skates: <c>*= 1.25f</c>
+	/// <br/> On honey block (<see cref="sticky"/>): <c>*= 0.25f</c>
+	/// <br/> On asphalt block (<see cref="powerrun"/>): <c>*= 3.5f</c>
+	/// <br/> Shadow Armor (<see cref="shadowArmor"/>): <c>*= 1.15f</c>
+	/// <br/> Extra jumps: Typically <c>*= 1.5f</c>, see <see cref="ExtraJump.UpdateHorizontalSpeeds"/>
+	/// <para/> When on a mount, all other modifiers are ignored and it is set to <see cref="Mount.RunSpeed"/>
+	/// </summary>
+	/// <remarks>To apply a global run speed modifier, use <see cref="moveSpeed"/>.</remarks>
 	public float maxRunSpeed = 3f;
+
+	/// <summary>
+	/// The acceleration, in pixels/ticks^2, that this player experiences while running. This affects how quickly the player reaches max speed, not the max speed (<see cref="maxRunSpeed"/>) itself.
+	/// <para/> This should only be modified in <see cref="ModPlayer.PostUpdateRunSpeeds"/>, <see cref="ModItem.HorizontalWingSpeeds"/>, or <see cref="ExtraJump.UpdateHorizontalSpeeds(Player)"/> to correctly function.
+	/// <para/> Defaults to 0.08f, which is then multiplied by <see cref="moveSpeed"/>. Effects typically multiply this by some factor. Some examples:
+	/// <para/> On ice (<see cref="slippy"/>): <c>*= 0.7f</c> (or <c>*= 2.1f</c> if wearing Ice Skates)
+	/// <br/> On honey block (<see cref="sticky"/>): <c>*= 0.25f</c>
+	/// <br/> Shadow Armor (<see cref="shadowArmor"/>): <c>*= 1.75f</c>
+	/// <br/> Wings: <c>*= <see cref="WingStats.AccRunAccelerationMult"/></c>
+	/// <br/> Extra jumps: Typically <c>*= 3f</c>, see <see cref="ExtraJump.UpdateHorizontalSpeeds"/>
+	/// <para/> When on a mount, all other modifiers are ignored and it is set to <see cref="Mount.Acceleration"/>
+	/// </summary>
+	/// <remarks>To apply a global run speed modifier, use <see cref="moveSpeed"/>.</remarks>
 	public float runAcceleration = 0.08f;
 	public float runSlowdown = 0.2f;
 	public bool adjWater;
 	public bool adjHoney;
+	public bool adjShimmer;
 	public bool adjLava;
 	public bool oldAdjWater;
 	public bool oldAdjHoney;
 	public bool oldAdjLava;
-	public bool[] adjTile = new bool[TileID.Count];
-	public bool[] oldAdjTile = new bool[TileID.Count];
+	public bool oldAdjShimmer;
+
+	private bool[] _adjTile = new bool[TileLoader.TileCount];
+	public bool[] adjTile {
+		get {
+			if (_adjTile.Length != TileLoader.TileCount)
+				Array.Resize(ref _adjTile, TileLoader.TileCount);
+
+			return _adjTile;
+		}
+		set => _adjTile = value;
+	}
+
+	private bool[] _oldAdjTile = new bool[TileLoader.TileCount];
+	public bool[] oldAdjTile {
+		get {
+			if (_oldAdjTile.Length != TileLoader.TileCount)
+				Array.Resize(ref _oldAdjTile, TileLoader.TileCount);
+
+			return _oldAdjTile;
+		}
+		set => _oldAdjTile = value;
+	}
+
 	public static int defaultItemGrabRange = 42;
 	private static float itemGrabSpeed = 0.45f;
 	private static float itemGrabSpeedMax = 4f;
-	public byte hairDye;
+	public int hairDye; //TML: Changed from byte to int.
 	public Color hairDyeColor = Color.Transparent;
 	public float hairDyeVar;
 	public int skinDyePacked;
@@ -1297,9 +_,24 @@
 	public Item boneGloveItem;
 	public bool goldRing;
 	public bool accDivingHelm;
-	public bool accFlipper;
+	//public bool accFlipper;
+	public bool accFlipper {
+		get {
+			return GetJumpState<FlipperJump>().Enabled;
+		}
+		set {
+			ref ExtraJumpState state = ref GetJumpState<FlipperJump>();
+			if (value) {
+				state.Enable();
+				// Allow equipping flippers while "midair" to still let the player use them
+				state.Available = true;
+			} else
+				state.Disable();
+		}
+	}
 	public bool hasLuck_LuckyCoin;
 	public bool hasLuck_LuckyHorseshoe;
+	/*
 	public bool hasJumpOption_Cloud;
 	public bool canJumpAgain_Cloud;
 	public bool isPerformingJump_Cloud;
@@ -1327,10 +_,32 @@
 	public bool hasJumpOption_Basilisk;
 	public bool canJumpAgain_Basilisk;
 	public bool isPerformingJump_Basilisk;
+	*/
+	internal bool hasJumpOption_Cloud { set { if (value) GetJumpState<CloudInABottleJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Sandstorm { set { if (value) GetJumpState<SandstormInABottleJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Blizzard { set { if (value) GetJumpState<BlizzardInABottleJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Fart { set { if (value) GetJumpState<FartInAJarJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Sail { set { if (value) GetJumpState<TsunamiInABottleJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Unicorn { set { if (value) GetJumpState<UnicornMountJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Santank { set { if (value) GetJumpState<SantankMountJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_WallOfFleshGoat { set { if (value) GetJumpState<GoatMountJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+	internal bool hasJumpOption_Basilisk { set { if (value) GetJumpState<BasiliskMountJump>().Enable(); else throw new ArgumentException("Forgot to comment out a hasJumpOption_X = false statement"); } }
+
 	public bool isPerformingPogostickTricks;
 	public bool autoJump;
 	public bool justJumped;
+
+	/// <summary>
+	/// How much to directly increase <see cref="jumpSpeed"/>, in pixels/tick.
+	/// </summary>
 	public float jumpSpeedBoost;
+
+	/// <summary>
+	/// The number of extra tiles this player can fall before they start taking fall damage. For example <see cref="ItemID.FrogLeg"/> adds 10 to extraFall.
+	/// </summary>
+	/// <remarks>
+	/// If you want to prevent fall damage entirely, use <see cref="noFallDmg"/>.
+	/// </remarks>
 	public int extraFall;
 	public bool canFloatInWater;
 	public bool hasFloatingTube;
@@ -1347,10 +_,17 @@
 	public int rocketSoundDelay;
 	public bool rocketRelease;
 	public bool rocketFrame;
+	/// <summary> If greater than 0, the player can briefly fly using rocket boots. Is usually set to the same value as <see cref="vanityRocketBoots"/> </summary>
 	public int rocketBoots;
+	/// <summary> Controls which rocket boots visuals and sounds will be used: <para/> 1: Rocket Boots <br/> 2: Fairy Boots (plus <see cref="fairyBoots"/>), Spectre Boots, Lightning Boots <br/> 3: Frostspark Boots <br/> 4: Terraspark Boots <br/> 5: Hellfire Treads </summary>
 	public int vanityRocketBoots;
 	public bool canRocket;
 	public bool jumpBoost;
+
+	/// <summary>
+	/// If <see langword="true"/>, this player will take no fall damage, such as the effect given by <see cref="ItemID.LuckyHorseshoe"/>.
+	/// <para/> If you want to increase the fall height required for fall damage, use <see cref="extraFall"/> instead.
+	/// </summary>
 	public bool noFallDmg;
 	public int swimTime;
 	public bool killGuide;
@@ -1358,6 +_,7 @@
 	public float equipmentBasedLuckBonus;
 	public float lastEquipmentBasedLuckBonus;
 	public bool hasCreditsSceneMusicBox;
+	/// <summary> Complete lava immunity, such as given by <see cref="ItemID.ObsidianSkinPotion"/>. </summary>
 	public bool lavaImmune;
 	public bool gills;
 	public bool slowFall;
@@ -1392,16 +_,27 @@
 	public int maxTurrets = 1;
 	public int maxTurretsOld = 1;
 	public bool vortexStealthActive;
+	/// <summary> Allows the player to walk on water, honey, and shimmer, such as given by <see cref="ItemID.WaterWalkingBoots"/>. </summary>
 	public bool waterWalk;
+	/// <summary> Allows the player to walk on water, honey, lava, and shimmer, such as given by <see cref="ItemID.LavaWaders"/>. </summary>
 	public bool waterWalk2;
 	public int forcedGravity;
 	public bool gravControl;
 	public bool gravControl2;
+
+	/// <summary>
+	/// If not <see langword="null"/>, this player will create damaging bee projectiles when taking damage.
+	/// </summary>
 	public Item honeyCombItem;
 	public int wireOperationsCooldown;
 	public int lastChest;
 	public TrackedProjectileReference piggyBankProjTracker;
 	public TrackedProjectileReference voidLensChest;
+	/// <summary>
+	/// Represents the chest the player currently has open. If -1, the player has no chest open.<br/>
+	/// Positive values indicate the index of the chest in <see cref="Main.chest"/> the player currently has open.<br/>
+	/// Negative values are used to indicate additional inventories: Piggy Bank (-2), Safe (-3), Defender's Forge (-4), Void Vault (-5)
+	/// </summary>
 	public int chest = -1;
 	public int chestX;
 	public int chestY;
@@ -1423,8 +_,11 @@
 	public PlayerInteractionAnchor tileEntityAnchor;
 	public DoorOpeningHelper doorHelper;
 	public ShoppingSettings currentShoppingSettings = ShoppingSettings.NotInShop;
+	/// <summary>The armor shader ID applied to the <see cref="EquipType.Head"/> equip texture by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cHead;
+	/// <summary>The armor shader ID applied to the <see cref="EquipType.Body"/> equip texture by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cBody;
+	/// <summary>The armor shader ID applied to the <see cref="EquipType.Legs"/> equip texture by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cLegs;
 	public int cHandOn;
 	public int cHandOff;
@@ -1445,10 +_,15 @@
 	public int cBackpack;
 	public int cTail;
 	public int cShieldFallback;
+	/// <summary>The armor shader ID applied to the Hook equipment slot by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cGrapple;
+	/// <summary>The armor shader ID applied to the Mount equipment slot by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cMount;
+	/// <summary>The armor shader ID applied to the Minecart equipment slot by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cMinecart;
+	/// <summary>The armor shader ID applied to the Pet equipment slot by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cPet;
+	/// <summary>The armor shader ID applied to the Light Pet equipment slot by a dye item (<see cref="Item.dye"/>) in the dye slot.</summary>
 	public int cLight;
 	public int cYorai;
 	public int cPortableStool;
@@ -1458,6 +_,12 @@
 	public int cMinion;
 	public int cLeinShampoo;
 	public int cFlameWaker;
+	/// <summary>
+	/// Provides efficient access to the number of projectiles of the specified type owned by this player currently active in the game world.<br/>
+	/// Can be used to prevent spawning additional projectiles when a limit is reached.<br/>
+	/// Updated each game update right before Player.UpdateBuffs.<br/>
+	/// For example, <c>return player.ownedProjectileCounts[Item.shoot] &lt; 1;</c> in <see cref="ModItem.CanUseItem"/> could prevent a player using the item if the projectile the item spawns is already in the game world for the player.
+	/// </summary>
 	public int[] ownedProjectileCounts = new int[ProjectileID.Count];
 	public bool[] npcTypeNoAggro = new bool[NPCID.Count];
 	public int lastPortalColorIndex;
@@ -1507,7 +_,7 @@
 	private int[] unlitTorchY = new int[maxTorchAttacks];
 	private static int[] _torchAttackPosX = new int[400];
 	private static int[] _torchAttackPosY = new int[400];
-	public int ladyBugLuckTimeLeft;
+	public double ladyBugLuckTimeLeft; //TML: Changed from int to double.
 	public float luck;
 	public float luckMinimumCap = -0.7f;
 	public float luckMaximumCap = 1f;
@@ -1558,7 +_,7 @@
 	private const int SaveSlotIndex_GuideItem = 2;
 	private const int SaveSlotIndex_TinkererItem = 3;
 	private const int SaveSlotIndexCount = 4;
-	private Item[] _temporaryItemSlots = new Item[4];
+	internal Item[] _temporaryItemSlots = new Item[4];
 	private static readonly PlayerFileData _visualCloneDummyData = new PlayerFileData();
 	private static readonly MemoryStream _visualCloneStream = new MemoryStream();
 	private static readonly BinaryWriter _visualCloneWriter = new BinaryWriter(_visualCloneStream);
@@ -1640,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// Returns the player's center adjusted for mount and step stool usage. Typically used in conjunction with <see cref="RotatedRelativePoint(Vector2, bool, bool)"/> to retrieve a suitable position for positioning items and effects originating from the player.
+	/// </summary>
 	public Vector2 MountedCenter {
 		get {
 			return new Vector2(position.X + (float)(width / 2), position.Y + 21f + HeightOffsetHitboxCenter);
@@ -1653,6 +_,9 @@
 
 	public override Vector2 VisualPosition => position + new Vector2(0f, gfxOffY);
 
+	/// <summary>
+	/// Checks if the player is currently "crowd controlled", meaning the player is <see cref="frozen"/>, <see cref="webbed"/>, or <see cref="stoned"/>. Used in various checks to prevent some player actions that shouldn't be possible while in those states, such as channeling attacks, quick using items, and swapping loadouts.
+	/// </summary>
 	public bool CCed {
 		get {
 			if (!frozen && !webbed)
@@ -1823,6 +_,10 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is the top 35% of the world.
+	/// <br/> <strong>NOTE:</strong> Vanilla uses a lot of different conditions for what counts as space. This flag is never used in vanilla, but the logic behind it is used for NPC shops and enemy spawns.
+	/// </summary>
 	public bool ZoneSkyHeight {
 		get {
 			return zone3[0];
@@ -1832,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is above ground (<see cref="Main.worldSurface"/>) but not in space (<see cref="ZoneSkyHeight"/>).
+	/// </summary>
 	public bool ZoneOverworldHeight {
 		get {
 			return zone3[1];
@@ -1841,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is underground (<see cref="Main.worldSurface"/>) but above the Caverns layer (<see cref="Main.rockLayer"/>).
+	/// </summary>
 	public bool ZoneDirtLayerHeight {
 		get {
 			return zone3[2];
@@ -1850,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is in the Caverns layer (<see cref="Main.rockLayer"/>) but not in the Underworld (<see cref="Main.UnderworldLayer"/>).
+	/// </summary>
 	public bool ZoneRockLayerHeight {
 		get {
 			return zone3[3];
@@ -1859,6 +_,9 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then this player is in the Underworld (<see cref="Main.UnderworldLayer"/>).
+	/// </summary>
 	public bool ZoneUnderworldHeight {
 		get {
 			return zone3[4];
@@ -2085,6 +_,10 @@
 		}
 	}
 
+	/// <summary>
+	/// If <see langword="true"/>, then any minecart (<see cref="MountID.Sets.Cart"/>) this player rides in will be significantly faster and fire lasers.
+	/// <br/> Cannot be <see langword="true"/> if <see cref="unlockedSuperCart"/> is <see langword="false"/>.
+	/// </summary>
 	public bool UsingSuperCart {
 		get {
 			if (!unlockedSuperCart)
@@ -2097,11 +_,13 @@
 		}
 	}
 
+	/*
 	public float bowEffectiveDamage => (rangedDamage / rangedMultDamage + arrowDamageAdditiveStack) * rangedMultDamage * arrowDamage;
 
 	public float gunEffectiveDamage => rangedDamage * bulletDamage;
 
 	public float specialistEffectiveDamage => rangedDamage * rocketDamage;
+	*/
 
 	public bool ShouldNotDraw {
 		get {
@@ -2118,6 +_,11 @@
 
 	public int talkNPC { get; private set; }
 
+	/// <summary>
+	/// The NPC instance the player is talking to, or null if <see cref="talkNPC"/> is -1
+	/// </summary>
+	public NPC TalkNPC => talkNPC >= 0 ? Main.npc[talkNPC] : null;
+
 	public bool isLockedToATile {
 		get {
 			if (!sitting.isSitting)
@@ -2155,7 +_,10 @@
 
 	public bool ItemTimeIsZero => itemTime == 0;
 
-	public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax - 1;
+	/// <summary>
+	/// Returns true if the item animation is in its first frame.
+	/// </summary>
+	public bool ItemAnimationJustStarted => itemAnimation == itemAnimationMax/* - 1*/ && itemAnimation > 0; //#2351 & #3139
 
 	public float NormalizedLuck {
 		get {
@@ -2228,6 +_,13 @@
 		return pos + vector;
 	}
 
+	/// <summary>
+	/// Takes an input position and returns the position adjusted to the players visual rotation and offset. This accounts for the player being shifted up or down and rotated while riding a mount, sitting in a chair, and sleeping. <br/>
+	/// </summary>
+	/// <param name="pos"></param>
+	/// <param name="reverseRotation"></param>
+	/// <param name="addGfxOffY"></param>
+	/// <returns></returns>
 	public Vector2 RotatedRelativePoint(Vector2 pos, bool reverseRotation = false, bool addGfxOffY = true)
 	{
 		float num = (reverseRotation ? (0f - fullRotation) : fullRotation);
@@ -2328,6 +_,7 @@
 	{
 		talkNPC = npcIndex;
 		if (Main.netMode != 1 && npcIndex >= 0 && npcIndex < 200)
+			// Gut feeling there is a to do on the above conditional
 			Main.BestiaryTracker.Chats.RegisterChatStartWith(Main.npc[npcIndex]);
 
 		if (talkNPC == -1)
@@ -2345,6 +_,7 @@
 		itemTimeMax = frames;
 	}
 
+	/*
 	public void ApplyItemTime(Item sItem)
 	{
 		SetItemTime(sItem.useTime);
@@ -2354,6 +_,17 @@
 	{
 		SetItemTime((int)((float)sItem.useTime * multiplier));
 	}
+	*/
+
+	//TML: Full remake of the above methods.
+	public void ApplyItemTime(Item sItem, float multiplier = 1, bool? callUseItem = null)
+	{
+		if ((callUseItem ?? ItemTimeIsZero) && ItemLoader.UseItem(sItem, this) == false)
+			return;
+
+		SetItemTime(CombinedHooks.TotalUseTime(sItem.useTime * multiplier, this, sItem));
+		ItemUsesThisAnimation++;
+	}
 
 	public void SetDummyItemTime(int frames)
 	{
@@ -2362,14 +_,15 @@
 		itemTimeMax = frames + 1;
 	}
 
-	private void SetItemAnimation(int frames)
+	public void SetItemAnimation(int frames)
 	{
 		itemAnimation = frames;
 		itemAnimationMax = frames;
 	}
 
-	private void ApplyItemAnimation(Item sItem)
+	public void ApplyItemAnimation(Item sItem)
 	{
+		/*
 		int num = 0;
 		if (sItem.autoReuse && sItem.reuseDelay == 0 && sItem.useTime <= sItem.useAnimation && sItem.shoot > 0 && sItem.useStyle == 5)
 			num = 1;
@@ -2386,6 +_,26 @@
 			SetItemAnimation(sItem.useAnimation + num);
 
 		reuseDelay = sItem.reuseDelay;
+		*/
+
+		//TODO: Just merge the tile/wall speed into TotalUseSpeedMultiplier?
+		if (sItem.createTile >= 0)
+			ApplyItemAnimation(sItem, tileSpeed);
+		else if (sItem.createWall >= 0)
+			ApplyItemAnimation(sItem, wallSpeed);
+		else
+			ApplyItemAnimation(sItem, 1);
+	}
+
+	// Overload added by TML.
+	public void ApplyItemAnimation(Item sItem, float multiplier, int? itemReuseDelay = null)
+	{
+		ItemLoader.UseAnimation(sItem, this);
+
+		SetItemAnimation(CombinedHooks.TotalAnimationTime(sItem.useAnimation * multiplier, this, sItem));
+
+		reuseDelay = (int)((itemReuseDelay ?? sItem.reuseDelay) / CombinedHooks.TotalUseSpeedMultiplier(this, sItem));
+		ItemUsesThisAnimation = 0;
 	}
 
 	public void MatchItemTimeToItemAnimation()
@@ -2407,6 +_,10 @@
 
 	public bool TeamChangeAllowed() => true;
 
+	/// <summary>
+	/// Spawns a <see cref="CombatText"/> indicating the player healed <paramref name="healAmount"/> life and syncs it if <paramref name="broadcast"/> is true. <br/>
+	/// Note that this doesn't actually heal the player, it only spawns the floating text. The <see cref="Heal(int)"/> method heals the player and calls this method and is more commonly used.
+	/// </summary>
 	public void HealEffect(int healAmount, bool broadcast = true)
 	{
 		CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), CombatText.HealLife, healAmount);
@@ -2753,7 +_,9 @@
 			Main.guideItem.position = base.Center;
 			Item item = GetItem(whoAmI, Main.guideItem, getItemInDropItemCheck);
 			if (item.stack > 0) {
+				//TODO: Replace with Item.DropItem?
-				int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+				// int num = //Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item.type, item.stack, noBroadcast: false, Main.guideItem.prefix, noGrabDelay: true);
+				int num = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item, noGrabDelay: true);
 				Main.item[num].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num, 1f);
@@ -2766,7 +_,9 @@
 			Main.reforgeItem.position = base.Center;
 			Item item2 = GetItem(whoAmI, Main.reforgeItem, getItemInDropItemCheck);
 			if (item2.stack > 0) {
+				//TODO: Replace with Item.DropItem?
-				int num2 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+				// int num2 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, Main.reforgeItem.prefix, noGrabDelay: true);
+				int num2 = Item.NewItem(new EntitySource_OverfullInventory(this), position, width, height, item2, noGrabDelay: true);
 				Main.item[num2].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num2, 1f);
@@ -2801,7 +_,9 @@
 			Main.mouseItem.position = base.Center;
 			Item item3 = GetItem(whoAmI, Main.mouseItem, getItemInDropItemCheck);
 			if (item3.stack > 0) {
+				//TODO: Replace with Item.DropItem?
-				int num3 = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+				int num3 = Item.NewItem(new EntitySource_OverfullInventory(this), (int)position.X, (int)position.Y, width, height, item3.type, item3.stack, noBroadcast: false, Main.mouseItem.prefix, noGrabDelay: true);
+				Main.item[num3] = item3.Clone(); // Added by TML.
 				Main.item[num3].newAndShiny = false;
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, num3, 1f);
@@ -2852,7 +_,8 @@
 			if (whoAmI == Main.myPlayer && theItemWeDrop.type == 5095)
 				LucyAxeMessage.Create(LucyAxeMessage.MessageSource.ThrownAway, base.Top, new Vector2(direction * 7, -2f));
 
-			int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, theItemWeDrop.type);
+			// int num = Item.NewItem(GetItemSource_Misc(4), (int)position.X, (int)position.Y, width, height, theItemWeDrop.type);
+			int num = Item.NewItem(GetItemSource_Misc(4), position, width, height, theItemWeDrop);
 			theItemWeDrop.position = Main.item[num].position;
 			Main.item[num] = theItemWeDrop;
 			theItemWeDrop = new Item();
@@ -2923,6 +_,14 @@
 		return -1;
 	}
 
+	/// <summary>
+	/// Gives the player the provided buff. This accounts for if the player is immune to the buff. This also accounts for adjusting the buff time for different game modes. If the player already has the buff, the re-apply logic will happen. Vanilla buff types are found in <see cref="BuffID"/> and modded buffs are typically retrieved using <see cref="ModContent.BuffType{T}"/>. The quiet parameter will determine if the network sync message should happen. This should only be set to false in non-deterministic situations (such as random chance) and code that only runs locally. Other situations run on all clients so the buff should automatically be applied on all clients, keeping the player buff data in sync without burdening the network. When in doubt, consult vanilla source code examples or test your code.
+	/// <br/> If applying a buff to a player other than the local player in pvp, quiet should be false and the buff must be true in <see cref="Main.pvpBuff"/> to properly sync.
+	/// </summary>
+	/// <param name="type">The buff type</param>
+	/// <param name="timeToAdd">The desired buff time in ticks. 60 ticks is 1 second</param>
+	/// <param name="quiet">If true, the network sync message is skipped.</param>
+	/// <param name="foodHack">unused</param>
 	public void AddBuff(int type, int timeToAdd, bool quiet = true, bool foodHack = false)
 	{
 		if (buffImmune[type])
@@ -3020,6 +_,7 @@
 			if (buffType[i] != type)
 				continue;
 
+			if (BuffLoader.ReApply(type, this, time, i)) { } else
 			if (type == 94) {
 				buffTime[i] += time;
 				if (buffTime[i] > manaSickTimeMax)
@@ -3039,7 +_,10 @@
 	private int AddBuff_DetermineBuffTimeToAdd(int type, int time1)
 	{
 		int num = time1;
+		/*
 		if (Main.expertMode && whoAmI == Main.myPlayer && (type == 20 || type == 22 || type == 23 || type == 24 || type == 30 || type == 31 || type == 32 || type == 33 || type == 35 || type == 36 || type == 39 || type == 44 || type == 46 || type == 47 || type == 69 || type == 70 || type == 80)) {
+		*/
+		if (Main.expertMode && whoAmI == Main.myPlayer && BuffID.Sets.LongerExpertDebuff[type]) {
 			float debuffTimeMultiplier = Main.GameModeInfo.DebuffTimeMultiplier;
 			if (Main.GameModeInfo.IsJourneyMode) {
 				if (Main.masterMode)
@@ -3054,6 +_,10 @@
 		return num;
 	}
 
+	/// <summary>
+	/// Removes the buff at the provided index in <see cref="buffType"/> and <see cref="buffTime"/> and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.ClearBuff(int)"/> if you only know the <see cref="BuffID"/>.
+	/// </summary>
+	/// <param name="b">The index in <see cref="buffType"/> of the buff to remove.</param>
 	public void DelBuff(int b)
 	{
 		buffTime[b] = 0;
@@ -3073,8 +_,16 @@
 		}
 	}
 
+	/// <summary>
+	/// Removes the provided buff type from the player and shuffles the remaining buff indexes down to fill the gap. Use <see cref="Player.DelBuff(int)"/> if you only know the buff index
+	/// </summary>
+	/// <param name="type">The buff type</param>
 	public void ClearBuff(int type)
 	{
+		//TML: Small optimization.
+		if (type == 0)
+			return;
+
 		for (int i = 0; i < maxBuffs; i++) {
 			if (buffType[i] == type)
 				DelBuff(i);
@@ -3117,6 +_,7 @@
 			AddBuff(item.buffType, num);
 		}
 
+		if (item.consumable && ItemLoader.ConsumeItem(item, this))
 		item.stack--;
 		if (item.stack <= 0)
 			item.TurnToAir();
@@ -3141,7 +_,13 @@
 			if (item.stack <= 0 || item.type <= 0 || !item.potion || item.healLife <= 0)
 				continue;
 
+			if (!CombinedHooks.CanUseItem(this, item))
+				continue;
+
+			/*
 			int num4 = item.healLife - num;
+			*/
+			int num4 = GetHealLife(item, true) - num;
 			if (item.type == 227 && num4 < 0) {
 				num4 += 30;
 				if (num4 > 0)
@@ -3175,6 +_,8 @@
 				ApplyPotionDelay(item);
 
 			ApplyLifeAndOrMana(item);
+
+			if (item.consumable && ItemLoader.ConsumeItem(item, this))
 			item.stack--;
 			if (item.stack <= 0)
 				item.TurnToAir();
@@ -3186,13 +_,13 @@
 	public Item QuickMana_GetItemToUse()
 	{
 		for (int i = 0; i < 58; i++) {
-			if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion))
+			if (inventory[i].stack > 0 && inventory[i].type > 0 && inventory[i].healMana > 0 && (potionDelay == 0 || !inventory[i].potion) && CombinedHooks.CanUseItem(this, inventory[i]))
 				return inventory[i];
 		}
 
 		if (useVoidBag()) {
 			for (int j = 0; j < 40; j++) {
-				if (bank4.item[j].stack > 0 && bank4.item[j].type > 0 && bank4.item[j].healMana > 0 && (potionDelay == 0 || !bank4.item[j].potion))
+				if (bank4.item[j].stack > 0 && bank4.item[j].type > 0 && bank4.item[j].healMana > 0 && (potionDelay == 0 || !bank4.item[j].potion) && CombinedHooks.CanUseItem(this, inventory[j]))
 					return bank4.item[j];
 			}
 		}
@@ -3226,7 +_,7 @@
 		if (cursed || CCed || dead)
 			return;
 
-		LegacySoundStyle legacySoundStyle = null;
+		SoundStyle? legacySoundStyle = null;
 		if (CountBuffs() == maxBuffs)
 			return;
 
@@ -3237,8 +_,10 @@
 			if (num == 0)
 				num = 3600;
 
+			ItemLoader.UseItem(item, this);
+
 			AddBuff(item.buffType, num);
-			if (item.consumable) {
+			if (item.consumable && ItemLoader.ConsumeItem(item, this)) {
 				item.stack--;
 				if (item.stack <= 0)
 					item.TurnToAir();
@@ -3256,8 +_,9 @@
 					continue;
 
 				int num3 = item2.buffType;
-				bool flag = QuickBuff_ShouldBotherUsingThisBuff(num3);
+				bool flag = CombinedHooks.CanUseItem(this, item2) && QuickBuff_ShouldBotherUsingThisBuff(num3);
 				if (item2.mana > 0 && flag) {
+					/*
 					if (statMana >= (int)((float)item2.mana * manaCost)) {
 						manaRegenDelay = (int)maxRegenDelay;
 						statMana -= (int)((float)item2.mana * manaCost);
@@ -3265,6 +_,11 @@
 					else {
 						flag = false;
 					}
+					*/
+					if (CheckMana(item2, -1, true, true))
+						manaRegenDelay = (int)maxRegenDelay;
+					else
+						flag = false;
 				}
 
 				if (whoAmI == Main.myPlayer && item2.type == 603 && !Main.runningCollectorsEdition)
@@ -3285,14 +_,17 @@
 				if (!flag)
 					continue;
 
+				ItemLoader.UseItem(item2, this);
+
 				legacySoundStyle = item2.UseSound;
 				int num4 = item2.buffTime;
 				if (num4 == 0)
 					num4 = 3600;
 
 				AddBuff(num3, num4);
-				if (item2.consumable) {
+				if (item2.consumable && ItemLoader.ConsumeItem(item2, this)) {
 					item2.stack--;
+
 					if (item2.stack <= 0)
 						item2.TurnToAir();
 				}
@@ -3412,6 +_,9 @@
 			if (item != null && item.mountType != -1 && mount.CanMount(item.mountType, this) && ItemCheck_CheckCanUse(item)) {
 				if (!QuickMinecartSnap()) {
 					mount.SetMount(item.mountType, this);
+
+					ItemLoader.UseItem(item, this);
+
 					if (item.UseSound != null)
 						SoundEngine.PlaySound(item.UseSound, base.Center);
 				}
@@ -3487,12 +_,20 @@
 	public Item QuickMount_GetItemToUse()
 	{
 		Item item = null;
+		bool equippedMountSufficient = false;
 		if (item == null && miscEquips[3].mountType != -1 && !MountID.Sets.Cart[miscEquips[3].mountType])
+			equippedMountSufficient = true;
+
+		if (equippedMountSufficient && CombinedHooks.CanUseItem(this, miscEquips[3]))
 			item = miscEquips[3];
 
 		if (item == null) {
 			for (int i = 0; i < 58; i++) {
 				if (inventory[i].mountType != -1 && !MountID.Sets.Cart[inventory[i].mountType]) {
+					if (!CombinedHooks.CanUseItem(this, inventory[i])) {
+						continue;
+					}
+
 					item = inventory[i];
 					break;
 				}
@@ -3555,6 +_,11 @@
 		if (item == null || !ItemCheck_CheckCanUse(item))
 			return;
 
+		if (ProjectileLoader.CanUseGrapple(item.shoot, this) is bool modCanGrapple) {
+			if (!modCanGrapple)
+				item = null;
+		}
+		else // Skip vanilla grapple checks
 		if (item.shoot == 73) {
 			int num2 = 0;
 			for (int i = 0; i < 1000; i++) {
@@ -3630,11 +_,13 @@
 		float shootSpeed = item.shootSpeed;
 		int damage = item.damage;
 		float knockBack = item.knockBack;
-		if (num7 == 13 || num7 == 32 || num7 == 315 || (num7 >= 230 && num7 <= 235) || num7 == 331 || num7 == 753 || num7 == 865 || num7 == 935) {
+
+		if (ProjectileID.Sets.SingleGrappleHook[num7]) {
 			grappling[0] = -1;
 			grapCount = 0;
 			for (int num8 = 0; num8 < 1000; num8++) {
 				if (Main.projectile[num8].active && Main.projectile[num8].owner == whoAmI) {
+					/*
 					switch (Main.projectile[num8].type) {
 						case 13:
 						case 230:
@@ -3651,6 +_,11 @@
 							Main.projectile[num8].Kill();
 							break;
 					}
+					*/
+					if (!ProjectileID.Sets.SingleGrappleHook[Main.projectile[num8].type])
+						continue;
+
+					Main.projectile[num8].Kill();
 				}
 			}
 		}
@@ -3721,11 +_,14 @@
 					break;
 				case -1:
 				case 649:
+					// Extra patch context.
 					num7 = 646;
 					break;
 			}
 		}
 
+		ProjectileLoader.UseGrapple(this, ref num7);
+
 		Vector2 vector = new Vector2(position.X + (float)width * 0.5f, position.Y + (float)height * 0.5f);
 		float num21 = (float)Main.mouseX + Main.screenPosition.X - vector.X;
 		float num22 = (float)Main.mouseY + Main.screenPosition.Y - vector.Y;
@@ -4055,6 +_,12 @@
 		if (Main.myPlayer != whoAmI)
 			return;
 
+		OnHit_Inner(x, y, victim);
+		PlayerLoader.OnHitAnything(this, x, y, victim);
+	}
+
+	private void OnHit_Inner(float x, float y, Entity victim)
+	{
 		bool flag = victim is NPC && (((NPC)victim).type == 488 || ((NPC)victim).SpawnedFromStatue);
 		if (titaniumStormCooldown > 0)
 			flag = true;
@@ -4148,6 +_,9 @@
 
 	public void OpenPresent(int itemType)
 	{
+		DropFromItem(itemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		if (Main.rand.Next(15) == 0 && Main.hardMode) {
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 602);
@@ -4372,10 +_,13 @@
 				break;
 			}
 		}
+		*/
 	}
 
 	public void OpenLegacyPresent(int itemType)
 	{
+		DropFromItem(itemType);
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		int num = Main.rand.Next(14);
 		if (num == 0 && Main.hardMode) {
@@ -4390,20 +_,41 @@
 		}
 		else {
 			int number3 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 591, Main.rand.Next(20, 50));
+			// Extra patch context for the below.
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number3, 1f);
 		}
+		*/
 	}
 
+	// Return value added by TML.
+	/// <summary>
+	/// Spawns an item into the world at this players position. This is a simpler alternative to <see cref="Item.NewItem(IEntitySource, int, int, int, int, int, int, bool, int, bool, bool)"/>. This method can be called from multiplayer client code without necessitating manually syncing the item.
+	/// <br/> Use <see cref="QuickSpawnItem(IEntitySource, Item, int)"/> if a specific instance of an Item needs to be spawned into the world to preserve modded data.
+	/// </summary>
+	/// <param name="source"></param>
+	/// <param name="item"></param>
+	/// <param name="stack"></param>
+	/// <returns>The index of the item within <see cref="Main.item"/></returns>
-	public void QuickSpawnItem(IEntitySource source, int item, int stack = 1)
+	public int QuickSpawnItem(IEntitySource source, int item, int stack = 1)
 	{
 		int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item, stack, noBroadcast: false, -1);
+
 		if (Main.netMode == 1)
 			NetMessage.SendData(21, -1, -1, null, number, 1f);
+
+		return number;
 	}
 
 	public void OpenBossBag(int type)
 	{
+		DropFromItem(type);
+
+		if (!ItemID.Sets.PreHardmodeLikeBossBag[type]) {
+			TryGettingDevArmor(GetItemSource_OpenItem(type));
+		}
+
+		/*
 		GameModeData gameModeInfo = Main.GameModeInfo;
 		float strength = 1f;
 		if (gameModeInfo.IsJourneyMode) {
@@ -4975,16 +_,20 @@
 			}
 
 			int num15 = (int)value;
+			// Extra patch context for the below.
 			if (num15 < 1)
 				num15 = 1;
 
 			value -= (float)num15;
 			QuickSpawnItem(itemSource_OpenItem, 71, num15);
 		}
+		*/
 	}
 
-	private void TryGettingDevArmor(IEntitySource source)
+	public void TryGettingDevArmor(IEntitySource source)
 	{
+		ModLoader.Default.ModLoaderMod.TryGettingPatreonOrDevArmor(source, this);
+
 		if (Main.rand.Next(Main.tenthAnniversaryWorld ? 8 : 16) == 0) {
 			switch (Main.rand.Next(18)) {
 				case 0:
@@ -5106,6 +_,9 @@
 
 	public void OpenFishingCrate(int crateItemID)
 	{
+		DropFromItem(crateItemID);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(crateItemID);
 		bool flag = ItemID.Sets.IsFishingCrateHardmode[crateItemID];
 		switch (crateItemID) {
@@ -6465,12 +_,22 @@
 					break;
 			}
 
+			// Extra patch context for the below.
 			int number72 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, type49, stack42);
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number72, 1f);
 		}
+		*/
 	}
 
+	/// <summary>
+	/// Counts the total stack of the specified item type in this players <see cref="inventory"/>. <br/>
+	/// Does not check Void Bag. <br/>
+	/// Use <see cref="Player.HasItem(int)"/> to check if the player has the item at all. <br/>
+	/// </summary>
+	/// <param name="type">The item type to count</param>
+	/// <param name="stopCountingAt">When to stop counting, useful to avoid unnecessary calculations</param>
+	/// <returns>The total amount counted</returns>
 	public int CountItem(int type, int stopCountingAt = 0)
 	{
 		int num = 0;
@@ -6485,6 +_,16 @@
 		return num;
 	}
 
+	/// <summary>
+	/// Use to consume a single item. The item does not have to be <see cref="Item.consumable"/>. <br/>
+	/// Attempts to reduce the <see cref="Item.stack"/> of the first <see cref="Item"/> found in the <see cref="inventory"/> by 1. <br/>
+	/// Respects <see cref="ItemLoader.ConsumeItem(Item, Player)"/>, so the item won't necessarily be consumed. <br/>
+	/// To consume multiple of the item, first check <see cref="Player.CountItem"/> to ensure that there are enough of the item, then use a for loop to call this method many times. <br/>
+	/// </summary>
+	/// <param name="type">The item type to consume</param>
+	/// <param name="reverseOrder">If true, the search for the item will start at the end of the player inventory</param>
+	/// <param name="includeVoidBag">If true, the void bag, if open, will also be considered for finding an item to consume</param>
+	/// <returns>True if the item was found and attempted to be consumed</returns>
 	public bool ConsumeItem(int type, bool reverseOrder = false, bool includeVoidBag = false)
 	{
 		int num = 0;
@@ -6498,7 +_,9 @@
 
 		for (int i = num; i != num2; i += num3) {
 			if (inventory[i].stack > 0 && inventory[i].type == type) {
+				if (ItemLoader.ConsumeItem(inventory[i], this))
-				inventory[i].stack--;
+					inventory[i].stack--;
+
 				if (inventory[i].stack <= 0)
 					inventory[i].SetDefaults();
 
@@ -6524,6 +_,9 @@
 
 	public void OpenShadowLockbox(int boxType)
 	{
+		DropFromItem(boxType);
+
+		/*
 		bool flag = true;
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(boxType);
 		while (flag) {
@@ -6551,15 +_,20 @@
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 
 			if (Main.rand.Next(5) == 0) {
+				// Extra patch context for the below.
 				number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 5010, 1, noBroadcast: false, -1);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
 		}
+		*/
 	}
 
 	public void OpenLockBox(int lockboxItemType)
 	{
+		DropFromItem(lockboxItemType);
+
+		/*
 		bool flag = true;
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(lockboxItemType);
 		while (flag) {
@@ -6593,16 +_,21 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 
+			// Extra patch context for the below.
 			if (Main.rand.Next(3) == 0) {
 				int number2 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 329, 1, noBroadcast: false, -1);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number2, 1f);
 			}
 		}
+		*/
 	}
 
 	public void OpenHerbBag(int bagType)
 	{
+		DropFromItem(bagType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(bagType);
 		int num = Main.rand.Next(2, 5);
 		if (Main.rand.Next(3) == 0)
@@ -6656,25 +_,35 @@
 			if (Main.rand.Next(3) == 0)
 				num3 += Main.rand.Next(1, 5);
 
+			// Extra patch context for the below.
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, num2, num3);
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
 	public void OpenCanofWorms(int sourceItemType)
 	{
+		DropFromItem(sourceItemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 		QuickSpawnItem(itemSource_OpenItem, 2002, Main.rand.Next(5, 9));
 		if (Main.rand.Next(10) < 3)
 			QuickSpawnItem(itemSource_OpenItem, 3191, Main.rand.Next(1, 3));
 
+		// Extra patch context.
 		if (Main.rand.Next(20) == 0)
 			QuickSpawnItem(itemSource_OpenItem, 2895);
+		*/
 	}
 
 	public void OpenOyster(int sourceItemType)
 	{
+		DropFromItem(sourceItemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(sourceItemType);
 		if (Main.rand.Next(5) == 0) {
 			if (Main.rand.Next(15) == 0)
@@ -6683,13 +_,18 @@
 				QuickSpawnItem(itemSource_OpenItem, 4413);
 			else
 				QuickSpawnItem(itemSource_OpenItem, 4412);
+			// Extra patch context for the below.
 		}
 
 		QuickSpawnItem(itemSource_OpenItem, 4411);
+		*/
 	}
 
 	public void OpenGoodieBag(int itemType)
 	{
+		DropFromItem(itemType);
+
+		/*
 		IEntitySource itemSource_OpenItem = GetItemSource_OpenItem(itemType);
 		if (Main.rand.Next(150) == 0) {
 			int number = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1810);
@@ -6970,14 +_,17 @@
 				int number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1851);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
+				// Extra patch context for the below.
 
 				number5 = Item.NewItem(itemSource_OpenItem, (int)position.X, (int)position.Y, width, height, 1852);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
 
+				// Extra patch context for the below.
 				break;
 			}
 		}
+		*/
 	}
 
 	public void UpdateDyes()
@@ -7002,12 +_,19 @@
 				int num = i % 10;
 				UpdateItemDye(i < 10, hideVisibleAccessory[num], armor[i], dye[num]);
 			}
+			// Needs to update modded slots between vanilla slots for proper ordering of dyes, so ModAccessorySlotPlayer doesn't override UpdateDyes and is manually called. Fixes #3061
+			if (i == 9)
+				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: false);
+			if (i == 19)
+				AccessorySlotLoader.ModSlotPlayer(this).UpdateDyes(socialSlots: true);
 		}
+
+		PlayerLoader.UpdateDyes(this);
 
 		cYorai = cPet;
 	}
 
-	private void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
+	internal void UpdateItemDye(bool isNotInVanitySlot, bool isSetToHidden, Item armorItem, Item dyeItem)
 	{
 		if (armorItem.IsAir)
 			return;
@@ -7020,13 +_,13 @@
 		if (!num && flag)
 			return;
 
-		if (armorItem.handOnSlot > 0 && armorItem.handOnSlot < ArmorIDs.HandOn.Count)
+		if (armorItem.handOnSlot > 0)
 			cHandOn = dyeItem.dye;
 
-		if (armorItem.handOffSlot > 0 && armorItem.handOffSlot < ArmorIDs.HandOff.Count)
+		if (armorItem.handOffSlot > 0)
 			cHandOff = dyeItem.dye;
 
-		if (armorItem.backSlot > 0 && armorItem.backSlot < ArmorIDs.Back.Count) {
+		if (armorItem.backSlot > 0) {
 			if (ArmorIDs.Back.Sets.DrawInBackpackLayer[armorItem.backSlot])
 				cBackpack = dyeItem.dye;
 			else if (ArmorIDs.Back.Sets.DrawInTailLayer[armorItem.backSlot])
@@ -7035,26 +_,26 @@
 				cBack = dyeItem.dye;
 		}
 
-		if (armorItem.frontSlot > 0 && armorItem.frontSlot < ArmorIDs.Front.Count)
+		if (armorItem.frontSlot > 0)
 			cFront = dyeItem.dye;
 
-		if (armorItem.shoeSlot > 0 && armorItem.shoeSlot < ArmorIDs.Shoe.Count) {
+		if (armorItem.shoeSlot > 0) {
 			if (armorItem.type == 4822 || armorItem.type == 4874)
 				cFlameWaker = dyeItem.dye;
 			else
 				cShoe = dyeItem.dye;
 		}
 
-		if (armorItem.waistSlot > 0 && armorItem.waistSlot < ArmorIDs.Waist.Count)
+		if (armorItem.waistSlot > 0)
 			cWaist = dyeItem.dye;
 
-		if (armorItem.shieldSlot > 0 && armorItem.shieldSlot < ArmorIDs.Shield.Count)
+		if (armorItem.shieldSlot > 0)
 			cShield = dyeItem.dye;
 
-		if (armorItem.neckSlot > 0 && armorItem.neckSlot < ArmorIDs.Neck.Count)
+		if (armorItem.neckSlot > 0)
 			cNeck = dyeItem.dye;
 
-		if (armorItem.faceSlot > 0 && armorItem.faceSlot < ArmorIDs.Face.Count) {
+		if (armorItem.faceSlot > 0) {
 			if (ArmorIDs.Face.Sets.DrawInFaceHeadLayer[armorItem.faceSlot])
 				cFaceHead = dyeItem.dye;
 			else if (ArmorIDs.Face.Sets.DrawInFaceFlowerLayer[armorItem.faceSlot])
@@ -7063,17 +_,17 @@
 				cFace = dyeItem.dye;
 		}
 
-		if (armorItem.beardSlot > 0 && armorItem.beardSlot < ArmorIDs.Beard.Count)
+		if (armorItem.beardSlot > 0)
 			cBeard = dyeItem.dye;
 
-		if (armorItem.balloonSlot > 0 && armorItem.balloonSlot < ArmorIDs.Balloon.Count) {
+		if (armorItem.balloonSlot > 0) {
 			if (ArmorIDs.Balloon.Sets.DrawInFrontOfBackArmLayer[armorItem.balloonSlot])
 				cBalloonFront = dyeItem.dye;
 			else
 				cBalloon = dyeItem.dye;
 		}
 
-		if (armorItem.wingSlot > 0 && armorItem.wingSlot < ArmorIDs.Wing.Count)
+		if (armorItem.wingSlot > 0)
 			cWings = dyeItem.dye;
 
 		if (armorItem.type == 934)
@@ -7112,12 +_,17 @@
 		}
 	}
 
+	public IEntitySource GetSource_Buff(int buffIndex) => GetProjectileSource_Buff(buffIndex);
+
+	// made internal, public rename ^
-	public IEntitySource GetProjectileSource_Buff(int buffIndex)
+	internal IEntitySource GetProjectileSource_Buff(int buffIndex)
 	{
 		int buffId = buffType[buffIndex];
 		return new EntitySource_Buff(this, buffId, buffIndex);
 	}
 
+	// Original vanilla methods:
+	/*
 	public IEntitySource GetProjectileSource_Item(Item item) => new EntitySource_ItemUse(this, item);
 	public IEntitySource GetItemSource_OpenItem(int itemType) => new EntitySource_ItemOpen(this, itemType);
 	public IEntitySource GetItemSource_Death() => new EntitySource_ByItemSourceId(this, 3);
@@ -7132,9 +_,35 @@
 	public IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 	public IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => new EntitySource_TileInteraction(this, tileCoordsX, tileCoordsY);
 	public IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => new EntitySource_OnHit_ByItemSourceID(this, victim, itemSourceId);
+	*/
+
+	// Internal redirects:
+	internal IEntitySource GetProjectileSource_Item(Item item) => GetSource_ItemUse(item);
+	internal IEntitySource GetItemSource_OpenItem(int itemType) => GetSource_OpenItem(itemType);
+	internal IEntitySource GetItemSource_Death() => GetSource_Death();
+	internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+	internal IEntitySource GetProjectileSource_Item_WithPotentialAmmo(Item item, int ammoItemId) => GetSource_ItemUse_WithPotentialAmmo(item, ammoItemId);
+	internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => GetSource_OnHit(victim, context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_OnHurt(Entity attacker, int projectileSourceId) => GetSource_OnHurt(attacker, context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_Accessory(Item item) => GetSource_Accessory(item);
+	internal IEntitySource GetProjectileSource_Misc(int projectileSourceId) => GetSource_Misc(context: ProjectileSourceID.ToContextString(projectileSourceId));
+	internal IEntitySource GetProjectileSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetItemSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetNPCSource_TileInteraction(int tileCoordsX, int tileCoordsY) => GetSource_TileInteraction(tileCoordsX, tileCoordsY);
+	internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => GetSource_OnHit(victim, context: ItemSourceID.ToContextString(itemSourceId));
+	internal IEntitySource GetProjectileSource_SetBonus(int projectileSourceId) => GetSource_FromThis(context: ProjectileSourceID.ToContextString(projectileSourceId));
+
+	// Public API methods can be found in:
+	//   Entity.TML.Sources.cs;
+	//   Player.TML.Sources.cs (if exists);
 
 	public void UpdateBuffs(int i)
 	{
+		// TML:
+		// All accessories that previously used each class-specific crit field individually now use 'allCrit' instead where appropriate.
+		// This allows them to automagically account for new classes, preventing modders from having to do extra work for no reason.
+		// - Thomas
+
 		if (soulDrain > 0 && whoAmI == Main.myPlayer)
 			AddBuff(151, 2);
 
@@ -7148,6 +_,9 @@
 			if (whoAmI == Main.myPlayer && !BuffID.Sets.TimeLeftDoesNotDecrease[buffType[j]])
 				buffTime[j]--;
 
+			//TML: This will be used at the very end of this scope.
+			int originalIndex = j;
+
 			if (buffType[j] == 1) {
 				lavaImmune = true;
 				fireWalk = true;
@@ -7162,8 +_,18 @@
 				manaRegenDelayBonus += 0.5f;
 				manaRegenBonus += 10;
 			}
+			// TML:
+			// The changes to this block exist to fix the Sharpening Station's armor penetration bonus
+			// being able to be applied to non-melee weapons (most notably summons) by holding a melee weapon.
+			// - Thomas
+			/*
 			else if (buffType[j] == 159 && inventory[selectedItem].melee) {
+			*/
+			else if (buffType[j] == 159) {
+				/*
 				armorPenetration += 12;
+				*/
+				GetArmorPenetration(DamageClass.Melee) += 12;
 			}
 			else if (buffType[j] == 192) {
 				pickSpeed -= 0.2f;
@@ -7171,9 +_,12 @@
 			}
 			else if (buffType[j] == 321) {
 				int num = 10;
+				allCrit += num;
+				/*
 				meleeCrit += num;
 				rangedCrit += num;
 				magicCrit += num;
+				*/
 				minionDamage += (float)num / 100f;
 			}
 			else if (buffType[j] == 2) {
@@ -7224,6 +_,9 @@
 			}
 			else if (buffType[j] == 16) {
 				archery = true;
+
+				//TML: Moved from PickAmmo, as StatModifier allows multiplicative buffs to be 'registered' alongside additive ones.
+				arrowDamage *= 1.1f;
 			}
 			else if (buffType[j] == 17) {
 				detectCreature = true;
@@ -7351,9 +_,12 @@
 				endurance += 0.1f;
 			}
 			else if (buffType[j] == 115) {
+				allCrit += 10;
+				/*
 				meleeCrit += 10;
 				rangedCrit += 10;
 				magicCrit += 10;
+				*/
 			}
 			else if (buffType[j] == 116) {
 				inferno = true;
@@ -7388,19 +_,22 @@
 						player.AddBuff(num2, 120);
 
 					if (flag) {
+						PlayerDeathReason reason = PlayerDeathReason.ByOther(16, whoAmI);
-						player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0, pvp: true);
+						player.Hurt(reason, damage, 0, pvp: true);
 						if (Main.netMode != 0) {
-							PlayerDeathReason reason = PlayerDeathReason.ByOther(16);
 							NetMessage.SendPlayerHurt(l, reason, damage, 0, critical: false, pvp: true, -1);
 						}
 					}
 				}
 			}
 			else if (buffType[j] == 117) {
+				allDamage += 0.1f;
+				/*
 				meleeDamage += 0.1f;
 				rangedDamage += 0.1f;
 				magicDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 			}
 			else if (buffType[j] == 119) {
 				loveStruck = true;
@@ -7596,10 +_,13 @@
 				}
 
 				float num17 = 0.15f * (float)nebulaLevelDamage;
+				allDamage += num17;
+				/*
 				meleeDamage += num17;
 				rangedDamage += num17;
 				magicDamage += num17;
 				minionDamage += num17;
+				*/
 			}
 			else if (buffType[j] == 62) {
 				if ((double)statLife <= (double)statLifeMax2 * 0.5) {
@@ -8287,10 +_,13 @@
 					}
 				}
 
+				allDamage += 0.2f;
+				/*
 				meleeDamage += 0.2f;
 				magicDamage += 0.2f;
 				rangedDamage += 0.2f;
 				minionDamage += 0.2f;
+				*/
 			}
 			else if (buffType[j] == 41) {
 				buffTime[j] = 18000;
@@ -8708,14 +_,20 @@
 			else if (buffType[j] == 26) {
 				wellFed = true;
 				statDefense += 2;
+				allCrit += 2;
+				allDamage += 0.05f;
+				/*
 				meleeCrit += 2;
 				meleeDamage += 0.05f;
+				*/
 				meleeSpeed += 0.05f;
+				/*
 				magicCrit += 2;
 				magicDamage += 0.05f;
 				rangedCrit += 2;
 				rangedDamage += 0.05f;
 				minionDamage += 0.05f;
+				*/
 				minionKB += 0.5f;
 				moveSpeed += 0.2f;
 				pickSpeed -= 0.05f;
@@ -8723,14 +_,20 @@
 			else if (buffType[j] == 206) {
 				wellFed = true;
 				statDefense += 3;
+				allCrit += 3;
+				allDamage += 0.075f;
+				/*
 				meleeCrit += 3;
 				meleeDamage += 0.075f;
+				*/
 				meleeSpeed += 0.075f;
+				/*
 				magicCrit += 3;
 				magicDamage += 0.075f;
 				rangedCrit += 3;
 				rangedDamage += 0.075f;
 				minionDamage += 0.075f;
+				*/
 				minionKB += 0.75f;
 				moveSpeed += 0.3f;
 				pickSpeed -= 0.1f;
@@ -8738,14 +_,20 @@
 			else if (buffType[j] == 207) {
 				wellFed = true;
 				statDefense += 4;
+				allCrit += 4;
+				allDamage += 0.1f;
+				/*
 				meleeCrit += 4;
 				meleeDamage += 0.1f;
+				*/
 				meleeSpeed += 0.1f;
+				/*
 				magicCrit += 4;
 				magicDamage += 0.1f;
 				rangedCrit += 4;
 				rangedDamage += 0.1f;
 				minionDamage += 0.1f;
+				*/
 				minionKB += 1f;
 				moveSpeed += 0.4f;
 				pickSpeed -= 0.15f;
@@ -8753,28 +_,40 @@
 			else if (buffType[j] == 333) {
 				hungry = true;
 				statDefense -= 2;
+				allCrit -= 2;
+				allDamage -= 0.05f;
+				/*
 				meleeCrit -= 2;
 				meleeDamage -= 0.05f;
+				*/
 				meleeSpeed -= 0.05f;
+				/*
 				magicCrit -= 2;
 				magicDamage -= 0.05f;
 				rangedCrit -= 2;
 				rangedDamage -= 0.05f;
 				minionDamage -= 0.05f;
+				*/
 				minionKB -= 0.5f;
 				pickSpeed += 0.05f;
 			}
 			else if (buffType[j] == 334) {
 				starving = true;
 				statDefense -= 4;
+				allCrit -= 4;
+				allDamage -= 0.1f;
+				/*
 				meleeCrit -= 4;
 				meleeDamage -= 0.1f;
+				*/
 				meleeSpeed -= 0.1f;
+				/*
 				magicCrit -= 4;
 				magicDamage -= 0.1f;
 				rangedCrit -= 4;
 				rangedDamage -= 0.1f;
 				minionDamage -= 0.1f;
+				*/
 				minionKB -= 1f;
 				pickSpeed += 0.15f;
 			}
@@ -8805,6 +_,9 @@
 			else if (buffType[j] == 79) {
 				meleeEnchant = 8;
 			}
+
+			if (j == originalIndex)
+				BuffLoader.Update(buffType[j], this, ref j);
 		}
 
 		UpdateHungerBuffs();
@@ -8925,6 +_,14 @@
 		}
 	}
 
+	/// <summary>
+	/// A helper method that handles code common to pet buffs. Can be used during the buff update code.<br/>
+	/// Sets the buff time to the value and spawns the corresponding pet projectile for the player if not yet spawned.<br/>
+	/// </summary>
+	/// <param name="buffIndex"></param>
+	/// <param name="petBool"></param>
+	/// <param name="petProjID"></param>
+	/// <param name="buffTimeToGive"></param>
 	public void BuffHandle_SpawnPetIfNeededAndSetTime(int buffIndex, ref bool petBool, int petProjID, int buffTimeToGive = 18000)
 	{
 		buffTime[buffIndex] = buffTimeToGive;
@@ -9226,23 +_,26 @@
 		accStopwatch = false;
 		accOreFinder = false;
 		accDreamCatcher = false;
+
+		PlayerLoader.ResetInfoAccessories(this);
+
 		for (int i = 0; i < 58; i++) {
 			int type = inventory[i].type;
-			RefreshInfoAccsFromItemType(type);
+			RefreshInfoAccsFromItemType(inventory[i]);
 			if (type == 4131)
 				flag = true;
 		}
 
 		for (int j = 0; j < 10; j++) {
 			int type2 = armor[j].type;
-			RefreshInfoAccsFromItemType(type2);
+			RefreshInfoAccsFromItemType(armor[j]);
 		}
 
 		if (flag) {
 			for (int k = 0; k < 40; k++) {
 				int type3 = bank4.item[k].type;
-				if (type3 < 0 || type3 > ItemID.Count || ItemID.Sets.WorksInVoidBag[type3])
-					RefreshInfoAccsFromItemType(type3);
+				if (type3 < 0 || ItemID.Sets.WorksInVoidBag[type3])
+					RefreshInfoAccsFromItemType(bank4.item[k]);
 			}
 		}
 
@@ -9301,11 +_,20 @@
 
 				if (Main.player[i].hasLuck_LuckyCoin)
 					hasLuck_LuckyCoin = true;
+
+				PlayerLoader.RefreshInfoAccessoriesFromTeamPlayers(this, Main.player[i]);
 			}
 		}
 	}
 
+	// Added by tML.
+	public void RefreshInfoAccsFromItemType(Item item)
+	{
+		RefreshInfoAccsFromItemType(item.type);
+		ItemLoader.UpdateInfoAccessory(item, this);
+	}
+
-	public void RefreshInfoAccsFromItemType(int accType)
+	private void RefreshInfoAccsFromItemType(int accType)
 	{
 		if ((accType == 15 || accType == 707) && accWatch < 1)
 			accWatch = 1;
@@ -9431,7 +_,10 @@
 		bool flag = false;
 		for (int j = 0; j < 58; j++) {
 			int type = inventory[j].type;
-			RefreshInfoAccsFromItemType(type);
+
+			ItemLoader.UpdateInventory(inventory[j], this);
+
+			RefreshInfoAccsFromItemType(inventory[j]);
 			RefreshMechanicalAccsFromItemType(type);
 			if (type == 4743)
 				hasFootball = true;
@@ -9456,8 +_,10 @@
 		if (flag) {
 			for (int l = 0; l < 40; l++) {
 				int type2 = bank4.item[l].type;
-				if (type2 < 0 || type2 > ItemID.Count || ItemID.Sets.WorksInVoidBag[type2]) {
-					RefreshInfoAccsFromItemType(type2);
+				if (ItemID.Sets.WorksInVoidBag[type2]) {
+					ItemLoader.UpdateInventory(bank4.item[l], this);
+
+					RefreshInfoAccsFromItemType(bank4.item[l]);
 					RefreshMechanicalAccsFromItemType(type2);
 				}
 			}
@@ -9471,8 +_,14 @@
 
 		for (int m = 3; m < 10; m++) {
 			if (IsItemSlotUnlockedAndUsable(m))
-				ApplyEquipFunctional(m, armor[m]);
+				ApplyEquipFunctional(armor[m], hideVisibleAccessory[m]);
 		}
+
+		PlayerLoader.UpdateEquips(this);
+
+		// Apply knockback glove here, rather than on hit. Moved from ItemCheck_OwnerOnlyCode/DashMovement/GetWeaponKnockback
+		if (kbGlove)
+			GetKnockback(DamageClass.Melee) *= 2f;
 
 		if (accFishingBobber)
 			fishingSkill += 10;
@@ -9481,14 +_,20 @@
 			lifeRegen += 2;
 			statDefense += 4;
 			meleeSpeed += 0.1f;
+			allDamage += 0.1f;
+			allCrit += 2;
+			/*
 			meleeDamage += 0.1f;
 			meleeCrit += 2;
 			rangedDamage += 0.1f;
 			rangedCrit += 2;
 			magicDamage += 0.1f;
 			magicCrit += 2;
+			*/
 			pickSpeed -= 0.15f;
+			/*
 			minionDamage += 0.1f;
+			*/
 			minionKB += 0.5f;
 		}
 
@@ -9497,6 +_,8 @@
 			maxTurrets++;
 		}
 
+		//TML: Wing loop is merged into ApplyEquipFunctional
+		/*
 		for (int n = 3; n < 10; n++) {
 			if (armor[n].wingSlot > 0 && IsItemSlotUnlockedAndUsable(n)) {
 				if (!hideVisibleAccessory[n] || (velocity.Y != 0f && !mount.Active))
@@ -9505,6 +_,7 @@
 				wingsLogic = armor[n].wingSlot;
 			}
 		}
+		*/
 
 		for (int num = 13; num < 20; num++) {
 			if (IsItemSlotUnlockedAndUsable(num))
@@ -9562,10 +_,10 @@
 		}
 	}
 
-	private void GrantArmorBenefits(Item armorPiece)
+	public void GrantArmorBenefits(Item armorPiece)
 	{
 		int type = armorPiece.type;
-		RefreshInfoAccsFromItemType(type);
+		RefreshInfoAccsFromItemType(armorPiece);
 		RefreshMechanicalAccsFromItemType(type);
 		if (armorPiece.type == 3017 || armorPiece.type == 3993) {
 			flowerBoots = true;
@@ -9737,6 +_,9 @@
 			armorPenetration += 5;
 
 		if (armorPiece.type == 2277) {
+			allDamage += 0.05f;
+			allCrit += 5;
+			/*
 			magicDamage += 0.05f;
 			meleeDamage += 0.05f;
 			rangedDamage += 0.05f;
@@ -9744,6 +_,7 @@
 			magicCrit += 5;
 			rangedCrit += 5;
 			meleeCrit += 5;
+			*/
 			meleeSpeed += 0.1f;
 			moveSpeed += 0.1f;
 		}
@@ -9758,9 +_,12 @@
 			nightVision = true;
 
 		if (armorPiece.type == 256 || armorPiece.type == 257 || armorPiece.type == 258) {
+			allCrit += 3;
+			/*
 			rangedCrit += 3;
 			meleeCrit += 3;
 			magicCrit += 3;
+			*/
 		}
 
 		if (armorPiece.type == 3374)
@@ -9799,22 +_,31 @@
 		}
 
 		if (armorPiece.type == 100 || armorPiece.type == 101 || armorPiece.type == 102) {
+			allCrit += 5;
+			/*
 			magicCrit += 5;
 			meleeCrit += 5;
 			rangedCrit += 5;
+			*/
 		}
 
 		if (armorPiece.type == 956 || armorPiece.type == 957 || armorPiece.type == 958) {
+			allCrit += 5;
+			/*
 			magicCrit += 5;
 			meleeCrit += 5;
 			rangedCrit += 5;
+			*/
 		}
 
 		if (armorPiece.type == 792 || armorPiece.type == 793 || armorPiece.type == 794) {
+			allDamage += 0.03f;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 		}
 
 		if (armorPiece.type == 231)
@@ -9843,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 374) {
+			allCrit += 5;
+			/*
 			magicCrit += 5;
 			meleeCrit += 5;
 			rangedCrit += 5;
+			*/
 		}
 
 		if (armorPiece.type == 375) {
+			allDamage += 0.03f;
+			/*
 			rangedDamage += 0.03f;
 			meleeDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 			moveSpeed += 0.1f;
 		}
 
@@ -9872,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 379) {
+			allDamage += 0.07f;
+			/*
 			rangedDamage += 0.07f;
 			meleeDamage += 0.07f;
 			magicDamage += 0.07f;
 			minionDamage += 0.07f;
+			*/
 		}
 
 		if (armorPiece.type == 380) {
+			allCrit += 10;
+			/*
 			magicCrit += 10;
 			meleeCrit += 10;
 			rangedCrit += 10;
+			*/
 		}
 
 		if (armorPiece.type >= 2367 && armorPiece.type <= 2369)
@@ -9904,16 +_,22 @@
 		}
 
 		if (armorPiece.type == 403) {
+			allDamage += 0.08f;
+			/*
 			rangedDamage += 0.08f;
 			meleeDamage += 0.08f;
 			magicDamage += 0.08f;
 			minionDamage += 0.08f;
+			*/
 		}
 
 		if (armorPiece.type == 404) {
+			allCrit += 7;
+			/*
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 			moveSpeed += 0.05f;
 		}
 
@@ -9934,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1208) {
+			allDamage += 0.03f;
+			allCrit += 2;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
@@ -9941,9 +_,13 @@
 			magicCrit += 2;
 			meleeCrit += 2;
 			rangedCrit += 2;
+			*/
 		}
 
 		if (armorPiece.type == 1209) {
+			allDamage += 0.02f;
+			allCrit += 1;
+			/*
 			meleeDamage += 0.02f;
 			rangedDamage += 0.02f;
 			magicDamage += 0.02f;
@@ -9951,6 +_,7 @@
 			magicCrit++;
 			meleeCrit++;
 			rangedCrit++;
+			*/
 		}
 
 		if (armorPiece.type == 1210) {
@@ -9970,17 +_,23 @@
 		}
 
 		if (armorPiece.type == 1213) {
+			allCrit += 6;
+			/*
 			magicCrit += 6;
 			meleeCrit += 6;
 			rangedCrit += 6;
+			*/
 		}
 
 		if (armorPiece.type == 1214) {
 			moveSpeed += 0.11f;
+			allDamage += 0.08f;
+			/*
 			meleeDamage += 0.08f;
 			rangedDamage += 0.08f;
 			magicDamage += 0.08f;
 			minionDamage += 0.08f;
+			*/
 		}
 
 		if (armorPiece.type == 1215) {
@@ -10001,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1218) {
+			allDamage += 0.04f;
+			allCrit += 3;
+			/*
 			meleeDamage += 0.04f;
 			rangedDamage += 0.04f;
 			magicDamage += 0.04f;
@@ -10008,9 +_,13 @@
 			magicCrit += 3;
 			meleeCrit += 3;
 			rangedCrit += 3;
+			*/
 		}
 
 		if (armorPiece.type == 1219) {
+			allDamage += 0.03f;
+			allCrit += 3;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
@@ -10018,6 +_,7 @@
 			magicCrit += 3;
 			meleeCrit += 3;
 			rangedCrit += 3;
+			*/
 			moveSpeed += 0.06f;
 		}
 
@@ -10044,31 +_,43 @@
 		}
 
 		if (armorPiece.type == 551 || armorPiece.type == 4900) {
+			allCrit += 7;
+			/*
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 		}
 
 		if (armorPiece.type == 552 || armorPiece.type == 4901) {
+			allDamage += 0.07f;
+			/*
 			rangedDamage += 0.07f;
 			meleeDamage += 0.07f;
 			magicDamage += 0.07f;
 			minionDamage += 0.07f;
+			*/
 			moveSpeed += 0.08f;
 		}
 
 		if (armorPiece.type == 4982) {
+			allCrit += 5;
+			/*
 			rangedCrit += 5;
 			meleeCrit += 5;
 			magicCrit += 5;
+			*/
 			manaCost -= 0.1f;
 		}
 
 		if (armorPiece.type == 4983) {
+			allDamage += 0.05f;
+			/*
 			rangedDamage += 0.05f;
 			meleeDamage += 0.05f;
 			magicDamage += 0.05f;
 			minionDamage += 0.05f;
+			*/
 			huntressAmmoCost90 = true;
 		}
 
@@ -10094,6 +_,9 @@
 		}
 
 		if (armorPiece.type == 1004) {
+			allDamage += 0.05f;
+			allCrit += 7;
+			/*
 			meleeDamage += 0.05f;
 			magicDamage += 0.05f;
 			rangedDamage += 0.05f;
@@ -10101,12 +_,16 @@
 			magicCrit += 7;
 			meleeCrit += 7;
 			rangedCrit += 7;
+			*/
 		}
 
 		if (armorPiece.type == 1005) {
+			allCrit += 8;
+			/*
 			magicCrit += 8;
 			meleeCrit += 8;
 			rangedCrit += 8;
+			*/
 			moveSpeed += 0.05f;
 		}
 
@@ -10139,7 +_,7 @@
 
 		if (armorPiece.type == 1548) {
 			rangedCrit += 5;
-			rocketDamage *= 1.15f;
+			specialistDamage *= 1.15f; // rocketDamage renamed.
 		}
 
 		if (armorPiece.type == 1549) {
@@ -10365,14 +_,21 @@
 			minionDamage += 0.11f;
 		}
 
+		// Extra patch context.
 		if (armorPiece.type == 1834) {
 			moveSpeed += 0.2f;
 			maxMinions++;
 			minionDamage += 0.11f;
 		}
+
+		// Lifted from NPC.SpawnNPC for NewNPC(..., 45), which is NPCID.Tim. See usage of the flag
+		if (armorPiece.type == 4256 || (armorPiece.type >= 1282 && armorPiece.type <= 1287))
+			hasGemRobe = true;
+
+		ItemLoader.UpdateEquip(armorPiece, this);
 	}
 
-	private void GrantPrefixBenefits(Item item)
+	public void GrantPrefixBenefits(Item item)
 	{
 		if (item.prefix == 62)
 			statDefense++;
@@ -10390,43 +_,61 @@
 			statManaMax2 += 20;
 
 		if (item.prefix == 67) {
+			allCrit += 2;
+			/*
 			meleeCrit += 2;
 			rangedCrit += 2;
 			magicCrit += 2;
+			*/
 		}
 
 		if (item.prefix == 68) {
+			allCrit += 4;
+			/*
 			meleeCrit += 4;
 			rangedCrit += 4;
 			magicCrit += 4;
+			*/
 		}
 
 		if (item.prefix == 69) {
+			allDamage += 0.01f;
+			/*
 			meleeDamage += 0.01f;
 			rangedDamage += 0.01f;
 			magicDamage += 0.01f;
 			minionDamage += 0.01f;
+			*/
 		}
 
 		if (item.prefix == 70) {
+			allDamage += 0.02f;
+			/*
 			meleeDamage += 0.02f;
 			rangedDamage += 0.02f;
 			magicDamage += 0.02f;
 			minionDamage += 0.02f;
+			*/
 		}
 
 		if (item.prefix == 71) {
+			allDamage += 0.03f;
+			/*
 			meleeDamage += 0.03f;
 			rangedDamage += 0.03f;
 			magicDamage += 0.03f;
 			minionDamage += 0.03f;
+			*/
 		}
 
 		if (item.prefix == 72) {
+			allDamage += 0.04f;
+			/*
 			meleeDamage += 0.04f;
 			rangedDamage += 0.04f;
 			magicDamage += 0.04f;
 			minionDamage += 0.04f;
+			*/
 		}
 
 		if (item.prefix == 73)
@@ -10452,6 +_,8 @@
 
 		if (item.prefix == 80)
 			meleeSpeed += 0.04f;
+
+		PrefixLoader.ApplyAccessoryEffects(this, item);
 	}
 
 	private void SpawnHallucination(Item item)
@@ -10590,6 +_,12 @@
 
 	private void ApplyEquipVanity(int itemSlot, Item currentItem)
 	{
+		ApplyEquipVanity(currentItem);
+	}
+
+	//TML: Split to make a public indexless overload.
+	public void ApplyEquipVanity(Item currentItem)
+	{
 		int type = currentItem.type;
 		if (currentItem.wingSlot > 0)
 			wings = currentItem.wingSlot;
@@ -10645,6 +_,8 @@
 
 		UpdateBootVisualEffects(currentItem);
 		UpdateFishingBobber(currentItem);
+
+		ItemLoader.UpdateVanity(currentItem, this);
 	}
 
 	private void DoEyebrellaRainEffect()
@@ -10670,9 +_,13 @@
 		return ArmorIDs.Wing.Sets.Stats[wingID];
 	}
 
-	private void ApplyEquipFunctional(int itemSlot, Item currentItem)
+	//TML: Made public, with the itemSlot parameter removed, so mods can call this method from their own accessory slots.
+	public void ApplyEquipFunctional(Item currentItem, bool hideVisual)
 	{
-		if (currentItem.expertOnly && !Main.expertMode)
+		int itemSlot = 0;
+		bool[] hideVisibleAccessory = { hideVisual };
+
+		if ((currentItem.expertOnly && !Main.expertMode) || (currentItem.masterOnly && !Main.masterMode))
 			return;
 
 		if (currentItem.type == 3810 || currentItem.type == 3809 || currentItem.type == 3812 || currentItem.type == 3811)
@@ -10803,6 +_,9 @@
 
 		if (currentItem.type == 3015) {
 			aggro -= 400;
+			allDamage += 0.05f;
+			allCrit += 5;
+			/*
 			meleeCrit += 5;
 			magicCrit += 5;
 			rangedCrit += 5;
@@ -10810,6 +_,7 @@
 			magicDamage += 0.05f;
 			rangedDamage += 0.05f;
 			minionDamage += 0.05f;
+			*/
 		}
 
 		if (currentItem.type == 3016)
@@ -11045,6 +_,9 @@
 		}
 
 		if (currentItem.type == 1301) {
+			allDamage += 0.1f;
+			allCrit += 8;
+			/*
 			meleeCrit += 8;
 			rangedCrit += 8;
 			magicCrit += 8;
@@ -11052,6 +_,7 @@
 			rangedDamage += 0.1f;
 			magicDamage += 0.1f;
 			minionDamage += 0.1f;
+			*/
 		}
 
 		if (currentItem.type == 111)
@@ -11094,9 +_,12 @@
 		}
 
 		if (currentItem.type == 1248) {
+			allCrit += 10;
+			/*
 			meleeCrit += 10;
 			rangedCrit += 10;
 			magicCrit += 10;
+			*/
 		}
 
 		if (currentItem.type == 854)
@@ -11501,10 +_,13 @@
 			minionDamage += 0.15f;
 
 		if (currentItem.type == 935) {
+			allDamage += 0.12f;
+			/*
 			magicDamage += 0.12f;
 			meleeDamage += 0.12f;
 			rangedDamage += 0.12f;
 			minionDamage += 0.12f;
+			*/
 		}
 
 		if (currentItem.wingSlot != -1)
@@ -11633,13 +_,25 @@
 			manaCost -= 0.08f;
 		}
 
+		//TML: Moved here from UpdateEquips.
+		if (currentItem.wingSlot > 0) {
+			if (!hideVisibleAccessory[itemSlot] || velocity.Y != 0f && !mount.Active)
+				wings = currentItem.wingSlot;
+
+			wingsLogic = currentItem.wingSlot;
+			equippedWings = currentItem;
+		}
+
+		ItemLoader.UpdateAccessory(currentItem, this, hideVisual);
+
+		// Vanilla: Return early if sounds are not relevant
 		if (Main.myPlayer != whoAmI)
 			return;
 
 		if (currentItem.type == 5104 || currentItem.type == 5105) {
 			ApplyWilsonBeard(currentItem);
 		}
-		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0 && Main.curMusic <= Main.maxMusic) {
+		else if (currentItem.type == 576 && Main.rand.Next(540) == 0 && Main.curMusic > 0) {
 			SoundEngine.PlaySound(SoundID.Item166, base.Center);
 			int num3 = -1;
 			if (Main.curMusic == 1)
@@ -11805,10 +_,12 @@
 				currentItem.SetDefaults(5112);
 			else if (Main.curMusic == 91)
 				currentItem.SetDefaults(5362);
-			else if (Main.curMusic > 13)
+			else if (Main.curMusic > 13 && Main.curMusic < Main.maxMusic)
 				currentItem.SetDefaults(1596 + Main.curMusic - 14);
-			else if (num3 != -1)
+			else if (num3 != -1 && Main.curMusic < Main.maxMusic)
 				currentItem.SetDefaults(num3 + 562);
+			else if (MusicLoader.musicToItem.TryGetValue(Main.curMusic, out int modMusicBoxType))
+				currentItem.SetDefaults(modMusicBoxType);
 		}
 
 		ApplyMusicBox(currentItem);
@@ -12019,6 +_,9 @@
 		if (currentItem.type == 5362)
 			Main.musicBox2 = 87;
 
+		if (MusicLoader.itemToMusic.TryGetValue(currentItem.type, out int modMusicBox))
+			Main.musicBox2 = modMusicBox;
+
 		Main.musicBoxNotModifiedByVolume = Main.musicBox2;
 	}
 
@@ -12057,10 +_,13 @@
 
 		if (head == 112 && body == 75 && legs == 64) {
 			setBonus = Language.GetTextValue("ArmorSetBonus.Pumpkin");
+			allDamage += 0.1f;
+			/*
 			meleeDamage += 0.1f;
 			magicDamage += 0.1f;
 			rangedDamage += 0.1f;
 			minionDamage += 0.1f;
+			*/
 		}
 
 		if (head == 180 && body == 182 && legs == 122) {
@@ -12390,6 +_,9 @@
 
 		if (head == 261 && body == 230 && legs == 213) {
 			setBonus = Language.GetTextValue("ArmorSetBonus.CrystalNinja");
+			allDamage += 0.1f;
+			allCrit += 10;
+			/*
 			rangedDamage += 0.1f;
 			meleeDamage += 0.1f;
 			magicDamage += 0.1f;
@@ -12397,6 +_,7 @@
 			rangedCrit += 10;
 			meleeCrit += 10;
 			magicCrit += 10;
+			*/
 			dashType = 5;
 		}
 
@@ -12581,11 +_,16 @@
 			minionDamage += 0.15f;
 			whipRangeMultiplier += 0.3f;
 			float num17 = 1.15f;
+			/*
 			float num18 = 1f / num17;
 			whipUseTimeMultiplier *= num18;
+			*/
+			summonerWeaponSpeedBonus += num17 - 1; //TML: Obsidian armor changed to additive.
 		}
 
 		ApplyArmorSoundAndDustChanges();
+
+		ItemLoader.UpdateArmorSet(this, armor[0], armor[1], armor[2]);
 	}
 
 	public void UpdateSocialShadow()
@@ -12926,6 +_,10 @@
 
 		bool flag9 = point.Y > Main.maxTilesY - 320;
 		bool flag10 = ZoneOverworldHeight && (point.X < 380 || point.X > Main.maxTilesX - 380);
+
+		//TODO: Are these flags a problem?
+		LoaderManager.Get<BiomeLoader>().UpdateBiomes(this);
+
 		ManageSpecialBiomeVisuals("Stardust", ZoneTowerStardust, vector4 - new Vector2(0f, 10f));
 		ManageSpecialBiomeVisuals("Nebula", ZoneTowerNebula, vector3 - new Vector2(0f, 10f));
 		ManageSpecialBiomeVisuals("Vortex", ZoneTowerVortex, vector2 - new Vector2(0f, 10f));
@@ -13080,8 +_,12 @@
 			}
 		}
 
+		// Added by TML.
+		ZonePurity = InZonePurity();
+
 		if (!dead) {
 			Point point2 = base.Center.ToTileCoordinates();
+			// Extra patch context.
 			if (WorldGen.InWorld(point2.X, point2.Y, 1)) {
 				int num21 = 0;
 				if (Main.tile[point2.X, point2.Y] != null)
@@ -13109,10 +_,13 @@
 				AchievementsHelper.HandleSpecialEvent(this, 15);
 			else if (_funkytownAchievementCheckCooldown == 0 && ZoneGraveyard)
 				AchievementsHelper.HandleSpecialEvent(this, 18);
+			// Extra patch context.
 		}
 		else {
 			_funkytownAchievementCheckCooldown = 100;
 		}
+
+		LoaderManager.Get<SceneEffectLoader>().UpdateSceneEffect(this);
 	}
 
 	private void TrySpawningFaelings()
@@ -13152,6 +_,13 @@
 
 	public void GetHairSettings(out bool fullHair, out bool hatHair, out bool hideHair, out bool backHairDraw, out bool drawsBackHairWithoutHeadgear)
 	{
+		fullHair = head >= 0 && ArmorIDs.Head.Sets.DrawFullHair[head];
+		hatHair = head >= 0 && ArmorIDs.Head.Sets.DrawHatHair[head];
+		hideHair = (face >= 0 && ArmorIDs.Face.Sets.PreventHairDraw[face]) || (faceHead >= 0 && head != 0);
+		backHairDraw = hair >= 0 && HairID.Sets.DrawBackHair[hair];
+		drawsBackHairWithoutHeadgear = head >= 0 && ArmorIDs.Head.Sets.DrawsBackHairWithoutHeadgear[head];
+
+		/*
 		fullHair = (hatHair = (hideHair = (drawsBackHairWithoutHeadgear = false)));
 		switch (head) {
 			case 0:
@@ -13272,6 +_,7 @@
 		backHairDraw = num > 50 && (num < 56 || num > 63) && (num < 74 || num > 77) && (num < 88 || num > 89) && num != 100 && num != 104 && num != 112 && num < 116;
 		if (num == 133 || num == 134 || num == 146 || num == 162 || num == 6)
 			backHairDraw = true;
+		*/
 	}
 
 	public void UpdateDead()
@@ -13287,6 +_,8 @@
 		ResetFloorFlags();
 		wings = 0;
 		wingsLogic = 0;
+		equippedWings = null; // Added by TML
+		selectItemOnNextUse = false; // Added by TML
 		ResetVisibleAccessories();
 		poisoned = false;
 		venom = false;
@@ -13333,6 +_,9 @@
 		leinforsHair = false;
 		overrideFishingBobber = -1;
 		gravDir = 1f;
+
+		PlayerLoader.UpdateDead(this);
+
 		for (int i = 0; i < maxBuffs; i++) {
 			if (buffType[i] <= 0 || !Main.persistentBuff[buffType[i]]) {
 				buffTime[i] = 0;
@@ -13522,6 +_,10 @@
 
 	public void SmartSelectLookup()
 	{
+		// Added by TML to preserve mouse item with moved call location
+		if (selectedItem == 58)
+			return;
+
 		if (mouseInterface)
 			controlTorch = false;
 
@@ -13538,6 +_,12 @@
 					toolStrategy = 5;
 			}
 
+			int modSelect = TileLoader.AutoSelect(tX, tY, this);
+			if (modSelect >= 0) {
+				SmartSelect_SelectItem(modSelect);
+				return;
+			}
+
 			SmartSelect_PickToolForStrategy(tX, tY, toolStrategy, wetTile);
 			_lastSmartCursorToolStrategy = toolStrategy;
 		}
@@ -13580,7 +_,11 @@
 						SmartSelect_SelectItem(i);
 						return;
 					}
+
+					/*
 					if (type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776)
+					*/
+					if (ItemID.Sets.Glowsticks[type])
 						SmartSelect_SelectItem(i);
 					break;
 				case 1:
@@ -13602,16 +_,26 @@
 					}
 					break;
 				case 4:
+					/*
 					if (inventory[i].type != 282 && inventory[i].type != 286 && inventory[i].type != 3002 && inventory[i].type != 3112 && inventory[i].type != 4776 && inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type]) {
+					*/
+					if (inventory[i].type != 930 && ItemID.Sets.Torches[type] && !ItemID.Sets.WaterTorches[type] && !ItemID.Sets.Glowsticks[type]) {
 						if (nonTorch == -1)
 							nonTorch = selectedItem;
 
+						/*
 						if (inventory[selectedItem].createTile != 4)
+						*/
+						if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 							selectedItem = i;
 
 						break;
 					}
+
+					/*
 					if ((type == 282 || type == 286 || type == 3002 || type == 3112 || type == 4776) && wetTile) {
+					*/
+					if (ItemID.Sets.Glowsticks[type] && wetTile) {
 						SmartSelect_SelectItem(i);
 						return;
 					}
@@ -13624,6 +_,9 @@
 							}
 						}
 
+						if (!flag && !ItemLoader.NeedsAmmo(inventory[i], this))
+							flag = true;
+
 						if (flag) {
 							SmartSelect_SelectItem(i);
 							return;
@@ -13639,7 +_,7 @@
 						if (nonTorch == -1)
 							nonTorch = selectedItem;
 
-						if (inventory[selectedItem].createTile != 4)
+						if (inventory[selectedItem].createTile < 0 || !TileID.Sets.Torch[inventory[selectedItem].createTile])
 							selectedItem = i;
 
 						break;
@@ -13666,6 +_,7 @@
 						case 3002:
 						case 3112:
 						case 4776:
+						case int thisType when ItemID.Sets.Glowsticks[thisType]:
 							SmartSelect_SelectItem(i);
 							return;
 					}
@@ -13858,6 +_,13 @@
 				if (tile == null)
 					return;
 
+				if (tile.type >= TileID.Count) {
+					if (tile.active() && TileID.Sets.Torch[tile.type])
+						NearbyModTorch.Add(tile.type);
+
+					continue;
+				}
+
 				if (!tile.active() || tile.type != 4 || tile.frameX < 0 || tile.frameY < 0)
 					continue;
 
@@ -13943,7 +_,7 @@
 				NetMessage.SendData(4, -1, -1, null, whoAmI);
 
 			if (numberOfTorchAttacksMade >= 95) {
-				int number = Item.NewItem(new EntitySource_ByItemSourceId(this, 6), (int)position.X, (int)position.Y, width, height, 5043);
+				int number = Item.NewItem(GetItemSource_Misc(6), (int)position.X, (int)position.Y, width, height, 5043);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number, 1f);
 			}
@@ -13991,6 +_,9 @@
 		if (inventory[selectedItem].createTile == 4 && inventory[selectedItem].placeStyle < TorchID.Count)
 			nearbyTorch[inventory[selectedItem].placeStyle] = true;
 
+		if (TileLoader.GetTile(inventory[selectedItem].createTile) is ModTile modTile && TileID.Sets.Torch[modTile.Type])
+			NearbyModTorch.Add(modTile.Type);
+
 		float num = 0f;
 		float num2 = 0f;
 		if (!ZoneDungeon && !ZoneLihzhardTemple) {
@@ -14064,8 +_,11 @@
 					num += 2f;
 				else if (ZoneDesert || ZoneCorrupt || ZoneCrimson || ZoneHallow)
 					num += 0.5f;
+				// Extra patch context.
 			}
 		}
+
+		TileLoader.ModifyTorchLuck(this, ref num2, ref num);
 
 		if (num2 >= 1f)
 			torchLuck += 1f;
@@ -14084,6 +_,8 @@
 			nearbyTorch[i] = false;
 		}
 
+		NearbyModTorch.Clear();
+
 		if (torchLuck < 0f)
 			torchLuck = 0f;
 
@@ -14214,10 +_,16 @@
 		arcticDivingGear = false;
 		noBuilding = false;
 		strongBees = false;
+		/*
 		armorPenetration = 0;
+		*/
 		ashWoodBonus = false;
 		shroomiteStealth = false;
+		/*
 		statDefense = 0;
+		*/
+		statDefense = DefenseStat.Default;
+		DefenseEffectiveness = MultipliableFloat.One * VanillaBaseDefenseEffectiveness();
 		accWatch = 0;
 		accCompass = 0;
 		accDepthMeter = 0;
@@ -14225,6 +_,9 @@
 		canFloatInWater = false;
 		lifeRegen = 0;
 		manaCost = 1f;
+
+		//TML: Individual class stats handled by ResetDamageClassData.
+		/*
 		meleeSpeed = 1f;
 		meleeDamage = 1f;
 		rangedDamage = 1f;
@@ -14235,6 +_,8 @@
 		meleeCrit = 4;
 		rangedCrit = 4;
 		magicCrit = 4;
+		*/
+
 		hasFootball = false;
 		drawingFootball = false;
 		minionKB = 0f;
@@ -14250,7 +_,7 @@
 		frogLegJumpBoost = false;
 		skyStoneEffects = false;
 		noFallDmg = false;
-		accFlipper = false;
+		//accFlipper = false;
 		spawnMax = false;
 		spaceGun = false;
 		killGuide = false;
@@ -14275,18 +_,33 @@
 
 		honeyCombItem = null;
 		gravControl2 = false;
+
+		PlayerLoader.ModifyMaxStats(this);
+
 		statLifeMax2 = statLifeMax;
 		statManaMax2 = statManaMax;
 		chloroAmmoCost80 = false;
 		huntressAmmoCost90 = false;
 		ammoCost80 = false;
 		ammoCost75 = false;
+
+		//TML: 1.3 throwing fields' readdition.
+		ThrownCost50 = false;
+		ThrownCost33 = false;
+		ThrownVelocity = 1f;
+
 		manaRegenBuff = false;
 		hasCreditsSceneMusicBox = false;
+		/*
 		arrowDamage = 1f;
 		arrowDamageAdditiveStack = 0f;
 		bulletDamage = 1f;
 		rocketDamage = 1f;
+		*/
+		arrowDamage = StatModifier.Default;
+		bulletDamage = StatModifier.Default;
+		specialistDamage = StatModifier.Default;
+
 		coolWhipBuff = false;
 		yoraiz0rEye = 0;
 		yoraiz0rDarkness = false;
@@ -14366,7 +_,9 @@
 		dangerSense = false;
 		endurance = 0f;
 		whipRangeMultiplier = 1f;
+		/*
 		whipUseTimeMultiplier = 1f;
+		*/
 		calmed = false;
 		beetleOrbs = 0;
 		beetleBuff = false;
@@ -14538,8 +_,10 @@
 		witheredWeapon = false;
 		parryDamageBuff = false;
 		slowOgreSpit = false;
+		hasGemRobe = false; // Added by TML.
 		wings = 0;
 		wingsLogic = 0;
+		equippedWings = null; // Added by TML.
 		wingTimeMax = 0;
 		brokenArmor = false;
 		silence = false;
@@ -14597,6 +_,9 @@
 		boneGloveItem = null;
 		hasLuck_LuckyCoin = false;
 		hasLuck_LuckyHorseshoe = false;
+		blockExtraJumps = false;
+		ExtraJumpLoader.ResetEnableFlags(this);
+		/*
 		hasJumpOption_Cloud = false;
 		hasJumpOption_Sail = false;
 		hasJumpOption_Sandstorm = false;
@@ -14606,6 +_,7 @@
 		hasJumpOption_Santank = false;
 		hasJumpOption_WallOfFleshGoat = false;
 		hasJumpOption_Basilisk = false;
+		*/
 		defendedByPaladin = false;
 		hasPaladinShield = false;
 		hasLucyTheAxe = false;
@@ -14652,18 +_,23 @@
 			}
 		}
 
+		ResetDamageClassData();
+
 		mount.CheckMountBuff(this);
+
+		PlayerLoader.ResetEffects(this);
+		PlayerLoader.ResetInfoAccessories(this);
 	}
 
 	private void UpdateLadyBugLuckTime()
 	{
 		if (ladyBugLuckTimeLeft > 0) {
-			ladyBugLuckTimeLeft -= Main.dayRate;
+			ladyBugLuckTimeLeft -= Main.desiredWorldEventsUpdateRate;
 			if (ladyBugLuckTimeLeft < 0)
 				ladyBugLuckTimeLeft = 0;
 		}
 		else if (ladyBugLuckTimeLeft < 0) {
-			ladyBugLuckTimeLeft += Main.dayRate;
+			ladyBugLuckTimeLeft += Main.desiredWorldEventsUpdateRate;
 			if (ladyBugLuckTimeLeft > 0)
 				ladyBugLuckTimeLeft = 0;
 		}
@@ -14836,6 +_,8 @@
 			lifeRegen -= 100;
 		}
 
+		PlayerLoader.UpdateBadLifeRegen(this);
+
 		if (honey && lifeRegen < 0) {
 			lifeRegen += 4;
 			if (lifeRegen > 0)
@@ -14906,6 +_,8 @@
 		if (whoAmI == Main.myPlayer && Main.SceneMetrics.HasHeartLantern)
 			lifeRegen += 2;
 
+		PlayerLoader.UpdateLifeRegen(this);
+
 		if (bleed)
 			lifeRegenTime = 0f;
 
@@ -14973,6 +_,8 @@
 		if (rabid)
 			num5 = ((!shinyStone) ? (num5 / 2f) : (num5 * 0.75f));
 
+		PlayerLoader.NaturalLifeRegen(this, ref num5);
+
 		float num7 = (float)statLifeMax2 / 400f * 0.85f + 0.15f;
 		num5 *= num7;
 		lifeRegen += (int)Math.Round(num5);
@@ -15166,8 +_,8 @@
 	public void UpdateJumpHeight()
 	{
 		if (mount.Active) {
-			jumpHeight = mount.JumpHeight(velocity.X);
+			jumpHeight = mount.JumpHeight(this, velocity.X);
-			jumpSpeed = mount.JumpSpeed(velocity.X);
+			jumpSpeed = mount.JumpSpeed(this, velocity.X);
 		}
 		else {
 			if (jumpBoost) {
@@ -15582,14 +_,14 @@
 			if (flag4)
 				num5 = 30;
 
-			float damage = (float)num5 * minionDamage;
+			float damage = GetTotalDamage(DamageClass.Summon).ApplyTo(num5);
 			float knockback = 10f;
 			if (flag4)
 				knockback = 7f;
 
 			int nPCImmuneTime = 30;
 			int playerImmuneTime = 6;
-			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime);
+			CollideWithNPCs(rect, damage, knockback, nPCImmuneTime, playerImmuneTime, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 44 && Math.Abs(velocity.X) > mount.DashSpeed - mount.RunSpeed / 4f) {
@@ -15599,11 +_,11 @@
 
 			rect2.Width = 2;
 			rect2.Inflate(6, 12);
-			float damage2 = 100f * minionDamage;
+			float damage2 = GetTotalDamage(DamageClass.Summon).ApplyTo(100f);
 			float knockback2 = 12f;
 			int nPCImmuneTime2 = 30;
 			int playerImmuneTime2 = 6;
-			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2);
+			CollideWithNPCs(rect2, damage2, knockback2, nPCImmuneTime2, playerImmuneTime2, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 45 && Math.Abs(velocity.X) > mount.DashSpeed * 0.9f) {
@@ -15613,11 +_,11 @@
 
 			rect3.Width = 2;
 			rect3.Inflate(6, 12);
-			float damage3 = 120f * minionDamage;
+			float damage3 = GetTotalDamage(DamageClass.Summon).ApplyTo(120f);
 			float knockback3 = 12f;
 			int nPCImmuneTime3 = 30;
 			int playerImmuneTime3 = 6;
-			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3);
+			CollideWithNPCs(rect3, damage3, knockback3, nPCImmuneTime3, playerImmuneTime3, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 14 && Math.Abs(velocity.X) > mount.RunSpeed / 2f) {
@@ -15627,11 +_,11 @@
 
 			rect4.Width = 2;
 			rect4.Inflate(6, 12);
-			float damage4 = 90f * minionDamage;
+			float damage4 = GetTotalDamage(DamageClass.Summon).ApplyTo(90f);
 			float knockback4 = 10f;
 			int nPCImmuneTime4 = 30;
 			int playerImmuneTime4 = 6;
-			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4);
+			CollideWithNPCs(rect4, damage4, knockback4, nPCImmuneTime4, playerImmuneTime4, DamageClass.Summon);
 		}
 
 		if (mount.Active && mount.Type == 17 && Math.Abs(velocity.X) > mount.RunSpeed / 2f) {
@@ -15641,11 +_,11 @@
 
 			rect5.Width = 2;
 			rect5.Inflate(6, 12);
-			float damage5 = 40f * minionDamage;
+			float damage5 = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 			float knockback5 = 10f;
 			int nPCImmuneTime5 = 30;
 			int playerImmuneTime5 = 12;
-			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5);
+			CollideWithNPCs(rect5, damage5, knockback5, nPCImmuneTime5, playerImmuneTime5, DamageClass.Summon);
 		}
 
 		TryUsingDiggerCart();
@@ -15680,7 +_,10 @@
 			num -= height;
 
 		if (runSoundDelay == 0 && velocity.Y == 0f) {
+			/*
 			SoundEngine.PlaySound(hermesStepSound.SoundType, (int)position.X, (int)position.Y, hermesStepSound.SoundStyle);
+			*/
+			SoundEngine.PlaySound(hermesStepSound.Style, position);
 			runSoundDelay = hermesStepSound.IntendedCooldown;
 		}
 
@@ -15822,7 +_,7 @@
 		}
 
 		if (num != 0) {
-			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+			int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, point.X, point.Y);
 			for (int i = 0; i < num2; i++) {
 				WorldGen.KillTile_MakeTileDust(point.X, point.Y, tile);
 			}
@@ -15833,7 +_,7 @@
 		}
 	}
 
-	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime)
+	public int CollideWithNPCs(Rectangle myRect, float Damage, float Knockback, int NPCImmuneTime, int PlayerImmuneTime, DamageClass? damageType = null)
 	{
 		int num = 0;
 		for (int i = 0; i < 200; i++) {
@@ -15851,7 +_,7 @@
 					num2 = 1;
 
 				if (whoAmI == Main.myPlayer)
-					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false);
+					ApplyDamageToNPC(nPC, (int)Damage, Knockback, num2, crit: false, damageType: damageType);
 
 				nPC.immune[whoAmI] = NPCImmuneTime;
 				GiveImmuneTimeForCollisionAttack(PlayerImmuneTime);
@@ -15863,21 +_,91 @@
 		return num;
 	}
 
+	// Added by TML
+	public void ApplyBannerOffenseBuff(NPC npc, ref NPC.HitModifiers modifiers) => ApplyBannerOffenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
+
+	// Added by TML
+	public void ApplyBannerOffenseBuff(int bannerId, ref NPC.HitModifiers modifiers)
+	{
+		if (!HasNPCBannerBuff(bannerId))
+			return;
+
+		var effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
+		modifiers.TargetDamageMultiplier *= Main.expertMode ? effect.ExpertDamageDealt : effect.NormalDamageDealt;
+	}
+
+	// Added by TML
+	public void ApplyBannerDefenseBuff(NPC npc, ref Player.HurtModifiers modifiers) => ApplyBannerDefenseBuff(Item.NPCtoBanner(npc.BannerID()), ref modifiers);
+
+	// Added by TML
+	public void ApplyBannerDefenseBuff(int bannerId, ref Player.HurtModifiers modifiers)
+	{
+		if (!HasNPCBannerBuff(bannerId))
+			return;
+
+		var effect = ItemID.Sets.BannerStrength[Item.BannerToItem(bannerId)];
+		modifiers.IncomingDamageMultiplier *= Main.expertMode ? effect.ExpertDamageReceived : effect.NormalDamageReceived;
+	}
+
+	/// <summary>
+	/// Deals damage to an NPC (and syncs the hit in multiplayer). <br/>
+	/// The damage will be affected by modifiers, armor pen, enemy resistances etc. <br/>
+	/// Will not apply damage class modifiers/knockback. Use <see cref="GetTotalDamage{T}"/> to adjust the damage before calling if necessary. <br/>
+	/// Will apply damage class based armor penetration. <br/>
+	/// Will exit early with no effect if <see cref="PlayerLoader.CanHitNPC"/> returns false.
+	/// </summary>
+	/// <param name="npc">The NPC to strike</param>
+	/// <param name="damage">The damage to deal to the NPC, before modifications, defense, resistances etc</param>
+	/// <param name="knockback">The amount of knockback to apply</param>
+	/// <param name="direction">The hit direction of the resulting strike (1 or -1)</param>
+	/// <param name="crit">Whether or not the strike is a crit</param>
+	/// <param name="damageType">Defaults to <see cref="DamageClass.Default"/></param>
+	/// <param name="damageVariation">Whether to apply damage variation. Defaults to false.</param>
-	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit)
+	public void ApplyDamageToNPC(NPC npc, int damage, float knockback, int direction, bool crit = false, DamageClass? damageType = null, bool damageVariation = false)
 	{
+		if (!PlayerLoader.CanHitNPC(this, npc))
+			return;
+
+		/*
 		int num = Item.NPCtoBanner(npc.BannerID());
 		if (num > 0 && HasNPCBannerBuff(num))
 			damage = ((!Main.expertMode) ? ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].NormalDamageDealt)) : ((int)((float)damage * ItemID.Sets.BannerStrength[Item.BannerToItem(num)].ExpertDamageDealt)));
+		*/
+		var modifiers = npc.GetIncomingStrikeModifiers(damageType ?? DamageClass.Default, direction);
+		PlayerLoader.ModifyHitNPC(this, npc, ref modifiers);
 
+		ApplyBannerOffenseBuff(npc, ref modifiers);
+
+		// most instances of this damage in vanilla are not scaling but they still use generic armor penetration bonus
+		modifiers.ArmorPenetration += GetTotalArmorPenetration(damageType ?? DamageClass.Generic);
+
+		StrikeNPCDirect(npc, modifiers.ToHitInfo(damage, crit, knockback, damageVariation, luck));
+	}
+
+	/// <summary>
+	/// Applies a hit to an NPC via <see cref="NPC.StrikeNPC(NPC.HitInfo, bool, bool)"/>. <br/>
+	/// Also calls player based OnHit and OnKill hooks, tracks dps and net syncs the strike
+	/// </summary>
+	/// <param name="npc">The NPC to strike</param>
+	/// <param name="hit">The hit to apply</param>
+	public void StrikeNPCDirect(NPC npc, NPC.HitInfo hit)
+	{
 		OnHit(npc.Center.X, npc.Center.Y, npc);
+		/*
 		damage += npc.checkArmorPenetration(armorPenetration, 0f);
+		*/
 		NPCKillAttempt attempt = new NPCKillAttempt(npc);
-		int dmg = (int)npc.StrikeNPC(damage, knockback, direction, crit);
-		if (accDreamCatcher)
+		int dmg = npc.StrikeNPC(hit);
+		PlayerLoader.OnHitNPC(this, npc, hit, dmg);
+
+		if (accDreamCatcher && !npc.HideStrikeDamage)
 			addDPS(dmg);
 
 		if (Main.netMode != 0)
+			/*
 			NetMessage.SendData(28, -1, -1, null, npc.whoAmI, damage, knockback, direction, crit.ToInt());
+			*/
+			NetMessage.SendStrikeNPC(npc, hit);
 
 		int num2 = Item.NPCtoBanner(npc.BannerID());
 		if (num2 >= 0)
@@ -15931,7 +_,7 @@
 
 				Rectangle rect2 = nPC.getRect();
 				if (rect.Intersects(rect2) && (nPC.noTileCollide || Collision.CanHit(position, width, height, nPC.position, nPC.width, nPC.height))) {
-					float num = 40f * minionDamage;
+					float num = GetTotalDamage(DamageClass.Summon).ApplyTo(40f);
 					float knockback = 5f;
 					int num2 = direction;
 					if (velocity.X < 0f)
@@ -15941,7 +_,7 @@
 						num2 = 1;
 
 					if (whoAmI == Main.myPlayer)
-						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false);
+						ApplyDamageToNPC(nPC, (int)num, knockback, num2, crit: false, DamageClass.Summon);
 
 					nPC.immune[whoAmI] = 10;
 					velocity.Y = -10f;
@@ -15987,8 +_,10 @@
 				autoJump = false;
 
 			bool flag = false;
+			/*
 			bool flag2 = wet && accFlipper;
 			bool flag3 = !mount.Active || !mount.Cart;
+			*/
 			if (mount.Active && mount.IsConsideredASlimeMount && wetSlime > 0) {
 				wetSlime = 0;
 				flag = true;
@@ -16012,7 +_,7 @@
 					}
 				}
 			}
-			else if ((sliding || velocity.Y == 0f || flag || canJumpAgain_Cloud || canJumpAgain_Sandstorm || canJumpAgain_Blizzard || canJumpAgain_Fart || canJumpAgain_Sail || canJumpAgain_Unicorn || canJumpAgain_Santank || canJumpAgain_WallOfFleshGoat || canJumpAgain_Basilisk || (flag2 && flag3)) && (releaseJump || (autoJump && (velocity.Y == 0f || sliding)))) {
+			else if ((sliding || velocity.Y == 0f || flag || AnyExtraJumpUsable()) && (releaseJump || (autoJump && (velocity.Y == 0f || sliding)))) {
 				if (mount.Active && MountID.Sets.Cart[mount.Type])
 					position.Y -= 0.001f;
 
@@ -16020,6 +_,7 @@
 					justJumped = true;
 
 				bool flag4 = false;
+				/*
 				if (wet && accFlipper) {
 					if (swimTime == 0)
 						swimTime = 30;
@@ -16073,6 +_,10 @@
 						canJumpAgain_Cloud = false;
 					}
 				}
+				*/
+
+				// Patch context: flag
+				bool attemptDoubleJumps = !flag;
 
 				canRocket = false;
 				rocketRelease = false;
@@ -16093,6 +_,10 @@
 					if (sliding)
 						velocity.X = 3 * -slideDir;
 				}
+				else if (attemptDoubleJumps && !blockExtraJumps) {
+					ExtraJumpLoader.ProcessJumps(this);
+				}
+				/*
 				else if (flag5) {
 					isPerformingJump_Sandstorm = true;
 					_ = height;
@@ -16303,6 +_,7 @@
 					Main.gore[num25].velocity.X = Main.gore[num25].velocity.X * 0.1f - velocity.X * 0.1f;
 					Main.gore[num25].velocity.Y = Main.gore[num25].velocity.Y * 0.1f - velocity.Y * 0.05f;
 				}
+				*/
 			}
 
 			releaseJump = false;
@@ -16334,16 +_,24 @@
 
 					Rectangle rect = nPC.getRect();
 					if (rectangle.Intersects(rect) && (nPC.noTileCollide || CanHit(nPC))) {
+						/*
 						float num = 30f * meleeDamage;
 						float num2 = 9f;
+						*/
+						float num = GetTotalDamage(DamageClass.Melee).ApplyTo(30f);
+						float num2 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
 						bool crit = false;
+
+						// Knockback glove and buff moved to UpdateEquips and Update
+						/*
 						if (kbGlove)
 							num2 *= 2f;
 
 						if (kbBuff)
 							num2 *= 1.5f;
+						*/
 
-						if (Main.rand.Next(100) < meleeCrit)
+						if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 							crit = true;
 
 						int num3 = direction;
@@ -16354,7 +_,7 @@
 							num3 = 1;
 
 						if (whoAmI == Main.myPlayer)
-							ApplyDamageToNPC(nPC, (int)num, num2, num3, crit);
+							ApplyDamageToNPC(nPC, (int)num, num2, num3, crit, DamageClass.Melee);
 
 						eocDash = 10;
 						dashDelay = 30;
@@ -16384,16 +_,25 @@
 						ConsumeSolarFlare();
 					}
 
+					/*
 					float num4 = 150f * meleeDamage;
 					float num5 = 9f;
+					*/
+					float num4 = GetTotalDamage(DamageClass.Melee).ApplyTo(150f);
+					float num5 = GetTotalKnockback(DamageClass.Melee).ApplyTo(9f);
+
 					bool crit2 = false;
+
+					// Knockback glove and buff moved to UpdateEquips and Update
+					/*
 					if (kbGlove)
 						num5 *= 2f;
 
 					if (kbBuff)
 						num5 *= 1.5f;
+					*/
 
-					if (Main.rand.Next(100) < meleeCrit)
+					if (Main.rand.Next(100) < GetTotalCritChance(DamageClass.Melee))
 						crit2 = true;
 
 					int num6 = direction;
@@ -16404,7 +_,7 @@
 						num6 = 1;
 
 					if (whoAmI == Main.myPlayer) {
-						ApplyDamageToNPC(nPC2, (int)num4, num5, num6, crit2);
+						ApplyDamageToNPC(nPC2, (int)num4, num5, num6, crit2, DamageClass.Melee);
 						int num7 = Projectile.NewProjectile(GetProjectileSource_OnHit(nPC2, 2), base.Center.X, base.Center.Y, 0f, 0f, 608, (int)num4, 15f, Main.myPlayer);
 						Main.projectile[num7].Kill();
 					}
@@ -16631,6 +_,14 @@
 		solarDashConsumedFlare = false;
 	}
 
+
+	// TODO:
+	// - Make public, as it has little reason to be private and could be of great help to those making modded dashes
+	// - Properly explain how to use this in the context of programming a modded dash (use ExampleShield for this; see below)
+	// - Make ExampleShield use this, and simplify it accordingly (it currently has way too many moving parts that require extra upkeep, for way too little payoff)
+	//
+	// I'll do all this in an upcoming PR if nobody else does.
+	// - Thomas
 	private void DoCommonDashHandle(out int dir, out bool dashing, DashStartAction dashStartAction = null)
 	{
 		dir = 0;
@@ -16745,7 +_,7 @@
 	public void CarpetMovement()
 	{
 		bool flag = false;
-		if (grappling[0] == -1 && carpet && !canJumpAgain_Cloud && !canJumpAgain_Sandstorm && !canJumpAgain_Blizzard && !canJumpAgain_Fart && !canJumpAgain_Sail && !canJumpAgain_Unicorn && !canJumpAgain_Santank && !canJumpAgain_WallOfFleshGoat && !canJumpAgain_Basilisk && jump == 0 && velocity.Y != 0f && rocketTime == 0 && wingTime == 0f && !mount.Active) {
+		if (grappling[0] == -1 && carpet && !AnyExtraJumpUsable() && jump == 0 && velocity.Y != 0f && rocketTime == 0 && wingTime == 0f && !mount.Active) {
 			if (controlJump && canCarpet) {
 				canCarpet = false;
 				carpetTime = 300;
@@ -16783,6 +_,8 @@
 
 	public void DoubleJumpVisuals()
 	{
+		ExtraJumpLoader.JumpVisuals(this);
+		/*
 		if (isPerformingJump_Cloud && hasJumpOption_Cloud && !canJumpAgain_Cloud && (canJumpAgain_Sandstorm || !hasJumpOption_Sandstorm) && ((gravDir == 1f && velocity.Y < 0f) || (gravDir == -1f && velocity.Y > 0f))) {
 			int num = height;
 			if (gravDir == -1f)
@@ -16894,6 +_,7 @@
 			Main.dust[num15].noGravity = true;
 			Main.dust[num15].noLight = true;
 		}
+		*/
 	}
 
 	public void WingMovement()
@@ -16930,6 +_,7 @@
 			if (wingsLogic == 26) {
 				num2 = 0.75f;
 				num5 = 0.15f;
+				// Patch note: num2, num5, num4, num3, num - Used below.
 				num4 = 1f;
 				num3 = 2.5f;
 				num = 0.125f;
@@ -17027,6 +_,8 @@
 					num = 0.15f;
 			}
 
+			ItemLoader.VerticalWingSpeeds(this, ref num2, ref num5, ref num4, ref num3, ref num);
+
 			velocity.Y -= num * gravDir;
 			if (gravDir == 1f) {
 				if (velocity.Y > 0f)
@@ -17335,7 +_,7 @@
 					Position.Y = projectile.position.Y + (float)(projectile.height / 2) - (float)(height / 2);
 					RemoveAllGrapplingHooks();
 					int num4 = 13;
-					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode))
+					if (miscEquips[2].stack > 0 && miscEquips[2].mountType >= 0 && MountID.Sets.Cart[miscEquips[2].mountType] && (!miscEquips[2].expertOnly || Main.expertMode) && (!miscEquips[2].masterOnly || Main.masterMode))
 						num4 = miscEquips[2].mountType;
 
 					int num5 = height + Mount.GetHeightBoost(num4);
@@ -17410,6 +_,12 @@
 			if (projectile.ai[0] != 2f || projectile.position.HasNaNs())
 				continue;
 
+			int type = projectile.type;
+			bool useAiType = projectile.ModProjectile != null && projectile.ModProjectile.AIType > 0;
+			if (useAiType) {
+				projectile.type = projectile.ModProjectile.AIType;
+			}
+
 			num += projectile.position.X + (float)(projectile.width / 2);
 			num2 += projectile.position.Y + (float)(projectile.height / 2);
 			num3++;
@@ -17450,6 +_,12 @@
 				if (vector5.X != 0f)
 					preferredPlayerDirectionToSet = Math.Sign(vector5.X);
 			}
+
+			if (useAiType) {
+				projectile.type = type;
+			}
+
+			ProjectileLoader.GrappleTargetPoint(projectile, this, ref num, ref num2);
 		}
 
 		if (num3 == 0) {
@@ -17474,13 +_,14 @@
 		if (Main.projectile[grappling[0]].type >= 646 && Main.projectile[grappling[0]].type <= 649)
 			num9 = 16f;
 
+		ProjectileLoader.GrapplePullSpeed(Main.projectile[grappling[0]], this, ref num9);
 		float num10 = num8;
 		num10 = ((!(num8 > num9)) ? 1f : (num9 / num8));
 		preferedPlayerVelocityX *= num10;
 		preferedPlayerVelocityY *= num10;
 	}
 
-	private void RefreshMovementAbilities(bool doubleJumps = true)
+	public void RefreshMovementAbilities(bool doubleJumps = true)
 	{
 		wingTime = wingTimeMax;
 		rocketTime = rocketTimeMax;
@@ -17491,6 +_,7 @@
 
 	private void RefreshDoubleJumps()
 	{
+		/*
 		if (hasJumpOption_Cloud)
 			canJumpAgain_Cloud = true;
 
@@ -17517,6 +_,28 @@
 
 		if (hasJumpOption_Basilisk)
 			canJumpAgain_Basilisk = true;
+		*/
+		RefreshExtraJumps();
+	}
+
+	/// <summary>
+	/// For each extra jump that is <see cref="ExtraJumpState.Enabled"/>, its <see cref="ExtraJumpState.Available"/> property set to <see langword="true"/>, allowing the extra jump to be used again.<br/>
+	/// Vanilla calls this method when the player is grounded and when jumping off of a grappling hook.
+	/// </summary>
+	public void RefreshExtraJumps()
+	{
+		ExtraJumpLoader.RefreshJumps(this);
+	}
+
+	/// <summary>
+	/// Sets the <see cref="ExtraJumpState.Available"/> flag for all extra jumps to <see langword="false"/>.<br/>
+	/// If you want to disable an extra jump, use <see cref="ExtraJumpState.Disable"/> instead.<br/>
+	/// If you want to disable <b>all</b> extra jumps, but not prevent them once the disabling factor is removed, use <see cref="blockExtraJumps"/> instead.
+	/// </summary>
+	public void ConsumeAllExtraJumps()
+	{
+		// Included to make consuming all extra jumps easier to write
+		ExtraJumpLoader.ConsumeAllJumps(this);
 	}
 
 	public void StickyMovement()
@@ -18269,10 +_,10 @@
 		if (gravDir == -1f)
 			num2 = (int)(position.Y - 0.1f) / 16;
 
-		Tile floorTile = GetFloorTile(num, num2);
+		Tile? floorTile = GetFloorTile(num, num2);
 		int num3 = -1;
 		if (floorTile != null)
-			num3 = floorTile.type;
+			num3 = floorTile.Value.type;
 
 		if (num3 <= -1) {
 			ResetFloorFlags();
@@ -18287,11 +_,14 @@
 		if (num3 == 666 && whoAmI == Main.myPlayer)
 			AddBuff(120, 180);
 
+
+		TileLoader.FloorVisuals(num3, this);
+
 		if (Main.tile[num - 1, num2].slope() != 0 || Main.tile[num, num2].slope() != 0 || Main.tile[num + 1, num2].slope() != 0)
 			num3 = -1;
 
 		if (!wet && !mount.Cart)
-			MakeFloorDust(Falling, num3, floorTile.color());
+			MakeFloorDust(Falling, num3, floorTile.Value.color());
 	}
 
 	public void ResetFloorFlags()
@@ -18303,9 +_,13 @@
 		runningOnSand = false;
 	}
 
+	//TML: Made return value nullable.
+	/// <summary>
+	/// Gets a solid, unactuated tile at the tile coordinates provided. Will fallback to the tile to the left or right if necessary. Returns null if no suitable tile is found. Typically used to retrieve the tile a player is standing on by passing in the tile coordinates directly below the player.
+	/// </summary>
-	public static Tile GetFloorTile(int x, int y)
+	public static Tile? GetFloorTile(int x, int y)
 	{
-		Tile result = null;
+		Tile? result = null;
 		if (Main.tile[x - 1, y] == null)
 			Main.tile[x - 1, y] = new Tile();
 
@@ -18351,6 +_,7 @@
 			}, whoAmI);
 		}
 
+		if (TileLoader.HasWalkDust(type)) { } else
 		if (type != 147 && type != 25 && type != 53 && type != 189 && type != 0 && type != 123 && type != 57 && type != 112 && type != 116 && type != 196 && type != 193 && type != 195 && type != 197 && type != 199 && type != 229 && type != 234 && type != 371 && type != 460 && type != 666)
 			return;
 
@@ -18434,6 +_,7 @@
 			if (num3 == 0 && Main.rand.Next(3) != 0)
 				flag2 = false;
 
+			// Patch note: num3 & flag2 are used below.
 			if (num3 == 53 && Main.rand.Next(3) != 0)
 				flag2 = false;
 
@@ -18447,6 +_,8 @@
 			if (type == 460)
 				newColor = new Color(100, 150, 130, 100);
 
+			TileLoader.WalkDust(type, ref num3, ref flag2, ref newColor);
+
 			if (!Falling) {
 				float num4 = Math.Abs(velocity.X) / 3f;
 				if ((float)Main.rand.Next(100) > num4 * 100f)
@@ -18712,6 +_,9 @@
 
 	public void Update(int i)
 	{
+		// Auto-disposed at the end of the method.
+		using var _currentPlr = new Main.CurrentPlayerOverride(this);
+
 		if (i == Main.myPlayer && Main.netMode != 2)
 			LockOnHelper.Update();
 
@@ -18833,6 +_,7 @@
 		if (whoAmI != Main.myPlayer) {
 			int num2 = (int)(position.X + (float)(width / 2)) / 16;
 			int num3 = (int)(position.Y + (float)(height / 2)) / 16;
+			/*
 			if (!WorldGen.InWorld(num2, num3, 4))
 				flag = true;
 			else if (Main.tile[num2, num3] == null)
@@ -18845,6 +_,9 @@
 				flag = true;
 			else if (Main.tile[num2, num3 + 3] == null)
 				flag = true;
+			*/
+			if (Main.netMode == 1 && !Main.sectionManager.TilesLoaded(num2 - 3, num3 - 3, num2 + 3, num3 + 3))
+				flag = true;
 
 			if (flag) {
 				outOfRange = true;
@@ -18878,6 +_,9 @@
 
 		UpdateHairDyeDust();
 		UpdateMiscCounter();
+
+		PlayerLoader.PreUpdate(this);
+
 		infernoCounter++;
 		if (infernoCounter >= 180)
 			infernoCounter = 0;
@@ -19218,6 +_,9 @@
 				}
 
 				controlDownHold = holdDownCardinalTimer[0] >= 45;
+
+				PlayerLoader.SetControls(this);
+
 				if (controlInv) {
 					if (releaseInventory)
 						ToggleInv();
@@ -19323,8 +_,12 @@
 							DpadRadial.ChangeSelection(-1);
 							CircularRadial.ChangeSelection(-1);
 						}
-
+						/*
 						if (controlTorch && flag7) {
+						*/
+						// TML: minor tweak, smart select item is held with controlUse even when item cannot be used right now.
+						// In any case where nonTorch has a value, we should be setting nonTorch instead of selectedItem
+						if (nonTorch != -1 && flag7) {
 							if (selectedItem != nonTorch)
 								SoundEngine.PlaySound(12);
 
@@ -19357,6 +_,7 @@
 						CaptureManager.Instance.Scrolling();
 					}
 					else if (!flag8) {
+						if (PlayerInput.MouseInModdedUI.Count > 0) { } else
 						if (!Main.playerInventory) {
 							HandleHotbar();
 						}
@@ -19397,62 +_,66 @@
 								if (Main.focusRecipe > Main.numAvailableRecipes - 1)
 									Main.focusRecipe = Main.numAvailableRecipes - 1;
 
+								// Extra patch context.
 								if (Main.focusRecipe < 0)
 									Main.focusRecipe = 0;
 							}
 						}
+
+						PlayerInput.MouseInModdedUI.Clear();
 					}
 				}
 				else {
 					bool flag10 = false;
 					if (!Main.drawingPlayerChat && selectedItem != 58 && !Main.editSign && !Main.editChest) {
 						int num15 = -1;
-						if (Main.keyState.IsKeyDown(Keys.D1)) {
+						// TML: Fix for digit keys being incorrectly checked instead of Hotbar hotkeys. Should be fixed in 1.4.5.
+						if (PlayerInput.Triggers.Current.Hotbar1) { 
 							num15 = 0;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D2)) {
+						if (PlayerInput.Triggers.Current.Hotbar2) {
 							num15 = 1;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D3)) {
+						if (PlayerInput.Triggers.Current.Hotbar3) {
 							num15 = 2;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D4)) {
+						if (PlayerInput.Triggers.Current.Hotbar4) {
 							num15 = 3;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D5)) {
+						if (PlayerInput.Triggers.Current.Hotbar5) {
 							num15 = 4;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D6)) {
+						if (PlayerInput.Triggers.Current.Hotbar6) {
 							num15 = 5;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D7)) {
+						if (PlayerInput.Triggers.Current.Hotbar7) {
 							num15 = 6;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D8)) {
+						if (PlayerInput.Triggers.Current.Hotbar8) {
 							num15 = 7;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D9)) {
+						if (PlayerInput.Triggers.Current.Hotbar9) {
 							num15 = 8;
 							flag10 = true;
 						}
 
-						if (Main.keyState.IsKeyDown(Keys.D0)) {
+						if (PlayerInput.Triggers.Current.Hotbar10) {
 							num15 = 9;
 							flag10 = true;
 						}
@@ -19461,14 +_,17 @@
 							if (num15 != nonTorch)
 								SoundEngine.PlaySound(12);
 
+							selectItemOnNextUse = true; // Added by TML
 							nonTorch = num15;
 						}
 					}
 				}
 			}
 
+			/* Moved into ItemCheck
 			if (selectedItem != 58)
 				SmartSelectLookup();
+			*/
 
 			if (stoned != lastStoned) {
 				if (whoAmI == Main.myPlayer && stoned) {
@@ -19566,11 +_,14 @@
 					}
 				}
 
+				/*
 				bool flag11 = false;
 				for (int num23 = 3; num23 < 10; num23++) {
 					if (armor[num23].stack > 0 && armor[num23].wingSlot > -1)
 						flag11 = true;
 				}
+				*/
+				bool flag11 = equippedWings != null;
 
 				if (stoned) {
 					int num24 = (int)(((float)num18 * gravDir - 2f) * 20f);
@@ -19706,9 +_,16 @@
 		else
 			afkCounter = 0;
 
+		// TML:
+		// This, right here, is the principal cause of crit chance being a massive pain.
+		// By commenting this out, your critical strike chance for the vanilla "three" classes capable of crits will no longer be modified based on your current weapon.
+		// This fixes a number of issues related to tooltip crit displays, and while it isn't the primary fix for crit swap, it definitely contributes to it.
+		// - Thomas
+		/*
 		meleeCrit += inventory[selectedItem].crit;
 		magicCrit += inventory[selectedItem].crit;
 		rangedCrit += inventory[selectedItem].crit;
+		*/
 		if (whoAmI == Main.myPlayer) {
 			Main.musicBox2 = -1;
 			if (Main.SceneMetrics.WaterCandleCount > 0)
@@ -19742,12 +_,21 @@
 				AddBuff(194, 2, quiet: false);
 		}
 
+		PlayerLoader.PreUpdateBuffs(this);
+
-		for (int num26 = 0; num26 < BuffID.Count; num26++) {
+		for (int num26 = 0; num26 < BuffLoader.BuffCount; num26++) {
 			buffImmune[num26] = false;
 		}
 
 		UpdateProjectileCaches(i);
 		UpdateBuffs(i);
+
+		PlayerLoader.PostUpdateBuffs(this);
+
+		// Moved from ItemCheck_OwnerOnlyCode/DashMovement/GetWeaponKnockback
+		if (kbBuff)
+			allKB *= 1.5f;
+
 		if (whoAmI == Main.myPlayer) {
 			if (!onFire && !poisoned)
 				trapDebuffSource = false;
@@ -19850,6 +_,10 @@
 		if (shadowDodge && !onHitDodge)
 			ClearBuff(59);
 
+
+		//TODO: Move down?
+		PlayerLoader.PostUpdateEquips(this);
+
 		if (maxTurretsOld != maxTurrets) {
 			UpdateMaxTurrets();
 			maxTurretsOld = maxTurrets;
@@ -19897,9 +_,14 @@
 
 			meleeDamage += (1f - stealth) * 3f;
 			meleeCrit += (int)((1f - stealth) * 30f);
+
+			// Psycho Knife knockback. Moved from ItemCheck_OwnerOnlyCode/GetWeaponKnockback
+			GetKnockback(DamageClass.Melee) *= 1f + (1f - stealth);
+
+			/*
 			if (meleeCrit > 100)
 				meleeCrit = 100;
-
+			*/
 			aggro -= (int)((1f - stealth) * 750f);
 			if (stealthTimer > 0)
 				stealthTimer--;
@@ -19930,6 +_,10 @@
 
 			rangedDamage += (1f - stealth) * 0.6f;
 			rangedCrit += (int)((1f - stealth) * 10f);
+
+			// Stealth knockback. Moved from GetWeaponKnockback
+			GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
+
 			aggro -= (int)((1f - stealth) * 750f);
 			if (stealthTimer > 0)
 				stealthTimer--;
@@ -19949,6 +_,10 @@
 
 				rangedDamage += (1f - stealth) * 0.8f;
 				rangedCrit += (int)((1f - stealth) * 20f);
+
+				// Stealth knockback. Moved from GetWeaponKnockback
+				GetKnockback(DamageClass.Ranged) *= 1f + (1f - stealth) * 0.5f;
+
 				aggro -= (int)((1f - stealth) * 1200f);
 				accRunSpeed *= 0.3f;
 				maxRunSpeed *= 0.3f;
@@ -19996,9 +_,12 @@
 		if (manaSick)
 			magicDamage *= 1f - manaSickReduction;
 
+		// Attack speed multipliers now applied in Player.GetWeaponAttackSpeed.
+		/*
 		float num32 = meleeSpeed - 1f;
 		num32 *= ItemID.Sets.BonusMeleeSpeedMultiplier[inventory[selectedItem].type];
 		meleeSpeed = 1f + num32;
+		*/
 		if (tileSpeed > 3f)
 			tileSpeed = 3f;
 
@@ -20007,11 +_,18 @@
 			wallSpeed = 3f;
 
 		wallSpeed = 1f / wallSpeed;
+
+		// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+		/*
 		if (statManaMax2 > 400)
 			statManaMax2 = 400;
+		*/
 
+		// positive value capping built-in to DefenseStat
+		/*
 		if (statDefense < 0)
 			statDefense = 0;
+		*/
 
 		if (slowOgreSpit) {
 			moveSpeed /= 3f;
@@ -20046,6 +_,9 @@
 			pickSpeed = 0.3f;
 
 		CapAttackSpeeds();
+
+		PlayerLoader.PostUpdateMiscEffects(this);
+
 		UpdateLifeRegen();
 		soulDrain = 0;
 		UpdateManaRegen();
@@ -20070,11 +_,14 @@
 			statDefense /= 2;
 
 		if (witheredWeapon) {
+			allDamage *= 0.5f;
+			/*
 			meleeDamage *= 0.5f;
 			rangedDamage *= 0.5f;
 			magicDamage *= 0.5f;
 			minionDamage *= 0.5f;
 			rangedMultDamage *= 0.5f;
+			*/
 		}
 
 		lastTileRangeX = tileRangeX;
@@ -20085,6 +_,8 @@
 			movementAbilitiesCache.PasteInto(this);
 
 		if (mount.Active && mount.BlockExtraJumps) {
+			ConsumeAllExtraJumps();
+			/*
 			canJumpAgain_Cloud = false;
 			canJumpAgain_Sandstorm = false;
 			canJumpAgain_Blizzard = false;
@@ -20094,11 +_,14 @@
 			canJumpAgain_Santank = false;
 			canJumpAgain_WallOfFleshGoat = false;
 			canJumpAgain_Basilisk = false;
+			*/
 		}
 		else if (velocity.Y == 0f || sliding) {
 			RefreshDoubleJumps();
 		}
 		else {
+			ExtraJumpLoader.ConsumeAndStopUnavailableJumps(this);
+			/*
 			if (!hasJumpOption_Cloud)
 				canJumpAgain_Cloud = false;
 
@@ -20125,6 +_,7 @@
 
 			if (!hasJumpOption_Basilisk)
 				canJumpAgain_Basilisk = false;
+			*/
 		}
 
 		if (!carpet) {
@@ -20511,6 +_,7 @@
 				}
 			}
 
+			/*
 			if (sandStorm) {
 				runAcceleration *= 1.5f;
 				maxRunSpeed *= 2f;
@@ -20550,6 +_,9 @@
 				runAcceleration *= 1.5f;
 				maxRunSpeed *= 1.25f;
 			}
+			*/
+
+			ExtraJumpLoader.UpdateHorizontalSpeeds(this);
 
 			if (carpetFrame != -1) {
 				runAcceleration *= 1.25f;
@@ -20594,6 +_,8 @@
 					mount.UpdateDrill(this, controlUp, controlDown);
 			}
 
+			PlayerLoader.PostUpdateRunSpeeds(this);
+
 			HorizontalMovement();
 			bool flag20 = !mount.Active;
 			if (forcedGravity > 0) {
@@ -20684,12 +_,13 @@
 				CancelAllJumpVisualEffects();
 			}
 			else {
+				bool isCustomWings = ItemLoader.WingUpdate(this, flag21);
 				if (flag21) {
 					WingAirVisuals();
 					WingMovement();
 				}
 
-				WingFrame(flag21);
+				WingFrame(flag21, isCustomWings);
 				if (wingsLogic > 0 && rocketBoots != 0 && velocity.Y != 0f && rocketTime != 0) {
 					int num45 = 6;
 					int num46 = rocketTime * num45;
@@ -20700,6 +_,7 @@
 					rocketTime = 0;
 				}
 
+				if (isCustomWings) { } else
 				if (flag21 && wings != 4 && wings != 22 && wings != 0 && wings != 24 && wings != 28 && wings != 30 && wings != 33 && wings != 45) {
 					bool flag22 = wingFrame == 3;
 					if (wings == 43 || wings == 44)
@@ -20722,7 +_,7 @@
 				if (empressBrooch)
 					rocketTime = rocketTimeMax;
 
-				if ((wingTime == 0f || wingsLogic == 0) && rocketBoots != 0 && controlJump && rocketDelay == 0 && canRocket && rocketRelease && !canJumpAgain_Cloud) {
+				if ((wingTime == 0f || wingsLogic == 0) && rocketBoots != 0 && controlJump && rocketDelay == 0 && canRocket && rocketRelease && !AnyExtraJumpUsable()) {
 					if (rocketTime > 0) {
 						rocketTime--;
 						rocketDelay = 10;
@@ -20916,6 +_,7 @@
 								Main.dust[num59].shader = GameShaders.Armor.GetSecondaryShader(cWings, this);
 							}
 
+							if (isCustomWings) { } else
 							if (wings == 4) {
 								rocketDelay2--;
 								if (rocketDelay2 <= 0) {
@@ -21257,12 +_,16 @@
 
 				for (int num79 = 0; num79 < 200; num79++) {
 					if (Main.npc[num79].active && !Main.npc[num79].dontTakeDamage && !Main.npc[num79].friendly && Main.npc[num79].immune[i] == 0 && CanNPCBeHitByPlayerOrPlayerProjectile(Main.npc[num79]) && rectangle2.Intersects(new Rectangle((int)Main.npc[num79].position.X, (int)Main.npc[num79].position.Y, Main.npc[num79].width, Main.npc[num79].height))) {
+						/*
 						float num80 = meleeCrit;
 						if (num80 < (float)rangedCrit)
 							num80 = rangedCrit;
 
 						if (num80 < (float)magicCrit)
 							num80 = magicCrit;
+						*/
+						//TML: Potentially bad for performance
+						float num80 = DamageClassLoader.DamageClasses.Select(t => GetTotalCritChance(t)).Max();
 
 						bool crit = false;
 						if ((float)Main.rand.Next(1, 101) <= num80)
@@ -21722,6 +_,8 @@
 		if (vortexDebuff)
 			velocity.Y = velocity.Y * 0.8f + (float)Math.Cos(base.Center.X % 120f / 120f * ((float)Math.PI * 2f)) * 5f * 0.2f;
 
+		PlayerLoader.PreUpdateMovement(this);
+
 		if (tongued) {
 			position += velocity;
 			flag30 = false;
@@ -21810,11 +_,13 @@
 
 		if (statMana > statManaMax2)
 			statMana = statManaMax2;
-
+		// More patch context.
 		grappling[0] = -1;
 		grapCount = 0;
 		UpdateReleaseUseTile();
 		UpdateAdvancedShadows();
+
+		PlayerLoader.PostUpdate(this);
 	}
 
 	private void TryToToggleSmartCursor(ref bool smartCursorWanted)
@@ -21989,9 +_,11 @@
 
 	private void CapAttackSpeeds()
 	{
+		/*
 		float num = meleeSpeed;
 		meleeSpeed = TurnAttackSpeedToUseTimeMultiplier(num);
 		summonerWeaponSpeedBonus = TurnAttackSpeedToUseTimeMultiplier(num + summonerWeaponSpeedBonus);
+		*/
 	}
 
 	private float TurnAttackSpeedToUseTimeMultiplier(float speed)
@@ -22088,6 +_,9 @@
 
 	public void RecalculateLuck()
 	{
+		if (!PlayerLoader.PreModifyLuck(this, ref luck))
+			goto skipVanillaLuck;
+
 		luck = GetLadyBugLuck() * 0.2f + torchLuck * 0.2f;
 		luck += (float)(int)luckPotion * 0.1f;
 		if (usedGalaxyPearl)
@@ -22101,6 +_,9 @@
 
 		luck += equipmentBasedLuckBonus;
 		luck += CalculateCoinLuck();
+		skipVanillaLuck:
+
+		PlayerLoader.ModifyLuck(this, ref luck);
 	}
 
 	public static int GetMouseScrollDelta() => PlayerInput.ScrollWheelDelta / 120;
@@ -22213,6 +_,8 @@
 
 		if (wingsLogic == 45 && (float)timeSinceLastDashStarted >= 60f)
 			runSlowdown *= 6f;
+
+		ItemLoader.HorizontalWingSpeeds(this);
 	}
 
 	private void RocketBootVisuals()
@@ -22327,7 +_,8 @@
 		}
 	}
 
-	public void WingFrame(bool wingFlap)
+	//TML: Added 'isCustomWings' parameter.
+	public void WingFrame(bool wingFlap, bool isCustomWings = false)
 	{
 		bool flag = wingsLogic != wings;
 		if (wings == 4) {
@@ -22969,6 +_,9 @@
 			num27 = 3;
 		}
 
+		if (isCustomWings)
+			return;
+
 		if (wings == 32)
 			num27 = 3;
 
@@ -23333,7 +_,7 @@
 		if (TileID.Sets.BasicChest[tile.type] || tile.type == 97)
 			r = new Rectangle(chestPointX * 16, chestPointY * 16, 32, 32);
 
-		if (tile.type == 88)
+		if (TileID.Sets.BasicDresser[tile.type])
 			r = new Rectangle(chestPointX * 16, chestPointY * 16, 48, 32);
 
 		if (tile.type == 29)
@@ -23552,6 +_,9 @@
 					break;
 			}
 
+			if (!CombinedHooks.CanNPCHitPlayer(Main.npc[i], this, ref specialHitSetter))
+				continue;
+
 			if ((specialHitSetter == -1 && immune) || (dash == 2 && i == eocHit && eocDash > 0) || npcTypeNoAggro[Main.npc[i].type])
 				continue;
 
@@ -23583,10 +_,15 @@
 					num3 = 1;
 
 				int num4 = Main.DamageVar((float)Main.npc[i].damage * damageMultiplier, 0f - luck);
+
+				// Moved to CombinedHooks.ModifyHitByNPC
+				/*
 				int num5 = Item.NPCtoBanner(Main.npc[i].BannerID());
 				if (num5 > 0 && HasNPCBannerBuff(num5))
 					num4 = ((!Main.expertMode) ? ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].NormalDamageReceived)) : ((int)((float)num4 * ItemID.Sets.BannerStrength[Item.BannerToItem(num5)].ExpertDamageReceived)));
+				*/
 
+				// Extra patch context.
 				bool flag3 = !immune;
 				if (specialHitSetter >= 0)
 					flag3 = hurtCooldowns[specialHitSetter] == 0;
@@ -23609,8 +_,11 @@
 					ApplyDamageToNPC(Main.npc[i], damage, knockback, -num3, crit: false);
 				}
 
+				// Moved to CombinedHooks.ModifyHitByNPC
+				/*
 				if (resistCold && Main.npc[i].coldDamage)
 					num4 = (int)((float)num4 * 0.7f);
+				*/
 
 				if (flag && Hurt(dodgeable: Main.npc[i].IsDamageDodgeable(), damageSource: PlayerDeathReason.ByNPC(i), Damage: num4, hitDirection: num3, pvp: false, quiet: false, Crit: false, cooldownCounter: specialHitSetter) > 0.0 && !dead && !flag2)
 					StatusFromNPC(Main.npc[i]);
@@ -23694,6 +_,9 @@
 
 	public void ItemCheck_ManageRightClickFeatures()
 	{
+		// TODO: Reintegrate AltFunctionUse
+		//ItemLoader.AltFunctionUse(this.inventory[this.selectedItem], this)
+
 		bool flag = selectedItem != 58 && controlUseTile && Main.myPlayer == whoAmI && !tileInteractionHappened && releaseUseItem && !controlUseItem && !mouseInterface && !CaptureManager.Instance.Active && !Main.HoveringOverAnNPC && !Main.SmartInteractShowingGenuine;
 		bool flag2 = flag;
 		if (!ItemID.Sets.ItemsThatAllowRepeatedRightClick[inventory[selectedItem].type] && !Main.mouseRightRelease)
@@ -23814,11 +_,18 @@
 			controlUseItem = true;
 		}
 
+		// Extra patch context.
 		if (flag2 && altFunctionUse == 0 && inventory[selectedItem].shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[inventory[selectedItem].shoot]) {
 			altFunctionUse = 1;
 			controlUseItem = true;
 		}
 
+		// Added by TML
+		if (flag2 && altFunctionUse == 0 && ItemLoader.AltFunctionUse(inventory[selectedItem], this)) {
+			altFunctionUse = 1;
+			controlUseItem = true;
+		}
+
 		if (!controlUseItem && altFunctionUse == 1)
 			altFunctionUse = 0;
 
@@ -23995,6 +_,12 @@
 
 	public void ScrollHotbar(int Offset)
 	{
+		//TML:
+		// Disable hotbar scrolling when using auto select.
+		// Previously it only worked when scrolling between 0 and 9, and made the sound.
+		if (selectedItem >= 10)
+			return;
+
 		Offset = ClampHotbarOffset(Offset);
 		selectedItem += Offset;
 		if (Offset != 0) {
@@ -24244,10 +_,13 @@
 			int num7 = Sign.ReadSign(num5, num6, CreateIfMissing: false);
 			if (num7 != -1 && tileTargetX >= num5 && tileTargetY >= num6 && tileTargetX <= num5 + 1 && tileTargetY <= num6 + 1) {
 				Main.signHover = num7;
+				// Extra patch context.
 				cursorItemIconEnabled = false;
 				cursorItemIconID = -1;
 			}
 		}
+
+		TileLoader.MouseOverFar(myX, myY);
 	}
 
 	private void TileInteractionsUse(int myX, int myY)
@@ -24326,7 +_,7 @@
 				Wiring.HitSwitch(myX, myY);
 				NetMessage.SendData(59, -1, -1, null, myX, myY);
 			}
-			else if (Main.tile[myX, myY].type == 139) {
+			else if (Main.tile[myX, myY].type == 139 || TileLoader.IsModMusicBox(Main.tile[myX, myY])) {
 				flag2 = true;
 				SoundEngine.PlaySound(28, myX * 16, myY * 16, 0);
 				WorldGen.SwitchMB(myX, myY);
@@ -24450,7 +_,10 @@
 				flag2 = true;
 				GamepadEnableGrappleCooldown();
 			}
+			/*
 			else if (Main.tile[myX, myY].type == 4 || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90)) {
+			*/
+			else if (TileID.Sets.Torch[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 13 || (Main.tile[myX, myY].type == 50 && Main.tile[myX, myY].frameX == 90) || TileID.Sets.CanDropFromRightClick[Main.tile[myX, myY].type]) {
 				WorldGen.KillTile(myX, myY);
 				if (Main.netMode == 1)
 					NetMessage.SendData(17, -1, -1, null, 0, myX, myY);
@@ -24770,7 +_,9 @@
 				if (!NPC.AnyNPCs(245) && Main.hardMode && NPC.downedPlantBoss) {
 					for (int m = 0; m < 58; m++) {
 						if (inventory[m].type == 1293) {
+							if (ItemLoader.ConsumeItem(inventory[m], this))
-							inventory[m].stack--;
+								inventory[m].stack--;
+
 							if (inventory[m].stack <= 0)
 								inventory[m].SetDefaults();
 
@@ -24788,7 +_,7 @@
 						NetMessage.SendData(61, -1, -1, null, whoAmI, 245f);
 				}
 			}
-			else if (Main.tile[myX, myY].type == 10) {
+			else if (TileLoader.IsClosedDoor(Main.tile[myX, myY])) {
 				flag2 = true;
 				if (WorldGen.IsLockedDoor(myX, myY)) {
 					int num43 = 1141;
@@ -24796,13 +_,18 @@
 					for (int n = 0; n < 58; n++) {
 						if (inventory[n].type == num43 && inventory[n].stack > 0) {
 							flag9 = true;
+							if (ItemLoader.ConsumeItem(inventory[n], this))
-							inventory[n].stack--;
+								inventory[n].stack--;
+
 							if (inventory[n].stack <= 0)
 								inventory[n] = new Item();
 
 							WorldGen.UnlockDoor(myX, myY);
 							if (Main.netMode == 1)
 								NetMessage.SendData(52, -1, -1, null, whoAmI, 2f, myX, myY);
+
+							// Added by TML.
+							break;
 						}
 					}
 
@@ -24821,18 +_,20 @@
 					}
 				}
 				else {
+					int originalClosedDoorType = Main.tile[myX, myY].type;
+
 					WorldGen.OpenDoor(myX, myY, direction);
-					if (Main.tile[myX, myY].type != 10) {
+					if (Main.tile[myX, myY].type != originalClosedDoorType) {
 						NetMessage.SendData(19, -1, -1, null, 0, myX, myY, direction);
 					}
 					else {
 						WorldGen.OpenDoor(myX, myY, -direction);
-						if (Main.tile[myX, myY].type != 10)
+						if (Main.tile[myX, myY].type != originalClosedDoorType)
 							NetMessage.SendData(19, -1, -1, null, 0, myX, myY, -direction);
 					}
 				}
 			}
-			else if (Main.tile[myX, myY].type == 11) {
+			else if (TileLoader.CloseDoorID(Main.tile[myX, myY]) >= 0) {
 				flag2 = true;
 				if (WorldGen.CloseDoor(myX, myY))
 					NetMessage.SendData(19, -1, -1, null, 1, myX, myY, direction);
@@ -25004,7 +_,10 @@
 				if (flag12)
 					NetMessage.SendTileSquare(-1, num62, num63, 2, 2);
 			}
+			/*
 			else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
+			*/
+			else if (TileID.Sets.BasicChest[Main.tile[myX, myY].type] && Main.tile[myX, myY].type < TileID.Count || Main.tile[myX, myY].type == 29 || Main.tile[myX, myY].type == 97 || Main.tile[myX, myY].type == 463 || Main.tile[myX, myY].type == 491) {
 				flag2 = true;
 				Main.mouseRightRelease = false;
 				int num68 = 0;
@@ -25046,7 +_,7 @@
 					editedChestName = false;
 				}
 
-				bool flag13 = Chest.IsLocked(Main.tile[num69, num70]);
+				bool flag13 = Chest.IsLocked(num69, num70);
 				if (Main.netMode == 1 && num68 == 0 && !flag13) {
 					if (num69 == chestX && num70 == chestY && chest != -1) {
 						chest = -1;
@@ -25116,7 +_,9 @@
 
 									flag15 = true;
 									if (flag16) {
+										if (ItemLoader.ConsumeItem(inventory[num76], this))
-										inventory[num76].stack--;
+											inventory[num76].stack--;
+
 										if (inventory[num76].stack <= 0)
 											inventory[num76] = new Item();
 									}
@@ -25190,13 +_,16 @@
 				if (flag17)
 					LaunchMinecartHook(myX, myY);
 			}
+
+			if (TileLoader.RightClick(myX, myY))
+				flag2 = true;
 		}
 
 		if (flag2)
 			tileInteractionHappened = true;
 	}
 
-	private static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
+	public static bool IsHoveringOverABottomSideOfABed(int myX, int myY)
 	{
 		short frameX = Main.tile[myX, myY].frameX;
 		bool flag = frameX / 72 == 1;
@@ -25345,7 +_,14 @@
 			StopPettingAnimal();
 	}
 
+	/// <summary>
+	/// Handles boilerplate for gamepad and UI when opening or closing a container.
+	/// <br/>Sets <see cref="Player.chestX"/>, and <see cref="Player.chestY"/>, and <see cref="Player.chest"/> to the given coordinates.
+	/// </summary>
+	/// <param name="x">The top-left X coordinate of the container.</param>
+	/// <param name="y">The top-left Y coordinate of the container.</param>
+	/// <param name="newChest">The container index in <see cref="Main.chest"/> if opening, or -1 if closing.</param>
-	private void OpenChest(int x, int y, int newChest)
+	public void OpenChest(int x, int y, int newChest)
 	{
 		if (chest != -1 && Main.myPlayer == whoAmI) {
 			for (int i = 0; i < 40; i++) {
@@ -26230,7 +_,10 @@
 			cursorItemIconID = 3747;
 		}
 
+		/*
 		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && (inventory[selectedItem].type == 424 || inventory[selectedItem].type == 1103 || inventory[selectedItem].type == 2339 || inventory[selectedItem].type == 2338 || inventory[selectedItem].type == 2337)) {
+		*/
+		if ((Main.tile[myX, myY].type == 219 || Main.tile[myX, myY].type == 642) && ItemID.Sets.ExtractinatorMode[inventory[selectedItem].type] > -1) {
 			noThrow = 2;
 			cursorItemIconEnabled = true;
 			cursorItemIconID = inventory[selectedItem].type;
@@ -26824,6 +_,8 @@
 			noThrow = 2;
 		}
 
+		TileLoader.MouseOver(myX, myY);
+
 		if (PlayerInput.UsingGamepad && cursorItemIconText.Length == 0) {
 			cursorItemIconEnabled = false;
 			cursorItemIconID = 0;
@@ -26967,11 +_,23 @@
 			if (!item.active || item.shimmerTime != 0f || item.noGrabDelay != 0 || item.playerIndexTheItemIsReservedFor != i || !CanAcceptItemIntoInventory(item) || (item.shimmered && !((double)item.velocity.Length() < 0.2)))
 				continue;
 
+			if (!ItemLoader.CanPickup(item, this))
+				continue;
+
 			int itemGrabRange = GetItemGrabRange(item);
 			Rectangle hitbox = item.Hitbox;
 			if (base.Hitbox.Intersects(hitbox)) {
-				if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0))
+				if (i == Main.myPlayer && (inventory[selectedItem].type != 0 || itemAnimation <= 0)) {
+					if (!CombinedHooks.OnPickup(Main.item[j], this)) {
+						Main.item[j] = new Item();
+						if (Main.netMode == 1)
+							NetMessage.SendData(21, -1, -1, null, j);
+
+						continue;
+					}
+
 					item = PickupItem(i, j, item);
+				}
 			}
 			else {
 				if (!new Rectangle((int)position.X - itemGrabRange, (int)position.Y - itemGrabRange, width + itemGrabRange * 2, height + itemGrabRange * 2).Intersects(hitbox))
@@ -26985,6 +_,7 @@
 					if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 						flag = true;
 
+					if (ItemLoader.GrabStyle(item, this)) { } else
 					if (flag)
 						PullItem_Pickup(item, 7f, 1);
 					else if (manaMagnet && (item.type == 184 || item.type == 1735 || item.type == 1868))
@@ -27105,6 +_,10 @@
 		return itemToPickUp;
 	}
 
+	/// <summary>
+	/// Heals the player for a certain amount.
+	/// </summary>
+	/// <param name="amount">The amount to heal the player by.</param>
 	public void Heal(int amount)
 	{
 		statLife += amount;
@@ -27115,6 +_,12 @@
 			statLife = statLifeMax2;
 	}
 
+	/// <summary>
+	/// Fetches the range at which the given item begins to gravitate towards the player.<br/>
+	/// This range, referred to as item grab range, is measured in pixels.
+	/// </summary>
+	/// <param name="item">The item whose grab range is being evaluated.</param>
+	/// <returns>The item grab range of the player, in pixels.</returns>
 	public int GetItemGrabRange(Item item)
 	{
 		int num = defaultItemGrabRange;
@@ -27139,9 +_,11 @@
 		if (ItemID.Sets.NebulaPickup[item.type])
 			num += 100;
 
+		// Extra patch context.
 		if (difficulty == 3 && CreativePowerManager.Instance.GetPower<CreativePowers.FarPlacementRangePower>().IsEnabledForPlayer(whoAmI))
 			num += 240;
 
+		ItemLoader.GrabRange(item, this, ref num);
 		return num;
 	}
 
@@ -27344,11 +_,26 @@
 		}
 	}
 
+	/// <summary>
+	/// Attempts to "purchase" something that costs the given <paramref name="price"/>.<br/>
+	/// Items will be taken from all of the player inventories and banks combined.<br/>
+	/// If <paramref name="customCurrency"/> is provided, the price will be in terms of the custom currency instead of coins.<br/>
+	/// If the player has enough currency, the currency will be taken from the inventories.<br/>
+	/// </summary>
+	/// <param name="price"></param>
+	/// <param name="customCurrency"></param>
+	/// <returns>true if the player had enough currency to pay the price.</returns>
 	public bool BuyItem(long price, int customCurrency = -1)
 	{
-		if (customCurrency != -1)
-			return CustomCurrencyManager.BuyItem(this, price, customCurrency);
+		if (CanAfford(price, customCurrency))
+			return PayCurrency(price, customCurrency);
+		return false;
+	}
 
+	public bool CanAfford(long price, int customCurrency = -1)
+	{
+		if (customCurrency != -1)
+			return CustomCurrencyManager.CanAfford(this, price, customCurrency);
 		bool overFlowing;
 		long num = Utils.CoinsCount(out overFlowing, inventory, 58, 57, 56, 55, 54);
 		long num2 = Utils.CoinsCount(out overFlowing, bank.item);
@@ -27357,7 +_,13 @@
 		long num5 = Utils.CoinsCount(out overFlowing, bank4.item);
 		if (Utils.CoinsCombineStacks(out overFlowing, num, num2, num3, num4, num5) < price)
 			return false;
+		return true;
+	}
 
+	public bool PayCurrency(long price, int customCurrency = -1)
+	{
+		if (customCurrency != -1)
+			return CustomCurrencyManager.PayCurrency(this, price, customCurrency);
 		List<Item[]> list = new List<Item[]>();
 		Dictionary<int, List<int>> dictionary = new Dictionary<int, List<int>>();
 		List<Point> list2 = new List<Point>();
@@ -27569,7 +_,7 @@
 			num2 += 4;
 		}
 
-		for (int i = 0; i < TileID.Count; i++) {
+		for (int i = 0; i < adjTile.Length; i++) {
 			oldAdjTile[i] = adjTile[i];
 			adjTile[i] = false;
 		}
@@ -27580,6 +_,8 @@
 		adjHoney = false;
 		oldAdjLava = adjLava;
 		adjLava = false;
+		oldAdjShimmer = adjShimmer;
+		adjShimmer = false;
 		alchemyTable = false;
 		int num3 = (int)((position.X + (float)(width / 2)) / 16f);
 		int num4 = (int)((position.Y + (float)height) / 16f);
@@ -27610,16 +_,21 @@
 							alchemyTable = true;
 							break;
 					}
+
+					TileLoader.AdjTiles(this, Main.tile[j, k].type);
 				}
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 0) || TileID.Sets.CountsAsWaterSource[Main.tile[j, k].type])
 					adjWater = true;
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 2) || TileID.Sets.CountsAsHoneySource[Main.tile[j, k].type])
 					adjHoney = true;
 
-				if (Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1)
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 1) || TileID.Sets.CountsAsLavaSource[Main.tile[j, k].type])
 					adjLava = true;
+
+				if ((Main.tile[j, k].liquid > 200 && Main.tile[j, k].liquidType() == 3) || TileID.Sets.CountsAsShimmerSource[Main.tile[j, k].type])
+					adjShimmer = true;
 			}
 		}
 
@@ -27627,7 +_,7 @@
 			return;
 
 		bool flag = false;
-		for (int l = 0; l < TileID.Count; l++) {
+		for (int l = 0; l < adjTile.Length; l++) {
 			if (oldAdjTile[l] != adjTile[l]) {
 				flag = true;
 				break;
@@ -27643,6 +_,9 @@
 		if (adjLava != oldAdjLava)
 			flag = true;
 
+		if (adjShimmer != oldAdjShimmer)
+			flag = true;
+
 		if (flag)
 			Recipe.FindRecipes();
 	}
@@ -27759,7 +_,7 @@
 			waist = 0;
 
 		if (!dead && body >= 0) {
-			sbyte b = (sbyte)(Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
+			int b = (Male ? ArmorIDs.Body.Sets.IncludedCapeBack : ArmorIDs.Body.Sets.IncludedCapeBackFemale)[body];
 			if (b != -1) {
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[b]) {
 					backpack = b;
@@ -27775,7 +_,7 @@
 				}
 			}
 
-			sbyte b2 = (sbyte)ArmorIDs.Body.Sets.IncludedCapeFront[body];
+			int b2 = ArmorIDs.Body.Sets.IncludedCapeFront[body];
 			if (b2 != -1 && front == -1) {
 				front = b2;
 				cFront = cBody;
@@ -27785,7 +_,7 @@
 			if (!includeCapeFrontAndBackInfo.Invalid && back == -1 && front == -1) {
 				front = includeCapeFrontAndBackInfo.frontCape;
 				cFront = cBody;
-				sbyte backCape = includeCapeFrontAndBackInfo.backCape;
+				int backCape = includeCapeFrontAndBackInfo.backCape;
 				if (ArmorIDs.Back.Sets.DrawInBackpackLayer[backCape]) {
 					backpack = backCape;
 					cBackpack = cBody;
@@ -27848,9 +_,14 @@
 			SetArmorEffectVisuals(this);
 		}
 
+		/*
 		hermesStepSound.SoundType = 17;
 		hermesStepSound.SoundStyle = -1;
+		*/
+		hermesStepSound.Style = SoundID.Run;
+
 		hermesStepSound.IntendedCooldown = 9;
+
 		if (head == 99 && body == 65 && legs == 54)
 			turtleArmor = true;
 
@@ -27859,8 +_,12 @@
 
 		ApplyArmorSoundAndDustChanges();
 		if (legs == 140) {
+			/*
 			hermesStepSound.SoundType = 2;
 			hermesStepSound.SoundStyle = 24;
+			*/
+			hermesStepSound.Style = SoundID.Item24;
+
 			hermesStepSound.IntendedCooldown = 6;
 		}
 
@@ -27870,6 +_,8 @@
 			faceHead = -1;
 		}
 
+		ItemLoader.PreUpdateVanitySet(this);
+
 		if (head > 0 && face > 0) {
 			if (ArmorIDs.Face.Sets.OverrideHelmet[face]) {
 				head = -1;
@@ -27881,7 +_,7 @@
 		}
 
 		if (head > 0 && faceHead > 0 && ArmorIDs.Head.Sets.UseAltFaceHeadDraw[head]) {
-			sbyte b3 = (sbyte)ArmorIDs.Face.Sets.AltFaceHead[faceHead];
+			int b3 = ArmorIDs.Face.Sets.AltFaceHead[faceHead];
 			if (b3 > 0)
 				faceHead = b3;
 		}
@@ -27905,6 +_,9 @@
 			obj.shader = GameShaders.Armor.GetSecondaryShader(cBody, this);
 		}
 
+		//TODO: Do these hooks go inside or outside the conditional?
+		CombinedHooks.PlayerFrameEffects(this);
+
 		if (!isDisplayDollOrInanimate) {
 			if (((body == 68 && legs == 57 && head == 106) || (body == 74 && legs == 63 && head == 106)) && Main.rand.Next(10) == 0) {
 				int num3 = Dust.NewDust(new Vector2(position.X - velocity.X * 2f, position.Y - 2f - velocity.Y * 2f), width, height, 43, 0f, 0f, 100, new Color(255, 0, 255), 0.3f);
@@ -28028,7 +_,11 @@
 
 		Item.GetDrawHitbox(HeldItem.type, this);
 		bool flag3 = CanVisuallyHoldItem(HeldItem);
-		bool flag4 = HeldItem.type != 4952;
+		// bool flag4 = HeldItem.type != 4952;
+		bool flag4 = HeldItem.useStyle != ItemUseStyleID.RaiseLamp; // TML: #RaiseLampAnimationFix
+
+		ItemLoader.UpdateVanitySet(this);
+
 		if (mount.Active) {
 			legFrameCounter = 0.0;
 			legFrame.Y = legFrame.Height * 6;
@@ -28245,6 +_,8 @@
 					}
 				}
 			}
+
+			ItemLoader.UseItemFrame(inventory[selectedItem], this);
 		}
 		else if (pulley) {
 			if (pulleyDir == 2)
@@ -28252,7 +_,7 @@
 			else
 				bodyFrame.Y = bodyFrame.Height * 2;
 		}
-		else if (flag3 && inventory[selectedItem].holdStyle == 1 && (!wet || !inventory[selectedItem].noWet) && (!happyFunTorchTime || inventory[selectedItem].createTile != 4)) {
+		else if (flag3 && inventory[selectedItem].holdStyle == 1 && (!wet || !inventory[selectedItem].noWet || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(inventory[selectedItem].type)]/*Allow biome torches underwater.*/) && (!happyFunTorchTime || inventory[selectedItem].createTile != 4)) {
 			bodyFrame.Y = bodyFrame.Height * 3;
 		}
 		else if (flag3 && inventory[selectedItem].holdStyle == 2 && (!wet || !inventory[selectedItem].noWet)) {
@@ -28381,6 +_,10 @@
 			reference9.Y = 0;
 		}
 
+		if (flag3 && itemAnimation <= 0) {
+			ItemLoader.HoldItemFrame(inventory[selectedItem], this);
+		}
+
 		if (legs == 140) {
 			legFrameCounter = 0.0;
 			legFrame.Y = legFrame.Height * (velocity.Y != 0f).ToInt();
@@ -28403,6 +_,8 @@
 
 	private void CancelAllJumpVisualEffects()
 	{
+		ExtraJumpLoader.StopActiveJump(this, out _);
+		/*
 		isPerformingJump_Cloud = false;
 		isPerformingJump_Sandstorm = false;
 		isPerformingJump_Blizzard = false;
@@ -28410,9 +_,10 @@
 		isPerformingJump_Sail = false;
 		isPerformingJump_Unicorn = false;
 		isPerformingJump_Santank = false;
+		*/
 	}
 
-	private void CancelAllBootRunVisualEffects()
+	public void CancelAllBootRunVisualEffects()
 	{
 		sailDash = false;
 		coldDash = false;
@@ -28501,6 +_,7 @@
 
 	private void UpdateVisibleAccessories()
 	{
+		/*
 		for (int i = 3; i < 10; i++) {
 			if (!IsItemSlotUnlockedAndUsable(i))
 				continue;
@@ -28531,6 +_,16 @@
 			if (!hideVisibleAccessory[i])
 				UpdateVisibleAccessory(i, item);
 		}
+		*/
+		for (int i = 3; i < 10; i++) {
+			if (!IsItemSlotUnlockedAndUsable(i))
+				continue;
+
+			// Commented code above moved into UpdateVisibleAccessories
+			UpdateVisibleAccessories(armor[i], hideVisibleAccessory[i], i);
+		}
+
+		PlayerLoader.UpdateVisibleAccessories(this);
 
 		for (int j = 13; j < 20; j++) {
 			if (IsItemSlotUnlockedAndUsable(j)) {
@@ -28538,7 +_,10 @@
 				if (!ItemIsVisuallyIncompatible(item2))
 					UpdateVisibleAccessory(j, item2);
 			}
+			// Extra patch context
 		}
+
+		PlayerLoader.UpdateVisibleVanityAccessories(this);
 
 		int type = HeldItem.type;
 		if (type == 4760 && ownedProjectileCounts[866] < 1) {
@@ -28547,7 +_,7 @@
 		}
 	}
 
-	private bool ItemIsVisuallyIncompatible(Item item)
+	public bool ItemIsVisuallyIncompatible(Item item)
 	{
 		if (compositeBackArm.enabled && item.shieldSlot > 0)
 			return true;
@@ -28575,7 +_,8 @@
 		return false;
 	}
 
-	private void UpdateVisibleAccessory(int itemSlot, Item item)
+	//TML: Made public, 'modded' parameter added.
+	public void UpdateVisibleAccessory(int itemSlot, Item item, bool modded = false)
 	{
 		if (item.stringColor > 0)
 			stringColor = item.stringColor;
@@ -28608,7 +_,7 @@
 		if (item.shoeSlot > 0) {
 			shoe = item.shoeSlot;
 			if (!Male && ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe] > 0)
-				shoe = (sbyte)ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
+				shoe = ArmorIDs.Shoe.Sets.MaleToFemaleID[shoe];
 		}
 
 		if (item.waistSlot > 0)
@@ -28642,9 +_,13 @@
 		if (item.wingSlot > 0)
 			wings = item.wingSlot;
 
-		if (item.type == 3580)
+		if (item.type == 3580) {
 			yoraiz0rEye = itemSlot - 2;
 
+			if (modded) // Treat similar to expert/master mode slots
+				yoraiz0rEye += 5;
+		}
+
 		if (item.type == 3581)
 			yoraiz0rDarkness = true;
 
@@ -28799,6 +_,9 @@
 		if (drawPlayer.head == 267)
 			yoraiz0rDarkness = true;
 
+		//TODO: Rename to SetArmorEffectVisuals?
+		ItemLoader.ArmorSetShadows(drawPlayer);
+
 		if (drawPlayer.stoned || drawPlayer.stealth != 1f) {
 			armorEffectDrawOutlines = false;
 			armorEffectDrawShadow = false;
@@ -28994,10 +_,12 @@
 				case 232:
 					if (!male)
 						num2 = 233;
+					// Patch context
 					break;
 			}
 		}
 
+		ItemLoader.SetMatch(armorSlotRequested, num, male, ref num2, ref somethingSpecial);
 		return num2;
 	}
 
@@ -29189,6 +_,10 @@
 			}
 
 			immune = true;
+
+			if (dead)
+				PlayerLoader.OnRespawn(this);
+
 			dead = false;
 			immuneTime = 0;
 		}
@@ -29505,14 +_,44 @@
 			frostArmor = true;
 	}
 
+	// Added to replace Main.CalculateDamagePlayersTake[InPvP]
+	private static float VanillaBaseDefenseEffectiveness()
+	{
+		if (Main.masterMode)
+			return 1;
+		if (Main.expertMode)
+			return 0.75f;
+
+		return 0.5f;
+	}
+
+	// made internal because public version has Crit param removed, added armorPenetration arg for smaller Projectile patches
-	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, bool Crit = false, int cooldownCounter = -1, bool dodgeable = true)
+	internal double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp, bool quiet, bool Crit, int cooldownCounter, bool dodgeable = true, float armorPenetration = 0)
 	{
+		return Hurt(damageSource, Damage, hitDirection, pvp, quiet, cooldownCounter, dodgeable, armorPenetration);
+	}
+
+	// extra parameters (armorPenetration, scalingArmorPenetration, knockback) added. Crit param removed
+	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0, float scalingArmorPenetration = 0, float knockback = 4.5f)
+	{
+		return Hurt(damageSource, Damage, hitDirection, out _,
+			pvp, quiet, cooldownCounter, dodgeable, armorPenetration, scalingArmorPenetration, knockback);
+	}
+
+	// out param and extras from above added
+	public double Hurt(PlayerDeathReason damageSource, int Damage, int hitDirection, out HurtInfo info, bool pvp = false, bool quiet = false, int cooldownCounter = -1, bool dodgeable = true, float armorPenetration = 0, float scalingArmorPenetration = 0, float knockback = 4.5f)
+	{
+		info = default;
+
 		if (shimmering && AllowShimmerDodge(damageSource, cooldownCounter, dodgeable))
 			return 0.0;
 
 		if (creativeGodMode)
 			return 0.0;
 
+		if (PlayerLoader.ImmuneTo(this, damageSource, cooldownCounter, dodgeable))
+			return 0.0;
+
 		bool flag = !immune;
 		bool flag2 = false;
 		int hitContext = cooldownCounter;
@@ -29530,7 +_,34 @@
 		}
 
 		if (flag) {
+			HurtModifiers modifiers = new() {
+				DamageSource = damageSource,
+				PvP = pvp,
+				CooldownCounter = cooldownCounter,
+				Dodgeable = dodgeable,
+				HitDirection = hitDirection
+			};
+			PlayerLoader.ModifyHurt(this, ref modifiers);
+
+			// intentionally add parameter modifiers after, to reduce the temptation to read their values in Modify hooks
+			modifiers.ArmorPenetration += armorPenetration;
+			modifiers.ScalingArmorPenetration += scalingArmorPenetration;
+
+			// ogre knockback re-implemented from below
+			if (flag2) {
+				// this gives the right values for X knockback.
+				// Y knockback will be slightly different, but mostly accurate
+				modifiers.Knockback.Base += 6f;
+				modifiers.KnockbackImmunityEffectiveness *= 0.8f; // still launch the player a little
+			}
+
+			ApplyVanillaHurtEffectModifiers(ref modifiers);
+			info = modifiers.ToHurtInfo(Damage, statDefense, pvp ? 0.5f : DefenseEffectiveness.Value, knockback, noKnockback);
+
 			if (dodgeable) {
+				if (whoAmI == Main.myPlayer && PlayerLoader.FreeDodge(this, info))
+					return 0.0;
+
 				if (whoAmI == Main.myPlayer && blackBelt && Main.rand.Next(10) == 0) {
 					NinjaDodge();
 					return 0.0;
@@ -29545,24 +_,44 @@
 					ShadowDodge();
 					return 0.0;
 				}
+
+				if (whoAmI == Main.myPlayer && PlayerLoader.ConsumableDodge(this, info))
+					return 0.0;
 			}
 
+			Hurt(info, quiet);
+			return info.Damage;
+		}
+
+		return 0.0;
+	}
+
+	private void OnHurt_Part1(HurtInfo info)
+	{
+		int hitDirection = info.HitDirection;
+		{
 			if (whoAmI == Main.myPlayer && panic)
 				AddBuff(63, 480);
 
 			if (whoAmI == Main.myPlayer && setSquireT2)
 				AddBuff(205, 300);
 
+			// Note for future, potential optimization, no need to reset stealth every hit
 			stealth = 1f;
 			if (Main.netMode == 1)
 				NetMessage.SendData(84, -1, -1, null, whoAmI);
 
+			// Note, vanilla condition can never fail, num2 (damage to take) is always at least 1
+			// num is commented out, as it was only used to lie about pvp
+			/*
 			int num = Damage;
 			double num2 = Main.CalculateDamagePlayersTake(num, statDefense);
 			if (Crit)
 				num *= 2;
 
 			if (num2 >= 1.0) {
+			*/
+			{
 				if (whoAmI == Main.myPlayer) {
 					Main.NotifyOfEvent(GameNotificationType.Damage);
 					if (hasFootball) {
@@ -29584,22 +_,60 @@
 					}
 				}
 
+				if (channel && inventory[selectedItem].InterruptChannelOnHurt) {
+					channel = false;
+				}
+
+				if (itemAnimation > 0 && inventory[selectedItem].StopAnimationOnHurt) {
+					channel = false;
+					itemAnimation = 0;
+					itemAnimationMax = 0;
+				}
+
 				if (invis) {
 					for (int k = 0; k < maxBuffs; k++) {
 						if (buffType[k] == 10)
 							DelBuff(k);
 					}
 				}
+			}
+		}
+	}
 
+	private void ApplyVanillaHurtEffectModifiers(ref HurtModifiers modifiers)
+	{
+		{
+			modifiers.FinalDamage *= Math.Max(1 - endurance, 0);
+			if (setSolar && solarShields > 0)
+				modifiers.FinalDamage *= 0.8f;
+
+			if (beetleDefense && beetleOrbs > 0)
+				modifiers.FinalDamage *= 1 - 0.15f * beetleOrbs;
+
+			if (defendedByPaladin && whoAmI == Main.myPlayer && TeammateHasPalidinShieldAndCanTakeDamage())
+				modifiers.FinalDamage *= 0.75f;
+		}
+	}
+
+	private void OnHurt_Part2(HurtInfo info)
+	{
+		// Implementations for solar flare, beetle defense and paladin's shield have been split into ApplyVanillaHurtEffectModifiers (above)
+		var damageSource = info.DamageSource;
+		{
+			{
+				/*
 				num2 = (int)((double)(1f - endurance) * num2);
 				if (num2 < 1.0)
 					num2 = 1.0;
+				*/
 
 				if (ConsumeSolarFlare()) {
+					/*
 					float num3 = 0.2f;
 					num2 = (int)((double)(1f - num3) * num2);
 					if (num2 < 1.0)
 						num2 = 1.0;
+						*/
 
 					if (whoAmI == Main.myPlayer) {
 						IEntitySource spawnSource = GetProjectileSource_SetBonus(1);
@@ -29607,15 +_,17 @@
 						if (damageSource.TryGetCausingEntity(out entity))
 							spawnSource = GetProjectileSource_OnHurt(entity, 1);
 
-						int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)(150f * meleeDamage), 15f, Main.myPlayer);
+						int num4 = Projectile.NewProjectile(spawnSource, base.Center.X, base.Center.Y, 0f, 0f, 608, (int)GetTotalDamage(DamageClass.Melee).ApplyTo(150f), 15f, Main.myPlayer);
 						Main.projectile[num4].netUpdate = true;
 						Main.projectile[num4].Kill();
 					}
 				}
 
 				if (beetleDefense && beetleOrbs > 0) {
+					/*
 					float num5 = 0.15f * (float)beetleOrbs;
 					num2 = (int)((double)(1f - num5) * num2);
+					*/
 					beetleOrbs--;
 					for (int l = 0; l < maxBuffs; l++) {
 						if (buffType[l] >= 95 && buffType[l] <= 97)
@@ -29626,12 +_,14 @@
 						AddBuff(95 + beetleOrbs - 1, 5, quiet: false);
 
 					beetleCounter = 0f;
+					/*
 					if (num2 < 1.0)
 						num2 = 1.0;
+					*/
 				}
 
 				if (magicCuffs) {
-					int num6 = num;
+					int num6 = info.SourceDamage; //num;
 					statMana += num6;
 					if (statMana > statManaMax2)
 						statMana = statManaMax2;
@@ -29659,14 +_,30 @@
 								}
 
 								if (flag3) {
+									/*
 									int damage = (int)(num2 * 0.25);
 									num2 = (int)(num2 * 0.75);
+									*/
+									int damage = info.Damage / 3; // Damage has already been reduced by 1/4 when applying to target player, so dividing by 3 gives us the correct value
 									player.Hurt(PlayerDeathReason.LegacyEmpty(), damage, 0);
 								}
 							}
 						}
 					}
+					/*
 					else {
+					*/
+				}
+			}
+		}
+	}
+
+	private bool TeammateHasPalidinShieldAndCanTakeDamage()
+	{
+		{
+			{
+				{
+					{
 						bool flag4 = false;
 						for (int n = 0; n < 255; n++) {
 							if (n != Main.myPlayer && Main.player[n].active && !Main.player[n].dead && !Main.player[n].immune && Main.player[n].hasPaladinShield && Main.player[n].team == team && (float)Main.player[n].statLife > (float)Main.player[n].statLifeMax2 * 0.25f) {
@@ -29675,11 +_,22 @@
 							}
 						}
 
+						/*
 						if (flag4)
 							num2 = (int)(num2 * 0.75);
+						*/
+						return flag4;
 					}
 				}
+			}
+		}
+	}
 
+	private void OnHurt_Part3(HurtInfo info)
+	{
+		double num2 = info.Damage;
+		{
+			{
 				if (brainOfConfusionItem != null && !brainOfConfusionItem.IsAir && Main.myPlayer == whoAmI) {
 					for (int num9 = 0; num9 < 200; num9++) {
 						if (!Main.npc[num9].active || Main.npc[num9].friendly)
@@ -29706,16 +_,39 @@
 						}
 					}
 
-					Projectile.NewProjectile(GetProjectileSource_Accessory(brainOfConfusionItem), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
+					Projectile.NewProjectile(GetSource_Accessory_OnHurt(brainOfConfusionItem, info.DamageSource), base.Center.X + (float)Main.rand.Next(-40, 40), base.Center.Y - (float)Main.rand.Next(20, 60), velocity.X * 0.3f, velocity.Y * 0.3f, 565, 0, 0f, whoAmI);
 				}
+			}
+		}
+	}
 
+	public void Hurt(HurtInfo info, bool quiet = false)
+	{
+		var damageSource = info.DamageSource;
+		int hitDirection = info.HitDirection;
+		int cooldownCounter = info.CooldownCounter;
+		bool pvp = info.PvP;
+		double num2 = info.Damage;
+		bool Crit = false; // Crit has been removed, since it didn't work anyway
+		bool flag2 = cooldownCounter == ImmunityCooldownID.DD2OgreKnockback;
+
+		{
+			{
 				if (Main.netMode == 1 && whoAmI == Main.myPlayer && !quiet) {
+					/*
 					if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart))
+					*/
+					if (info.Knockback != 0 && hitDirection != 0 && (!mount.Active || !mount.Cart))
 						NetMessage.SendData(13, -1, -1, null, whoAmI);
 
 					NetMessage.SendData(16, -1, -1, null, whoAmI);
-					NetMessage.SendPlayerHurt(whoAmI, damageSource, Damage, hitDirection, Crit, pvp, hitContext);
+					NetMessage.SendPlayerHurt(whoAmI, info);
 				}
+
+				PlayerLoader.OnHurt(this, info);
+				OnHurt_Part1(info);
+				OnHurt_Part2(info);
+				OnHurt_Part3(info);
 
 				Color color = (Crit ? CombatText.DamagedFriendlyCrit : CombatText.DamagedFriendly);
 				CombatText.NewText(new Rectangle((int)position.X, (int)position.Y, width, height), color, (int)num2, Crit);
@@ -29785,7 +_,7 @@
 							else if (Main.expertMode)
 								num19 *= 2;
 
-							Projectile.NewProjectile(GetProjectileSource_Accessory(item), x, y, num16, num17, type, num19, 5f, whoAmI, 0f, position.Y);
+							Projectile.NewProjectile(GetSource_Accessory_OnHurt(item, info.DamageSource), x, y, num16, num17, type, num19, 5f, whoAmI, 0f, position.Y);
 						}
 					}
 
@@ -29809,7 +_,7 @@
 						else if (Main.expertMode)
 							num21 *= 1.5f;
 
-						IEntitySource projectileSource_Accessory = GetProjectileSource_Accessory(honeyCombItem);
+						IEntitySource projectileSource_Accessory = GetSource_Accessory_OnHurt(honeyCombItem, info.DamageSource);
 						for (int num22 = 0; num22 < num20; num22++) {
 							float speedX = (float)Main.rand.Next(-35, 36) * 0.02f;
 							float speedY = (float)Main.rand.Next(-35, 36) * 0.02f;
@@ -29821,6 +_,7 @@
 				}
 
 				StopVanityActions();
+				/*
 				if (flag2 && hitDirection != 0) {
 					if (!mount.Active || !mount.Cart) {
 						float num23 = 10.5f;
@@ -29838,9 +_,16 @@
 				else if (!noKnockback && hitDirection != 0 && (!mount.Active || !mount.Cart)) {
 					velocity.X = 4.5f * (float)hitDirection;
 					velocity.Y = -3.5f;
+				}
+				*/
+
+				if (info.Knockback != 0 && hitDirection != 0 && (!mount.Active || !mount.Cart)) {
+					velocity.X = info.Knockback * hitDirection;
+					velocity.Y = info.Knockback * -7 / 9;
 					fallStart = (int)(position.Y / 16f);
 				}
 
+				if (info.SoundDisabled) { } else
 				if (stoned)
 					SoundEngine.PlaySound(0, (int)position.X, (int)position.Y);
 				else if (mount.Active && mount.Type == 52)
@@ -29858,6 +_,9 @@
 
 				eyeHelper.BlinkBecausePlayerGotHurt();
 				if (statLife > 0) {
+					if (info.DustDisabled)
+						goto PostDust;
+
 					double num24 = num2 / (double)statLifeMax2 * 100.0;
 					float num25 = 2 * hitDirection;
 					float num26 = 0f;
@@ -29882,6 +_,9 @@
 							Dust.NewDust(position, width, height, 5, num25 + (float)hitDirection * num26 * Main.rand.NextFloat(), -2f);
 						}
 					}
+
+					PostDust:
+					PlayerLoader.PostHurt(this, info);
 				}
 				else {
 					statLife = 0;
@@ -29890,13 +_,17 @@
 				}
 			}
 
+			/*
 			if (pvp)
 				num2 = Main.CalculateDamagePlayersTakeInPVP(num, statDefense);
 
 			return num2;
+			*/
 		}
 
+		/*
 		return 0.0;
+		*/
 	}
 
 	private static bool AllowShimmerDodge(PlayerDeathReason damageSource, int cooldownCounter, bool dodgeable)
@@ -29931,6 +_,14 @@
 			if (FileUtilities.Exists(Main.playerPathName + ".bak", isCloudSave))
 				FileUtilities.Delete(Main.playerPathName + ".bak", isCloudSave);
 
+			//TML: Delete .tplr and .tplr.bak
+			string moddedPlayerPathName = Path.ChangeExtension(Main.playerPathName, ".tplr");
+			if (FileUtilities.Exists(moddedPlayerPathName, isCloudSave))
+				FileUtilities.Delete(moddedPlayerPathName, isCloudSave);
+
+			if (FileUtilities.Exists(moddedPlayerPathName + ".bak", isCloudSave))
+				FileUtilities.Delete(moddedPlayerPathName + ".bak", isCloudSave);
+
 			Main.ActivePlayerFileData = new PlayerFileData();
 		}
 	}
@@ -29941,6 +_,12 @@
 			return;
 
 		StopVanityActions();
+
+		bool playSound = true;
+		bool genGore = true;
+		if (!PlayerLoader.PreKill(this, dmg, hitDirection, pvp, ref playSound, ref genGore, ref damageSource))
+			return;
+
 		if (pvp)
 			pvpDeath = true;
 
@@ -30004,10 +_,14 @@
 			}
 		}
 
+		if (!playSound)
+			goto postSound;
+
 		if (Main.dontStarveWorld || Main.tenthAnniversaryWorld)
 			SoundEngine.PlaySound(Male ? SoundID.DSTMaleHurt : SoundID.DSTFemaleHurt, position);
 		else
 			SoundEngine.PlaySound(5, (int)position.X, (int)position.Y);
+		postSound:
 
 		if (Main.tenthAnniversaryWorld) {
 			for (int j = 0; j < 85; j++) {
@@ -30041,12 +_,15 @@
 		headVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 		bodyVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
 		legVelocity.X = (float)Main.rand.Next(-20, 21) * 0.1f + (float)(2 * hitDirection);
-		if (stoned) {
+		if (stoned || !genGore) {
 			headPosition = Vector2.Zero;
 			bodyPosition = Vector2.Zero;
 			legPosition = Vector2.Zero;
 		}
 
+		if (!genGore)
+			goto postGore;
+
 		for (int l = 0; l < 100; l++) {
 			if (stoned) {
 				Dust.NewDust(position, width, height, 1, 2 * hitDirection, -2f);
@@ -30063,10 +_,14 @@
 				Dust.NewDust(position, width, height, 5, 2 * hitDirection, -2f);
 			}
 		}
+		postGore:
 
 		mount.Dismount(this);
 		dead = true;
 		respawnTimer = GetRespawnTime(pvp);
+
+		PlayerLoader.Kill(this, dmg, hitDirection, pvp, damageSource);
+
 		immuneAlpha = 0;
 		if (!ChildSafety.Disabled)
 			immuneAlpha = 255;
@@ -30191,6 +_,9 @@
 		if (newItem.uniqueStack && HasItem(newItem.type))
 			return new ItemSpaceStatus(CanTakeItem: false);
 
+		if (ItemLoader.ItemSpace(newItem, this))
+			return new ItemSpaceStatus(CanTakeItem: true);
+
 		int num = 50;
 		if (newItem.IsACoin)
 			num = 54;
@@ -30240,7 +_,11 @@
 		if (theSlot.type == 0)
 			return true;
 
+		bool vanillaResult = false;
 		if (theSlot.stack < theSlot.maxStack && theItemToAccept.IsTheSameAs(theSlot))
+			vanillaResult = true;
+
+		if (vanillaResult && ItemLoader.CanStack(theSlot, theItemToAccept))
 			return true;
 
 		return false;
@@ -30277,7 +_,12 @@
 			if (inventory[i].type <= 0 || inventory[i].stack >= inventory[i].maxStack || !newItem.IsTheSameAs(inventory[i]))
 				continue;
 
+			if (!ItemLoader.TryStackItems(inventory[i], newItem, out int numTransfered))
+				continue;
+
 			SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
+			// #OnStackHook re-implemented below
+			/*
 			if (newItem.stack + inventory[i].stack <= inventory[i].maxStack) {
 				inventory[i].stack += newItem.stack;
 				if (!settings.NoText)
@@ -30301,6 +_,19 @@
 				Recipe.FindRecipes();
 
 			settings.HandlePostAction(inventory[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered);
+
+			DoCoins(i);
+			if (plr == Main.myPlayer)
+				Recipe.FindRecipes();
+
+			settings.HandlePostAction(inventory[i]);
+
+			if (newItem.stack <= 0)
+				return new Item();
 		}
 
 		if (newItem.CanFillEmptyAmmoSlot()) {
@@ -30325,6 +_,16 @@
 		return newItem;
 	}
 
+	/// <summary>
+	/// Places the <paramref name="newItem"/> directly into this player's inventory. The <paramref name="settings"/> dictate how or if the pickup text is displayed as well as if the item can be placed into the Void Vault inventory. It is typical to use one of the existing options contained in the static fields of <see cref="GetItemSettings"/> for this parameter to match vanilla behavior. The <paramref name="plr"/> parameter should always be set to the whoAmI of this player.
+	/// <para/> Modders commonly use <see cref="QuickSpawnItem(IEntitySource, Item, int)"/> to give a player an item as it is simpler to implement, but GetItem allows for more control and should be used when possible.
+	/// <para/> The return value is an Item instance containing the overflow. If the full stack of <paramref name="newItem"/> is placed into the inventory successfully, the return value will be an empty item instance. If the inventory is full or if only a partial stack of <paramref name="newItem"/> fit in the inventory, the return value will be the Item that didn't fit. If the returned <see cref="Item"/> isn't <see cref="Item.IsAir"/>, that will have to be handled by the calling code, typically by spawning the item in the world as a drop or leaving it where <paramref name="newItem"/> came from.
+	/// <para/> Make sure to test code using this method with a full inventory. Consulting vanilla code to match similar usages is recommended to implement specific item movement and popup text behavior the user would expect.
+	/// </summary>
+	/// <param name="plr"></param>
+	/// <param name="newItem"></param>
+	/// <param name="settings"></param>
+	/// <returns></returns>
 	public Item GetItem(int plr, Item newItem, GetItemSettings settings)
 	{
 		bool isACoin = newItem.IsACoin;
@@ -30416,11 +_,16 @@
 	private bool GetItem_FillIntoOccupiedSlot_VoidBag(int plr, Item[] inv, Item newItem, GetItemSettings settings, Item returnItem, int i)
 	{
 		if (inv[i].type > 0 && inv[i].stack < inv[i].maxStack && returnItem.IsTheSameAs(inv[i])) {
+			if (!ItemLoader.TryStackItems(inv[i], returnItem, out int numTransfered))
+				return false;
+
 			if (newItem.IsACoin)
 				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 			else
 				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+			// #OnStackHook re-implemented below
+			/*
 			if (returnItem.stack + inv[i].stack <= inv[i].maxStack) {
 				inv[i].stack += returnItem.stack;
 				if (!settings.NoText)
@@ -30438,6 +_,16 @@
 
 			inv[i].stack = inv[i].maxStack;
 			settings.HandlePostAction(inv[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.ItemPickupToVoidContainer, newItem, numTransfered, noStack: false, settings.LongText);
+
+			AchievementsHelper.NotifyItemPickup(this, returnItem);
+			settings.HandlePostAction(inv[i]);
+
+			if (returnItem.stack <= 0)
+				return true;
 		}
 
 		return false;
@@ -30446,12 +_,18 @@
 	private bool GetItem_FillIntoOccupiedSlot(int plr, Item newItem, GetItemSettings settings, Item returnItem, int i)
 	{
 		if (inventory[i].type > 0 && inventory[i].stack < inventory[i].maxStack && returnItem.IsTheSameAs(inventory[i])) {
+			if (!ItemLoader.TryStackItems(inventory[i], returnItem, out int numTransfered))
+				return false;
+
 			if (newItem.IsACoin)
 				SoundEngine.PlaySound(38, (int)position.X, (int)position.Y);
 			else
 				SoundEngine.PlaySound(7, (int)position.X, (int)position.Y);
 
+			// #OnStackHook re-implemented below
+			/*
 			if (returnItem.stack + inventory[i].stack <= inventory[i].maxStack) {
+
 				inventory[i].stack += returnItem.stack;
 				if (!settings.NoText)
 					PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, returnItem.stack, noStack: false, settings.LongText);
@@ -30476,6 +_,19 @@
 				Recipe.FindRecipes();
 
 			settings.HandlePostAction(inventory[i]);
+			*/
+
+			if (!settings.NoText)
+				PopupText.NewText(PopupTextContext.RegularItemPickup, newItem, numTransfered, noStack: false, settings.LongText);
+
+			DoCoins(i);
+			if (plr == Main.myPlayer)
+				Recipe.FindRecipes();
+
+			AchievementsHelper.NotifyItemPickup(this, returnItem);
+			settings.HandlePostAction(inventory[i]);
+			if (returnItem.stack <= 0)
+				return true;
 		}
 
 		return false;
@@ -30560,6 +_,8 @@
 			return;
 
 		bool flag = true;
+		flag &= WallLoader.CanPlace(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
+
 		if (TileReplacementEnabled)
 			flag = PlaceThing_TryReplacingWalls(flag);
 
@@ -30568,6 +_,8 @@
 
 		WorldGen.PlaceWall(tileTargetX, tileTargetY, inventory[selectedItem].createWall);
 		if (Main.tile[tileTargetX, tileTargetY].wall == inventory[selectedItem].createWall) {
+			WallLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
+
 			ApplyItemTime(inventory[selectedItem], wallSpeed);
 			if (Main.netMode == 1)
 				NetMessage.SendData(17, -1, -1, null, 3, tileTargetX, tileTargetY, inventory[selectedItem].createWall);
@@ -30627,7 +_,9 @@
 
 			WorldGen.PlaceWall(num, num2, createWall);
 			if (Main.tile[num, num2].wall == createWall) {
+				if (ItemLoader.ConsumeItem(inventory[selectedItem], this))
-				inventory[selectedItem].stack--;
+					inventory[selectedItem].stack--;
+
 				if (inventory[selectedItem].stack == 0)
 					inventory[selectedItem].SetDefaults();
 
@@ -30673,9 +_,13 @@
 			int? forcedRandom = null;
 			TileObject objectData = default(TileObject);
 			FigureOutWhatToPlace(tile, item, out tileToCreate, out var previewPlaceStyle, out overrideCanPlace, out forcedRandom);
+			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
 			if (overrideCanPlace.HasValue) {
 				canPlace = overrideCanPlace.Value;
 			}
+			else if (!TileLoader.CanPlace(tileTargetX, tileTargetY, tileToCreate)) {
+				canPlace = false;
+			}
 			else if (TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle) && tileToCreate != 82 && tileToCreate != 227) {
 				newObjectType = true;
 				canPlace = TileObject.CanPlace(tileTargetX, tileTargetY, (ushort)tileToCreate, previewPlaceStyle, direction, out objectData, onlyCheck: false, forcedRandom);
@@ -30757,9 +_,15 @@
 			if (!WorldGen.IsTileReplacable(tileTargetX, tileTargetY))
 				return false;
 
+			if (!TileLoader.CanReplace(tileTargetX, tileTargetY, tile.type, HeldItem.createTile))
+				return false;
+
+			if (!TileLoader.CanPlace(tileTargetX, tileTargetY, HeldItem.createTile))
+				return false;
+
 			if (0 == 0) {
 				if (hitReplace.AddDamage(num, pickaxeDamage) < 100) {
-					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile);
+					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tile, tileTargetX, tileTargetY);
 					for (int i = 0; i < num2; i++) {
 						WorldGen.KillTile_MakeTileDust(tileTargetX, tileTargetY, tile);
 					}
@@ -30778,15 +_,15 @@
 			}
 
 			int[,] typeCaches = PlaceThing_Tiles_GetAutoAccessoryCache();
-			ushort num3 = (ushort)HeldItem.createTile;
+			int num3 = HeldItem.createTile;
 			int num4 = HeldItem.placeStyle;
 			if (UsingBiomeTorches && num3 == 4)
-				num4 = BiomeTorchPlaceStyle(num4);
+				BiomeTorchPlaceStyle(ref num3, ref num4);
 
 			if (UsingBiomeTorches && num3 == 215)
-				num4 = BiomeCampfirePlaceStyle(num4);
+				BiomeCampfirePlaceStyle(ref num3, ref num4);
 
-			if (WorldGen.ReplaceTile(tileTargetX, tileTargetY, num3, num4)) {
+			if (WorldGen.ReplaceTile(tileTargetX, tileTargetY, (ushort)num3, num4)) {
 				canUse = false;
 				NetMessage.SendData(17, -1, -1, null, 21, tileTargetX, tileTargetY, (int)num3, num4);
 				ApplyItemTime(HeldItem);
@@ -30803,10 +_,10 @@
 		int createTile = HeldItem.createTile;
 		int num = HeldItem.placeStyle;
 		if (UsingBiomeTorches && createTile == 4)
-			num = BiomeTorchPlaceStyle(num);
+			BiomeTorchPlaceStyle(ref createTile, ref num);
 
 		if (UsingBiomeTorches && createTile == 215)
-			num = BiomeCampfirePlaceStyle(num);
+			BiomeCampfirePlaceStyle(ref createTile, ref num);
 
 		Tile tile = Main.tile[tileTargetX, tileTargetY];
 		if (WorldGen.WouldTileReplacementBeBlockedByLiquid(tileTargetX, tileTargetY, 1))
@@ -30833,11 +_,19 @@
 		if (TileID.Sets.Platforms[tile.type] && tile.type == createTile)
 			return tile.frameY != num * 18;
 
+		/*
 		if (tile.type == 4 && tile.type == createTile)
 			return tile.frameY != num * 22;
+		*/
+		if (TileID.Sets.Torch[tile.type] && TileID.Sets.Torch[createTile])
+			return tile.type != createTile || tile.frameY != num * 22;
 
+		/*
 		if (tile.type == 215 && tile.type == createTile)
 			return tile.frameX / 54 != num;
+		*/
+		if (TileID.Sets.Campfire[tile.type] && TileID.Sets.Campfire[createTile])
+			return tile.type != createTile || tile.frameX / 54 != num;
 
 		if (TileID.Sets.BasicChest[tile.type] && TileID.Sets.BasicChest[createTile]) {
 			if (tile.frameX / 36 == num)
@@ -30938,7 +_,7 @@
 		}
 		else {
 			if (UsingBiomeTorches && tileToCreate == 4 && num == 0)
-				num = BiomeTorchPlaceStyle(num);
+				BiomeTorchPlaceStyle(ref tileToCreate, ref num);
 
 			flag = WorldGen.PlaceTile(tileTargetX, tileTargetY, tileToCreate, mute: false, forced, whoAmI, num);
 		}
@@ -30964,8 +_,12 @@
 			PlaceThing_Tiles_PlaceIt_UnslopeForSolids();
 			PlaceThing_Tiles_PlaceIt_KillGrassForSolids();
 			PlaceThing_Tiles_PlaceIt_AutoPaintAndActuate(typeCaches, tileToCreate);
+
+			// Extra patch context.
 			if (PlayerInput.UsingGamepad && ItemID.Sets.SingleUseInGamepad[inventory[selectedItem].type] && Main.myPlayer == whoAmI && !Main.SmartCursorIsUsed)
 				Main.blockMouse = true;
+
+			TileLoader.PlaceInWorld(tileTargetX, tileTargetY, inventory[selectedItem]);
 		}
 
 		return data;
@@ -30981,7 +_,10 @@
 		}
 	}
 
+	/* Added type to support modded tiletypes. Changed to ref, but kept int return to keep patches small.
 	public int BiomeTorchPlaceStyle(int style)
+	*/
+	public int BiomeTorchPlaceStyle(ref int type, ref int style)
 	{
 		if (!UsingBiomeTorches || style != 0)
 			return style;
@@ -31011,6 +_,12 @@
 		else if (ZoneDesert && Main.remixWorld)
 			style = 16;
 
+		if (CurrentSceneEffect.biomeTorchItemType.value > -1) {
+			var item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeTorchItemType.value];
+			type = item.createTile;
+			style = item.placeStyle;
+		}
+
 		return style;
 	}
 
@@ -31044,10 +_,17 @@
 		else if (ZoneDesert && Main.remixWorld)
 			style = 4383;
 
+		if (CurrentSceneEffect.biomeTorchItemType.value > -1) {
+			style = CurrentSceneEffect.biomeTorchItemType.value;
+		}
+
 		return style;
 	}
 
+	/* Added type to support modded tiletypes. Changed to ref, but kept int return to keep patches small.
 	public int BiomeCampfirePlaceStyle(int style)
+	*/
+	public int BiomeCampfirePlaceStyle(ref int type, ref int style)
 	{
 		if (!UsingBiomeTorches || style != 0)
 			return style;
@@ -31077,6 +_,12 @@
 		else if (ZoneDesert && Main.remixWorld)
 			style = 8;
 
+		if (CurrentSceneEffect.biomeCampfireItemType.value > -1) {
+			var item = ContentSamples.ItemsByType[CurrentSceneEffect.biomeCampfireItemType.value];
+			type = item.createTile;
+			style = item.placeStyle;
+		}
+
 		return style;
 	}
 
@@ -31110,6 +_,10 @@
 		else if (ZoneDesert && Main.remixWorld)
 			itemType = 4689;
 
+		if (CurrentSceneEffect.biomeCampfireItemType.value > -1) {
+			itemType = CurrentSceneEffect.biomeCampfireItemType.value;
+		}
+
 		return itemType;
 	}
 
@@ -31253,7 +_,9 @@
 				int num7 = FindItem(849);
 				if (num7 > -1 && WorldGen.PlaceActuator(num5, num6)) {
 					NetMessage.SendData(17, -1, -1, null, 8, num5, num6);
+					if (ItemLoader.ConsumeItem(inventory[num7], this))
-					inventory[num7].stack--;
+						inventory[num7].stack--;
+
 					if (inventory[num7].stack <= 0)
 						inventory[num7].SetDefaults();
 				}
@@ -31648,7 +_,7 @@
 			if (Main.tile[tileTargetX, tileTargetY].nactive() && Main.tile[tileTargetX, tileTargetY].type == 59)
 				canPlace = true;
 		}
-		else if (inventory[selectedItem].createTile == 4 || inventory[selectedItem].createTile == 136) {
+		else if (TileID.Sets.Torch[inventory[selectedItem].createTile] || inventory[selectedItem].createTile == 136) {
 			if (Main.tile[tileTargetX, tileTargetY].wall > 0) {
 				canPlace = true;
 			}
@@ -31729,7 +_,10 @@
 		else if (inventory[selectedItem].createTile == 275 || inventory[selectedItem].createTile == 276 || inventory[selectedItem].createTile == 277) {
 			canPlace = true;
 		}
+		/*
 		else if (inventory[selectedItem].createTile == 51 || inventory[selectedItem].createTile == 330 || inventory[selectedItem].createTile == 331 || inventory[selectedItem].createTile == 332 || inventory[selectedItem].createTile == 333 || inventory[selectedItem].createTile == 336 || inventory[selectedItem].createTile == 340 || inventory[selectedItem].createTile == 342 || inventory[selectedItem].createTile == 341 || inventory[selectedItem].createTile == 343 || inventory[selectedItem].createTile == 344 || inventory[selectedItem].createTile == 379 || inventory[selectedItem].createTile == 351) {
+		*/
+		else if (TileID.Sets.CanPlaceNextToNonSolidTile[inventory[selectedItem].createTile]) {
 			if (Main.tile[tileTargetX + 1, tileTargetY].active() || Main.tile[tileTargetX + 1, tileTargetY].wall > 0 || Main.tile[tileTargetX - 1, tileTargetY].active() || Main.tile[tileTargetX - 1, tileTargetY].wall > 0 || Main.tile[tileTargetX, tileTargetY + 1].active() || Main.tile[tileTargetX, tileTargetY + 1].wall > 0 || Main.tile[tileTargetX, tileTargetY - 1].active() || Main.tile[tileTargetX, tileTargetY - 1].wall > 0)
 				canPlace = true;
 		}
@@ -32318,7 +_,9 @@
 		byte paint = targetItem.paint;
 		if (paintingAWall) {
 			if (Main.tile[x, y].wallColor() != paint && WorldGen.paintWall(x, y, paint, broadCast: true)) {
+				if (ItemLoader.ConsumeItem(targetItem, this))
-				targetItem.stack--;
+					targetItem.stack--;
+
 				if (targetItem.stack <= 0)
 					targetItem.SetDefaults();
 
@@ -32327,7 +_,9 @@
 			}
 		}
 		else if (Main.tile[x, y].color() != paint && WorldGen.paintTile(x, y, paint, broadCast: true)) {
+			if (ItemLoader.ConsumeItem(targetItem, this))
-			targetItem.stack--;
+				targetItem.stack--;
+
 			if (targetItem.stack <= 0)
 				targetItem.SetDefaults();
 
@@ -32383,13 +_,19 @@
 		int num6 = -1;
 		int num7 = 1;
 		switch (extractType) {
+			/*
 			case 1:
+			*/
+			case ItemID.DesertFossil:
 				num /= 3;
 				num2 *= 2;
 				num3 = 20;
 				num4 = 10;
 				break;
+			/*
 			case 2:
+			*/
+			case ItemID.OldShoe:
 				num = -1;
 				num2 = -1;
 				num3 = -1;
@@ -32397,7 +_,10 @@
 				num5 = 1;
 				num7 = -1;
 				break;
+			/*
 			case 3:
+			*/
+			case ItemID.LavaMoss:
 				num = -1;
 				num2 = -1;
 				num3 = -1;
@@ -32767,6 +_,8 @@
 				num9 += Main.rand.Next(0, 6);
 		}
 
+		ItemLoader.ExtractinatorUse(ref num8, ref num9, extractType, extractinatorBlockType);
+
 		if (num8 > 0)
 			DropItemFromExtractinator(num8, num9);
 	}
@@ -32782,8 +_,16 @@
 			NetMessage.SendData(21, -1, -1, null, number, 1f);
 	}
 
+	/// <summary>
+	/// Changes the player's direction (<see cref="Entity.direction"/>) while adjusting arm and item rotations to be consistent. Will also account for <see cref="pulley"/> and <see cref="pulleyDir"/>. The player direction change will be prevented if the player is on a rope but there isn't space for the player to face the new direction.
+	/// </summary>
+	/// <param name="dir"></param>
 	public void ChangeDir(int dir)
 	{
+		// added by TML, forward port from 1.4.5
+		if (dir == direction)
+			return;
+
 		if (!pulley || pulleyDir != 2) {
 			direction = dir;
 		}
@@ -32800,7 +_,17 @@
 				position.X = num;
 				direction = dir;
 			}
+			// added by TML, forward port from 1.4.5
+			else {
+				return;
+			}
 		}
+
+		// Added by TML, forward port from 1.4.5
+		compositeBackArm.rotation *= -1;
+		compositeFrontArm.rotation *= -1;
+		itemRotation *= -1;
+		itemLocation.X = MountedCenter.X + (MountedCenter.X - itemLocation.X);
 	}
 
 	public Rectangle getRect() => new Rectangle((int)position.X, (int)position.Y, width, height);
@@ -32875,8 +_,13 @@
 	public PlayerFishingConditions GetFishingConditions()
 	{
 		PlayerFishingConditions result = default(PlayerFishingConditions);
+
+		/*
 		Fishing_GetBestFishingPole(out result.PolePower, out result.PoleItemType);
 		Fishing_GetBait(out result.BaitPower, out result.BaitItemType);
+		*/
+		Fishing_GetBestFishingPole(out result.Pole);
+		Fishing_GetBait(out result.Bait);
 		if (result.BaitItemType == 2673)
 			return result;
 
@@ -32890,16 +_,22 @@
 		if (canFloatInWater && wet)
 			num += 5;
 
+		/*
 		if (sitting.TryGetSittingBlock(this, out var tile) && ((tile.type == 15 && tile.frameY / 40 == 1) || tile.type == 497))
+		*/
+		if (sitting.TryGetSittingBlock(this, out var _) && sitting.details.IsAToilet) // Make modded toilets give the fishing boost as well
 			num += 5;
 
 		int num2 = result.BaitPower + result.PolePower + fishingSkill + num;
-		result.LevelMultipliers = Fishing_GetPowerMultiplier();
+		result.LevelMultipliers = Fishing_GetPowerMultiplier(result.Pole, result.Bait);
 		result.FinalFishingLevel = (int)((float)num2 * result.LevelMultipliers);
 		return result;
 	}
 
+	/*
 	private static float Fishing_GetPowerMultiplier()
+	*/
+	private float Fishing_GetPowerMultiplier(Item pole, Item bait)
 	{
 		float num = 1f;
 		if (Main.raining)
@@ -32932,44 +_,46 @@
 		if (Main.bloodMoon)
 			num *= 1.1f;
 
+		PlayerLoader.GetFishingLevel(this, pole, bait, ref num);
 		return num;
 	}
 
+	/*
 	private void Fishing_GetBait(out int baitPower, out int baitType)
+	*/
+	private void Fishing_GetBait(out Item bait)
 	{
-		baitPower = 0;
-		baitType = 0;
+		bait = null;
 		for (int i = 54; i < 58; i++) {
 			if (inventory[i].stack > 0 && inventory[i].bait > 0) {
-				baitPower = inventory[i].bait;
-				baitType = inventory[i].type;
+				bait = inventory[i];
 				break;
 			}
 		}
 
-		if (baitPower != 0 || baitType != 0)
+		if (bait != null)
 			return;
 
 		for (int j = 0; j < 50; j++) {
 			if (inventory[j].stack > 0 && inventory[j].bait > 0) {
-				baitPower = inventory[j].bait;
-				baitType = inventory[j].type;
+				bait = inventory[j];
 				break;
 			}
 		}
 	}
 
+	/*
 	private void Fishing_GetBestFishingPole(out int fishingPolePower, out int fishingPoleType)
+	*/
+	private void Fishing_GetBestFishingPole(out Item pole)
 	{
-		fishingPolePower = inventory[selectedItem].fishingPole;
-		fishingPoleType = inventory[selectedItem].type;
+		pole = inventory[selectedItem];
-		if (fishingPolePower != 0)
+		if (pole.fishingPole != 0)
 			return;
 
 		for (int i = 0; i < 58; i++) {
-			if (inventory[i].fishingPole > fishingPolePower) {
+			if (inventory[i].fishingPole > pole.fishingPole) {
-				fishingPolePower = inventory[i].fishingPole;
+				pole = inventory[i];
-				fishingPoleType = inventory[i].type;
 			}
 		}
 	}
@@ -32995,7 +_,9 @@
 	{
 		for (int i = 0; i < 58; i++) {
 			if (inventory[i].type == 2997 && inventory[i].stack > 0) {
+				if (ItemLoader.ConsumeItem(inventory[i], this))
-				inventory[i].stack--;
+					inventory[i].stack--;
+
 				if (inventory[i].stack <= 0)
 					inventory[i].SetDefaults();
 
@@ -33008,7 +_,9 @@
 
 		for (int j = 0; j < 40; j++) {
 			if (bank4.item[j].type == 2997 && bank4.item[j].stack > 0) {
+				if (ItemLoader.ConsumeItem(bank4.item[j], this))
-				bank4.item[j].stack--;
+					bank4.item[j].stack--;
+
 				if (bank4.item[j].stack <= 0)
 					bank4.item[j].SetDefaults();
 
@@ -33191,12 +_,21 @@
 		return TextureAssets.Item[type].Frame();
 	}
 
+	/// <summary>
+	/// Used to determine what the overall scale of an item should be.<br></br>
+	/// <see cref="CombinedHooks.ModifyItemScale"/> is called here.
+	/// </summary>
+	/// <param name="item">The item to fetch the adjusted scale of.</param>
+	/// <returns>
+	/// The final scale of the item, after the Titan Glove effect and all modded calculations.
+	/// </returns>
 	public float GetAdjustedItemScale(Item item)
 	{
 		float scale = item.scale;
 		if (item.melee)
 			ApplyMeleeScale(ref scale);
 
+		CombinedHooks.ModifyItemScale(this, item, ref scale);
 		return scale;
 	}
 
@@ -33220,6 +_,14 @@
 
 	public void ItemCheck()
 	{
+		if (PlayerLoader.PreItemCheck(this))
+			ItemCheck_Inner();
+
+		PlayerLoader.PostItemCheck(this);
+	}
+
+	private void ItemCheck_Inner()
+	{
 		if (CCed) {
 			channel = false;
 			itemAnimation = (itemAnimationMax = 0);
@@ -33237,10 +_,10 @@
 			}
 
 			if (!cursorItemIconEnabled && item.stack > 0 && item.fishingPole > 0) {
-				Fishing_GetBait(out var _, out var baitType);
-				if (baitType > 0) {
+				Fishing_GetBait(out var bait);
+				if (bait != null) {
 					cursorItemIconEnabled = true;
-					cursorItemIconID = baitType;
+					cursorItemIconID = bait.type;
 					cursorItemIconPush = 6;
 				}
 			}
@@ -33268,6 +_,70 @@
 			}
 		}
 
+		// #2351
+		// TML is motivated to bring the itemAnimation and itemTime counters to parity, fixing desync bugs with autoReuse items and providing clearer behavior.
+		// The flow of this method has changed as follows...
+		//
+		// VANILLA:
+		// 1. Reuse delay is applied
+		// 2. Item animation is applied if button is pressed
+		// 3. Item animation is reduced
+		// 4. 'releaseUseItem' is set
+		// 5. Item time is reduced
+		// 6. Hold / Use styles are invoked
+		// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+		// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+		//
+		// TML:
+		// 1. Item animation is reduced
+		// 2. Item time is reduced
+		// 3. Reuse delay is applied
+		// 4. Item animation is applied if button is pressed
+		// 5. 'releaseUseItem' is set
+		// 6. Hold / Use styles are invoked
+		// 7. Item logic applies item time if (itemAnimation > 0 && itemTime == 0)
+		// 8. More item logic/and effects (consumables, teleportations) if (itemAnimation > 0)
+		//
+		// At the end of ItemCheck:
+		//   VANILLA: itemAnimation goes from itemAnimationMax-1 to 0, before it can restart
+		//   TML:     itemAnimation goes from itemAnimationMax to 1, before it can restart
+		//
+		//   VANILLA: If the item has autoReuse, then it can restart at itemAnimation = 1, making the actual animation one frame shorter than expected.
+		//            If a reusable item has equal itemAnimation and itemTime, the animation will be faster, and they will start to fire at different times
+		//
+		//   TML:     ItemCheck_HandleMPItemAnimation unnecessary. Animation times for modded items as written. See Item.ApplyItemAnimationCompensations
+		//
+		//   VANILLA: All items which don't have autoReuse get 1 frame where itemAnimation == 0, this is often used to despawn projectiles
+		//   TML:     There will be no frame with itemAnimation == 0 if an item is 'reused immediately', via autoReuse, knockbackGlove, or perfect click timing.
+		//            bound projectiles should despawn in the frame of itemAnimation <= 1, after doing damage.
+		//            Player.ItemAnimationEndingOrEnded has been made for this purpose but its use is not recommended due to potential for multiplayer desync.
+		//            Better to have ai counters for projectile lifetime set to itemAnimationMax on spawn
+		//
+		//   VANILLA: hitbox calulation and duration is based on an itemAnimation value between itemAnimationMax-1 and 1, resulting in itemAnimationMax-1 frames of hitbox
+		//   TML:     hitbox lasts the same length as itemAnimation, slightly more backswing (rotation) in the first frame
+		//
+		//   VANILLA: itemTime goes from itemTimeMax to 1, before it can restart, 0 means not using item
+		//   TML:     no change
+
+		goto DecrementItemAnimation;
+
+		ReuseDelayAndAnimationStart:
+
+		// SmartSelectLookup moved here from Player.Update so that it can apply between uses, without changing selectedItem prematurely for half the Update method
+		if (itemAnimation == 0 && reuseDelay == 0 && (!controlUseItem || selectItemOnNextUse)) {
+			selectItemOnNextUse = false;
+
+			int oldSelect = selectedItem;
+			SmartSelectLookup();
+			if (selectedItem != oldSelect) {
+				item = inventory[selectedItem];
+				// TML feature, allow the item to be instantly used
+				releaseUseItem = true;
+				// prevent remaining item time carrying over to new weapon (for items like starfury with less than one shot per use)
+				itemTime = itemTimeMax = 0;
+			}
+		}
+
 		ItemCheck_HandleMount();
 		int weaponDamage = GetWeaponDamage(item);
 		ItemCheck_HandleMPItemAnimation(item);
@@ -33309,7 +_,7 @@
 			if (whoAmI == Main.myPlayer && gravDir == 1f && item.mountType != -1 && mount.CanMount(item.mountType, this))
 				mount.SetMount(item.mountType, this);
 
-			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && item.shoot < ProjectileID.Count && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
+			if ((item.shoot <= 0 || !ProjectileID.Sets.MinionTargettingFeature[item.shoot] || altFunctionUse != 2) && flag3 && whoAmI == Main.myPlayer && item.shoot >= 0 && (ProjectileID.Sets.LightPet[item.shoot] || Main.projPet[item.shoot]))
 				FreeUpPetsAndMinions(item);
 
 			if (flag3)
@@ -33339,13 +_,25 @@
 				itemHeight = drawHitbox.Height;
 				itemWidth = drawHitbox.Width;
 			}
+		// The itemAnimation > 0 block has been split in 2 parts (above and below) to allow for the insertion of labels
+		}
+		goto ReleaseUseItem;
 
+		DecrementItemAnimation:
+
+		if (itemAnimation > 0) {
 			itemAnimation--;
 			if (itemAnimation == 0 && whoAmI == Main.myPlayer)
 				PlayerInput.TryEndingFastUse();
 		}
 
+		goto DecrementItemTime;
+
+		ReleaseUseItem:
 		releaseUseItem = !controlUseItem;
+		goto HoldAndUseStyle;
+
+		DecrementItemTime:
 		if (itemTime > 0) {
 			itemTime--;
 			if (ItemTimeIsZero && whoAmI == Main.myPlayer && !JustDroppedAnItem) {
@@ -33355,6 +_,11 @@
 			}
 		}
 
+		goto ReuseDelayAndAnimationStart;
+
+		HoldAndUseStyle:
+		ItemLoader.HoldItem(item, this);
+
 		if (itemAnimation > 0)
 			ItemCheck_ApplyUseStyle(heightOffsetHitboxCenter, item2, drawHitbox);
 		else
@@ -33364,14 +_,19 @@
 			ItemCheck_EmitHeldItemLight(item);
 			ItemCheck_EmitFoodParticles(item);
 			ItemCheck_EmitDrinkParticles(item);
-			if (whoAmI == Main.myPlayer)
+
+			// TML attempts to make ApplyItemTime calls run on remote players, so this check is removed. #ItemTimeOnAllClients
+			if (whoAmI == Main.myPlayer || true)
 				ItemCheck_OwnerOnlyCode(ref context, item, weaponDamage, drawHitbox);
 
 			if (ItemTimeIsZero && itemAnimation > 0) {
+				if (ItemLoader.UseItem(item, this) == true)
+					ApplyItemTime(item, callUseItem: false);
+
 				if (item.hairDye >= 0) {
 					ApplyItemTime(item);
 					if (whoAmI == Main.myPlayer) {
-						hairDye = (byte)item.hairDye;
+						hairDye = item.hairDye;
 						NetMessage.SendData(4, -1, -1, null, whoAmI);
 					}
 				}
@@ -33484,7 +_,7 @@
 				if (ItemTimeIsZero) {
 					ApplyItemTime(item);
 				}
-				else if (itemTime == item.useTime / 2) {
+				else if (itemTime == itemTimeMax / 2) { // item.useTime -> itemTimeMax
 					for (int l = 0; l < 70; l++) {
 						Dust.NewDust(position, width, height, 15, velocity.X * 0.5f, velocity.Y * 0.5f, 150, default(Color), 1.5f);
 					}
@@ -33608,7 +_,7 @@
 						Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33634,7 +_,7 @@
 						Main.dust[Dust.NewDust(position, width, height, 15, 0f, 0f, 150, Color.Cyan, 1.2f)].velocity *= 0.5f;
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33649,7 +_,7 @@
 					else if (Main.netMode == 1 && whoAmI == Main.myPlayer)
 						NetMessage.SendData(73);
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 			}
@@ -33665,11 +_,11 @@
 							NetMessage.SendData(4, -1, -1, null, whoAmI);
 					}
 
-					if (item.stack > 0)
+					if (ItemLoader.ConsumeItem(item, this) && item.stack > 0)
 						item.stack--;
 				}
 				else {
-					float num10 = item.useTime;
+					float num10 = itemTimeMax;
 					num10 = (num10 - (float)itemTime) / num10;
 					float num11 = 44f;
 					float num12 = (float)Math.PI * 3f;
@@ -33703,11 +_,16 @@
 			}
 
 			if (whoAmI == Main.myPlayer) {
+				/*
 				if (!dontConsumeWand && itemTime == (int)((float)item.useTime * tileSpeed) && item.tileWand > 0) {
+				*/
+				if (!dontConsumeWand && itemTimeMax != 0 && itemTime == itemTimeMax && item.tileWand > 0) {
 					int tileWand = item.tileWand;
 					for (int num15 = 0; num15 < 58; num15++) {
 						if (tileWand == inventory[num15].type && inventory[num15].stack > 0) {
+							if (ItemLoader.ConsumeItem(inventory[num15], this))
-							inventory[num15].stack--;
+								inventory[num15].stack--;
+
 							if (inventory[num15].stack <= 0)
 								inventory[num15] = new Item();
 
@@ -33732,6 +_,15 @@
 							flag6 = false;
 					}
 
+					// Copied as-is from 1.3
+					if (item.CountsAsClass(DamageClass.Throwing)) {
+						if (ThrownCost50 && Main.rand.Next(100) < 50)
+							flag6 = false;
+
+						if (ThrownCost33 && Main.rand.Next(100) < 33)
+							flag6 = false;
+					}
+
 					if (item.IsACoin)
 						flag6 = true;
 
@@ -33739,7 +_,7 @@
 					if (flag7.HasValue)
 						flag6 = flag7.Value;
 
-					if (flag6) {
+					if (flag6 && ItemLoader.ConsumeItem(item, this)) {
 						if (item.stack > 0)
 							item.stack--;
 
@@ -33770,6 +_,8 @@
 		if (Main.myPlayer == whoAmI && itemAnimation == 0) {
 			Tile targetTile = Main.tile[tileTargetX, tileTargetY];
 			FigureOutWhatToPlace(targetTile, sItem, out var tileToCreate, out var previewPlaceStyle, out var overrideCanPlace, out var forcedRandom);
+			PlantLoader.CheckAndInjectModSapling(tileTargetX, tileTargetY, ref tileToCreate, ref previewPlaceStyle);
+
 			if ((!overrideCanPlace.HasValue || overrideCanPlace.Value) && TileObjectData.CustomPlace(tileToCreate, previewPlaceStyle))
 				TileObject.CanPlace(tileTargetX, tileTargetY, tileToCreate, previewPlaceStyle, direction, out var _, onlyCheck: true, forcedRandom);
 		}
@@ -33782,7 +_,7 @@
 		overrideCanPlace = null;
 		forcedRandom = null;
 		if (UsingBiomeTorches && tileToCreate == 215 && previewPlaceStyle == 0)
-			previewPlaceStyle = BiomeCampfirePlaceStyle(previewPlaceStyle);
+			BiomeCampfirePlaceStyle(ref tileToCreate, ref previewPlaceStyle);
 
 		if (targetTile != null && targetTile.active()) {
 			ushort type = targetTile.type;
@@ -33820,13 +_,18 @@
 			_spawnMuramasaCut = true;
 
 		if (type == 3852) {
+			//TML: This is handled by Item.useLimitPerAnimation
+			/*
 			if (itemAnimation < itemAnimationMax - 12)
 				flag = false;
+			*/
 
 			if (altFunctionUse == 2 && !ItemAnimationJustStarted)
 				flag = false;
 		}
 
+		//TML: Eventide and nightglow handled by Item.useLimitPerAnimation. Zenith use limit didn't do anything anyway
+		/*
 		if (type == 4956 && itemAnimation < itemAnimationMax - 3 * sItem.useTime)
 			flag = false;
 
@@ -33835,10 +_,15 @@
 
 		if (type == 4953 && itemAnimation < itemAnimationMax - 10)
 			flag = false;
+		*/
 
 		if (type == 5451 && ownedProjectileCounts[1020] > 0)
 			flag = false;
 
+		// Added by TML
+		if (sItem.useLimitPerAnimation != null && ItemUsesThisAnimation >= sItem.useLimitPerAnimation.Value)
+			flag = false;
+
 		ItemCheck_TurretAltFeatureUse(sItem, flag);
 		ItemCheck_MinionAltFeatureUse(sItem, flag);
 		bool flag2 = itemAnimation > 0 && ItemTimeIsZero && flag;
@@ -33848,6 +_,10 @@
 		if (sItem.shoot > 0 && flag2)
 			ItemCheck_Shoot(whoAmI, sItem, weaponDamage);
 
+		// Added by TML. #ItemTimeOnAllClients - TODO: item time application with these item types
+		if (whoAmI != Main.myPlayer)
+			return;
+
 		ItemCheck_UseWiringTools(sItem);
 		ItemCheck_UseLawnMower(sItem);
 		ItemCheck_PlayInstruments(sItem);
@@ -33858,7 +_,7 @@
 		else {
 			toolTime--;
 			if (toolTime < 0)
-				toolTime = sItem.useTime;
+				toolTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem); //sItem.useTime;
 		}
 
 		ItemCheck_TryDestroyingDrones(sItem);
@@ -33898,7 +_,10 @@
 			Projectile.NewProjectile(GetProjectileSource_Accessory(boneGloveItem), center.X, center.Y, vector.X, vector.Y, 532, 25, 5f, whoAmI);
 		}
 
+		/*
 		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && sItem.type != 1991 && sItem.type != 3183 && sItem.type != 4821 && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
+		*/
+		if (((sItem.damage < 0 || sItem.type <= 0 || sItem.noMelee) && sItem.type != 1450 && !ItemID.Sets.CatchingTool[sItem.type] && sItem.type != 3542 && sItem.type != 3779) || itemAnimation <= 0)
 			return;
 
 		ItemCheck_GetMeleeHitbox(sItem, heldItemFrame, out var dontAttack, out var itemRectangle);
@@ -33906,7 +_,11 @@
 			return;
 
 		itemRectangle = ItemCheck_EmitUseVisuals(sItem, itemRectangle);
+
+		/*
 		if (Main.myPlayer == whoAmI && (sItem.type == 1991 || sItem.type == 3183 || sItem.type == 4821))
+		*/
+		if (Main.myPlayer == whoAmI && ItemID.Sets.CatchingTool[sItem.type])
 			itemRectangle = ItemCheck_CatchCritters(sItem, itemRectangle);
 
 		if (sItem.type == 3183 || sItem.type == 4821) {
@@ -33916,7 +_,9 @@
 
 		if (sItem.damage > 0) {
 			UpdateMeleeHitCooldowns();
-			float knockBack = sItem.knockBack;
+			float knockBack = GetWeaponKnockback(sItem, sItem.knockBack);
+			// Knockback glove, buff and psycho knife moved to UpdateEquips, Update
+			/*
 			float num = 1f;
 			if (kbGlove)
 				num += 1f;
@@ -33927,6 +_,7 @@
 			knockBack *= num;
 			if (inventory[selectedItem].type == 3106)
 				knockBack += knockBack * (1f - stealth);
+			*/
 
 			bool[] shouldIgnore2 = ItemCheck_GetTileCutIgnoreList(sItem);
 			ItemCheck_CutTiles(sItem, itemRectangle, shouldIgnore2);
@@ -34216,15 +_,21 @@
 			if (i == whoAmI || !player.active || !player.hostile || player.immune || player.dead || (team != 0 && team == player.team) || !itemRectangle.Intersects(player.Hitbox) || !CanHit(player))
 				continue;
 
+			if (!CombinedHooks.CanHitPvp(this, sItem, player))
+				continue;
+
 			bool flag = false;
+			/*
 			if (Main.rand.Next(1, 101) <= 10)
 				flag = true;
+			*/
 
 			int num = Main.DamageVar(damage, luck);
+
 			StatusToPlayerPvP(sItem.type, i);
 			OnHit(player.Center.X, player.Center.Y, player);
-			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayer(whoAmI);
+			PlayerDeathReason playerDeathReason = PlayerDeathReason.ByPlayerItem(whoAmI, sItem);
-			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag);
+			int num2 = (int)player.Hurt(playerDeathReason, num, direction, pvp: true, quiet: false, flag, -1);
 			if (inventory[selectedItem].type == 3211) {
 				Vector2 vector = new Vector2(direction * 100 + Main.rand.Next(-25, 26), Main.rand.Next(-75, 76));
 				vector.Normalize();
@@ -34260,6 +_,8 @@
 				}
 			}
 
+			// Extra context
+
 			if (inventory[selectedItem].type == 3106) {
 				stealth = 1f;
 				if (Main.netMode == 1)
@@ -34375,9 +_,20 @@
 				TakeDamageFromJellyfish(npcIndex);
 		}
 		else {
+			// TODO: Should this be able to bypass the conditions above?
+			// https://github.com/tModLoader/tModLoader/pull/2984
+			bool? modCanHit = CombinedHooks.CanPlayerHitNPCWithItem(this, sItem, nPC);
+			if (modCanHit is false)
+				return;
+
+			if (modCanHit is true)
+				goto skipVanillaHitChecks;
+
 			if (nPC.friendly && (nPC.type != 22 || !killGuide) && (nPC.type != 54 || !killClothier) && (!nPC.isLikeATownNPC || sItem.type != 5129))
 				return;
 
+			skipVanillaHitChecks:
+
 			Rectangle rectangle = new Rectangle((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
 			bool flag = itemRectangle.Intersects(rectangle);
 			int type = sItem.type;
@@ -34388,21 +_,39 @@
 				flag = ((!_spawnVolcanoExplosion) ? (flag || flag2) : flag2);
 			}
 
+			bool? modCanCollide = CombinedHooks.CanPlayerMeleeAttackCollideWithNPC(this, sItem, itemRectangle, nPC);
+			if (modCanCollide == false)
+				return;
+			if (modCanCollide == true)
+				flag = true;
+
 			if (!flag || (!nPC.noTileCollide && !CanHit(nPC)))
 				return;
 
+			var modifiers = nPC.GetIncomingStrikeModifiers(sItem.DamageType, direction);
+			/*
 			int num = originalDamage;
+			*/
+			float num = 1000f; // to reduce patches, set to 1000, and then turn it into a multiplier later
 			bool flag3 = false;
+			if (!sItem.DamageType.UseStandardCritCalcs)
+				goto skipStandardCritCalcs;
+
 			int weaponCrit = GetWeaponCrit(sItem);
 			if (Main.rand.Next(1, 101) <= weaponCrit)
 				flag3 = true;
+			
+			skipStandardCritCalcs:
 
+			/*
 			int num2 = Item.NPCtoBanner(nPC.BannerID());
 			if (num2 > 0 && HasNPCBannerBuff(num2))
 				num = ((!Main.expertMode) ? ((int)((float)num * ItemID.Sets.BannerStrength[Item.BannerToItem(num2)].NormalDamageDealt)) : ((int)((float)num * ItemID.Sets.BannerStrength[Item.BannerToItem(num2)].ExpertDamageDealt)));
+			*/
+			ApplyBannerOffenseBuff(nPC, ref modifiers);
 
 			if (parryDamageBuff && sItem.melee) {
-				num *= 5;
+				modifiers.ScalingBonusDamage += 4f; //num *= 5;
 				parryDamageBuff = false;
 				ClearBuff(198);
 			}
@@ -34437,12 +_,15 @@
 				}, whoAmI);
 			}
 
+			/*
 			int num6 = Main.DamageVar(num, luck);
+			*/
+			modifiers.SourceDamage *= num / 1000f;
 			float armorPenetrationPercent = 0f;
 			if (sItem.type == 5129 && nPC.isLikeATownNPC) {
 				armorPenetrationPercent = 1f;
 				if (nPC.type == 18)
-					num6 *= 2;
+					modifiers.TargetDamageMultiplier *= 2; //num6 *= 2;
 			}
 
 			if (sItem.type == 3258) {
@@ -34470,23 +_,41 @@
 			if (nPC.life > 5)
 				OnHit(nPC.Center.X, nPC.Center.Y, nPC);
 
+			/*
 			num6 += nPC.checkArmorPenetration(armorPenetration, armorPenetrationPercent);
+			*/
+			modifiers.ArmorPenetration += GetWeaponArmorPenetration(sItem);
+			modifiers.ScalingArmorPenetration += armorPenetrationPercent;
+			CombinedHooks.ModifyPlayerHitNPCWithItem(this, sItem, nPC, ref modifiers);
+			var strike = modifiers.ToHitInfo(originalDamage, flag3, knockBack, damageVariation: true, luck);
+
 			NPCKillAttempt attempt = new NPCKillAttempt(nPC);
-			int dmgDone = (int)nPC.StrikeNPC(num6, knockBack, direction, flag3);
+			int dmgDone = nPC.StrikeNPC(strike);
+
+			CombinedHooks.OnPlayerHitNPCWithItem(this, sItem, nPC, strike, dmgDone);
+			/*
 			ApplyNPCOnHitEffects(sItem, itemRectangle, num, knockBack, npcIndex, num6, dmgDone);
+			*/
+			// num was pre-variation and post buffs. Equivalent to strike.SourceDamage.
+			// num6 is post-variation and armor pen, only used by bees and muramasa.
+			// By switching to strike.SourceDamage for num6, we introduce a slight vanilla discrepancy, but we remove the double damage randomization, and armor penetration
+			ApplyNPCOnHitEffects(sItem, itemRectangle, strike.SourceDamage, strike.Knockback, npcIndex, strike.SourceDamage, dmgDone);
 			int num7 = Item.NPCtoBanner(nPC.BannerID());
 			if (num7 >= 0)
 				lastCreatureHit = num7;
 
 			if (Main.netMode != 0) {
+				/*
 				if (flag3)
 					NetMessage.SendData(28, -1, -1, null, npcIndex, num6, knockBack, direction, 1);
 				else
 					NetMessage.SendData(28, -1, -1, null, npcIndex, num6, knockBack, direction);
+				*/
+				NetMessage.SendStrikeNPC(nPC, strike);
 			}
 
-			if (accDreamCatcher)
-				addDPS(num6);
+			if (accDreamCatcher && !nPC.HideStrikeDamage)
+				addDPS(dmgDone); // Intentionally changed from num6 (strike damage)
 
 			SetMeleeHitCooldown(npcIndex, itemAnimation);
 			if (attempt.DidNPCDie())
@@ -34746,11 +_,17 @@
 
 	private Rectangle ItemCheck_CatchCritters(Item sItem, Rectangle itemRectangle)
 	{
+		//TML: Effectively replaced by ItemID.Sets.LavaproofCatchingTool
+		/*
 		bool flag = sItem.type == 3183 || sItem.type == 4821;
+		*/
 		for (int i = 0; i < 200; i++) {
 			if (!Main.npc[i].active || Main.npc[i].catchItem <= 0)
 				continue;
 
+			NPC.CheckCatchNPC(Main.npc[i], itemRectangle, sItem, this, ItemID.Sets.LavaproofCatchingTool[sItem.type]);
+
+			/*
 			Rectangle value = new Rectangle((int)Main.npc[i].position.X, (int)Main.npc[i].position.Y, Main.npc[i].width, Main.npc[i].height);
 			if (!itemRectangle.Intersects(value))
 				continue;
@@ -34766,6 +_,7 @@
 			else {
 				NPC.CatchNPC(i, whoAmI);
 			}
+			*/
 		}
 
 		return itemRectangle;
@@ -35074,6 +_,8 @@
 			Main.dust[num29].velocity.Y *= 2f;
 		}
 
+		CombinedHooks.MeleeEffects(this, sItem, itemRectangle);
+
 		return itemRectangle;
 	}
 
@@ -35153,6 +_,8 @@
 			}
 		}
 
+		ItemLoader.UseItemHitbox(sItem, this, ref itemRectangle, ref dontAttack);
+
 		if (sItem.type == 1450 && Main.rand.Next(3) == 0) {
 			int num3 = -1;
 			float x = itemRectangle.X + Main.rand.Next(itemRectangle.Width);
@@ -35256,29 +_,75 @@
 		releaseUseItem = false;
 	}
 
+	// Added by TML.
+	public void UseManaMaxIncreasingItem(int increase)
+	{
+		// Failsafe.  Might not be needed?
+		if (increase < 0)
+			increase = 0;
+
+		statManaMax += increase;
+		statManaMax2 += increase;
+		statMana += increase;
+
+		if (Main.myPlayer == whoAmI)
+			ManaEffect(increase);
+	}
+
 	private void ItemCheck_UseManaCrystal(Item sItem)
 	{
+		/*
 		if (sItem.type == 109 && itemAnimation > 0 && statManaMax < 200 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 109 && itemAnimation > 0 && ConsumedManaCrystals < ManaCrystalMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statManaMax += 20;
 			statManaMax2 += 20;
 			statMana += 20;
 			if (Main.myPlayer == whoAmI)
 				ManaEffect(20);
+			*/
+			UseManaMaxIncreasingItem(20);
+			ConsumedManaCrystals++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 1);
 		}
 	}
 
+	// Added by TML.
+	public void UseHealthMaxIncreasingItem(int increase)
+	{
+		// Failsafe.  Might not be needed?
+		if (increase < 0)
+			increase = 0;
+
+		statLifeMax += increase;
+		statLifeMax2 += increase;
+		statLife += increase;
+
+		if (Main.myPlayer == whoAmI)
+			HealEffect(increase);
+	}
+
 	private void ItemCheck_UseLifeFruit(Item sItem)
 	{
+		/*
 		if (sItem.type == 1291 && itemAnimation > 0 && statLifeMax >= 400 && statLifeMax < 500 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 1291 && itemAnimation > 0 && ConsumedLifeCrystals == LifeCrystalMax && ConsumedLifeFruit < LifeFruitMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statLifeMax += 5;
 			statLifeMax2 += 5;
 			statLife += 5;
 			if (Main.myPlayer == whoAmI)
 				HealEffect(5);
+			*/
+			UseHealthMaxIncreasingItem(5);
+			ConsumedLifeFruit++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 2);
 		}
@@ -35286,13 +_,21 @@
 
 	private void ItemCheck_UseLifeCrystal(Item sItem)
 	{
+		/*
 		if (sItem.type == 29 && itemAnimation > 0 && statLifeMax < 400 && ItemTimeIsZero) {
+		*/
+		if (sItem.type == 29 && itemAnimation > 0 && ConsumedLifeCrystals < LifeCrystalMax && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			/*
 			statLifeMax += 20;
 			statLifeMax2 += 20;
 			statLife += 20;
 			if (Main.myPlayer == whoAmI)
 				HealEffect(20);
+			*/
+			UseHealthMaxIncreasingItem(20);
+			ConsumedLifeCrystals++;
 
 			AchievementsHelper.HandleSpecialEvent(this, 0);
 		}
@@ -35479,7 +_,10 @@
 			}
 		}
 
+		/*
 		itemTime = (int)((float)item.useTime * pickSpeed);
+		*/
+		ApplyItemTime(item, pickSpeed);
 	}
 
 	private void DamageTileWithShovel(Player user, Item item, int x, int y)
@@ -35516,7 +_,10 @@
 
 		if (toolTime == 0 && itemAnimation > 0 && controlUseItem) {
 			Tile tile = Main.tile[tileTargetX, tileTargetY];
+			/*
 			if (!tile.active() || IsTilePoundable(tile))
+			*/
+			if (!tile.active() || IsTilePoundable(tile) && !TileID.Sets.CanBeSloped[tile.type])
 				poundRelease = false;
 		}
 
@@ -35566,7 +_,14 @@
 		if (Main.tileHammer[tile.type]) {
 			canHitWalls = false;
 			if (sItem.hammer > 0) {
+				if (TileLoader.GetTile(tile.type) is ModTile modTile) {
+					num2 += (int)(sItem.hammer / modTile.MineResist);
+					goto skipVanillaHammerPower;
+				}
+
 				num2 += sItem.hammer;
+				skipVanillaHammerPower:
+
 				if (!WorldGen.CanKillTile(x, y))
 					num2 = 0;
 
@@ -35596,10 +_,17 @@
 			}
 		}
 		else if (Main.tileAxe[tile.type]) {
+			if (TileLoader.GetTile(tile.type) is ModTile modTile) {
+				num2 += (int)(sItem.axe / modTile.MineResist);
+				goto skipVanillaAxePower;
+			}
+
 			num2 = ((tile.type != 80) ? (num2 + (int)((float)sItem.axe * 1.2f)) : (num2 + (int)((float)(sItem.axe * 3) * 1.2f)));
 			if (Main.getGoodWorld)
 				num2 = (int)((double)num2 * 1.3);
 
+			skipVanillaAxePower:
+
 			if (sItem.axe > 0) {
 				AchievementsHelper.CurrentlyMining = true;
 				if (!WorldGen.CanKillTile(x, y))
@@ -35630,7 +_,7 @@
 						NetMessage.SendData(17, -1, -1, null, 0, x, y);
 
 					if (sItem.type == 5295 && flag)
-						TryReplantingTree();
+						TryReplantingTree(x, y);
 				}
 				else {
 					WorldGen.KillTile(x, y, fail: true);
@@ -35649,8 +_,12 @@
 			PickTile(x, y, sItem.pick);
 		}
 
+
 		if (sItem.pick > 0)
+		/*
 			itemTime = (int)((float)sItem.useTime * pickSpeed);
+		*/
+			ApplyItemTime(sItem, pickSpeed);
 
 		ItemCheck_UseMiningTools_TryPoundingTile(sItem, num, ref canHitWalls, x, y);
 	}
@@ -35673,10 +_,13 @@
 		return true;
 	}
 
-	private void TryReplantingTree()
+	private void TryReplantingTree(int x, int y)
 	{
-		ushort type = 20;
+		int type = 20;
 		int style = 0;
+
+		PlantLoader.CheckAndInjectModSapling(x, y, ref type, ref style);
+
 		if (!TileObject.CanPlace(tileTargetX, tileTargetY, type, style, direction, out var objectData))
 			return;
 
@@ -35798,7 +_,14 @@
 	private void ItemCheck_UseMiningTools_TryPoundingTile(Item sItem, int tileHitId, ref bool hitWall, int x, int y)
 	{
 		Tile tile = Main.tile[x, y];
+
+		/*
 		if (sItem.hammer > 0 && tile.active() && (Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442) && poundRelease) {
+		*/
+		bool canTrySloping = sItem.hammer > 0 && tile.active() && poundRelease;
+		bool vanillaSloping = Main.tileSolid[tile.type] || tile.type == 314 || tile.type == 351 || tile.type == 424 || tile.type == 442;
+
+		if (canTrySloping && (vanillaSloping || TileID.Sets.CanBeSloped[tile.type])) {
 			hitWall = false;
 			ApplyItemTime(sItem);
 			int damageAmount = 100;
@@ -35810,6 +_,7 @@
 				if (!poundRelease)
 					return;
 
+				if (TileLoader.Slope(x, y, Main.tile[x, y].type)) { } else
 				if (TileID.Sets.Platforms[Main.tile[x, y].type]) {
 					if (tile.halfBrick()) {
 						WorldGen.PoundTile(x, y);
@@ -36439,7 +_,9 @@
 			}
 
 			if (num3 >= 0 && WorldGen.PlaceWire(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num3], this))
-				inventory[num3].stack--;
+					inventory[num3].stack--;
+
 				if (inventory[num3].stack <= 0)
 					inventory[num3].SetDefaults();
 
@@ -36457,7 +_,9 @@
 			}
 
 			if (num4 >= 0 && WorldGen.PlaceWire2(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num4], this))
-				inventory[num4].stack--;
+					inventory[num4].stack--;
+
 				if (inventory[num4].stack <= 0)
 					inventory[num4].SetDefaults();
 
@@ -36476,7 +_,9 @@
 			}
 
 			if (num5 >= 0 && WorldGen.PlaceWire3(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num5], this))
-				inventory[num5].stack--;
+					inventory[num5].stack--;
+
 				if (inventory[num5].stack <= 0)
 					inventory[num5].SetDefaults();
 
@@ -36495,7 +_,9 @@
 			}
 
 			if (num6 >= 0 && WorldGen.PlaceWire4(num, num2)) {
+				if (ItemLoader.ConsumeItem(inventory[num6], this))
-				inventory[num6].stack--;
+					inventory[num6].stack--;
+
 				if (inventory[num6].stack <= 0)
 					inventory[num6].SetDefaults();
 
@@ -36528,7 +_,9 @@
 		else if (sItem.type == 849 && sItem.stack > 0 && WorldGen.PlaceActuator(num, num2)) {
 			ApplyItemTime(sItem);
 			NetMessage.SendData(17, -1, -1, null, 8, tileTargetX, tileTargetY);
+			if (ItemLoader.ConsumeItem(sItem, this))
-			sItem.stack--;
+				sItem.stack--;
+
 			if (sItem.stack <= 0)
 				sItem.SetDefaults();
 		}
@@ -36620,11 +_,21 @@
 
 	private void ItemCheck_Shoot(int i, Item sItem, int weaponDamage)
 	{
+		if (!CombinedHooks.CanShoot(this, sItem))
+			return;
+
 		int projToShoot = sItem.shoot;
 		float speed = sItem.shootSpeed;
 		int damage = sItem.damage;
 		if (sItem.melee && !ProjectileID.Sets.NoMeleeSpeedVelocityScaling[projToShoot])
-			speed /= meleeSpeed;
+			speed /= inverseMeleeSpeed;
+
+		// Copied as-is from 1.3
+		if (sItem.CountsAsClass(DamageClass.Throwing) && speed < 16f) {
+			speed *= ThrownVelocity;
+			if (speed > 16f)
+				speed = 16f;
+		}
 
 		bool canShoot = false;
 		int Damage = weaponDamage;
@@ -36678,6 +_,12 @@
 		if (!canShoot)
 			return;
 
+		// Added by TML. #ItemTimeOnAllClients
+		if (whoAmI != Main.myPlayer) {
+			ApplyItemTime(sItem);
+			return;
+		}
+
 		KnockBack = GetWeaponKnockback(sItem, KnockBack);
 		IEntitySource projectileSource_Item_WithPotentialAmmo = GetProjectileSource_Item_WithPotentialAmmo(sItem, usedAmmoItemId);
 		if (projToShoot == 228)
@@ -36708,7 +_,8 @@
 		Vector2 pointPoisition = RotatedRelativePoint(MountedCenter);
 		bool flag = true;
 		int type = sItem.type;
-		if (type == 723 || type == 3611)
+		//if (type == 723 || type == 3611)
+		if (!sItem.ChangePlayerDirectionOnShoot)
 			flag = false;
 
 		Vector2 value = Vector2.UnitX.RotatedBy(fullRotation);
@@ -36824,6 +_,16 @@
 			num3 = vector5.Y;
 		}
 
+		goto DirtBallShoot;
+
+		ShootHook:
+		Vector2 velocity = new Vector2(num2, num3);
+
+		CombinedHooks.ModifyShootStats(this, sItem, ref pointPoisition, ref velocity, ref projToShoot, ref Damage, ref KnockBack);
+
+		num2 = velocity.X;
+		num3 = velocity.Y;
+
 		if (sItem.useStyle == 5) {
 			if (sItem.type == 3029) {
 				Vector2 vector6 = new Vector2(num2, num3);
@@ -36859,6 +_,12 @@
 			NetMessage.SendData(41, -1, -1, null, whoAmI);
 		}
 
+		if (!CombinedHooks.Shoot(this, sItem, (EntitySource_ItemUse_WithAmmo)projectileSource_Item_WithPotentialAmmo, pointPoisition, velocity, projToShoot, Damage, KnockBack))
+			return;
+
+		goto ShootProj;
+
+		DirtBallShoot:
 		if (projToShoot == 17) {
 			pointPoisition.X = (float)Main.mouseX + Main.screenPosition.X;
 			pointPoisition.Y = (float)Main.mouseY + Main.screenPosition.Y;
@@ -36868,6 +_,9 @@
 			LimitPointToPlayerReachableArea(ref pointPoisition);
 		}
 
+		goto ShootHook;
+
+		ShootProj:
 		if (projToShoot == 76) {
 			projToShoot += Main.rand.Next(3);
 			float num7 = (float)Main.screenHeight / Main.GameViewMatrix.Zoom.Y;
@@ -38410,10 +_,14 @@
 		projType = 721;
 		Item item = inventory[selectedItem];
 		if (!item.IsAir && item.shoot > 0 && ProjectileID.Sets.IsAGolfBall[item.shoot]) {
+			// Extra patch context.
 			projType = item.shoot;
 			return;
 		}
 
+		if (LoaderManager.Get<AccessorySlotLoader>().PreferredGolfBall(ref projType))
+			return;
+
 		for (int num = 19; num >= 0; num--) {
 			if (IsItemSlotUnlockedAndUsable(num)) {
 				_ = num % 10;
@@ -38438,6 +_,11 @@
 	{
 		if (sItem.shoot > 0 && ProjectileID.Sets.MinionTargettingFeature[sItem.shoot] && altFunctionUse == 2 && cShoot && ItemTimeIsZero) {
 			ApplyItemTime(sItem);
+
+			// Added by TML. #ItemTimeOnAllClients
+			if (whoAmI != Main.myPlayer)
+				return;
+
 			MinionNPCTargetAim(doNotDisableIfTheTargetIsTheSame: false);
 		}
 	}
@@ -38448,6 +_,11 @@
 			return;
 
 		ApplyItemTime(sItem);
+
+		// Added by TML. #ItemTimeOnAllClients
+		if (whoAmI != Main.myPlayer)
+			return;
+
 		for (int i = 0; i < 1000; i++) {
 			Projectile projectile = Main.projectile[i];
 			if (projectile.active && projectile.owner == Main.myPlayer && ProjectileID.Sets.TurretFeature[projectile.type])
@@ -38469,12 +_,17 @@
 	private void ItemCheck_EmitHeldItemLight(Item sItem)
 	{
 		Vector2? handPosition = HandPosition;
-		if (((ItemID.Sets.Torches[sItem.type] && !wet) || ItemID.Sets.WaterTorches[sItem.type]) && !pulley && !happyFunTorchTime) {
+		if (((ItemID.Sets.Torches[sItem.type] && !wet) || ItemID.Sets.WaterTorches[BiomeTorchHoldStyle(sItem.type)]) && !pulley && !happyFunTorchTime) {
 			float R = 1f;
 			float G = 0.95f;
 			float B = 0.8f;
 			int num = 0;
 			int num2 = BiomeTorchHoldStyle(sItem.type);
+			if (num2 >= ItemID.Count) {
+				// This could be a different hook, but then modders would have to move code. TorchID could be used, but it would be a lot of work managing another modded ID and would limit torch lighting and dust behavior to the vanilla pattern.
+				ItemLoader.GetItem(num2).HoldItem(this);
+				goto PostVanillaTorchLight;
+			}
 			if (num2 == 523)
 				num = 8;
 			else if (num2 == 974)
@@ -38552,6 +_,7 @@
 				Lighting.AddLight(RotatedRelativePoint(new Vector2(itemLocation.X + 12f + velocity.X, itemLocation.Y - 14f + velocity.Y)), R, G, B);
 			}
 		}
+		PostVanillaTorchLight:
 
 		if ((sItem.type == 105 || sItem.type == 713) && !wet && !pulley) {
 			int maxValue2 = 20;
@@ -38777,6 +_,12 @@
 
 	private void ItemCheck_ApplyHoldStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
 	{
+		ItemCheck_ApplyHoldStyle_Inner(mountOffset, sItem, heldItemFrame);
+		ItemLoader.HoldStyle(sItem, this, heldItemFrame);
+	}
+
+	private void ItemCheck_ApplyHoldStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
+	{
 		if (isPettingAnimal) {
 			int num = miscCounter % 14 / 7;
 			CompositeArmStretchAmount stretch = CompositeArmStretchAmount.ThreeQuarters;
@@ -38798,7 +_,7 @@
 				itemLocation.X = position.X + (float)width * 0.5f + 20f * (float)direction;
 			}
 			else if (sItem.type == 930) {
-				itemLocation.X = position.X + (float)(width / 2) * 0.5f - 12f - (float)(2 * direction);
+				itemLocation.X = position.X + width * 0.5f - 2 * direction; // forward port from 1.4.5
 				float x = position.X + (float)(width / 2) + (float)(38 * direction);
 				if (direction == 1)
 					x -= 10f;
@@ -38865,7 +_,7 @@
 					if (Main.tile[num5, num6] == null)
 						Main.tile[num5, num6] = new Tile();
 
-					if (Main.tile[num5, num6].active() && Main.tile[num5, num6].type == 215 && Main.tile[num5, num6].frameY < 54) {
+					if (Main.tile[num5, num6].active() && TileID.Sets.Campfire[Main.tile[num5, num6].type] && Main.tile[num5, num6].frameY < 54) {
 						miscTimer++;
 						if (Main.rand.Next(5) == 0)
 							miscTimer++;
@@ -38982,7 +_,7 @@
 		}
 		else if (sItem.holdStyle == 3 && !pulley) {
 			if (!Main.dedServ) {
-				itemLocation.X = position.X + (float)width * 0.5f - (float)heldItemFrame.Width * 0.5f - (float)(direction * 2);
+				itemLocation.X = position.X + (float)width * 0.5f - (float)(direction * 2); // forward port from 1.4.5
 				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
 				itemRotation = 0f;
 			}
@@ -39041,7 +_,10 @@
 
 	private void ItemCheck_ApplyManaRegenDelay(Item sItem)
 	{
+		/*
 		if (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))
+		*/
+ 		if (GetManaCost(sItem) > 0)
 			manaRegenDelay = (int)maxRegenDelay;
 	}
 
@@ -39105,6 +_,12 @@
 
 	public void ItemCheck_ApplyUseStyle(float mountOffset, Item sItem, Rectangle heldItemFrame)
 	{
+		ItemCheck_ApplyUseStyle_Inner(mountOffset, sItem, heldItemFrame);
+		ItemLoader.UseStyle(sItem, this, heldItemFrame);
+	}
+
+	private void ItemCheck_ApplyUseStyle_Inner(float mountOffset, Item sItem, Rectangle heldItemFrame)
+	{
 		if (Main.dedServ)
 			return;
 
@@ -39456,7 +_,7 @@
 			}
 			else if (sItem.type == 4262) {
 				itemRotation = 0f;
-				itemLocation.X = base.Center.X + (float)(-heldItemFrame.Width) * 0.5f + (float)(direction * -6);
+				itemLocation.X = base.Center.X + (float)(direction * -6); // forward port from 1.4.5
 				itemLocation.Y = MountedCenter.Y - 6f;
 				if (Main.rand.Next(20) == 0) {
 					int num21 = Main.rand.Next(570, 573);
@@ -39482,7 +_,7 @@
 				itemLocation += (itemRotation.ToRotationVector2() * num22 * direction).Floor();
 			}
 			else {
-				itemLocation.X = position.X + (float)width * 0.5f - (float)heldItemFrame.Width * 0.5f - (float)(direction * 2);
+				itemLocation.X = position.X + (float)width * 0.5f - (float)(direction * 2); // forward port from 1.4.5
 				itemLocation.Y = MountedCenter.Y - (float)heldItemFrame.Height * 0.5f;
 			}
 
@@ -39713,7 +_,7 @@
 		if (sItem.pick > 0 || sItem.axe > 0 || sItem.hammer > 0 || flag)
 			toolTime = 1;
 
-		if (grappling[0] > -1) {
+		if (grappling[0] > -1 || sItem.useTurnOnAnimationStart) { // useTurnOnAnimationStart check added by tML
 			pulley = false;
 			pulleyDir = 1;
 			if (controlRight)
@@ -39780,7 +_,10 @@
 			}
 
 			for (int l = 0; l < list.Count; l++) {
+				/*
 				if (!(num - num3 > (float)maxMinions - num2))
+				*/
+				if (!(num - num3 > (float)maxMinions - num2 + 0.00001f)) // existing - killedSoFar > maxMinions - needed. Even if a modder does 1/3f for Projectile.minionSlots, the floating point math won't work out without an "epsilon".
 					break;
 
 				int type2 = Main.projectile[list[l]].type;
@@ -39862,8 +_,12 @@
 
 	private void ApplyLifeAndOrMana(Item item)
 	{
+		/*
 		int num = item.healLife;
 		int healMana = item.healMana;
+		*/
+		int num = item.healLife > 0 ? GetHealLife(item, true) : 0;
+		int healMana = item.healMana > 0 ? GetHealMana(item, true) : 0;
 		if (item.type == 3001) {
 			int healLife = item.healLife;
 			int num2 = 120;
@@ -39903,6 +_,9 @@
 
 	private bool ItemCheck_CheckCanUse(Item sItem)
 	{
+		if (sItem.IsAir || !CombinedHooks.CanUseItem(this, sItem))
+			return false;
+
 		int num = whoAmI;
 		bool flag = true;
 		int num2 = (int)((float)Main.mouseX + Main.screenPosition.X) / 16;
@@ -40262,7 +_,7 @@
 		if (baitTypeUsed == 2673)
 			flag = true;
 
-		if (flag) {
+		if (CombinedHooks.CanConsumeBait(this, item) ?? flag) {
 			if (item.type == 4361 || item.type == 4362)
 				NPC.LadyBugKilled(base.Center, item.type == 4362);
 
@@ -40306,6 +_,11 @@
 		if (sItem.type == 3006)
 			flag2 = true;
 
+		if (sItem.type != ItemID.MedusaHead /*3269*/ && !CheckMana(sItem, pay:!flag2))
+			canUse = false;
+
+		return canUse; // TML: The below code was moved to CheckMana and GetManaCost in Player.TML.
+
 		if (sItem.type != 3269 && (!spaceGun || (sItem.type != 127 && sItem.type != 4347 && sItem.type != 4348))) {
 			if (statMana >= num) {
 				if (!flag2)
@@ -40475,6 +_,13 @@
 
 	private void ItemCheck_HandleMPItemAnimation(Item sItem)
 	{
+		// Firstly, in vanilla, autoReuse items go from itemAnimation == 1 to itemAnimationMax-1 here, skipping the frame where itemAnimation == 0
+		//   this prevents the item flickering out while being auto-reused, and prevents other control inputs that can happen on that 'frame where item is not in use' like useTurn
+		//   but has the side-effect that autoReuse items are one frame shorter. tML fixes the itemAnimation counter, see the comments near the top of ItemCheck_Inner (#2351)
+		//
+		// Secondly, we don't need to play the shoot-sound and ensure hold-out animation looping for remote players because Shoot logic now runs remote side in tML (#ItemTimeOnAllClients)
+
+		/*
 		if (sItem.autoReuse && !noItems) {
 			releaseUseItem = true;
 			if (itemAnimation == 1 && sItem.stack > 0) {
@@ -40484,23 +_,43 @@
 					itemAnimation = 0;
 			}
 		}
+		*/
 
 		TryAllowingItemReuse(sItem);
 	}
 
 	private void TryAllowingItemReuse(Item sItem)
 	{
+		if (CanAutoReuseItem(sItem))
+			releaseUseItem = true;
+	}
+
+	//TML: Public method split from TryAllowingItemReuse
+	public bool CanAutoReuseItem(Item sItem)
+	{
+		if (CombinedHooks.CanAutoReuseItem(this, sItem) is bool autoReuse)
+			return autoReuse;
+
+		/*
 		bool flag = false;
+		*/
+		bool flag = sItem.autoReuse;
 		if (autoReuseGlove) {
+			/*
 			flag |= sItem.melee && sItem.type != 3030;
 			flag |= sItem.summon && ItemID.Sets.SummonerWeaponThatScalesWithAttackSpeed[sItem.type];
+			*/
+			flag |= sItem.CountsAsClass(DamageClass.Melee) || sItem.CountsAsClass(DamageClass.SummonMeleeSpeed);
 		}
 
 		if (autoReuseAllWeapons && sItem.damage > 0 && (!sItem.channel || !channel))
 			flag = true;
 
+		/*
 		if (flag)
 			releaseUseItem = true;
+		*/
+		return flag;
 	}
 
 	private void ItemCheck_HandleMount()
@@ -40508,6 +_,7 @@
 		if (!mount.Active)
 			return;
 
+		MountLoader.UseAbility(this, Vector2.Zero, false);
 		if (whoAmI == Main.myPlayer && gravDir == -1f) {
 			mount.Dismount(this);
 		}
@@ -40626,6 +_,10 @@
 		worldY = i * 16;
 	}
 
+	/// <summary>
+	/// Kills <see cref="Projectile.sentry"/> projectiles exceeding the players current <see cref="maxTurrets"/>. The oldest projectiles, determined by <see cref="Projectile.timeLeft"/>, are killed. <br/>
+	/// Call this method immediately after spawning a <see cref="Projectile.sentry"/> projectile.<br/>
+	/// </summary>
 	public void UpdateMaxTurrets()
 	{
 		if (Main.myPlayer != whoAmI)
@@ -40853,8 +_,14 @@
 		}
 	}
 
+	// TML-specific overload that exists for consistency with other GetWeaponXYZ methods
+	public float GetWeaponKnockback(Item sItem) => GetWeaponKnockback(sItem, sItem.knockBack);
+
+	//TML: 'KnockBack' -> 'baseKnockback'.
-	public float GetWeaponKnockback(Item sItem, float KnockBack)
+	public float GetWeaponKnockback(Item sItem, float baseKnockback)
 	{
+		// knockback moved into UpdateEquips/Update as sensible
+		/*
 		if (sItem.summon)
 			KnockBack += minionKB;
 
@@ -40871,10 +_,16 @@
 			KnockBack *= 1f + (1f - stealth) * 0.5f;
 
 		return KnockBack;
+		*/
+
+		StatModifier modifier = GetTotalKnockback(sItem.DamageType);
+		CombinedHooks.ModifyWeaponKnockback(this, sItem, ref modifier);
+		return Math.Max(0f, modifier.ApplyTo(baseKnockback));
 	}
 
 	public int GetWeaponCrit(Item sItem)
 	{
+		/*
 		if (sItem.melee)
 			return meleeCrit;
 
@@ -40885,10 +_,17 @@
 			return magicCrit;
 
 		return 0;
+		*/
+
+		float crit = sItem.crit + GetTotalCritChance(sItem.DamageType);
+		CombinedHooks.ModifyWeaponCrit(this, sItem, ref crit);
+		return (int)(crit + 5E-06f);
 	}
 
-	public int GetWeaponDamage(Item sItem)
+	//TML: Added 'forTooltip' parameter.
+	public int GetWeaponDamage(Item sItem, bool forTooltip = false)
 	{
+		/*
 		int num = sItem.damage;
 		if (num > 0) {
 			if (sItem.melee) {
@@ -40919,10 +_,44 @@
 		}
 
 		return num;
+		*/
+
+		StatModifier modifier = GetTotalDamage(sItem.DamageType);
+
+		if (AmmoID.Sets.IsArrow[sItem.useAmmo])
+			modifier = modifier.CombineWith(arrowDamage);
+
+		if (AmmoID.Sets.IsBullet[sItem.useAmmo])
+			modifier = modifier.CombineWith(bulletDamage);
+
+		if (AmmoID.Sets.IsSpecialist[sItem.useAmmo] || ItemID.Sets.IsRangedSpecialistWeapon[sItem.type])
+			modifier = modifier.CombineWith(specialistDamage);
+
+		CombinedHooks.ModifyWeaponDamage(this, sItem, ref modifier);
+
+		float baseDamage = sItem.damage;
+		if (forTooltip)
+			baseDamage *= ItemID.Sets.ToolTipDamageMultiplier[sItem.type];
+
+		return Math.Max(0, (int)(modifier.ApplyTo(baseDamage) + 5E-06f));
 	}
 
+	/// <summary>
+	/// Whether or not the player has ammunition available for the given weapon.
+	/// </summary>
+	/// <param name="sItem">The weapon for which to try to find ammunition.</param>
+	/// <returns>True if the player has ammo available; false otherwise.</returns>
+	public bool HasAmmo(Item sItem) => HasAmmo(sItem, canUse: true);
+
+	//TML: Internal split for vanilla canUse calls
-	public bool HasAmmo(Item sItem, bool canUse)
+	internal bool HasAmmo(Item sItem, bool canUse)
 	{
+		if (!canUse)
+			return false; // just in case I guess...
+
+		return sItem.useAmmo == 0 || ChooseAmmo(sItem) != null || !ItemLoader.NeedsAmmo(sItem, this);
+
+		/*
 		if (sItem.useAmmo > 0) {
 			canUse = false;
 			for (int i = 0; i < 58; i++) {
@@ -40934,6 +_,7 @@
 		}
 
 		return canUse;
+		*/
 	}
 
 	private bool PickAmmo_TryFindingSpecificMatches(int launcher, int ammo, out int pickedProjectileId)
@@ -40945,15 +_,68 @@
 		return false;
 	}
 
+	// Overloaded added by TML.
+	/// <summary>
+	/// A more-convenient-to-call variant of the vanilla PickAmmo method, which handles most vanilla ammunition logic to decide various common stats related to ammunition-consuming weapons.<br></br>
+	/// The stats output by this method take into account any extra stats which the ammunition it finds may provide (read: it accounts for ammo damage and knockback).<br></br>
+	/// </summary>
+	/// <param name="weapon">The weapon for which to handle ammunition logic.</param>
+	/// <param name="projToShoot">The projectile that should be shot based on the given weapon and the located ammunition.</param>
+	/// <param name="speed">The speed at which the projectile that would be made by the given weapon and located ammunition should move.</param>
+	/// <param name="damage">The damage value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+	/// <param name="knockBack">The knockback value that the projectile shot should have, based on the given weapon and the located ammunition.</param>
+	/// <param name="usedAmmoItemId">The numerical ID of the located ammunition.</param>
+	/// <param name="dontConsume">
+	/// Whether or not ammo consumption logic should be called upon.<br></br>
+	/// This defaults to false, and if it is true for any reason, ammo will not be consumed at the end of the method.<br></br>
+	/// This is useful for gathering the data needed based on PickAmmo's calculations without incidentally consuming any ammunition in the process.
+	/// </param>
+	/// <returns>True if ammo was found/chosen, and false otherwise.</returns>
+	public bool PickAmmo(Item weapon, out int projToShoot, out float speed, out int damage, out float knockBack, out int usedAmmoItemId, bool dontConsume = false)
+	{
+		projToShoot = weapon.shoot;
+		speed = weapon.shootSpeed;
+		damage = GetWeaponDamage(weapon);
+		knockBack = GetWeaponKnockback(weapon);
+
+		bool canShoot = false;
+		PickAmmo(weapon, ref projToShoot, ref speed, ref canShoot, ref damage, ref knockBack, out usedAmmoItemId, dontConsume);
+
+		if (!canShoot) {
+			projToShoot = 0;
+			return false;
+		}
+
+		return true;
+	}
+
+	//TML: Method split, 1st part of original PickAmmo.
+	/*
 	public void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int Damage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
+	*/
+	/// <summary>
+	/// Attempts to select an ammo item stack from this player's inventory to shoot with the given weapon.
+	/// </summary>
+	/// <param name="weapon">The weapon for which this call should try to find ammo.</param>
+	/// <returns>Null if no suitable ammo is found; otherwise, returns the first ammo item found.</returns>
+	public Item ChooseAmmo(Item weapon)
 	{
-		Item item = new Item();
+		var sItem = weapon;
+		Item item = null;
 		bool flag = false;
+		/*
 		usedAmmoItemId = 0;
+		*/
+		bool canShoot = false; // Dummy.
+
 		if (sItem.useAmmo == AmmoID.Coin) {
 			for (int i = 0; i < 4; i++) {
 				int num = 50 + i;
+
+				/*
 				if (inventory[num].ammo == sItem.useAmmo && inventory[num].stack > 0) {
+				*/
+				if (inventory[num].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[i], this)) {
 					item = inventory[num];
 					canShoot = true;
 					flag = true;
@@ -40963,7 +_,10 @@
 		}
 
 		for (int j = 54; j < 58; j++) {
+			/*
 			if (inventory[j].ammo == sItem.useAmmo && inventory[j].stack > 0) {
+			*/
+			if (inventory[j].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[j], this)) {
 				item = inventory[j];
 				canShoot = true;
 				flag = true;
@@ -40973,7 +_,10 @@
 
 		if (!flag) {
 			for (int k = 0; k < 54; k++) {
+				/*
 				if (inventory[k].ammo == sItem.useAmmo && inventory[k].stack > 0) {
+				*/
+				if (inventory[k].stack > 0 && ItemLoader.CanChooseAmmo(sItem, inventory[k], this)) {
 					item = inventory[k];
 					canShoot = true;
 					break;
@@ -40981,10 +_,43 @@
 			}
 		}
 
+		return item;
+	}
+
+	//TML: Method split, 2nd part of original PickAmmo. This one gets called by vanilla in place of it.
+	internal void PickAmmo(Item sItem, ref int projToShoot, ref float speed, ref bool canShoot, ref int totalDamage, ref float KnockBack, out int usedAmmoItemId, bool dontConsume = false)
+	{
+		usedAmmoItemId = 0;
+		Item item = ChooseAmmo(sItem);
+		canShoot = item != null;
+
+		bool shootWithNoAmmo = false;
+		if (!canShoot && !ItemLoader.NeedsAmmo(sItem, this)) {
+			item = ContentSamples.ItemsByType[sItem.useAmmo];
+			if (item.ammo == sItem.useAmmo)
+				canShoot = shootWithNoAmmo = true;
+		}
+
 		if (!canShoot)
 			return;
 
 		usedAmmoItemId = item.type;
+
+		StatModifier ammoDamage = GetTotalDamage(item.DamageType);
+		if (AmmoID.Sets.IsArrow[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(arrowDamage);
+
+		if (AmmoID.Sets.IsBullet[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(bulletDamage);
+
+		if (AmmoID.Sets.IsSpecialist[item.ammo])
+			ammoDamage = ammoDamage.CombineWith(specialistDamage);
+
+		// TODO: Why do we reset Base to 0 here? Why not use += for Flat?
+		ammoDamage.Base = 0;
+		ammoDamage.Flat = totalDamage;
+		ref float Damage = ref ammoDamage.Flat; // Vanilla projectile damage applied from here on is interpreted as flat additions
+
 		int pickedProjectileId = -1;
 		if (PickAmmo_TryFindingSpecificMatches(sItem.type, item.type, out pickedProjectileId))
 			projToShoot = pickedProjectileId;
@@ -41015,6 +_,7 @@
 			projToShoot = 117;
 
 		if (projToShoot == 42) {
+			/*
 			if (item.type == 370) {
 				projToShoot = 65;
 				Damage += 5;
@@ -41027,6 +_,12 @@
 				projToShoot = 354;
 				Damage += 5;
 			}
+			*/
+
+			if (ItemID.Sets.SandgunAmmoProjectileData[item.type] is ItemID.Sets.SandgunAmmoInfo data) {
+				projToShoot = data.ProjectileType;
+				Damage += data.BonusDamage;
+			}
 		}
 
 		if (inventory[selectedItem].type == 2888 && projToShoot == 1)
@@ -41043,6 +_,9 @@
 			speed *= 1.1f;
 		}
 
+		// Item damage applied below, with ammoDamage.ApplyTo(item.damage)
+		// Damage class boosts come from the ammo damage class
+		/*
 		if (item.ranged) {
 			if (item.damage > 0)
 				Damage += (int)((float)item.damage * rangedDamage);
@@ -41050,6 +_,7 @@
 		else {
 			Damage += item.damage;
 		}
+		*/
 
 		if ((sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && archery) {
 			if (speed < 20f) {
@@ -41058,11 +_,69 @@
 					speed = 20f;
 			}
 
+			//TML: Archery potion damage buff moved into arrowDamage stat modifier
+			/*
 			Damage = (int)((double)Damage * 1.1);
+			*/
 		}
 
 		KnockBack += item.knockBack;
+
+		ItemLoader.PickAmmo(sItem, item, this, ref projToShoot, ref speed, ref ammoDamage, ref KnockBack);
+		totalDamage = (int)(ammoDamage.ApplyTo(item.damage) + 5E-06f);
+
+		if (!dontConsume && !shootWithNoAmmo && item.consumable && !IsAmmoFreeThisShot(sItem, item, projToShoot)) {
+			CombinedHooks.OnConsumeAmmo(this, sItem, item);
+			item.stack--;
+			if (item.stack <= 0) {
+				item.active = false;
+				item.TurnToAir();
+			}
+		}
+	}
+
+	//TML: Method split, 3rd part of original PickAmmo.
+	/// <summary>
+	/// Determines whether or not the given ammunition should be conserved, based on the given weapon as wielded by this player.
+	/// </summary>
+	/// <param name="weapon">The weapon attempting to consume the ammo.</param>
+	/// <param name="ammo">The ammo attempting to be conserved (i.e. not consumed).</param>
+	/// <param name="projToShoot">The projectile that should be shot by the given weapon/ammo combination.</param>
+	/// <returns>True if the ammo should be conserved on the given shot; false otherwise.</returns>
+	public bool IsAmmoFreeThisShot(Item weapon, Item ammo, int projToShoot)
+	{
+		Item sItem = weapon;
+		Item item = ammo;
+
+		// TODO:
+		// The current approach to ammo consumption hooks demands that vanilla conservation chances still be allowed to factor in.
+		// While this is fine for some, for others, it may be preferable to be able to guarantee ammo consumption if it should happen.
+		// For this, two approaches exist. each has their ups and downs:
+		// 1 - CanConsumeAmmo to nullable, return given value if it exists
+		// 2 - separate hook for forced ammo consumption. returns false by default, return true to bypass all vanilla conservation chances
+		//
+		// Post-May-freeze, will decide on one and make changes accordingly.
+		// - Thomas
+
+		if (!CombinedHooks.CanConsumeAmmo(this, sItem, item))
+			return true;
+
+		if (sItem.consumeAmmoOnFirstShotOnly && !ItemAnimationJustStarted)
+			return true;
+
+		if (sItem.consumeAmmoOnLastShotOnly) {
+			int useTime = CombinedHooks.TotalUseTime(sItem.useTime, this, sItem);
+			bool isLastShot = itemAnimation <= useTime || // not enough time to shoot again
+				sItem.useLimitPerAnimation != null && ItemUsesThisAnimation == sItem.useLimitPerAnimation - 1; // this shot hits the limit
+
+			if (!isLastShot)
+				return true;
+		}
+
+		/*
 		bool flag2 = dontConsume;
+		*/
+		bool flag2 = false;
 		if (sItem.type == 3475 && Main.rand.Next(3) != 0)
 			flag2 = true;
 
@@ -41075,7 +_,10 @@
 		if (sItem.type == 5134 && Main.rand.Next(3) == 0)
 			flag2 = true;
 
+		/*
 		if (magicQuiver && (sItem.useAmmo == AmmoID.Arrow || sItem.useAmmo == AmmoID.Stake) && Main.rand.Next(5) == 0)
+		*/
+		if (magicQuiver && AmmoID.Sets.IsArrow[sItem.useAmmo] && Main.rand.Next(5) == 0)
 			flag2 = true;
 
 		if (ammoBox && Main.rand.Next(5) == 0)
@@ -41102,11 +_,15 @@
 		if (sItem.type == 1553 && Main.rand.Next(3) != 0)
 			flag2 = true;
 
+
+		//TML: Clockwork Assault Rifle + Eventide. Handled by consumeAmmoOnLastShotOnly.
+		/*
 		if (sItem.type == 434 && !ItemAnimationJustStarted)
 			flag2 = true;
 
 		if (sItem.type == 4953 && itemAnimation > sItem.useAnimation - 8)
 			flag2 = true;
+		*/
 
 		if (huntressAmmoCost90 && Main.rand.Next(10) == 0)
 			flag2 = true;
@@ -41120,9 +_,20 @@
 		if (ammoCost75 && Main.rand.Next(4) == 0)
 			flag2 = true;
 
+		// Copied as-is from 1.3
+		if (item.CountsAsClass(DamageClass.Throwing)) {
+			if (ThrownCost50 && Main.rand.Next(100) < 50)
+				flag2 = true;
+
+			if (ThrownCost33 && Main.rand.Next(100) < 33)
+				flag2 = true;
+		}
+
 		if (Main.remixWorld && sItem.type == 1319 && Main.rand.Next(2) == 0)
 			flag2 = true;
 
+		//TML: Flamethrower + Elf Melter (handled by consumeAmmoOnFirstShotOnly) + Clentaminator (handled by consumeAmmoOnFirstShotOnly)
+		/*
 		if (projToShoot == 85 && itemAnimation < itemAnimationMax - sItem.useTime)
 			flag2 = true;
 
@@ -41136,6 +_,9 @@
 				item.TurnToAir();
 			}
 		}
+		*/
+
+		return flag2;
 	}
 
 	public void GetOtherPlayersPickTile(int x, int y, int pickDamage)
@@ -41173,7 +_,7 @@
 					NetMessage.SendData(17, -1, -1, null, 0, x, y, 1f);
 				}
 
-				if (Main.tile[x, y].type == 21)
+				if (Main.tile[x, y].type == 21 || Main.tile[x, y].type < TileID.Count && TileID.Sets.BasicChest[Main.tile[x, y].type])
 					NetMessage.SendData(34, -1, -1, null, 1, x, y);
 
 				if (Main.tile[x, y].type == 467)
@@ -41181,6 +_,14 @@
 
 				if (Main.tile[x, y].type == 88)
 					NetMessage.SendData(34, -1, -1, null, 3, x, y);
+
+				if (Main.tile[x, y].type >= TileID.Count) {
+					if (TileID.Sets.BasicChest[Main.tile[x, y].type])
+						NetMessage.SendData(34, -1, -1, null, 101, x, y, 0f, 0, Main.tile[x, y].type, 0);
+
+					if (TileID.Sets.BasicDresser[Main.tile[x, y].type])
+						NetMessage.SendData(34, -1, -1, null, 103, x, y, 0f, 0, Main.tile[x, y].type, 0);
+				}
 			}
 			else {
 				bool flag = Main.tile[x, y].active();
@@ -41260,7 +_,14 @@
 		if (Main.tileNoFail[tileTarget.type])
 			num = 100;
 
+		if (TileLoader.GetTile(tileTarget.type) is ModTile modTile) {
+			num += (int)(pickPower / modTile.MineResist);
+			goto skipVanillaPickPower;
+		}
+
 		num = ((!Main.tileDungeon[tileTarget.type] && tileTarget.type != 25 && tileTarget.type != 58 && tileTarget.type != 117 && tileTarget.type != 203) ? ((tileTarget.type == 85) ? ((!Main.getGoodWorld) ? (num + pickPower / 3) : (num + pickPower / 4)) : ((tileTarget.type != 48 && tileTarget.type != 232) ? ((tileTarget.type == 226) ? (num + pickPower / 4) : ((tileTarget.type != 107 && tileTarget.type != 221) ? ((tileTarget.type != 108 && tileTarget.type != 222) ? ((tileTarget.type == 111 || tileTarget.type == 223) ? (num + pickPower / 4) : ((tileTarget.type != 211) ? (num + pickPower) : (num + pickPower / 5))) : (num + pickPower / 3)) : (num + pickPower / 2))) : (num + pickPower * 2))) : (num + pickPower / 2));
+		skipVanillaPickPower:
+
 		if (tileTarget.type == 211 && pickPower < 200)
 			num = 0;
 
@@ -41315,6 +_,9 @@
 		else if (tileTarget.type == 223 && pickPower < 150) {
 			num = 0;
 		}
+		else {
+			TileLoader.PickPowerCheck(tileTarget, pickPower, ref num);
+		}
 
 		if (tileTarget.type == 147 || tileTarget.type == 0 || tileTarget.type == 40 || tileTarget.type == 53 || tileTarget.type == 57 || tileTarget.type == 59 || tileTarget.type == 123 || tileTarget.type == 224 || tileTarget.type == 397)
 			num += pickPower;
@@ -41631,15 +_,43 @@
 	public void DropItems()
 	{
 		IEntitySource itemSource_Death = GetItemSource_Death();
+
+		var startInventory = PlayerLoader.GetStartingItems(this, DropItems_GetDefaults().Where(item => !item.IsAir), true);
+		var startCounts = new Dictionary<int, int>();
+
+		foreach (Item item in startInventory) {
+			if (!startCounts.ContainsKey(item.netID))
+				startCounts[item.netID] = 0;
+
+			startCounts[item.netID] += item.stack;
+		}
+
+		startCounts[ModContent.ItemType<ModLoader.Default.StartBag>()] = 1;
+
+		//TML: Drop code for modded accessory Slots, should run prior to dropping other items in case conditions are used based on player's current equips
+		AccessorySlotLoader.ModSlotPlayer(this).DropItems(itemSource_Death);
+
 		for (int i = 0; i < 59; i++) {
 			if (inventory[i].stack > 0) {
 				bool flag = true;
 				int type = inventory[i].type;
+
+				/*
 				if ((uint)(type - 3506) <= 1u || type == 3509)
 					flag = false;
 
 				if (flag)
 					TryDroppingSingleItem(itemSource_Death, inventory[i]);
+				*/
+				Item itemToDrop = inventory[i];
+				if (startCounts.TryGetValue(type, out int startCount)) {
+					int n = Math.Min(itemToDrop.stack, startCount);
+					itemToDrop.stack -= n;
+					startCounts[type] -= n;
+				}
+
+				if (itemToDrop.stack > 0)
+					TryDroppingSingleItem(itemSource_Death, itemToDrop);
 			}
 
 			inventory[i].TurnToAir();
@@ -41661,23 +_,48 @@
 			loadouts[type].TryDroppingItems(this, itemSource_Death);
 		}
 
+		DropItems_End(startInventory);
+	}
+
+	//TML: Method split.
+	private IEnumerable<Item> DropItems_GetDefaults()
+	{
+		var inventory = new Item[this.inventory.Length];
+
+		for (int i = 0; i < inventory.Length; i++) {
+			inventory[i] = new Item();
+		}
+
 		inventory[0].SetDefaults(3507);
 		inventory[0].Prefix(-1);
 		inventory[1].SetDefaults(3509);
 		inventory[1].Prefix(-1);
 		inventory[2].SetDefaults(3506);
 		inventory[2].Prefix(-1);
+
+		return inventory;
+	}
+
+	//TML: Method split.
+	private void DropItems_End(IList<Item> startInventory)
+	{
+		PlayerLoader.SetStartInventory(this, startInventory);
 		Main.mouseItem.TurnToAir();
 	}
 
 	public void TryDroppingSingleItem(IEntitySource source, Item theItem)
 	{
 		if (theItem.stack > 0) {
+			/*
 			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem.type);
+			*/
+			int num = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, theItem);
 			Item obj = Main.item[num];
+			/*
 			obj.netDefaults(theItem.netID);
 			obj.Prefix(theItem.prefix);
 			obj.stack = theItem.stack;
+			*/
 			obj.velocity.Y = (float)Main.rand.Next(-20, 1) * 0.2f;
 			obj.velocity.X = (float)Main.rand.Next(-20, 21) * 0.2f;
 			obj.noGrabDelay = 100;
@@ -41733,9 +_,13 @@
 		}
 	}
 
+	private Player _clientClone;
 	public Player clientClone()
 	{
-		Player player = new Player();
+		// Disable cloning until the end of the method.
+		using var _disableItemCLone = new Item.DisableCloneMethod("Item.Clone is bad for performance, and should not be called during Player.clientClone or ModPlayer.CopyClientStateTo. Use Item.CopyNetStateTo instead");
+
+		Player player = _clientClone ??= new Player();
 		player.zone1 = zone1;
 		player.zone2 = zone2;
 		player.zone3 = zone3;
@@ -41743,6 +_,9 @@
 		player.zone5 = zone5;
 		player.voidVaultInfo = voidVaultInfo;
 		player.luck = luck;
+
+		BiomeLoader.CopyCustomBiomesTo(this, player);
+
 		player.extraAccessory = extraAccessory;
 		player.MinionRestTargetPoint = MinionRestTargetPoint;
 		player.MinionAttackTargetNPC = MinionAttackTargetNPC;
@@ -41771,34 +_,34 @@
 		player.hideMisc = hideMisc;
 		player.shieldRaised = shieldRaised;
 		for (int i = 0; i < 59; i++) {
-			player.inventory[i] = inventory[i].Clone();
+			inventory[i].CopyNetStateTo(player.inventory[i]);
 			if (i < armor.Length)
-				player.armor[i] = armor[i].Clone();
+				armor[i].CopyNetStateTo(player.armor[i]);
 
 			if (i < dye.Length)
-				player.dye[i] = dye[i].Clone();
+				dye[i].CopyNetStateTo(player.dye[i]);
 
 			if (i < miscEquips.Length)
-				player.miscEquips[i] = miscEquips[i].Clone();
+				miscEquips[i].CopyNetStateTo(player.miscEquips[i]);
 
 			if (i < miscDyes.Length)
-				player.miscDyes[i] = miscDyes[i].Clone();
+				miscDyes[i].CopyNetStateTo(player.miscDyes[i]);
 
 			if (i < bank.item.Length)
-				player.bank.item[i] = bank.item[i].Clone();
+				bank.item[i].CopyNetStateTo(player.bank.item[i]);
 
 			if (i < bank2.item.Length)
-				player.bank2.item[i] = bank2.item[i].Clone();
+				bank2.item[i].CopyNetStateTo(player.bank2.item[i]);
 
 			if (i < bank3.item.Length)
-				player.bank3.item[i] = bank3.item[i].Clone();
+				bank3.item[i].CopyNetStateTo(player.bank3.item[i]);
 
 			if (i < bank4.item.Length)
-				player.bank4.item[i] = bank4.item[i].Clone();
+				bank4.item[i].CopyNetStateTo(player.bank4.item[i]);
 		}
 
 		CloneLoadouts(player);
-		player.trashItem = trashItem.Clone();
+		trashItem.CopyNetStateTo(player.trashItem);
 		for (int j = 0; j < maxBuffs; j++) {
 			player.buffType[j] = buffType[j];
 			player.buffTime[j] = buffTime[j];
@@ -41806,6 +_,9 @@
 
 		DpadRadial.CopyTo(player.DpadRadial);
 		CircularRadial.CopyTo(player.CircularRadial);
+
+		PlayerLoader.CopyClientState(this, player);
+
 		return player;
 	}
 
@@ -41814,26 +_,26 @@
 		Item[] array = armor;
 		Item[] array2 = clonePlayer.armor;
 		for (int i = 0; i < array.Length; i++) {
-			array2[i] = array[i].Clone();
+			array[i].CopyNetStateTo(array2[i]);
 		}
 
 		array = dye;
 		array2 = clonePlayer.dye;
 		for (int j = 0; j < array.Length; j++) {
-			array2[j] = array[j].Clone();
+			array[j].CopyNetStateTo(array2[j]);
 		}
 
 		for (int k = 0; k < Loadouts.Length; k++) {
 			array = Loadouts[k].Armor;
 			array2 = clonePlayer.Loadouts[k].Armor;
 			for (int l = 0; l < array.Length; l++) {
-				array2[l] = array[l].Clone();
+				array[l].CopyNetStateTo(array2[l]);
 			}
 
 			array = Loadouts[k].Dye;
 			array2 = clonePlayer.Loadouts[k].Dye;
 			for (int m = 0; m < array.Length; m++) {
-				array2[m] = array[m].Clone();
+				array[m].CopyNetStateTo(array2[m]);
 			}
 		}
 	}
@@ -41855,7 +_,10 @@
 		if (Main.tile[x, y - 1] == null)
 			return false;
 
+		/*
 		if (!Main.tile[x, y - 1].active() || Main.tile[x, y - 1].type != 79)
+		*/
+		if (!Main.tile[x, y - 1].active() || !TileID.Sets.IsValidSpawnPoint[Main.tile[x, y - 1].type])
 			return false;
 
 		for (int i = x - 1; i <= x + 1; i++) {
@@ -41963,7 +_,13 @@
 			}
 		}
 		catch (Exception exception) {
+			// IO Exception
 			FancyErrorPrinter.ShowFileSavingFailError(exception, playerFile.Path);
+
+			if (!Main.gameMenu)
+				WorldGen.SaveAndQuit();
+
+			Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.PlayerSaveFail")}\n\n{exception}", Main.menuMode);
 			throw;
 		}
 	}
@@ -41979,11 +_,33 @@
 		if (string.IsNullOrEmpty(path))
 			return;
 
+		// TML: Split method into several methods to facilitate separation between saving to disk and generating save data.
+		// TML: Delay vanilla saving until modded data is serialized (in case of exceptions)
+		// Moved to SavePlayerFile_Write
+		/*
 		if (FileUtilities.Exists(path, isCloudSave))
 			FileUtilities.Copy(path, path + ".bak", isCloudSave);
+		*/
+
+		PlayerLoader.PreSavePlayer(player);
+		byte[] plrData = SavePlayerFile_Vanilla(playerFile);
+		PlayerLoader.PostSavePlayer(player);
+
+		player.ModSaveErrors.Clear(); // Here instead of inside PlayerIO.SaveData because SerializedClone would clear.
+		TagCompound tplrData = PlayerIO.SaveData(player);
+
+		SavePlayerFile_Write(playerFile, plrData, tplrData);
+	}
+
+	public static byte[] SavePlayerFile_Vanilla(PlayerFileData playerFile)
+	{
+		var player = playerFile.Player;
 
 		RijndaelManaged rijndaelManaged = new RijndaelManaged();
+		/*
 		using Stream stream = (isCloudSave ? ((Stream)new MemoryStream(2000)) : ((Stream)new FileStream(path, FileMode.Create)));
+		*/
+		using Stream stream = new MemoryStream(2000);
 		using CryptoStream cryptoStream = new CryptoStream(stream, rijndaelManaged.CreateEncryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Write);
 		using BinaryWriter binaryWriter = new BinaryWriter(cryptoStream);
 		binaryWriter.Write(279);
@@ -41992,8 +_,30 @@
 		binaryWriter.Flush();
 		cryptoStream.FlushFinalBlock();
 		stream.Flush();
+
+		// TML: Delay vanilla saving until modded data is serialized (in case of exceptions)
+		// Replaced with FileUtilities.WriteAllBytes in SavePlayerFile_Write
+		/*
 		if (isCloudSave && SocialAPI.Cloud != null)
 			SocialAPI.Cloud.Write(playerFile.Path, ((MemoryStream)stream).ToArray());
+		*/
+
+		return ((MemoryStream)stream).ToArray();
+	}
+
+	private static void SavePlayerFile_Write(PlayerFileData playerFile, byte[] plrData, TagCompound tplrData)
+	{
+		string path = playerFile.Path;
+		bool isCloudSave = playerFile.IsCloudSave;
+		if (string.IsNullOrEmpty(path))
+			return;
+
+		BackupIO.Player.ArchivePlayer(path, isCloudSave);
+		if (FileUtilities.Exists(path, isCloudSave))
+			FileUtilities.Copy(path, path + ".bak", isCloudSave);
+
+		FileUtilities.WriteAllBytes(path, plrData, isCloudSave);
+		PlayerIO.Save(tplrData, path, isCloudSave);
 	}
 
 	private static void Serialize(PlayerFileData playerFile, Player newPlayer, BinaryWriter fileIO)
@@ -42001,8 +_,8 @@
 		fileIO.Write(newPlayer.name);
 		fileIO.Write(newPlayer.difficulty);
 		fileIO.Write(playerFile.GetPlayTime().Ticks);
-		fileIO.Write(newPlayer.hair);
-		fileIO.Write(newPlayer.hairDye);
+		PlayerIO.WriteVanillaHair(newPlayer.hair, fileIO);
+		PlayerIO.WriteByteVanillaHairDye(newPlayer.hairDye, fileIO);
 		BitsByte bitsByte = (byte)0;
 		for (int i = 0; i < 8; i++) {
 			bitsByte[i] = newPlayer.hideVisibleAccessory[i];
@@ -42018,9 +_,13 @@
 		fileIO.Write(newPlayer.hideMisc);
 		fileIO.Write((byte)newPlayer.skinVariant);
 		fileIO.Write(newPlayer.statLife);
-		fileIO.Write(newPlayer.statLifeMax);
+
+		// Keep the player state valid with vanilla (#HealthManaAPI)
+		// Any modifications to statLifeMax/statManaMax by mods can just be done during runtime
+		fileIO.Write(100 + newPlayer.ConsumedLifeCrystals * 20 + newPlayer.ConsumedLifeFruit * 5); // newPlayer.statLifeMax
 		fileIO.Write(newPlayer.statMana);
-		fileIO.Write(newPlayer.statManaMax);
+		fileIO.Write(20 + newPlayer.ConsumedManaCrystals * 20); // newPlayer.statManaMax
+
 		fileIO.Write(newPlayer.extraAccessory);
 		fileIO.Write(newPlayer.unlockedBiomeTorches);
 		fileIO.Write(newPlayer.UsingBiomeTorches);
@@ -42057,57 +_,58 @@
 		fileIO.Write(newPlayer.shoeColor.G);
 		fileIO.Write(newPlayer.shoeColor.B);
 		for (int k = 0; k < newPlayer.armor.Length; k++) {
-			fileIO.Write(newPlayer.armor[k].netID);
-			fileIO.Write(newPlayer.armor[k].prefix);
+			ItemIO.WriteVanillaID(newPlayer.armor[k], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.armor[k], fileIO);
 		}
 
 		for (int l = 0; l < newPlayer.dye.Length; l++) {
-			fileIO.Write(newPlayer.dye[l].netID);
-			fileIO.Write(newPlayer.dye[l].prefix);
+			ItemIO.WriteVanillaID(newPlayer.dye[l], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.dye[l], fileIO);
 		}
 
 		for (int m = 0; m < 58; m++) {
-			fileIO.Write(newPlayer.inventory[m].netID);
+			ItemIO.WriteVanillaID(newPlayer.inventory[m], fileIO);
 			fileIO.Write(newPlayer.inventory[m].stack);
-			fileIO.Write(newPlayer.inventory[m].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.inventory[m], fileIO);
 			fileIO.Write(newPlayer.inventory[m].favorited);
 		}
 
 		for (int n = 0; n < newPlayer.miscEquips.Length; n++) {
-			fileIO.Write(newPlayer.miscEquips[n].netID);
-			fileIO.Write(newPlayer.miscEquips[n].prefix);
-			fileIO.Write(newPlayer.miscDyes[n].netID);
-			fileIO.Write(newPlayer.miscDyes[n].prefix);
+			ItemIO.WriteVanillaID(newPlayer.miscEquips[n], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.miscEquips[n], fileIO);
+			ItemIO.WriteVanillaID(newPlayer.miscDyes[n], fileIO);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.miscDyes[n], fileIO);
 		}
 
 		for (int num = 0; num < 40; num++) {
-			fileIO.Write(newPlayer.bank.item[num].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank.item[num], fileIO);
 			fileIO.Write(newPlayer.bank.item[num].stack);
-			fileIO.Write(newPlayer.bank.item[num].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank.item[num], fileIO);
 		}
 
 		for (int num2 = 0; num2 < 40; num2++) {
-			fileIO.Write(newPlayer.bank2.item[num2].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank2.item[num2], fileIO);
 			fileIO.Write(newPlayer.bank2.item[num2].stack);
-			fileIO.Write(newPlayer.bank2.item[num2].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank2.item[num2], fileIO);
 		}
 
 		for (int num3 = 0; num3 < 40; num3++) {
-			fileIO.Write(newPlayer.bank3.item[num3].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank3.item[num3], fileIO);
 			fileIO.Write(newPlayer.bank3.item[num3].stack);
-			fileIO.Write(newPlayer.bank3.item[num3].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank3.item[num3], fileIO);
 		}
 
 		for (int num4 = 0; num4 < 40; num4++) {
-			fileIO.Write(newPlayer.bank4.item[num4].netID);
+			ItemIO.WriteVanillaID(newPlayer.bank4.item[num4], fileIO);
 			fileIO.Write(newPlayer.bank4.item[num4].stack);
-			fileIO.Write(newPlayer.bank4.item[num4].prefix);
+			ItemIO.WriteByteVanillaPrefix(newPlayer.bank4.item[num4], fileIO);
 			fileIO.Write(newPlayer.bank4.item[num4].favorited);
 		}
 
 		fileIO.Write(newPlayer.voidVaultInfo);
-		for (int num5 = 0; num5 < maxBuffs; num5++) {
-			if (Main.buffNoSave[newPlayer.buffType[num5]]) {
+		for (int num5 = 0; num5 < 44; num5++) {
+			//TML: Don't save buffs to vanilla player
+			if (true || Main.buffNoSave[newPlayer.buffType[num5]]) {
 				fileIO.Write(0);
 				fileIO.Write(0);
 			}
@@ -42130,7 +_,7 @@
 		}
 
 		fileIO.Write(newPlayer.hbLocked);
-		for (int num7 = 0; num7 < newPlayer.hideInfo.Length; num7++) {
+		for (int num7 = 0; num7 < InfoDisplayLoader.DefaultDisplayCount; num7++) {
 			fileIO.Write(newPlayer.hideInfo[num7]);
 		}
 
@@ -42139,7 +_,7 @@
 			fileIO.Write(newPlayer.DpadRadial.Bindings[num8]);
 		}
 
-		for (int num9 = 0; num9 < newPlayer.builderAccStatus.Length; num9++) {
+		for (int num9 = 0; num9 < BuilderToggleLoader.DefaultDisplayCount; num9++) {
 			fileIO.Write(newPlayer.builderAccStatus[num9]);
 		}
 
@@ -42270,12 +_,28 @@
 		if (Main.rand == null)
 			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 
+		var plrData = FileUtilities.ReadAllBytes(playerPath, cloudSave);
+		var tplrData = PlayerIO.ReadDataBytes(playerPath, cloudSave);
+		return LoadPlayerFromStream(playerFileData, plrData, tplrData);
+	}
+
+	public static PlayerFileData LoadPlayerFromStream(PlayerFileData playerFileData, byte[] plrData, byte[] tplrData)
+	{
+		string playerPath = playerFileData.Path;
+
 		Player player = new Player();
 		bool gotToReadName = false;
+
+		// Override Main.CurrentPlayer until the end of this method.
+		using var _currentPlr = new Main.CurrentPlayerOverride(player);
+
 		try {
 			RijndaelManaged rijndaelManaged = new RijndaelManaged();
 			rijndaelManaged.Padding = PaddingMode.None;
+			/*
 			using (MemoryStream stream = new MemoryStream(FileUtilities.ReadAllBytes(playerPath, cloudSave))) {
+			*/
+			using (MemoryStream stream = new MemoryStream(plrData)) {
 				using CryptoStream input = new CryptoStream(stream, rijndaelManaged.CreateDecryptor(ENCRYPTION_KEY, ENCRYPTION_KEY), CryptoStreamMode.Read);
 				using BinaryReader binaryReader = new BinaryReader(input);
 				int num = binaryReader.ReadInt32();
@@ -42291,7 +_,7 @@
 					return playerFileData;
 				}
 
-				Deserialize(playerFileData, player, binaryReader, num, out gotToReadName);
+				Deserialize(playerFileData, player, binaryReader, tplrData, num, out gotToReadName); // Added tplrData argument
 			}
 
 			player.PlayerFrame();
@@ -42299,6 +_,9 @@
 			playerFileData.Player = player;
 			return playerFileData;
 		}
+		catch (CustomModDataException e) {
+			playerFileData.customDataFail = e;
+		}
 		catch {
 		}
 
@@ -42322,8 +_,33 @@
 		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
 		Serialize(_visualCloneDummyData, this, _visualCloneWriter);
 		_visualCloneStream.Seek(0L, SeekOrigin.Begin);
-		Deserialize(_visualCloneDummyData, player, _visualCloneReader, 279, out var _);
+		try {
+			Deserialize(_visualCloneDummyData, player, _visualCloneReader, PlayerIO.SaveData(this), Main.curRelease, out var _); // Added PlayerIO.SaveData argument
+		}
+		catch (CustomModDataException) {
+			// Same exception should already be caught in LoadPlayerFromStream
+		}
 		return player;
+	}
+
+	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, TagCompound tplrData, int release, out bool gotToReadName)
+	{
+		Deserialize(data, newPlayer, fileIO, release, out gotToReadName);
+
+		if (tplrData != null)
+			PlayerIO.Load(newPlayer, tplrData);
+
+		LoadPlayer_LastMinuteFixes(newPlayer);
+	}
+
+	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, byte[] tplrData, int release, out bool gotToReadName)
+	{
+		Deserialize(data, newPlayer, fileIO, release, out gotToReadName);
+
+		if (tplrData != null)
+			PlayerIO.Load(newPlayer, TagIO.FromStream(tplrData.ToMemoryStream()));
+
+		LoadPlayer_LastMinuteFixes(newPlayer);
 	}
 
 	private static void Deserialize(PlayerFileData data, Player newPlayer, BinaryReader fileIO, int release, out bool gotToReadName)
@@ -42394,8 +_,16 @@
 		if (newPlayer.statManaMax > 200)
 			newPlayer.statManaMax = 200;
 
+		// Allow mana stat to exceed vanilla bounds (#HealthManaAPI)
+		/*
 		if (newPlayer.statMana > 400)
 			newPlayer.statMana = 400;
+		*/
+
+		// Clamping of the values happens automatically
+		newPlayer.ConsumedLifeCrystals = (newPlayer.statLifeMax - 100) / 20;
+		newPlayer.ConsumedLifeFruit = (newPlayer.statLifeMax - 400) / 5;
+		newPlayer.ConsumedManaCrystals = (newPlayer.statManaMax - 20) / 20;
 
 		if (release >= 125)
 			newPlayer.extraAccessory = fileIO.ReadBoolean();
@@ -42795,7 +_,10 @@
 			}
 		}
 
+		// Moved to the tplr variants of Deserialize, after modded data is read
+		/*
 		LoadPlayer_LastMinuteFixes(newPlayer);
+		*/
 	}
 
 	private static void AdjustRespawnTimerForWorldJoining(Player newPlayer)
@@ -42834,7 +_,7 @@
 	{
 		for (int i = 3; i < 10; i++) {
 			Item item = armorArray[i];
-			if (item.IsAir)
+			if (item.IsAir || item._globals.Length > 0)
 				continue;
 
 			for (int j = i + 1; j < 10; j++) {
@@ -42856,7 +_,29 @@
 	private static void LoadPlayer_LastMinuteFixes(Player newPlayer)
 	{
 		newPlayer.skinVariant = (int)MathHelper.Clamp(newPlayer.skinVariant, 0f, PlayerVariantID.Count - 1);
+
 		for (int i = 3; i < 10; i++) {
+			LoadPlayer_LastMinuteFixes(newPlayer, newPlayer.armor[i]);
+		}
+
+		var modSlotPlayer = AccessorySlotLoader.ModSlotPlayer(newPlayer);
+		for (int i = 0; i < modSlotPlayer.SlotCount; i++) {
+			LoadPlayer_LastMinuteFixes(newPlayer, modSlotPlayer.exAccessorySlot[i]);
+		}
+
+		LoadPlayer_Finish(newPlayer);
+	}
+
+	//TML: Method split to take an individual item param
+	private static void LoadPlayer_LastMinuteFixes(Player newPlayer, Item item)
+	{
+		// Fake variables
+		var armor = newPlayer.armor;
+		newPlayer.armor = new[] {item};
+		int i = 0;
+
+		// Originally the for loop in the previous method
+		{
 			int type = newPlayer.armor[i].type;
 			if (type == 908 || type == 5000)
 				newPlayer.lavaMax += 420;
@@ -42864,8 +_,10 @@
 			if (type == 906 || type == 4038 || type == 3999 || type == 4003)
 				newPlayer.lavaMax += 420;
 
-			if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0)
+			if (newPlayer.wingsLogic == 0 && newPlayer.armor[i].wingSlot >= 0) {
 				newPlayer.wingsLogic = newPlayer.armor[i].wingSlot;
+				newPlayer.equippedWings = newPlayer.armor[i];
+			}
 
 			if (type == 158 || type == 396 || type == 1250 || type == 1251 || type == 1252)
 				newPlayer.noFallDmg = true;
@@ -42876,7 +_,16 @@
 			newPlayer.lavaTime = newPlayer.lavaMax;
 		}
 
+		// restore armor variable
+		newPlayer.armor = armor;
+	}
+
+	private static void LoadPlayer_Finish(Player newPlayer)
+	{
 		newPlayer.FixLoadedData();
+
+		// Added by TML, makes sure player is ready to go!
+		newPlayer.ResetEffects();
 	}
 
 	public static PlayerFileData GetFileData(string file, bool cloudSave)
@@ -42887,12 +_,17 @@
 		PlayerFileData playerFileData = LoadPlayer(file, cloudSave);
 		if (playerFileData.Player != null) {
 			if (playerFileData.Player.loadStatus != 0 && playerFileData.Player.loadStatus != 1) {
+				CustomModDataException customDataFail = playerFileData.customDataFail;
-				if (FileUtilities.Exists(file + ".bak", cloudSave))
+				if (FileUtilities.Exists(file + ".bak", cloudSave)) {
 					FileUtilities.Move(file + ".bak", file, cloudSave);
+					PlayerIO.LoadBackup(file, cloudSave);
+				}
 
 				playerFileData = LoadPlayer(file, cloudSave);
 				if (playerFileData.Player == null)
 					return null;
+
+				playerFileData.customDataFail = customDataFail;
 			}
 
 			return playerFileData;
@@ -42907,6 +_,13 @@
 		return GameShaders.Hair.GetColor(hairDye, this, useLighting ? color : Color.White);
 	}
 
+	/// <summary>
+	/// Checks if the player has the specified item in their <see cref="inventory"/>. <br/>
+	/// Does not check Void Bag. <br/>
+	/// Use <see cref="Player.CountItem(int, int)"/> instead to count the total amount if needed. <br/>
+	/// </summary>
+	/// <param name="type">The item type to count</param>
+	/// <returns>True if the player has the item</returns>
 	public bool HasItem(int type)
 	{
 		for (int i = 0; i < 58; i++) {
@@ -42917,6 +_,9 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Similar to <see cref="HasItem(int)"/>, but checks the provided Item[] <paramref name="collection"/> for items instead. Useful for checking other Item arrays, such as <see cref="Player.armor"/> or <see cref="Player.bank"/>.
+	/// </summary>
 	public bool HasItem(int type, Item[] collection)
 	{
 		for (int i = 0; i < collection.Length; i++) {
@@ -42927,6 +_,9 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Similar to <see cref="HasItem(int)"/>, but also checks the Void Bag.
+	/// </summary>
 	public bool HasItemInInventoryOrOpenVoidBag(int type)
 	{
 		if (!HasItem(type)) {
@@ -43028,6 +_,17 @@
 
 	public Player()
 	{
+		ResetDamageClassData();
+
+		buffType = new int[maxBuffs];
+		buffTime = new int[maxBuffs];
+		buffImmune = new bool[BuffLoader.BuffCount]; // TODO: Move all these patches to field initializers.
+		ownedProjectileCounts = new int[ProjectileLoader.ProjectileCount];
+		npcTypeNoAggro = new bool[NPCLoader.NPCCount];
+
+		PlayerLoader.SetupPlayer(this);
+		LoaderManager.Get<BiomeLoader>().SetupPlayer(this);
+
 		width = 20;
 		height = 42;
 		name = string.Empty;
@@ -43075,7 +_,10 @@
 		usedGalaxyPearl = false;
 		usedGummyWorm = false;
 		usedAmbrosia = false;
+
+		PlayerLoader.ModifyMaxStats(this);
+
-		for (int n = 0; n < TileID.Count; n++) {
+		for (int n = 0; n < adjTile.Length; n++) {
 			adjTile[n] = false;
 			oldAdjTile[n] = false;
 		}
@@ -43332,11 +_,29 @@
 		int questsDone = anglerQuestsFinished;
 		float anglerRewardRarityMultiplier = GetAnglerRewardRarityMultiplier(questsDone);
 		anglerRewardRarityMultiplier *= (float)(currentShoppingSettings.PriceAdjustment + 1.0) / 2f;
+
+		var rewardItems = new List<Item>();
+
 		GetItemSettings anglerRewardSettings = GetItemSettings.NPCEntityToPlayerInventorySettings;
-		GetAnglerReward_MainReward(source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
+		GetAnglerReward_MainReward(rewardItems, source, questsDone, anglerRewardRarityMultiplier, questItemType, ref anglerRewardSettings);
-		GetAnglerReward_Decoration(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Decoration(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-		GetAnglerReward_Money(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Money(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
-		GetAnglerReward_Bait(source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+		GetAnglerReward_Bait(rewardItems, source, questsDone, anglerRewardRarityMultiplier, ref anglerRewardSettings);
+
+		PlayerLoader.AnglerQuestReward(this, anglerRewardRarityMultiplier, rewardItems);
+
+		foreach (Item rewardItem in rewardItems) {
+			rewardItem.position = Center;
+
+			Item getItem = GetItem(whoAmI, rewardItem, GetItemSettings.NPCEntityToPlayerInventorySettings);
+
+			if (getItem.stack > 0) {
+				int number = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, getItem.type, getItem.stack, noBroadcast: false, 0, noGrabDelay: true);
+
+				if (Main.netMode == 1)
+					NetMessage.SendData(21, -1, -1, null, number, 1f);
+			}
+		}
 	}
 
 	public static float GetAnglerRewardRarityMultiplier(int questsDone)
@@ -43346,7 +_,8 @@
 		return num * 0.9f;
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_MainReward(IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_MainReward(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, int questItemType, ref GetItemSettings anglerRewardSettings)
 	{
 		Item item = new Item();
 		item.type = 0;
@@ -43482,6 +_,8 @@
 			}
 		}
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 		if (item2.stack > 0) {
@@ -43489,11 +_,14 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 
 		if (item.type == 2417) {
 			Item item3 = new Item();
 			Item item4 = new Item();
 			item3.SetDefaults(2418);
+			rewardItems.Add(item3);
+			/*
 			item3.position = base.Center;
 			item2 = GetItem(whoAmI, item3, anglerRewardSettings);
 			if (item2.stack > 0) {
@@ -43501,15 +_,20 @@
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number2, 1f);
 			}
+			*/
 
 			item4.SetDefaults(2419);
+			rewardItems.Add(item4);
+			/*
 			item4.position = base.Center;
 			item2 = GetItem(whoAmI, item4, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number3 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number3, 1f);
 			}
+			*/
 		}
 		else {
 			if (item.type != 2498)
@@ -43518,26 +_,35 @@
 			Item item5 = new Item();
 			Item item6 = new Item();
 			item5.SetDefaults(2499);
+			rewardItems.Add(item5);
+			/*
 			item5.position = base.Center;
 			item2 = GetItem(whoAmI, item5, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number4 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number4, 1f);
 			}
+			*/
 
 			item6.SetDefaults(2500);
+			rewardItems.Add(item6);
+			/*
 			item6.position = base.Center;
 			item2 = GetItem(whoAmI, item6, anglerRewardSettings);
+
 			if (item2.stack > 0) {
 				int number5 = Item.NewItem(source, (int)position.X, (int)position.Y, width, height, item2.type, item2.stack, noBroadcast: false, 0, noGrabDelay: true);
 				if (Main.netMode == 1)
 					NetMessage.SendData(21, -1, -1, null, number5, 1f);
 			}
+			*/
 		}
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Decoration(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Decoration(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		float value = 1f - rarityReduction;
 		int num = 100;
@@ -43609,6 +_,8 @@
 		}
 
 		item.SetDefaults(defaults);
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 		if (item2.stack > 0) {
@@ -43616,9 +_,11 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Bait(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Bait(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		if (Main.rand.Next((int)(100f * rarityReduction)) > 50)
 			return;
@@ -43649,6 +_,8 @@
 		if (Main.rand.Next(250) <= questsDone)
 			item.stack++;
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
 		if (item2.stack > 0) {
@@ -43656,9 +_,11 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
+	//TML: Added 'rewardsItems' parameter.
-	private void GetAnglerReward_Money(IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
+	private void GetAnglerReward_Money(List<Item> rewardItems, IEntitySource source, int questsDone, float rarityReduction, ref GetItemSettings anglerRewardSettings)
 	{
 		Item item = new Item();
 		int num = (questsDone + 50) / 2;
@@ -43692,6 +_,8 @@
 			item.stack = num;
 		}
 
+		rewardItems.Add(item);
+		/*
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, anglerRewardSettings);
 		if (item2.stack > 0) {
@@ -43699,6 +_,7 @@
 			if (Main.netMode == 1)
 				NetMessage.SendData(21, -1, -1, null, number, 1f);
 		}
+		*/
 	}
 
 	public bool DropAnglerAccByMissing(List<int> itemIdsOfAccsWeWant, float totalChance, out bool botheredRollingForADrop, out int itemIdToDrop)
@@ -43845,13 +_,17 @@
 				list.Add(3556);
 			}
 
+			// Extra patch context.
 			if (NPC.downedMoonlord)
 				list.Add(3024);
 		}
 
+		PlayerLoader.GetDyeTraderReward(this, list);
+
 		num = list[Main.rand.Next(list.Count)];
 		Item item = new Item();
 		item.SetDefaults(num);
+		// Extra patch context.
 		item.stack = 6;
 		item.position = base.Center;
 		Item item2 = GetItem(whoAmI, item, GetItemSettings.NPCEntityToPlayerInventorySettings);
@@ -44020,7 +_,10 @@
 			}
 		}
 
+		/*
 		int damage = (int)(20f * (1f + magicDamage + minionDamage - 2f));
+		*/
+		int damage = (int)GetTotalDamage(DamageClass.MagicSummonHybrid).ApplyTo(20f);
 		IEntitySource projectileSource_SetBonus = GetProjectileSource_SetBonus(3);
 		_ = Main.projectile[Projectile.NewProjectile(projectileSource_SetBonus, MinionRestTargetPoint, Vector2.Zero, 656, damage, 0f, Main.myPlayer)];
 	}
