--- src/TerrariaNetCore/Terraria/WorldGen.cs
+++ src/tModLoader/Terraria/WorldGen.cs
@@ -24,6 +_,8 @@
 using Terraria.ObjectData;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
+using Terraria.ModLoader.IO;
 
 namespace Terraria
 {
@@ -695,7 +_,13 @@
 		private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();
 		public static int tileReframeCount;
 		public static bool noMapUpdate;
+		public static StructureMap structures;
+		public static double worldSurface;
 		public static double worldSurfaceLow;
+		public static double worldSurfaceHigh;
+		public static double rockLayer;
+		public static double rockLayerLow;
+		public static double rockLayerHigh;
 		public static int tLeft;
 		public static int tRight;
 		public static int tTop;
@@ -932,6 +_,7 @@
 		public static Queue<Point> ExploitDestroyQueue = new Queue<Point>();
 		public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;
 		private static bool skipFramingDuringGen = false;
+		private static double _timePass = 0.0; // Added by TML; used to account for more precise time rates.
 
 		public static UnifiedRandom genRand {
 			get {
@@ -1225,7 +_,7 @@
 				}
 			}
 
-			for (int j = 0; j < 670; j++) {
+			for (int j = 0; j < NPCLoader.NPCCount; j++) {
 				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
 					continue;
 
@@ -1265,7 +_,7 @@
 			}
 
 			int num2 = -1;
-			for (int j = 0; j < 670; j++) {
+			for (int j = 0; j < Main.townNPCCanSpawn.Length; j++) {
 				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
 					continue;
 
@@ -1291,6 +_,8 @@
 		}
 
 		public static bool CheckSpecialTownNPCSpawningConditions(int type) {
+			if (!NPCLoader.CheckConditions(type))
+				return false;
 			if (type == 160) {
 				if ((double)roomY2 > Main.worldSurface)
 					return false;
@@ -1821,7 +_,7 @@
 			int num = 0;
 			int num2 = 50;
 			Housing_GetTestedRoomBounds(out int startX, out int endX, out int startY, out int endY);
-			int[] tileTypeCounts = new int[625];
+			int[] tileTypeCounts = new int[TileLoader.TileCount];
 			CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
 			int num3 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
 			if (num3 < 50)
@@ -1972,7 +_,7 @@
 			roomY2 = y;
 			numRoomTiles = 0;
 			roomCeilingsCount = 0;
-			for (int i = 0; i < 625; i++) {
+			for (int i = 0; i < houseTile.Length; i++) {
 				houseTile[i] = false;
 			}
 
@@ -2045,6 +_,8 @@
 				houseTile[Main.tile[x, y].type] = true;
 				if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
 					return;
+				if (TileLoader.CloseDoorID(Main.tile[x, y]) >= 0 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126))
+					return;
 			}
 
 			if (x < roomX1)
@@ -2309,15 +_,29 @@
 		public static void setWorldSize() {
 			Main.bottomWorld = Main.maxTilesY * 16;
 			Main.rightWorld = Main.maxTilesX * 16;
+			/*
 			Main.maxSectionsX = Main.maxTilesX / 200;
 			Main.maxSectionsY = Main.maxTilesY / 150;
+			*/
+			Main.maxSectionsX = (Main.maxTilesX - 1) / Main.sectionWidth + 1;
+			Main.maxSectionsY = (Main.maxTilesY - 1) / Main.sectionHeight + 1;
 		}
 
 		public static void worldGenCallback(object threadContext) {
+			try {
+				do_worldGenCallBack(threadContext);
+			}
+			catch (Exception e) {
+				Logging.Terraria.Error(Language.GetTextValue("tModLoader.WorldGenError"), e);
+			}
+		}
+
+		public static void do_worldGenCallBack(object threadContext) {
 			SoundEngine.PlaySound(10);
 			clearWorld();
 			GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
 			WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
+			BackupIO.archiveLock = false;
 			if (Main.menuMode == 10 || Main.menuMode == 888)
 				Main.menuMode = 6;
 
@@ -2340,12 +_,19 @@
 		}
 
 		public static void JustQuit() {
+			/*
 			try {
 				SoundEngine.PlaySound(34, -1, -1, 0);
 				SoundEngine.PlaySound(35, -1, -1, 0);
 			}
 			catch {
 			}
+			*/
+			
+			// Properly stop waterfall/lava(fall) sounds
+			Main.ambientWaterfallStrength = 0f;
+			Main.ambientLavafallStrength = 0f;
+			Main.ambientLavaStrength = 0f;
 
 			Main.invasionProgress = -1;
 			Main.invasionProgressDisplayLeft = 0;
@@ -2354,6 +_,14 @@
 			Main.menuMode = 10;
 			Main.gameMenu = true;
 			SoundEngine.StopTrackedSounds();
+
+			try {
+				// This has been moved here out of WorldGen.SaveAndQuit, so that the "menu close" sound plays AFTER all sounds have stopped
+				SoundEngine.PlaySound(11);
+			}
+			catch {
+			}
+
 			CaptureInterface.ResetFocus();
 			Main.ActivePlayerFileData.StopPlayTimer();
 			Main.fastForwardTime = false;
@@ -2371,12 +_,15 @@
 
 		public static void SaveAndQuitCallBack(object threadContext) {
 			int netMode = Main.netMode;
+
+			/*
 			try {
 				SoundEngine.PlaySound(34, -1, -1, 0);
 				SoundEngine.PlaySound(35, -1, -1, 0);
 			}
 			catch {
 			}
+			*/
 
 			if (netMode == 0)
 				WorldFile.CacheSaveTime();
@@ -2388,6 +_,18 @@
 			Main.menuMode = 10;
 			Main.gameMenu = true;
 			SoundEngine.StopTrackedSounds();
+
+			try {
+				// Delay playing the "menu close" sound until AFTER all sounds have stopped
+				SoundEngine.PlaySound(11);
+			}
+			catch {
+			}
+			
+			// Properly stop waterfall/lavafall sounds
+			Main.ambientWaterfallStrength = 0f;
+			Main.ambientLavafallStrength = 0f;
+			
 			CaptureInterface.ResetFocus();
 			Main.ActivePlayerFileData.StopPlayTimer();
 			Player.SavePlayer(Main.ActivePlayerFileData);
@@ -2402,6 +_,11 @@
 				Main.netMode = 0;
 			}
 
+			//This is only called in case of a manual quit or disconnect.
+			//There is a less common (client) call to this in Netplay.InnerClientLoop.
+			SystemLoader.OnWorldUnload();
+			TileIO.PostExitWorldCleanup();
+
 			Main.fastForwardTime = false;
 			Main.UpdateTimeRate();
 			Main.menuMode = 0;
@@ -2410,7 +_,10 @@
 		}
 
 		public static void SaveAndQuit(Action callback = null) {
+			//TML: Moved to WorldGen.JustQuit(), see the comment there.
+			/*
 			SoundEngine.PlaySound(11);
+			*/
 			ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
 		}
 
@@ -2484,13 +_,20 @@
 					}
 
 					if (!worldBackup) {
-						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
+						string message = Language.GetTextValue("Error.LoadFailedNoBackup");
+						if (WorldIO.customDataFail != null) {
+							message = WorldIO.customDataFail.modName + " " + message;
+							message += "\n" + WorldIO.customDataFail.InnerException;
+						}
+
+						Console.WriteLine(message);
 						return;
 					}
 
 					FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
 					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
 					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
+					WorldIO.LoadDedServBackup(Main.worldPathName, isCloudSave);
 					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 					if (loadFailed || !loadSuccess) {
 						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
@@ -2498,7 +_,14 @@
 							FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
 							FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
 							FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
-							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
+							WorldIO.RevertDedServBackup(Main.worldPathName, isCloudSave);
+							string message = Language.GetTextValue("Error.LoadFailed");
+							if (WorldIO.customDataFail != null) {
+								message = WorldIO.customDataFail.modName + " " + message;
+								message += "\n" + WorldIO.customDataFail.InnerException;
+							}
+
+							Console.WriteLine(message);
 							return;
 						}
 					}
@@ -2525,6 +_,12 @@
 			if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
 				Main.anglerQuestFinished = true;
 
+			// Move rest of method to main thread to fix concurrent modification exceptions
+			Main.OnTickForInternalCodeOnly += FinishPlayWorld;
+		}
+
+		internal static void FinishPlayWorld() {
+			Main.OnTickForInternalCodeOnly -= FinishPlayWorld;
 			Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
 			Main.ActivePlayerFileData.StartPlayTimer();
 			_lastSeed = Main.ActiveWorldFileData.Seed;
@@ -2556,6 +_,7 @@
 		}
 
 		public static void serverLoadWorldCallBack() {
+			Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}, Size={2}x{3}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave, Main.ActiveWorldFileData.WorldSizeX, Main.ActiveWorldFileData.WorldSizeY);
 			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 			if (loadFailed || !loadSuccess) {
@@ -2753,21 +_,26 @@
 			noLiquidCheck = false;
 			Liquid.numLiquid = 0;
 			LiquidBuffer.numLiquidBuffer = 0;
+			/*
 			if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY) {
 				for (int j = 0; j < lastMaxTilesX; j++) {
 					float num = (float)j / (float)lastMaxTilesX;
 					Main.statusText = Lang.gen[46].Value + " " + (int)(num * 100f + 1f) + "%";
 					for (int k = 0; k < lastMaxTilesY; k++) {
-						Main.tile[j, k] = null;
+						Main.tile[j, k] = default;
 					}
 				}
 			}
+			*/
 
 			lastMaxTilesX = Main.maxTilesX;
 			lastMaxTilesY = Main.maxTilesY;
-			if (Main.netMode != 2)
+			if (Main.netMode != 2) {
-				Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
+				// Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
+				Main.sectionManager = new WorldSections((Main.maxTilesX - 1) / Main.sectionWidth + 1, (Main.maxTilesY - 1) / Main.sectionHeight + 1);
+			}
 
+			/*
 			if (Main.netMode != 1) {
 				for (int l = 0; l < Main.maxTilesX; l++) {
 					float num2 = (float)l / (float)Main.maxTilesX;
@@ -2780,6 +_,8 @@
 					}
 				}
 			}
+			*/
+			Main.tile.ClearEverything();
 
 			for (int n = 0; n < Main.countsAsHostForGameplay.Length; n++) {
 				Main.countsAsHostForGameplay[n] = false;
@@ -5616,6 +_,8 @@
 		}
 
 		public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null) {
+			var generationStopwatch = Stopwatch.StartNew();
+
 			drunkWorldGen = false;
 			drunkWorldGenText = false;
 			switch (seed) {
@@ -5665,21 +_,35 @@
 			Main.lockMenuBGChange = true;
 			WorldGenConfiguration configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
 			Hooks.ProcessWorldGenConfig(ref configuration);
+
+			Logging.Terraria.InfoFormat("Generating World: {0}", Main.ActiveWorldFileData.Name);
+
 			_lastSeed = seed;
 			_generator = new WorldGenerator(seed, configuration);
 			_genRand = new UnifiedRandom(seed);
 			Main.rand = new UnifiedRandom(seed);
-			StructureMap structures = new StructureMap();
 			desertHiveHigh = Main.maxTilesY;
 			desertHiveLow = 0;
 			desertHiveLeft = Main.maxTilesX;
 			desertHiveRight = 0;
 			worldSurfaceLow = 0.0;
+
+			structures = new StructureMap();
+
+			/*
 			double worldSurface = 0.0;
 			double worldSurfaceHigh = 0.0;
 			double rockLayerLow = 0.0;
 			double rockLayer = 0.0;
 			double rockLayerHigh = 0.0;
+			*/
+
+			worldSurface = 0.0;
+			worldSurfaceHigh = 0.0;
+			rockLayerLow = 0.0;
+			rockLayer = 0.0;
+			rockLayerHigh = 0.0;
+
 			int copper = 7;
 			int iron = 6;
 			int silver = 9;
@@ -5731,6 +_,9 @@
 			int logX = -1;
 			int logY = -1;
 			int dungeonLocation = 0;
+
+			SystemLoader.PreWorldGen();
+
 			AddGenerationPass("Reset", delegate (GenerationProgress progress, GameConfiguration passConfig) {
 				numOceanCaveTreasure = 0;
 				skipDesertTileCheck = false;
@@ -8402,10 +_,11 @@
 							int num557 = 0;
 							while (!flag36 && num557 < 100) {
 								num557++;
+								// Extra context.
 								int num558 = genRand.Next(num543 - num548, num543 + num548 + 1);
 								int num559 = genRand.Next(num544 - num549, num544 + num549 - 2);
 								PlaceTile(num558, num559, 4, mute: true, forced: false, -1, 3);
-								if (Main.tile[num558, num559].type == 4)
+								if (TileID.Sets.Torch[Main.tile[num558, num559].type])
 									flag36 = true;
 							}
 
@@ -11551,7 +_,7 @@
 							}
 						}
 
-						if (TileID.Sets.BasicChest[Main.tile[num57, num58].type]) {
+						if (TileID.Sets.BasicChest[Main.tile[num57, num58].type] && Main.tile[num57, num58].type < TileID.Count) {
 							int num86 = Main.tile[num57, num58].frameX / 18;
 							int num87 = 0;
 							ushort type2 = 21;
@@ -11744,7 +_,7 @@
 			});
 
 			AddGenerationPass("Micro Biomes", delegate (GenerationProgress progress, GameConfiguration passConfig) {
-				progress.Message = Lang.gen[76].Value;
+				progress.Message = Lang.gen[76].Value + "..Dead Man's Chests";
 				_ = (float)(Main.maxTilesX * Main.maxTilesY) / 5040000f;
 				float num30 = 10f;
 				if (getGoodWorldGen)
@@ -11762,6 +_,7 @@
 					possibleChestsToTrapify.Remove(num32);
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Thin Ice";
 				progress.Set(1f / num30);
 				if (!notTheBees) {
 					ThinIceBiome thinIceBiome = configuration.CreateBiome<ThinIceBiome>();
@@ -11784,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Sword Shrines";
 				progress.Set(0.1f);
 				progress.Set(2f / num30);
 				EnchantedSwordBiome enchantedSwordBiome = configuration.CreateBiome<EnchantedSwordBiome>();
@@ -11806,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Campsites";
 				progress.Set(0.2f);
 				progress.Set(3f / num30);
 				if (!notTheBees) {
@@ -11818,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Explosive Traps";
 				progress.Set(4f / num30);
 				if (!notTheBees) {
 					MiningExplosivesBiome miningExplosivesBiome = configuration.CreateBiome<MiningExplosivesBiome>();
@@ -11832,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Living Trees";
 				progress.Set(0.3f);
 				progress.Set(5f / num30);
 				MahoganyTreeBiome mahoganyTreeBiome = configuration.CreateBiome<MahoganyTreeBiome>();
@@ -11845,9 +_,11 @@
 					num43++;
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Long Minecart Tracks";
 				progress.Set(0.4f);
 				progress.Set(6f / num30);
 				progress.Set(7f / num30);
+				// Extra patch context.
 				TrackGenerator trackGenerator = new TrackGenerator();
 				int random6 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
 				WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
@@ -11868,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Standard Minecart Tracks";
 				progress.Set(8f / num30);
 				random6 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
 				worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
@@ -11887,6 +_,7 @@
 					}
 				}
 
+				progress.Message = Lang.gen[76].Value + "..Lava Traps";
 				progress.Set(9f / num30);
 				if (!notTheBees) {
 					double num48 = (double)Main.maxTilesX * 0.02;
@@ -12248,11 +_,18 @@
 				progress.Message = Lang.gen[87].Value;
 			});
 
+			SystemLoader.ModifyWorldGenTasks(_generator._passes, ref _generator._totalLoadWeight);
 			_generator.GenerateWorld(customProgressObject);
 			ConsumePostGenActions(structures);
+			SystemLoader.PostWorldGen();
 			Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
 			Main.NotifyOfEvent(GameNotificationType.WorldGen);
 			drunkWorldGenText = false;
+			BackupIO.archiveLock = true;
+
+			generationStopwatch.Stop();
+
+			Logging.tML.Info($"Generation of {Main.maxTilesX}x{Main.maxTilesY} {(crimson ? "Crimson" : "Corruption")} world with seed {seed} completed in {generationStopwatch.Elapsed:m'm 's's 'fff'ms'}");
 		}
 
 		private static Point GetAdjustedFloorPosition(int x, int y) {
@@ -12536,7 +_,7 @@
 		}
 
 		private static void PrefixItemFromOptions(Item item, int[] options) {
-			byte prefix = item.prefix;
+			int prefix = item.prefix;
 			if (!item.Prefix(-3))
 				return;
 
@@ -13166,7 +_,7 @@
 			if (!InWorld(i, y))
 				return false;
 
-			while (Main.tile[i, num].type == 20) {
+			while (TileID.Sets.TreeSapling[Main.tile[i, num].type]) {
 				num++;
 				if (Main.tile[i, num] == null)
 					return false;
@@ -13182,7 +_,7 @@
 			if (tile2.wall != 0 || tile2.liquid != 0)
 				return false;
 
-			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
+			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112 && !TileLoader.CanGrowModPalmTree(tile.type))
 				return false;
 
 			if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
@@ -13242,10 +_,10 @@
 
 		public static bool GrowEpicTree(int i, int y) {
 			int j;
-			for (j = y; Main.tile[i, j].type == 20; j++) {
+			for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 			}
 
-			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109)))) {
+			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type))) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type))))) {
 				int num = 2;
 				if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20)) {
 					bool flag = false;
@@ -13472,10 +_,10 @@
 					int num5 = genRand.Next(3);
 					bool flag3 = false;
 					bool flag4 = false;
-					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
+					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
 						flag3 = true;
 
-					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
+					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
 						flag4 = true;
 
 					if (!flag3) {
@@ -15196,7 +_,7 @@
 		public static void TreeGrowFXCheck(int x, int y) {
 			int treeHeight = 1;
 			int passStyle = -1;
-			Tile topTile = null;
+			Tile topTile = default;
 			for (int num = -1; num > -100; num--) {
 				Tile tile = Main.tile[x, y + num];
 				if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
@@ -15408,6 +_,8 @@
 						break;
 					}
 			}
+
+			PlantLoader.GetTreeLeaf(t.type, ref passStyle);
 		}
 
 		public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false) {
@@ -15465,13 +_,13 @@
 				case 492:
 					return true;
 				default:
-					return false;
+					return TileLoader.CanGrowModTree(type);
 			}
 		}
 
 		public static bool GrowTree(int i, int y) {
 			int j;
-			for (j = y; Main.tile[i, j].type == 20; j++) {
+			for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 			}
 
 			if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
@@ -16619,10 +_,10 @@
 			int num6 = genRand.Next(3);
 			bool flag3 = false;
 			bool flag4 = false;
-			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
+			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i - 1, y].type)))
 				flag3 = true;
 
-			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
+			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i + 1, y].type)))
 				flag4 = true;
 
 			if (!flag3) {
@@ -16915,6 +_,7 @@
 						if (TileID.Sets.CommonSapling[Main.tile[i, j].type])
 							break;
 
+						/*
 						switch (Main.tile[i, j].type) {
 							case 3:
 							case 24:
@@ -16938,6 +_,10 @@
 							case 530:
 								continue;
 						}
+						*/
+
+						if (TileID.Sets.IgnoredByGrowingSaplings[Main.tile[i, j].type])
+							continue;
 
 						return false;
 					}
@@ -16955,6 +_,7 @@
 		}
 
 		public static void smCallBack(object threadContext) {
+			var hardmodeTasks = new List<GenPass>();
 			IsGeneratingHardMode = true;
 			if (Main.rand == null)
 				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
@@ -16987,8 +_,15 @@
 				num3 = (int)((float)Main.maxTilesX * (1f - num2));
 			}
 
-			GERunner(num3, 0, 3 * num5, 5f);
-			GERunner(num4, 0, 3 * -num5, 5f, good: false);
+			hardmodeTasks.Add(new PassLegacy("Hardmode Good", (progress, config) => {
+				GERunner(num3, 0, 3 * num5, 5f, true);
+			}));
+
+			hardmodeTasks.Add(new PassLegacy("Hardmode Evil", (progress, config) => {
+				GERunner(num4, 0, 3 * -(float)num5, 5f, false);
+			}));
+
+			hardmodeTasks.Add(new PassLegacy("Hardmode Walls", (progress, config) => {
 			float num7 = (float)Main.maxTilesX / 4200f;
 			int num8 = (int)(25f * num7);
 			ShapeData shapeData = new ShapeData();
@@ -17018,13 +_,23 @@
 					shapeData.Clear();
 				}
 			}
+			}));
 
+			hardmodeTasks.Add(new PassLegacy("Hardmode Announcement", (progress, config) => {
 			if (Main.netMode == 0)
 				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
 			else if (Main.netMode == 2)
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
 
 			AchievementsHelper.NotifyProgressionEvent(9);
+			}));
+
+			SystemLoader.ModifyHardmodeTasks(hardmodeTasks);
+
+			foreach (GenPass task in hardmodeTasks) {
+				task.Apply(null, null);
+			}
+
 			if (Main.netMode == 2)
 				Netplay.ResetSections();
 
@@ -17069,7 +_,7 @@
 
 			int frameX = Main.tile[i, j].frameX;
 			Tile tile = Main.tile[i, j];
-			if (tile.type != 11)
+			if (TileLoader.CloseDoorID(Main.tile[i, j]) < 0)
 				return false;
 
 			int num4 = tile.frameY;
@@ -17116,13 +_,14 @@
 				}
 			}
 
+			ushort closeDoorID = (ushort)TileLoader.CloseDoorID(tile);
 			for (int l = num7; l < num7 + 2; l++) {
 				for (int m = num3; m < num3 + 3; m++) {
 					if (l == num2) {
 						if (Main.tile[l, m] == null)
 							Main.tile[l, m] = new Tile();
 
-						Main.tile[l, m].type = 10;
+						Main.tile[l, m].type = closeDoorID;
 						Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
 					}
 					else {
@@ -17286,7 +_,7 @@
 							bool flag2 = false;
 							for (int k = num6 - 8; k < num6 + 8; k++) {
 								for (int l = num7 - 8; l < num7 + 8; l++) {
-									if (Main.tile[k, l].active() && Main.tile[k, l].type == 4) {
+									if (Main.tile[k, l].active() && TileID.Sets.Torch[Main.tile[k, l].type]) {
 										flag2 = true;
 										break;
 									}
@@ -23753,7 +_,7 @@
 				Main.tile[i, j] = new Tile();
 
 			Tile tile = Main.tile[i, j];
-			if (tile.type != 10)
+			if (TileLoader.OpenDoorID(Main.tile[i, j]) < 0)
 				return false;
 
 			if (IsLockedDoor(tile))
@@ -23818,8 +_,9 @@
 
 			int num8 = num4 % 36 * 54;
 			SoundEngine.PlaySound(8, i * 16, j * 16);
+			ushort openDoorID = (ushort)TileLoader.OpenDoorID(Main.tile[i, j]);
 			Main.tile[num6, num].active(active: true);
-			Main.tile[num6, num].type = 11;
+			Main.tile[num6, num].type = openDoorID;
 			Main.tile[num6, num].frameY = (short)num8;
 			Main.tile[num6, num].frameX = num2;
 			Main.tile[num6, num].color(color);
@@ -23827,7 +_,7 @@
 				Main.tile[num6 + 1, num] = new Tile();
 
 			Main.tile[num6 + 1, num].active(active: true);
-			Main.tile[num6 + 1, num].type = 11;
+			Main.tile[num6 + 1, num].type = openDoorID;
 			Main.tile[num6 + 1, num].frameY = (short)num8;
 			Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num].color(color);
@@ -23835,7 +_,7 @@
 				Main.tile[num6, num + 1] = new Tile();
 
 			Main.tile[num6, num + 1].active(active: true);
-			Main.tile[num6, num + 1].type = 11;
+			Main.tile[num6, num + 1].type = openDoorID;
 			Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
 			Main.tile[num6, num + 1].frameX = num2;
 			Main.tile[num6, num + 1].color(color2);
@@ -23843,7 +_,7 @@
 				Main.tile[num6 + 1, num + 1] = new Tile();
 
 			Main.tile[num6 + 1, num + 1].active(active: true);
-			Main.tile[num6 + 1, num + 1].type = 11;
+			Main.tile[num6 + 1, num + 1].type = openDoorID;
 			Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
 			Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num + 1].color(color2);
@@ -23851,7 +_,7 @@
 				Main.tile[num6, num + 2] = new Tile();
 
 			Main.tile[num6, num + 2].active(active: true);
-			Main.tile[num6, num + 2].type = 11;
+			Main.tile[num6, num + 2].type = openDoorID;
 			Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
 			Main.tile[num6, num + 2].frameX = num2;
 			Main.tile[num6, num + 2].color(color3);
@@ -23859,7 +_,7 @@
 				Main.tile[num6 + 1, num + 2] = new Tile();
 
 			Main.tile[num6 + 1, num + 2].active(active: true);
-			Main.tile[num6 + 1, num + 2].type = 11;
+			Main.tile[num6 + 1, num + 2].type = openDoorID;
 			Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
 			Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
 			Main.tile[num6 + 1, num + 2].color(color3);
@@ -23915,11 +_,15 @@
 				return;
 
 			destroyObject = true;
+			// Extra context.
 			for (int k = 0; k < num; k++) {
 				if (Main.tile[x, num5 + k].type == type)
 					KillTile(x, num5 + k);
 			}
 
+			if (!TileLoader.Drop(x, j, type))
+				goto SkipDrops;
+
 			if (type == 92)
 				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
 
@@ -24029,6 +_,8 @@
 				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, type2);
 			}
 
+			SkipDrops:
+
 			destroyObject = false;
 		}
 
@@ -24125,6 +_,9 @@
 					KillTile(num + 1, num6 + m);
 			}
 
+			if (!TileLoader.Drop(num, j, type))
+				goto skipDrop;
+
 			if (type == 104) {
 				int num7 = frameX / 36;
 				int num8 = 0;
@@ -24392,6 +_,7 @@
 			if (type == 592)
 				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4867);
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -25298,7 +_,13 @@
 				}
 			}
 
+
+			if (!TileLoader.Drop(x, y, TileID.ChristmasTree))
+				goto SkipThis;
+
 			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
+
+			SkipThis:
 			destroyObject = false;
 		}
 
@@ -25616,7 +_,9 @@
 			if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
 				flag = true;
 
-			if (Main.tile[x, num].type == 20) {
+			if (TileID.Sets.TreeSapling[Main.tile[x, num].type]) {
+				int originalType = Main.tile[x, num].type;
+				int newType = TileID.Saplings;
 				int num5 = Main.tile[x, num].frameX / 54;
 				int type2 = Main.tile[x, num + 2].type;
 				int num6 = -1;
@@ -25653,12 +_,16 @@
 					case 112:
 						num6 = 9;
 						break;
+					case int _ when TileLoader.SaplingGrowthType(type2, ref newType, ref num6):
+						break;
 					default:
 						flag = true;
 						break;
 				}
 
-				if (!flag && num5 != num6) {
+				if (!flag && (originalType != newType || num5 != num6)) {
+					Main.tile[x, num].type = (ushort)newType;
+					Main.tile[x, num + 1].type = (ushort)newType;
 					int num7 = 54 * num6;
 					num7 += genRand.Next(3) * 18;
 					Main.tile[x, num].frameX = (short)num7;
@@ -25676,6 +_,9 @@
 			if (Main.tile[x, num + 1].type == type)
 				KillTile(x, num + 1);
 
+			if (!TileLoader.Drop(x, num, type))
+				goto skipDrop;
+
 			if (type == 216)
 				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 970 + num3);
 
@@ -25731,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -25867,6 +_,9 @@
 				if (type != 395)
 					Sign.KillSign(num7, num8);
 
+				if (!TileLoader.Drop(x, y, type))
+					goto skipDrop;
+
 				switch (type) {
 					case 85: {
 							int type2 = 321;
@@ -25905,6 +_,7 @@
 						break;
 				}
 
+				skipDrop:
 				destroyObject = false;
 				return;
 			}
@@ -27435,6 +_,9 @@
 					KillTile(x, num + k);
 			}
 
+			if (!TileLoader.Drop(x, num + 1, type))
+				goto skipDrop;
+
 			if (type == 91) {
 				int num3 = frameX / 18;
 				num3 += num2 * 111;
@@ -27472,6 +_,7 @@
 					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 337 + num3);
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -27641,7 +_,14 @@
 			}
 
 			destroyObject = true;
+
+			if (!TileLoader.Drop(i, j, 2699))
+				goto SkipDrop;
+
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
+
+			SkipDrop:
+
 			TEWeaponsRack.Kill(num, num2);
 			for (int m = 0; m < 3; m++) {
 				for (int n = 0; n < 3; n++) {
@@ -27746,7 +_,14 @@
 				return;
 
 			destroyObject = true;
+
+			if (!TileLoader.Drop(i, j, 498))
+				goto SkipDrop;
+
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
+
+			SkipDrop:
+
 			for (int m = 0; m <= 1; m++) {
 				for (int n = 0; n <= 2; n++) {
 					int num7 = num + m;
@@ -27798,7 +_,14 @@
 				return;
 
 			destroyObject = true;
+
+			if (!TileLoader.Drop(i, j, TileID.Womannequin))
+				goto SkipDrop;
+			
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
+			
+			SkipDrop:
+
 			for (int m = 0; m <= 1; m++) {
 				for (int n = 0; n <= 2; n++) {
 					int num7 = num + m;
@@ -27813,7 +_,7 @@
 
 		public static void Place1x2(int x, int y, ushort type, int style) {
 			short frameX = 0;
-			if (type == 20)
+			if (TileID.Sets.TreeSapling[type])
 				frameX = (short)(genRand.Next(3) * 18);
 
 			if (Main.tile[x, y - 1] == null)
@@ -27899,6 +_,9 @@
 			if (Main.tile[x, num + 1].type == type)
 				KillTile(x, num + 1);
 
+			if (!TileLoader.Drop(x, num, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 42: {
 						int type2 = 0;
@@ -28045,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -28176,6 +_,9 @@
 			if (Main.tile[num + 1, y].type == type)
 				KillTile(num + 1, y);
 
+			if (!TileLoader.Drop(num3, y, type))
+				goto skipDrop;
+
 			if (type == 16) {
 				if (num3 == 1)
 					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 716);
@@ -28399,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			SquareTileFrame(num, y);
 			SquareTileFrame(num + 1, y);
@@ -28493,6 +_,8 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 			if (type == 79) {
 				int num6 = 0;
 				switch (num3) {
@@ -28697,9 +_,11 @@
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num - 1; num7 < num + 4; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 4; num8++) {
+					// Extra patch context.
 					TileFrame(num7, num8);
 				}
 			}
@@ -29013,6 +_,8 @@
 				if (!flag)
 					return;
 
+				if (!TileLoader.Drop(i, j, type))
+					goto skipDrop; // do not know the size for this
 				if (type == 238) {
 					float num6 = i * 16;
 					float num7 = j * 16;
@@ -29033,10 +_,13 @@
 				if (type == 236)
 					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
 
+				skipDrop:
+
 				_ = Main.tile[i, j].frameX;
 				destroyObject = true;
 				for (int n = num; n < num + 2; n++) {
 					for (int num10 = num4; num10 < num4 + 2; num10++) {
+						// Extra patch context.
 						if (Main.tile[n, num10] == null)
 							Main.tile[n, num10] = new Tile();
 
@@ -29326,7 +_,9 @@
 			if (type == 444 && Main.netMode != 1 && !flag6)
 				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num3), num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
 
-			if (num13 != 0)
+			// FishingCrate, GeyserTrap, AntlionLarva, and BeeHive
+			// geyser is 2x1
+			if (TileLoader.Drop(num2, num3, type) && num13 != 0)
 				Item.NewItem(GetItemSource_FromTileBreak(num2, num3), num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num13);
 
 			destroyObject = false;
@@ -29392,7 +_,7 @@
 				case 484: {
 						ushort type4 = Main.tile[num2, num6 - 1].type;
 						ushort type5 = Main.tile[num2 + 1, num6 - 1].type;
-						if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && type4 != 88 && type5 != 88 && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && type4 != 470 && type5 != 470 && type4 != 475 && type5 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
+						if (!TileID.Sets.BasicChest[type4] && !TileID.Sets.BasicChest[type5] && !TileID.Sets.BasicDresser[type4] && !TileID.Sets.BasicDresser[type5] && !TileID.Sets.BasicChestFake[type4] && !TileID.Sets.BasicChestFake[type5] && type4 != 470 && type5 != 470 && type4 != 475 && type5 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
 							flag = true;
 
 						break;
@@ -29746,7 +_,7 @@
 				}
 			}
 
-			if (num13 != 0)
+			if (TileLoader.Drop(i, j, type) && num13 != 0)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num13);
 
 			if (type == 138 && !gen && Main.netMode != 1)
@@ -29781,6 +_,9 @@
 		}
 
 		public static bool IsAContainer(Tile t) {
+			if (TileID.Sets.BasicDresser[t.type])
+				return true;
+
 			if (t.type != 88 && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
 				return TileID.Sets.BasicChestFake[t.type];
 
@@ -29820,7 +_,7 @@
 
 				for (int k = num3; k < num4; k++) {
 					for (int l = num5; l < num6; l++) {
-						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (Main.tile[k, l].type == 0 || Main.tile[k, l].type == 1 || Main.tile[k, l].type == 23 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 40 || Main.tile[k, l].type == 53 || Main.tile[k, l].type == 57 || Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 117 || Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 164 || Main.tileMoss[Main.tile[k, l].type] || Main.tile[k, l].type == 199 || Main.tile[k, l].type == 200 || Main.tile[k, l].type == 203 || Main.tile[k, l].type == 234 || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
+						if ((double)(Math.Abs((float)k - vector.X) + Math.Abs((float)l - vector.Y)) < strength * 0.5 * (1.0 + genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (TileID.Sets.CanBeClearedDuringOreRunner[Main.tile[k, l].type] || Main.tileMoss[Main.tile[k, l].type] || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
 							Main.tile[k, l].type = type;
 							SquareTileFrame(k, l);
 							if (Main.netMode == 2)
@@ -30014,7 +_,7 @@
 				if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
 					flag = true;
 
-				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || Main.tile[k, j - 1].type == 88 || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
+				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || TileID.Sets.BasicDresser[Main.tile[k, j - 1].type]  || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
 					return;
 
 				if (!SolidTileAllowBottomSlope(k, j + 1))
@@ -30026,7 +_,8 @@
 
 			_ = Main.tile[i, j].frameX;
 			destroyObject = true;
-			if (type == 235)
+		
+			if (TileLoader.Drop(i, j, type) && type == 235)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
 
 			for (int l = num; l < num + 3; l++) {
@@ -30186,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 14) {
 				int type2;
 				if (num6 >= 1 && num6 <= 3) {
@@ -30628,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num12 = num5 - 1; num12 < num5 + 4; num12++) {
 				for (int num13 = num - 1; num13 < num + 4; num13++) {
@@ -30757,15 +_,23 @@
 				return;
 
 			destroyObject = true;
+
+			// Extra patch context.
+
 			for (int m = num; m < num + 3; m++) {
 				for (int n = num2; n < num2 + 4; n++) {
 					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 						KillTile(m, n);
 				}
 			}
+
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 
 			switch (type) {
 				case 101: {
+						// Extra patch context.
+
 						int type4;
 						switch (num3) {
 							case 1:
@@ -30912,9 +_,11 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num - 1; num7 < num + 4; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 4; num8++) {
+					// Extra patch context.
 					TileFrame(num7, num8);
 				}
 			}
@@ -30962,12 +_,17 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 464)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
 
 			if (type == 466)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3816);
 
+			skipDrop:
+
 			destroyObject = false;
 			for (int num5 = num - 1; num5 < num + 6; num5++) {
 				for (int num6 = num2 - 1; num6 < num2 + 5; num6++) {
@@ -31013,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 275)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
 
@@ -31118,9 +_,12 @@
 			if (type == 612)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4895);
 
+			skipDrop:
+
 			destroyObject = false;
 			for (int num4 = num - 1; num4 < num + 7; num4++) {
 				for (int num5 = num2 - 1; num5 < num2 + 4; num5++) {
+					// Extra patch context.
 					TileFrame(num4, num5);
 				}
 			}
@@ -31442,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			int type2 = 928;
 			switch (num2) {
 				case 1:
@@ -31457,9 +_,11 @@
 			}
 
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
+			skipDrop:
 			destroyObject = false;
 			for (int num7 = num; num7 < num + 4; num7++) {
 				for (int num8 = num3; num8 < num3 + 3; num8++) {
+					// Extra patch context.
 					TileFrame(num7, num8);
 				}
 			}
@@ -31558,7 +_,8 @@
 					if (Main.tile[k, l] == null)
 						Main.tile[k, l] = new Tile();
 
-					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35)) {
+					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35
+						|| TileLoader.IsModMusicBox(Main.tile[k, l]))) {
 						if (Main.tile[k, l].frameX < 36)
 							Main.tile[k, l].frameX += 36;
 						else
@@ -31720,6 +_,10 @@
 				}
 			}
 
+			// size ???
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			if (type == 35)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
 			else if (num3 == 28)
@@ -31842,9 +_,11 @@
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5112);
 			else if (num3 >= 13)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1596 + num3 - 13);
+				// Extra patch context.
 			else
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 562 + num3);
 
+			skipDrop:
 			for (int num7 = num - 1; num7 < num + 3; num7++) {
 				for (int num8 = num2 - 1; num8 < num2 + 3; num8++) {
 					TileFrame(num7, num8);
@@ -31970,8 +_,10 @@
 		}
 
 		public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1) {
+			/*
 			if (type >= 625)
 				return false;
+			*/
 
 			if (!TileObject.CanPlace(x, y, type, style, direction, out TileObject objectData))
 				return false;
@@ -32146,7 +_,13 @@
 			if (point.Y == 0)
 				type2 = 3239;
 
+			if (!TileLoader.Drop(x, y, type))
+				goto SkipDrop;
+
 			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, num * 16, num2 * 16, type2);
+
+			SkipDrop:
+
 			for (int k = x - 1; k < x + num + 1; k++) {
 				for (int l = y - 1; l < y + num2 + 1; l++) {
 					TileFrame(k, l);
@@ -32199,7 +_,13 @@
 			if (point.Y == 0)
 				type2 = 3240;
 
+			if (!TileLoader.Drop(x, y, type))
+				goto SkipDrop;
+
 			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, width * 16, height * 16, type2);
+
+			SkipDrop:
+
 			for (int m = x - 1; m < x + width + 1; m++) {
 				for (int n = y - 1; n < y + height + 1; n++) {
 					TileFrame(m, n);
@@ -32542,7 +_,7 @@
 				}
 			}
 
-			if (type == 88) {
+			if (TileID.Sets.BasicDresser[type]) {
 				if (Chest.CreateChest(x - 1, y - 1) == -1)
 					flag2 = false;
 				else if (Main.netMode == 1)
@@ -32719,6 +_,9 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
+
 			switch (type) {
 				case 254:
 					if (frameX < 72)
@@ -32927,6 +_,7 @@
 					}
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num8 = num3 - 1; num8 < num3 + 3; num8++) {
 				for (int num9 = num - 1; num9 < num + 3; num9++) {
@@ -33290,6 +_,8 @@
 				}
 			}
 
+			if (!TileLoader.Drop(i, j, type))
+				goto skipDrop;
 			if (type == 454) {
 				switch (Main.rand.Next(9)) {
 					case 2:
@@ -33489,12 +_,16 @@
 						break;
 				}
 
+				// Extra patch context.
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
 			}
+
+			skipDrop:
 
 			destroyObject = false;
 			for (int num19 = num - 1; num19 < num + num3 + 1; num19++) {
 				for (int num20 = num2 - 1; num20 < num2 + 4; num20++) {
+					// Extra patch context.
 					TileFrame(num19, num20);
 				}
 			}
@@ -33560,8 +_,13 @@
 				for (int num8 = num2; num8 < num2 + 3; num8++) {
 					if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
 						KillTile(n, num8);
+
+					// Extra patch context.
 				}
 			}
+
+			if (!TileLoader.Drop(num, j, type))
+				goto skipDrop;
 
 			switch (type) {
 				case 106:
@@ -33658,6 +_,7 @@
 					break;
 			}
 
+			skipDrop:
 			destroyObject = false;
 			for (int num16 = num - 1; num16 < num + 4; num16++) {
 				for (int num17 = num2 - 1; num17 < num2 + 4; num17++) {
@@ -34258,7 +_,7 @@
 				}
 			}
 
-			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234)) {
+			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[num2, num].type)) {
 				KillTile(i, j);
 				return true;
 			}
@@ -34269,7 +_,7 @@
 					return true;
 				}
 			}
-			else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234))) {
+			else if (i == num2 && (!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[i, j + 1].type))) {
 				KillTile(i, j);
 				return true;
 			}
@@ -34327,14 +_,17 @@
 				for (int n = num2; n < num2 + 2; n++) {
 					if (Main.tile[m, n].type == type)
 						KillTile(m, n);
+
+					// Extra patch context.
 				}
 			}
 
-			if (Main.netMode != 1 && !noTileActions) {
+			if (Main.netMode != 1 && !noTileActions && TileLoader.Drop(num, num2, type)) {
 				switch (type) {
 					case 12:
 						Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 29);
 						break;
+					// Extra patch context.
 					case 31:
 						if (flag) {
 							int num3 = Main.rand.Next(5);
@@ -34458,6 +_,9 @@
 			if (num2 == 112)
 				num2 = 53;
 
+			if (TileLoader.CanGrowModPalmTree(num2))
+				num2 = 53;
+
 			if (num2 != 53 && num2 != type)
 				KillTile(i, j);
 
@@ -34841,6 +_,9 @@
 			if (num4 == 492)
 				num4 = 2;
 
+			if (TileLoader.CanGrowModTree(num4))
+				num4 = 2;
+
 			if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
 				KillTile(i, j);
 
@@ -35135,7 +_,7 @@
 					int wall = Main.tile[k, l].wall;
 					switch (conversionType) {
 						case 4:
-							if (type <= 625 && wall <= 316) {
+							if (true) { //if (type <= X && wall <= X) {
 								if (WallID.Sets.Conversion.Grass[wall] && wall != 81) {
 									Main.tile[k, l].wall = 81;
 									SquareWallFrame(k, l);
@@ -35221,8 +_,10 @@
 							}
 							continue;
 						case 2:
+							/*
 							if (type > 625 || wall > 316)
 								continue;
+							*/
 							if (WallID.Sets.Conversion.Grass[wall] && wall != 70) {
 								Main.tile[k, l].wall = 70;
 								SquareWallFrame(k, l);
@@ -35310,7 +_,7 @@
 							}
 							continue;
 						case 1:
-							if (type <= 625 && wall <= 316) {
+							if (true) { //if (type <= X && wall <= X) {
 								if (WallID.Sets.Conversion.Grass[wall] && wall != 69) {
 									Main.tile[k, l].wall = 69;
 									SquareWallFrame(k, l);
@@ -35730,7 +_,7 @@
 			if (num3 / 255 > cactusWaterLimit)
 				return;
 
-			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234) {
+			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234 || TileLoader.CanGrowModCactus(Main.tile[i, j].type)) {
 				if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
 					return;
 
@@ -35748,7 +_,7 @@
 									return;
 							}
 
-							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234)
+							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234 || TileLoader.CanGrowModCactus(Main.tile[m, n].type))
 								num5++;
 						}
 						catch {
@@ -35916,6 +_,10 @@
 			if (!flag)
 				return;
 
+			// size ???
+			if (!TileLoader.Drop(num, num2, type))
+				goto skipDrop;
+
 			destroyObject = true;
 			if (num4 >= 7 && num4 <= 9)
 				SoundEngine.PlaySound(6, i * 16, j * 16);
@@ -36424,6 +_,7 @@
 				}
 			}
 
+			skipDrop:
 			destroyObject = false;
 		}
 
@@ -36452,6 +_,9 @@
 			if (num != -1 && Main.netMode == 1 && type == 467)
 				NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
 
+			if (num != 1 && Main.netMode == 1 && type >= TileID.Count && TileID.Sets.BasicChest[type])
+				NetMessage.SendData(34, -1, -1, null, 100, x, y, style, 0, type, 0);
+
 			return num;
 		}
 
@@ -37562,8 +_,10 @@
 			if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
 				return false;
 
+			/*
 			if (num >= 625)
 				return false;
+			*/
 
 			bool result = false;
 			if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY) {
@@ -37641,7 +_,7 @@
 									return false;
 								break;
 							case 3:
-							case 20:
+							case int _ when TileID.Sets.TreeSapling[num]:
 							case 24:
 							case 27:
 							case 32:
@@ -37893,7 +_,7 @@
 							SquareTileFrame(i, j);
 						}
 					}
-					else if (num == 4) {
+					else if (TileID.Sets.Torch[num]) {
 						if (Main.tile[i - 1, j] == null)
 							Main.tile[i - 1, j] = new Tile();
 
@@ -38028,7 +_,7 @@
 							case 26:
 							case 86:
 							case 87:
-							case 88:
+							case int _ when TileID.Sets.BasicDresser[num]:
 							case 89:
 							case 114:
 							case 186:
@@ -38049,13 +_,15 @@
 								PlaceJunglePlant(i, j, (ushort)num, 0, 0);
 								SquareTileFrame(i, j);
 								break;
-							case 20: {
+							case int _ when TileID.Sets.TreeSapling[num]: {
 									if (Main.tile[i, j + 1] == null)
 										Main.tile[i, j + 1] = new Tile();
 
 									int type = Main.tile[i, j + 1].type;
+									int dummyType = TileID.Saplings;
+									int dummyStyle = 0;
-									if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 53 || type == 234 || type == 116 || type == 112)) {
+									if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 53 || type == 234 || type == 116 || type == 112 || TileLoader.SaplingGrowthType(type, ref dummyType, ref dummyStyle))) {
-										Place1x2(i, j, (ushort)num, style);
+										Place1x2(i, j, (ushort)dummyType, dummyStyle);
 										SquareTileFrame(i, j);
 									}
 
@@ -38250,6 +_,9 @@
 											case 314:
 												Minecart.PlaceTrack(tile, style);
 												break;
+											case int _ when num >= TileID.Count && TileObjectData.GetTileData(num, style) != null:
+												PlaceObject(i, j, (ushort)num, mute, style);
+												break;
 											default:
 												tile.active(active: true);
 												tile.type = (ushort)num;
@@ -38267,7 +_,8 @@
 
 						SquareTileFrame(i, j);
 						result = true;
-						if (!mute) {
+						// tML: to fix a number of errors post-sound-rework, tile placements are now automagically muted during initial worldgen
+						if (!mute && !generatingWorld) {
 							switch (num) {
 								case 127:
 									SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
@@ -38313,11 +_,13 @@
 				return;
 
 			fail = KillWall_CheckFailure(fail, tile);
+			WallLoader.KillWall(i, j, tile.wall, ref fail);
-			KillWall_PlaySounds(i, j, tile);
+			KillWall_PlaySounds(i, j, tile, fail);
 			int num = 10;
 			if (fail)
 				num = 3;
 
+			WallLoader.NumDust(i, j, tile.wall, fail, ref num);
 			for (int k = 0; k < num; k++) {
 				KillWall_MakeWallDust(i, j, tile);
 			}
@@ -38331,7 +_,7 @@
 			tile.wall = 0;
 			tile.wallColor(0);
 			SquareWallFrame(i, j);
-			if (tile.type >= 0 && tile.type < 625 && TileID.Sets.FramesOnKillWall[tile.type])
+			if (tile.type >= 0 && TileID.Sets.FramesOnKillWall[tile.type])
 				TileFrame(i, j);
 		}
 
@@ -38345,7 +_,10 @@
 			return fail;
 		}
 
-		private static void KillWall_PlaySounds(int i, int j, Tile tileCache) {
+		private static void KillWall_PlaySounds(int i, int j, Tile tileCache, bool fail = false) {
+			if (!WallLoader.KillSound(i,j,tileCache.wall,fail))
+				return;
+
 			if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
 				SoundEngine.PlaySound(13, i * 16, j * 16);
 			else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
@@ -38356,7 +_,8 @@
 
 		private static void KillWall_DropItems(int i, int j, Tile tileCache) {
 			int num = KillWall_GetItemDrops(tileCache);
-			if (num > 0)
+
+			if (WallLoader.Drop(i, j, Main.tile[i,j].wall, ref num) && num > 0)
 				Item.NewItem(GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, num);
 		}
 
@@ -39481,6 +_,9 @@
 			if (tileCache.wall == 245)
 				num = 195;
 
+			if (!WallLoader.CreateDust(i, j, tileCache.wall, ref num))
+				return;
+
 			if (tileCache.wall == 44) {
 				int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
 				Main.dust[num2].noGravity = true;
@@ -39554,11 +_,14 @@
 				return false;
 
 			Tile tile = Main.tile[i, j];
-			Tile tile2 = null;
+			Tile tile2 = default;
 			if (tile == null)
 				return false;
 
 			if (!tile.active())
+				return false;
+
+			if (!TileLoader.CanKillTile(i, j, tile.type, ref blockDamaged))
 				return false;
 
 			if (j >= 1)
@@ -39574,7 +_,9 @@
 						if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
 							return false;
 						break;
+					case int _ when TileID.Sets.BasicDresser[type]:
 					case 21:
+					case int _ when TileID.Sets.BasicChest[type]:
 					case 26:
 					case 72:
 					case 77:
@@ -39620,10 +_,11 @@
 						break;
 					}
 				case 21:
-				case 467:
+				case ushort _ when TileID.Sets.BasicChest[tile.type]:
 					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
 						return false;
 					break;
+				case ushort _ when TileID.Sets.BasicDresser[tile.type]:
 				case 88:
 					if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
 						return false;
@@ -39747,7 +_,7 @@
 					return true;
 			}
 
-			if (tile.type == 88) {
+			if (TileID.Sets.BasicDresser[tile.type]) {
 				int num2 = tile.frameX / 18;
 				int y3 = y - tile.frameY / 18;
 				num2 %= 3;
@@ -39766,7 +_,7 @@
 		}
 
 		public static bool ReplaceWall(int x, int y, ushort targetWall) {
-			if (targetWall >= 316)
+			if (targetWall >= WallLoader.WallCount)
 				return false;
 
 			Tile tile = Main.tile[x, y];
@@ -39798,7 +_,7 @@
 				return false;
 
 			MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
-			int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
+			int num = KillTile_GetTileDustAmount(false, tileSafely, x, y);
 			for (int i = 0; i < num; i++) {
 				KillTile_MakeTileDust(x, y, tileSafely);
 			}
@@ -39900,7 +_,7 @@
 
 		public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y) {
 			Tile tile = Main.tile[x, y];
-			if (attemptingToReplaceWith >= 625)
+			if (attemptingToReplaceWith >= TileLoader.TileCount)
 				return false;
 
 			if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith])
@@ -39909,7 +_,7 @@
 			bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
 			bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
 			bool flag2 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
-			bool flag3 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
+			bool flag3 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(x, y, tile);
 			bool flag4 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
 			return !(num && flag && flag2 && flag3 && flag4);
 		}
@@ -40101,6 +_,14 @@
 
 							return true;
 						}
+					default:
+						var tree = PlantLoader.Get<ModTree>(TileID.Trees, tile.type);
+						if (tree != null) {
+							tree.SetTreeFoliageSettings(tile, ref xoffset, ref treeFrame, ref floorY, ref topTextureFrameWidth, ref topTextureFrameHeight);
+							treeStyle = tile.type + ModTree.VanillaTopTextureCount;
+							return true;
+						}
+						break;
 				}
 			}
 
@@ -40131,6 +_,11 @@
 		}
 
 		public static TreeTypes GetTreeType(int tileType) {
+
+			TreeTypes modType = PlantLoader.GetModTreeType(tileType);
+			if (modType != TreeTypes.None)
+				return modType;
+
 			switch (tileType) {
 				case 2:
 				case 477:
@@ -40175,7 +_,8 @@
 
 			GetTreeBottom(i, j, out int x, out int y);
 			int num = y;
-			TreeTypes treeType = GetTreeType(Main.tile[x, y].type);
+			int tileType = Main.tile[x, y].type;
+			TreeTypes treeType = GetTreeType(tileType);
 			if (treeType == TreeTypes.None)
 				return;
 
@@ -40197,7 +_,9 @@
 				return;
 
 			bool flag = false;
+			if (!PlantLoader.ShakeTree(x, y, tileType, ref flag)) {
+			}
-			if (Main.getGoodWorld && genRand.Next(15) == 0) {
+			else if (Main.getGoodWorld && genRand.Next(15) == 0) {
 				Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16, y * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16));
 			}
 			else if (genRand.Next(300) == 0 && treeType == TreeTypes.Forest) {
@@ -40523,6 +_,8 @@
 			if (num == 2)
 				return;
 
+			TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem); //Placed before gen check on purpose.
+
 			if (gen)
 				noItem = true;
 
@@ -40530,8 +_,9 @@
 				if (!noItem && FixExploitManEaters.SpotProtected(i, j))
 					return;
 
-				if (!gen && !Main.gameMenu)
+				if (!Main.dedServ && !gen && !Main.gameMenu)
 					KillTile_PlaySounds(i, j, fail, tile);
+
 			}
 
 			if (tile.type == 128 || tile.type == 269) {
@@ -40664,7 +_,7 @@
 			if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
 				return;
 
-			int num16 = KillTile_GetTileDustAmount(fail, tile);
+			int num16 = KillTile_GetTileDustAmount(fail, tile, i, j);
 			for (int k = 0; k < num16; k++) {
 				KillTile_MakeTileDust(i, j, tile);
 			}
@@ -40851,6 +_,9 @@
 		private static Player GetPlayerForTile(int x, int y) => Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
 
 		private static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false) {
+			if (!TileLoader.Drop(x, y, Main.tile[x, y].type))
+				return;
+
 			KillTile_GetItemDrops(x, y, tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, includeLargeObjectDrops);
 			if (!Main.getGoodWorld || tileCache.active()) {
 				if (dropItem > 0) {
@@ -42126,6 +_,8 @@
 							}
 						}
 
+						TileLoader.DropPalmTreeWood(Main.tile[x, j].type, ref dropItem);
+
 						break;
 					}
 				case 171:
@@ -42756,7 +_,7 @@
 
 						if (Main.tile[i, k] != null) {
 							Tile tile = Main.tile[i, k];
-							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23) {
+							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23 || TileLoader.CanDropAcorn(tile.type)) {
 								dropItem = 9;
 								secondaryItem = 27;
 							}
@@ -42803,6 +_,7 @@
 						dropItem = 2503;
 						break;
 				}
+				TileLoader.DropTreeWood(Main.tile[x,y].type, ref dropItem);
 			}
 
 			int num = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
@@ -42875,6 +_,7 @@
 			if (Main.player[num4].ZoneGraveyard)
 				num5 = 606;
 
+			TileLoader.DropCritterChance(i,j,tileCache.type,ref num,ref num2,ref num3);
 			if (num > 0 && NPC.CountNPCS(num5) < 5 && genRand.Next(num) == 0) {
 				int type = num5;
 				if (num5 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
@@ -42923,6 +_,10 @@
 				return;
 
 			int type = tileCache.type;
+
+			if(!TileLoader.KillSound(i,j,type,fail))
+				return;
+
 			if (type == 127 || type == 623) {
 				SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
 			}
@@ -43046,7 +_,14 @@
 			return value;
 		}
 
+		public static int KillTile_GetTileDustAmount(bool fail,Tile tileCache,int x,int y) {
+			int result = KillTile_GetTileDustAmount_Vanilla(fail,tileCache);
+
+			TileLoader.NumDust(x,y,tileCache.type,fail,ref result);
+
+			return result;
+		}
-		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache) {
+		private static int KillTile_GetTileDustAmount_Vanilla(bool fail, Tile tileCache) {
 			switch (tileCache.type) {
 				default:
 					if (!fail)
@@ -44084,8 +_,11 @@
 						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 199)
 							num = 121;
 
+						//patch file: num11, k
 						if (Main.tile[num11, k].active() && Main.tile[num11, k].type == 147)
 							num = 122;
+
+						TileLoader.TreeDust(Main.tile[num11, k], ref num);
 					}
 				}
 			}
@@ -44104,8 +_,11 @@
 						if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
 							num = 79;
 
+						//patch file: l
 						if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
 							num = 77;
+
+						TileLoader.PalmTreeDust(Main.tile[i, l], ref num);
 					}
 				}
 			}
@@ -44714,7 +_,7 @@
 			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
 				flag = true;
 
-			if (num >= 0) {
+			if (TileLoader.CreateDust(i,j,tileCache.type,ref num) && num >= 0) {
 				if (tileCache.type == 518) {
 					int num14 = (int)tileCache.liquid / 16;
 					num14 -= 3;
@@ -44805,6 +_,10 @@
 			if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
 				return t.frameX < 54;
 
+			// something might be meant to go here but it's not this - Chicken Bones (I don't know what a "locked door" even is)
+			//if (TileLoader.OpenDoorID(t) < 0)
+			//	return true;
+
 			return false;
 		}
 
@@ -46431,6 +_,13 @@
 			if (gen)
 				return;
 
+			SystemLoader.PreUpdateWorld();
+
+			UpdateWorld_Inner();
+
+			SystemLoader.PostUpdateWorld();
+		}
+		private static void UpdateWorld_Inner() {
 			AllowedToSpreadInfections = true;
 			CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
 			if (power != null && power.GetIsUnlocked())
@@ -46462,7 +_,7 @@
 				Liquid.skipCount = 0;
 			}
 
-			int worldUpdateRate = GetWorldUpdateRate();
+			double worldUpdateRate = GetWorldUpdateRate();
 			if (worldUpdateRate == 0)
 				return;
 
@@ -46507,8 +_,15 @@
 			if (Main.dayTime)
 				return;
 
+			_timePass += Main.desiredWorldEventsUpdateRate;
+
+			/*
 			for (int l = 0; l < Main.dayRate; l++) {
 				float num6 = Main.maxTilesX / 4200;
+			*/
+
+			for (int l = 1; l <= (int)_timePass; l++) {
+				float num6 = Main.maxTilesX / 4200f; // Selfish fix for falling stars on extra small worlds
 				num6 *= Star.starfallBoost;
 				if (!((float)Main.rand.Next(8000) < 10f * num6))
 					continue;
@@ -46536,13 +_,24 @@
 					num15 = (float)num7 / num15;
 					num13 *= num15;
 					num14 *= num15;
+
+					/*
 					Projectile.NewProjectile(new EntitySource_ByProjectileSourceId(11), position.X, position.Y, num13, num14, 720, 0, 0f, Main.myPlayer, 0f, num10);
+					*/
+					var source = new EntitySource_Misc(nameof(ProjectileSourceID.FallingStar));
+
+					Projectile.NewProjectile(source, position.X, position.Y, num13, num14, 720, 0, 0f, Main.myPlayer, 0f, num10);
+
+					// Extra patch context.
 				}
 			}
+
+			_timePass %= 1.0;
 		}
 
+		//TML: Changed return value from 'int' to 'double'.
-		public static int GetWorldUpdateRate() {
+		public static double GetWorldUpdateRate() {
-			int result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
+			double result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
 			if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
 				result = 0;
 
@@ -46550,6 +_,8 @@
 		}
 
 		private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+			TileLoader.RandomUpdate(i,j,Main.tile[i,j].type);
+			WallLoader.RandomUpdate(i,j,Main.tile[i,j].wall);
 			int num = i - 1;
 			int num2 = i + 2;
 			int num3 = j - 1;
@@ -47254,6 +_,8 @@
 		}
 
 		private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist) {
+			TileLoader.RandomUpdate(i,j,Main.tile[i,j].type);
+			WallLoader.RandomUpdate(i,j,Main.tile[i,j].wall);
 			int num = i - 1;
 			int num2 = i + 2;
 			int num3 = j - 1;
@@ -52371,6 +_,8 @@
 							return false;
 					}
 					if (Main.tile[x, y - 1].active()) {
+						if (TileID.Sets.BasicChest[Main.tile[x, y - 1].type])
+							return false;
 						switch (Main.tile[x, y - 1].type) {
 							case 21:
 							case 26:
@@ -52534,7 +_,7 @@
 
 		public static bool UpdateMapTile(int i, int j, bool addToList = true) {
 			bool result = false;
-			if (Main.mapEnabled && !noMapUpdate && !gen && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList) {
+			if (!Main.dedServ && Main.mapEnabled && !noMapUpdate && !gen && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList) {
 				result = true;
 				if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1) {
 					MapHelper.updateTileX[MapHelper.numUpdateTile] = (short)i;
@@ -52819,7 +_,10 @@
 						Liquid.AddWater(i, j);
 
 					if (tile.active()) {
-						if (noBreak && Main.tileFrameImportant[tile.type] && tile.type != 4)
+						if (!TileLoader.TileFrame(i, j, tile.type, ref resetFrame, ref noBreak))
+							return;
+
+						if (noBreak && Main.tileFrameImportant[tile.type] && !TileID.Sets.Torch[tile.type])
 							return;
 
 						int num = tile.type;
@@ -52843,7 +_,7 @@
 								case 571:
 									CheckBamboo(i, j);
 									break;
-								case 4:
+								case int _ when TileID.Sets.Torch[num]:
 									CheckTorch(i, j);
 									break;
 								case 442:
@@ -53343,7 +_,7 @@
 															if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455 && num != 491 && num != 499) {
 																switch (num) {
 																	case 15:
-																	case 20:
+																	case int _ when TileID.Sets.TreeSapling[num]:
 																	case 216:
 																	case 338:
 																	case 390:
@@ -53413,7 +_,7 @@
 																				CheckOnTable1x1(i, j, num);
 																				return;
 																			default:
-																				if (TileID.Sets.BasicChest[num]) {
+																				if (TileID.Sets.BasicChest[num] && num < TileID.Count) {
 																					CheckChest(i, j, num);
 																					return;
 																				}
@@ -53671,6 +_,7 @@
 																														CheckGnome(i, j);
 																														break;
 																												}
+																												TileLoader.CheckModTile(i, j, num); // TODO: Test this. Not sure this is still correct.
 
 																												return;
 																											}
@@ -53874,13 +_,10 @@
 										}
 
 										switch (num) {
-											case 147:
+											case int _ when TileID.Sets.Snow[num]:
 												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 												break;
-											case 161:
-											case 163:
-											case 164:
-											case 200:
+											case int _ when TileID.Sets.Ices[num]:
 												TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 												break;
 											case 162:
@@ -53888,7 +_,7 @@
 												break;
 											default:
 												if (Main.tileBrick[num]) {
-													if (num == 60 || num == 70)
+													if (TileID.Sets.GrassSpecial[num])
 														TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													else
 														TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -53899,14 +_,14 @@
 												break;
 										}
 
-										if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && down == 165) {
+										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && down == 165) {
 											if (tile9.frameY == 72)
 												down = num;
 											else if (tile9.frameY == 0)
 												down = num;
 										}
 
-										if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && up == 165) {
+										if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && up == 165) {
 											if (tile8.frameY == 90)
 												up = num;
 											else if (tile8.frameY == 54)
@@ -53921,7 +_,7 @@
 												up = num;
 										}
 
-										if ((num == 200 || num == 161 || num == 147 || num == 163 || num == 164) && down == 165)
+										if ((TileID.Sets.Ices[num] || num == 147) && down == 165)
 											down = num;
 
 										if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
@@ -54070,7 +_,7 @@
 														if (mergeDown)
 															up = num;
 													}
-													else if (up == 147) {
+													else if (up >= 0 && TileID.Sets.Snow[up]) {
 														TileFrame(i, j - 1);
 														if (mergeDown)
 															up = num;
@@ -54081,7 +_,7 @@
 														if (mergeUp)
 															down = num;
 													}
-													else if (down == 147) {
+													else if (down >= 0 && TileID.Sets.Snow[down]) {
 														TileFrame(i, j + 1);
 														if (mergeUp)
 															down = num;
@@ -54092,7 +_,7 @@
 														if (mergeRight)
 															left = num;
 													}
-													else if (left == 147) {
+													else if (left >= 0 && TileID.Sets.Snow[left]) {
 														TileFrame(i - 1, j);
 														if (mergeRight)
 															left = num;
@@ -54212,16 +_,14 @@
 										}
 										else {
 											switch (num) {
-												case 58:
-												case 75:
-												case 76:
+												case int _ when TileID.Sets.HellSpecial[num]:
 													TileMergeAttempt(-2, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
 												case 57:
 													TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 59:
+												case int _ when TileID.Sets.Mud[num]:
 													if ((double)j > Main.rockLayer)
 														TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -54253,14 +_,10 @@
 													TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 147:
+												case int _ when TileID.Sets.Snow[num]:
 													TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
-												case 161:
-												case 163:
-												case 164:
-												case 200:
-												case 224:
+												case int _ when TileID.Sets.IcesSlush[num]:
 													TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
 												case 162:
@@ -54363,11 +_,11 @@
 											TileMergeAttempt(num, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 
 										bool flag = false;
-										if (num == 2 || num == 23 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
+										if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
 											flag = true;
 											TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											int num32 = TileID.Sets.NeedsGrassFramingDirt[num];
-											if (num == 60 || num == 70) {
+											if (TileID.Sets.GrassSpecial[num]) {
 												num32 = 59;
 											}
 											else if (Main.tileMoss[num]) {
@@ -55798,7 +_,7 @@
 												}
 											}
 											else {
-												if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492) {
+												if (!TileID.Sets.Grass[num] && !TileID.Sets.GrassSpecial[num]) {
 													if (up == -1 && down == -2 && left == num && right == num) {
 														switch (num27) {
 															case 0:
@@ -56347,7 +_,7 @@
 												TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											}
 
-											if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
+											if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
 												TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 
 											if (up == num && down == num && left == num && right == num) {
@@ -57245,7 +_,7 @@
 
 		public static bool AllowsSandfall(Tile tileTopCache) {
 			bool result = true;
-			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
+			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || TileID.Sets.BasicDresser[tileTopCache.type] || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
 				result = false;
 
 			return result;
