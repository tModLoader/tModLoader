--- src/TerrariaNetCore/Terraria/WorldGen.cs
+++ src/tModLoader/Terraria/WorldGen.cs
@@ -1,6 +_,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Xna.Framework;
@@ -22,13 +_,16 @@
 using Terraria.IO;
 using Terraria.Localization;
 using Terraria.Map;
+using Terraria.ModLoader;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.Exceptions;
 using Terraria.ObjectData;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
 
 namespace Terraria;
 
-public class WorldGen
+public partial class WorldGen
 {
 	public static class WorldSize
 	{
@@ -889,14 +_,22 @@
 	public static int SmallConsecutivesFound = 0;
 	public static int SmallConsecutivesEliminated = 0;
 	public static bool tempRemixWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/Don%27t_dig_up">Don't dig up (aka Remix)</see> secret world seed. See also <see cref="Main.remixWorld"/>. </summary>
 	public static bool remixWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/Get_fixed_boi">Get fixed boi (aka Zenith)</see> secret world seed. This seed combines multiple secret seeds. Note that the other secret world seed bools inherited by this seed will be set as well, so there is no need to specifically check both those bools and this bool. See also <see cref="Main.zenithWorld"/>. </summary>
 	public static bool everythingWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/No_traps">No traps</see> secret world seed. See also <see cref="Main.noTrapsWorld"/>. </summary>
 	public static bool noTrapsWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/Drunk_world">Drunk world</see> secret world seed. See also <see cref="Main.drunkWorld"/>. </summary>
 	public static bool drunkWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/For_the_worthy">For the worthy</see> secret world seed. See also <see cref="Main.getGoodWorld"/>. </summary>
 	public static bool getGoodWorldGen = false;
 	public static bool tempTenthAnniversaryWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/Celebrationmk10">Celebrationmk10</see> secret world seed. See also <see cref="Main.tenthAnniversaryWorld"/>. </summary>
 	public static bool tenthAnniversaryWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/The_Constant">The Constant</see> secret world seed. See also <see cref="Main.dontStarveWorld"/>. </summary>
 	public static bool dontStarveWorldGen = false;
+	/// <summary> If true, the world is generating with the <see href="https://terraria.wiki.gg/wiki/Not_the_bees">Not the bees</see> secret world seed. See also <see cref="Main.notTheBeesWorld"/>. </summary>
 	public static bool notTheBees = false;
 	public static bool drunkWorldGenText = false;
 	public static bool placingTraps = false;
@@ -923,6 +_,9 @@
 	public static bool noMapUpdateRefresh = false;
 	private static bool skipFramingDuringGen = false;
 
+	/// <summary>
+	/// The random number generator for world generation. It is important to use this instead of <see cref="Main.rand"/> for all world generation randomness to make the world seed feature reliable.
+	/// </summary>
 	public static UnifiedRandom genRand {
 		get {
 			if (_lastSeed != _genRandSeed) {
@@ -989,6 +_,7 @@
 		list.Add(new Point16(105, 37));
 		list.Add(new Point16(105, 2));
 		GenVars.statueList = list.ToArray();
+		GenVars.StatuesWithTraps = new List<int>(new int[4] {4, 7, 10, 18 }); // Duplicated here for modder convenience. 
 	}
 
 	public static void PlaceStatueTrap(int x, int y)
@@ -1284,7 +_,7 @@
 			}
 		}
 
-		for (int j = 0; j < NPCID.Count; j++) {
+		for (int j = 0; j < NPCLoader.NPCCount; j++) {
 			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
 				continue;
 
@@ -1325,7 +_,7 @@
 		}
 
 		int num2 = -1;
-		for (int j = 0; j < NPCID.Count; j++) {
+		for (int j = 0; j < Main.townNPCCanSpawn.Length; j++) {
 			if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
 				continue;
 
@@ -1352,6 +_,9 @@
 
 	public static bool CheckSpecialTownNPCSpawningConditions(int type)
 	{
+		if (!NPCLoader.CheckConditions(type))
+			return false;
+
 		if (type == 160) {
 			if (!NPC.unlockedTruffleSpawn && (double)roomY2 > Main.worldSurface)
 				return false;
@@ -1932,7 +_,7 @@
 		int num = 0;
 		int num2 = 50;
 		Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
-		int[] tileTypeCounts = new int[TileID.Count];
+		int[] tileTypeCounts = new int[TileLoader.TileCount];
 		CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
 		int num3 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
 		if (num3 < 50)
@@ -2093,7 +_,7 @@
 		roomY2 = y;
 		numRoomTiles = 0;
 		roomCeilingsCount = 0;
-		for (int i = 0; i < TileID.Count; i++) {
+		for (int i = 0; i < houseTile.Length; i++) {
 			houseTile[i] = false;
 		}
 
@@ -2167,6 +_,10 @@
 			houseTile[Main.tile[x, y].type] = true;
 			if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
 				return;
+
+			//TML: Handle modded closed doors. Mimics the above if statement.
+			if (TileLoader.CloseDoorID(Main.tile[x, y]) >= 0 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126))
+				return;
 		}
 
 		if (x < roomX1)
@@ -2323,11 +_,14 @@
 						return false;
 
 					switch (Main.tile[m, n].type) {
+						case ushort _ when TileID.Sets.AvoidedByMeteorLanding[Main.tile[m, n].type]:
+						/*
 						case 226:
 						case 470:
 						case 475:
 						case 488:
 						case 597:
+						*/
 							return false;
 					}
 				}
@@ -2440,8 +_,13 @@
 	{
 		Main.bottomWorld = Main.maxTilesY * 16;
 		Main.rightWorld = Main.maxTilesX * 16;
+
+		/*
 		Main.maxSectionsX = Main.maxTilesX / 200;
 		Main.maxSectionsY = Main.maxTilesY / 150;
+		*/
+		Main.maxSectionsX = (Main.maxTilesX - 1) / Main.sectionWidth + 1;
+		Main.maxSectionsY = (Main.maxTilesY - 1) / Main.sectionHeight + 1;
 	}
 
 	public static int GetWorldSize()
@@ -2457,10 +_,23 @@
 
 	public static void worldGenCallback(object threadContext)
 	{
+		try {
+			do_worldGenCallBack(threadContext);
+		}
+		catch (Exception e) {
+			Utils.ShowFancyErrorMessage(Language.GetTextValue("tModLoader.WorldGenError") + "\n" + e, 0);
+		}
+	}
+
+	public static void do_worldGenCallBack(object threadContext)
+	{
 		SoundEngine.PlaySound(10);
 		clearWorld();
 		GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
 		WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
+
+		BackupIO.archiveLock = false;
+
 		if (Main.menuMode == 10 || Main.menuMode == 888)
 			Main.menuMode = 6;
 
@@ -2485,12 +_,20 @@
 
 	public static void JustQuit()
 	{
+		/*
 		try {
 			SoundEngine.PlaySound(34, -1, -1, 0);
 			SoundEngine.PlaySound(35, -1, -1, 0);
 		}
 		catch {
 		}
+		*/
+
+		// Properly stop waterfall/lava(fall) sounds.
+		// The above wouldn't do anything in the new sound system.
+		Main.ambientWaterfallStrength = 0f;
+		Main.ambientLavafallStrength = 0f;
+		Main.ambientLavaStrength = 0f;
 
 		Main.invasionProgress = -1;
 		Main.invasionProgressDisplayLeft = 0;
@@ -2499,6 +_,14 @@
 		Main.menuMode = 10;
 		Main.gameMenu = true;
 		SoundEngine.StopTrackedSounds();
+
+		try {
+			// This has been moved here out of WorldGen.SaveAndQuit, so that the "menu close" sound plays AFTER all sounds have stopped
+			SoundEngine.PlaySound(11);
+		}
+		catch {
+		}
+
 		CaptureInterface.ResetFocus();
 		Main.ActivePlayerFileData.StopPlayTimer();
 		Main.fastForwardTimeToDawn = false;
@@ -2518,12 +_,20 @@
 	public static void SaveAndQuitCallBack(object threadContext)
 	{
 		int netMode = Main.netMode;
+
+		/*
 		try {
 			SoundEngine.PlaySound(34, -1, -1, 0);
 			SoundEngine.PlaySound(35, -1, -1, 0);
 		}
 		catch {
 		}
+		*/
+		
+		// Properly stop waterfall/lavafall sounds.
+		// The above wouldn't do anything in the new sound system.
+		Main.ambientWaterfallStrength = 0f;
+		Main.ambientLavafallStrength = 0f;
 
 		if (netMode == 0)
 			WorldFile.CacheSaveTime();
@@ -2535,6 +_,14 @@
 		Main.menuMode = 10;
 		Main.gameMenu = true;
 		SoundEngine.StopTrackedSounds();
+
+		try {
+			// Delay playing the "menu close" sound until AFTER all sounds have stopped
+			SoundEngine.PlaySound(11);
+		}
+		catch {
+		}
+		
 		CaptureInterface.ResetFocus();
 		Main.ActivePlayerFileData.StopPlayTimer();
 		Player.SavePlayer(Main.ActivePlayerFileData);
@@ -2544,10 +_,15 @@
 			WorldFile.SaveWorld();
 			SoundEngine.PlaySound(10);
 		}
+		// Extra patch context.
 		else {
 			Netplay.Disconnect = true;
 			Main.netMode = 0;
 		}
+
+		// This is only called in case of a manual quit or disconnect.
+		// There is a less common (client) call to this in Netplay.InnerClientLoop.
+		SystemLoader.OnWorldUnload();
 
 		Main.fastForwardTimeToDawn = false;
 		Main.fastForwardTimeToDusk = false;
@@ -2559,7 +_,10 @@
 
 	public static void SaveAndQuit(Action callback = null)
 	{
+		//TML: Moved to WorldGen.JustQuit(), see the comment there.
+		/*
 		SoundEngine.PlaySound(11);
+		*/
 		ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
 	}
 
@@ -2603,6 +_,8 @@
 
 	public static void playWorldCallBack(object threadContext)
 	{
+		Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave, Main.ActiveWorldFileData.WorldSizeX, Main.ActiveWorldFileData.WorldSizeY, Main.ActiveWorldFileData.HasCrimson.ToInt(), Main.ActiveWorldFileData.GameMode);
+
 		if (Main.rand == null)
 			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 
@@ -2624,30 +_,62 @@
 					worldBackup = false;
 
 				if (!Main.dedServ) {
+					// If the loading error is mod related, show the exception, then back to the load backup/load failed menus.
+					if (WorldFile.LastThrownLoadException is CustomModDataException ex) {
+						WorldIO.customDataFail = ex;
+						Utils.ShowFancyErrorMessage($"{Language.GetTextValue("tModLoader.WorldIOException")}\n{ex.modName}\n\n{ex.Message}\n{ex.StackTrace}", worldBackup ? 200 : 201);
+						return;
+					}
 					if (worldBackup)
 						Main.menuMode = 200;
 					else
 						Main.menuMode = 201;
-
 					return;
 				}
 
 				if (!worldBackup) {
+					/*
 					Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
+					*/
+					string message = Language.GetTextValue("Error.LoadFailedNoBackup");
+
+					if (WorldIO.customDataFail != null) {
+						message = WorldIO.customDataFail.modName + " " + message;
+						message += "\n" + WorldIO.customDataFail.InnerException;
+					}
+
+					Console.WriteLine(message);
 					return;
 				}
 
 				FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
 				FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
 				FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
+
+				WorldIO.LoadDedServBackup(Main.worldPathName, isCloudSave);
+
 				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 				if (loadFailed || !loadSuccess) {
 					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
+
+					// Patch context/merge.
 					if (loadFailed || !loadSuccess) {
 						FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
 						FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
 						FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
+
+						WorldIO.RevertDedServBackup(Main.worldPathName, isCloudSave);
+
+						/*
 						Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
+						*/
+						string message = Language.GetTextValue("Error.LoadFailed");
+
+						if (WorldIO.customDataFail != null) {
+							message = $"{WorldIO.customDataFail.modName} {message}\r\n{WorldIO.customDataFail.InnerException}";
+						}
+
+						Console.WriteLine(message);
 						return;
 					}
 				}
@@ -2674,6 +_,12 @@
 		if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
 			Main.anglerQuestFinished = true;
 
+		// TML: Move rest of method to main thread to fix concurrent modification exceptions
+		Main.QueueMainThreadAction(FinishPlayWorld);
+	}
+
+	internal static void FinishPlayWorld()
+	{
 		Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
 		_lastSeed = Main.ActiveWorldFileData.Seed;
 		WorldFile.SetOngoingToTemps();
@@ -2709,6 +_,8 @@
 
 	public static void serverLoadWorldCallBack()
 	{
+		Logging.Terraria.InfoFormat("Loading World: {0}, IsCloud={1}, Width: {2}, Height: {3}, Evil: {4}, GameMode: {5}", Main.ActiveWorldFileData.Name, Main.ActiveWorldFileData.IsCloudSave, Main.ActiveWorldFileData.WorldSizeX, Main.ActiveWorldFileData.WorldSizeY, Main.ActiveWorldFileData.HasCrimson.ToInt(), Main.ActiveWorldFileData.GameMode);
+
 		Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
 		WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
 		if (loadFailed || !loadSuccess) {
@@ -2949,6 +_,9 @@
 		noLiquidCheck = false;
 		Liquid.numLiquid = 0;
 		LiquidBuffer.numLiquidBuffer = 0;
+
+		// TileMap.ClearEverything() is instead called below.
+		/*
 		if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY) {
 			for (int j = 0; j < lastMaxTilesX; j++) {
 				float num = (float)j / (float)lastMaxTilesX;
@@ -2958,12 +_,18 @@
 				}
 			}
 		}
+		*/
 
 		lastMaxTilesX = Main.maxTilesX;
 		lastMaxTilesY = Main.maxTilesY;
+
 		if (Main.netMode != 2)
+			/*
 			Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
+			*/
+			Main.sectionManager = new WorldSections((Main.maxTilesX - 1) / Main.sectionWidth + 1, (Main.maxTilesY - 1) / Main.sectionHeight + 1);
 
+		/*
 		if (Main.netMode != 1) {
 			for (int l = 0; l < Main.maxTilesX; l++) {
 				float num2 = (float)l / (float)Main.maxTilesX;
@@ -2976,6 +_,8 @@
 				}
 			}
 		}
+		*/
+		Main.tile.ClearEverything();
 
 		for (int n = 0; n < Main.countsAsHostForGameplay.Length; n++) {
 			Main.countsAsHostForGameplay[n] = false;
@@ -3026,6 +_,9 @@
 
 		setWorldSize();
 		Star.SpawnStars();
+
+		SystemLoader.ClearWorld();
+
 		worldCleared = true;
 	}
 
@@ -4881,6 +_,14 @@
 		}
 	}
 
+	/// <summary>
+	/// Returns true if the provided tile coordinates are within the world bounds.
+	/// <para/>When dealing with random coordinates combined with addition or subtraction, there is a chance you might construct coordinates outside the bounds of the world. This will crash world generation, so it is important that you check that the coordinates are suitable before attempting to do things at those coordinates. Use this method to check if the given coordinates fall inside the world. The fluff parameter further checks that the coordinates are at least that many tiles away from the edge, which is useful for world generation actions that could affect large areas of tiles.
+	/// </summary>
+	/// <param name="x"></param>
+	/// <param name="y"></param>
+	/// <param name="fluff"></param>
+	/// <returns></returns>
 	public static bool InWorld(int x, int y, int fluff = 0)
 	{
 		if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
@@ -5231,17 +_,17 @@
 
 	private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
 	{
-		_generator.Append(new PassLegacy(name, method));
+		_vanillaGenPasses.Add(name, new PassLegacy(name, method));
 	}
 
 	private static void AddGenerationPass(GenPass pass)
 	{
-		_generator.Append(pass);
+		_vanillaGenPasses.Add(pass.Name, pass);
 	}
 
 	private static void AddGenerationPass(string name, double weight, WorldGenLegacyMethod method)
 	{
-		_generator.Append(new PassLegacy(name, method, weight));
+		_vanillaGenPasses.Add(name, new PassLegacy(name, method, weight));
 	}
 
 	public static bool checkUnderground(int x, int y)
@@ -5970,8 +_,12 @@
 			GenVars.desertHiveRight = x;
 	}
 
+	// TML: split into GenerateWorld, AddGenPasses (called at loadtime now and stored in a list), AddGenPassesFromLoadTime (the replacement for AddGenPasses in GenerateWorld), and GenerateWorld_RunTasksAndFinish
 	public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
 	{
+		// For timing logging, used below.
+		var generationStopwatch = Stopwatch.StartNew();
+
 		remixWorldGen = tempRemixWorldGen;
 		tenthAnniversaryWorldGen = tempTenthAnniversaryWorldGen;
 		drunkWorldGen = false;
@@ -6030,10 +_,13 @@
 		}
 
 		Main.zenithWorld = everythingWorldGen;
-		Console.WriteLine("Creating world - Seed: {0} Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", seed, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.expertMode);
+		Utils.LogAndConsoleInfoMessageFormat("Creating world - Seed: {0}, Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", seed, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.expertMode);
 		Main.lockMenuBGChange = true;
 		GenVars.configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
 		Hooks.ProcessWorldGenConfig(ref GenVars.configuration);
+
+		Logging.Terraria.InfoFormat("Generating World: {0}", Main.ActiveWorldFileData.Name);
+
 		_lastSeed = seed;
 		_generator = new WorldGenerator(seed, GenVars.configuration);
 		_genRand = new UnifiedRandom(seed);
@@ -6097,9 +_,18 @@
 		GenVars.logX = -1;
 		GenVars.logY = -1;
 		GenVars.dungeonLocation = 0;
+
+		SystemLoader.PreWorldGen();
+
 		if (everythingWorldGen)
 			Main.starGame = true;
 
+		AddGenPassesFromLoadTime();
+		GenerateWorld_RunTasksAndFinish(seed, generationStopwatch, customProgressObject);
+	}
+
+	internal static void AddGenPasses()
+	{
 		AddGenerationPass("Reset", delegate (GenerationProgress progress, GameConfiguration passConfig) {
 			if (genRand.Next(2) == 0)
 				GenVars.crimsonLeft = false;
@@ -7904,7 +_,10 @@
 					}
 
 					for (int num861 = num857; num861 < Main.maxTilesY; num861++) {
+						/*
 						Main.tile[num856, num861] = new Tile();
+						*/
+						Main.tile[num856, num861].Clear(TileDataType.All);
 						Main.tile[num856, num861].active(active: true);
 						Main.tile[num856, num861].type = 57;
 					}
@@ -9368,10 +_,11 @@
 						int num627 = 0;
 						while (!flag37 && num627 < 100) {
 							num627++;
+							// Extra patch context.
 							int num628 = genRand.Next(num613 - num618, num613 + num618 + 1);
 							int num629 = genRand.Next(num614 - num619, num614 + num619 - 2);
 							PlaceTile(num628, num629, 4, mute: true, forced: false, -1, 3);
-							if (Main.tile[num628, num629].type == 4)
+							if (TileID.Sets.Torch[Main.tile[num628, num629].type])
 								flag37 = true;
 						}
 
@@ -13065,12 +_,17 @@
 					if (TileID.Sets.BasicChest[Main.tile[num64, num65].type]) {
 						int num104 = Main.tile[num64, num65].frameX / 18;
 						int num105 = 0;
+						// Extra patch context.
 						ushort type2 = 21;
 						int num106 = num64;
 						int num107 = num65 - Main.tile[num64, num65].frameY / 18;
 						if (Main.tile[num64, num65].type == 467)
 							type2 = 467;
 
+						// Added to allow automatic fixing of modded chests
+						if (TileID.Sets.BasicChest[Main.tile[num64, num65].type])
+							type2 = Main.tile[num64, num65].type;
+
 						while (num104 >= 2) {
 							num105++;
 							num104 -= 2;
@@ -13255,12 +_,13 @@
 		});
 
 		AddGenerationPass("Micro Biomes", delegate (GenerationProgress progress, GameConfiguration passConfig) {
-			progress.Message = Lang.gen[76].Value;
+			progress.Message = Lang.gen[76].Value + "..Dead Man's Chests";
 			_ = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
 			double num36 = 10.0;
 			if (getGoodWorldGen || noTrapsWorldGen)
 				num36 *= 3.0;
 
+			// Extra patch context.
 			DeadMansChestBiome deadMansChestBiome = GenVars.configuration.CreateBiome<DeadMansChestBiome>();
 			List<int> possibleChestsToTrapify = deadMansChestBiome.GetPossibleChestsToTrapify(GenVars.structures);
 			int random = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(genRand);
@@ -13278,6 +_,7 @@
 				possibleChestsToTrapify.Remove(num39);
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Thin Ice";
 			progress.Set(1.0 / num36);
 			if (!notTheBees || remixWorldGen) {
 				ThinIceBiome thinIceBiome = GenVars.configuration.CreateBiome<ThinIceBiome>();
@@ -13300,6 +_,7 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Sword Shrines";
 			progress.Set(0.1);
 			progress.Set(2.0 / num36);
 			EnchantedSwordBiome enchantedSwordBiome = GenVars.configuration.CreateBiome<EnchantedSwordBiome>();
@@ -13327,9 +_,11 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Campsites";
 			progress.Set(0.2);
 			progress.Set(3.0 / num36);
 			if (!notTheBees || remixWorldGen) {
+				// Extra patch context.
 				CampsiteBiome campsiteBiome = GenVars.configuration.CreateBiome<CampsiteBiome>();
 				int random3 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(genRand);
 				num38 = 1000;
@@ -13344,6 +_,7 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Explosive Traps";
 			progress.Set(4.0 / num36);
 			if (!notTheBees || remixWorldGen) {
 				MiningExplosivesBiome miningExplosivesBiome = GenVars.configuration.CreateBiome<MiningExplosivesBiome>();
@@ -13368,6 +_,7 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Living Trees";
 			progress.Set(0.3);
 			progress.Set(5.0 / num36);
 			MahoganyTreeBiome mahoganyTreeBiome = GenVars.configuration.CreateBiome<MahoganyTreeBiome>();
@@ -13381,9 +_,11 @@
 				num51++;
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Long Minecart Tracks";
 			progress.Set(0.4);
 			progress.Set(6.0 / num36);
 			progress.Set(7.0 / num36);
+			// Extra patch context.
 			TrackGenerator trackGenerator = new TrackGenerator();
 			int random5 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
 			WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
@@ -13404,6 +_,7 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Standard Minecart Tracks";
 			progress.Set(8.0 / num36);
 			random5 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
 			worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
@@ -13423,11 +_,13 @@
 				}
 			}
 
+			progress.Message = Lang.gen[76].Value + "..Lava Traps";
 			progress.Set(9.0 / num36);
 			if (!notTheBees) {
 				double num55 = (double)Main.maxTilesX * 0.02;
 				if (noTrapsWorldGen)
 					num36 *= 5.0;
+				// Extra patch context.
 				else if (getGoodWorldGen)
 					num36 *= 2.0;
 
@@ -13803,7 +_,7 @@
 				int num19 = genRand.Next(minValue, maxValue);
 				int num20 = genRand.Next(minValue2, maxValue2);
 				Tile tile2 = Main.tile[num19, num20];
-				if (tile2.active() && tile2.type >= 0 && tile2.type < TileID.Count) {
+				if (tile2.active() && tile2.type >= 0) {
 					bool flag2 = TileID.Sets.Dirt[tile2.type];
 					if (notTheBees)
 						flag2 = flag2 || TileID.Sets.Mud[tile2.type];
@@ -13849,12 +_,35 @@
 			skipFramingDuringGen = false;
 			progress.Message = Lang.gen[87].Value;
 		});
+	}
+
+	private static void AddGenPassesFromLoadTime()
+	{
+		foreach (var pass in _vanillaGenPasses) {
+			pass.Value.Reset();
+			_generator.Append(pass.Value);
+		}
+	}
+
+	private static void GenerateWorld_RunTasksAndFinish(int seed, Stopwatch generationStopwatch, GenerationProgress customProgressObject)
+	{
+		SystemLoader.ModifyWorldGenTasks(_generator._passes, ref _generator._totalLoadWeight);
 
 		_generator.GenerateWorld(customProgressObject);
 		ConsumePostGenActions(GenVars.structures);
+
+		SystemLoader.PostWorldGen();
+
 		Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
+		Main.ActiveWorldFileData.modVersionsDuringWorldGen = ModLoader.ModLoader.Mods.ToDictionary(x => x.Name, x => x.Version);
 		Main.NotifyOfEvent(GameNotificationType.WorldGen);
 		drunkWorldGenText = false;
+
+		BackupIO.archiveLock = true;
+
+		generationStopwatch.Stop();
+
+		Logging.tML.Info($"Generation of {Main.maxTilesX}x{Main.maxTilesY} {(crimson ? "Crimson" : "Corruption")} world with seed {seed} completed in {generationStopwatch.Elapsed:m'm 's's 'fff'ms'}");
 	}
 
 	private static Point GetAdjustedFloorPosition(int x, int y)
@@ -14265,7 +_,7 @@
 
 	private static void PrefixItemFromOptions(Item item, int[] options)
 	{
-		byte prefix = item.prefix;
+		int prefix = item.prefix;
 		if (!item.Prefix(-3))
 			return;
 
@@ -15349,6 +_,17 @@
 	public static Point RandomRectanglePoint(Rectangle rectangle) => new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
 	public static Point RandomRectanglePoint(int x, int y, int width, int height) => new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
 	public static Point RandomWorldPoint(int padding) => RandomWorldPoint(padding, padding, padding, padding);
+	/// <summary>
+	/// Generates a random tile coordinate within the world bounds. The optional parameters define additional padding, avoiding the edges or defining a target area.
+	/// <para/> <c>Point point = WorldGen.RandomWorldPoint((int)Main.worldSurface, 40, 500, 60)</c> is equivalent to <code>int x = WorldGen.genRand.Next(60, Main.maxTilesX - 40);
+	/// int y = WorldGen.genRand.Next((int)Main.worldSurface, Main.maxTilesY - 500);
+	/// </code>
+	/// </summary>
+	/// <param name="top"></param>
+	/// <param name="right"></param>
+	/// <param name="bottom"></param>
+	/// <param name="left"></param>
+	/// <returns></returns>
 	public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0) => new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));
 
 	public static bool GrowPalmTree(int i, int y)
@@ -15357,7 +_,7 @@
 		if (!InWorld(i, y))
 			return false;
 
-		while (Main.tile[i, num].type == 20) {
+		while (TileID.Sets.TreeSapling[Main.tile[i, num].type]) {
 			num++;
 			if (Main.tile[i, num] == null)
 				return false;
@@ -15377,7 +_,11 @@
 		if (tile2.wall != 0 || tile2.liquid != 0)
 			return false;
 
+		bool vanillaCanGrow = true;
 		if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
+			vanillaCanGrow = false;
+		
+		if (!vanillaCanGrow && !TileLoader.CanGrowModPalmTree(tile.type))
 			return false;
 
 		if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
@@ -15442,10 +_,11 @@
 	public static bool GrowEpicTree(int i, int y)
 	{
 		int j;
-		for (j = y; Main.tile[i, j].type == 20; j++) {
+		for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 		}
 
+		//TML: Two CanGrowModTree inserted as ORs after 'type == 23'.
-		if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109)))) {
+		if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type))) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type))))) {
 			int num = 2;
 			if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20)) {
 				bool flag = false;
@@ -15672,10 +_,12 @@
 				int num5 = genRand.Next(3);
 				bool flag3 = false;
 				bool flag4 = false;
+
+				//TML: Again, two CanGrowModTree inserted as ORs after 'type == 23'.
-				if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
+				if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i - 1, j].type)))
 					flag3 = true;
 
-				if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
+				if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109 || TileLoader.CanGrowModTree(Main.tile[i + 1, j].type)))
 					flag4 = true;
 
 				if (!flag3) {
@@ -17443,7 +_,7 @@
 	{
 		int treeHeight = 1;
 		int passStyle = -1;
-		Tile topTile = null;
+		Tile topTile = default;
 		for (int num = -1; num > -100; num--) {
 			Tile tile = Main.tile[x, y + num];
 			if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
@@ -17655,14 +_,18 @@
 						case 17:
 							passStyle = num2 + 8;
 							break;
+							// Extra extra patch context.
 					}
 				}
 
 				passStyle += num;
 				treeHeight += 5;
+				// Extra patch context.
 				break;
 			}
 		}
+
+		PlantLoader.GetTreeLeaf(t.type, ref passStyle);
 	}
 
 	public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
@@ -17752,14 +_,17 @@
 			case 662:
 				return true;
 			default:
+				/*
 				return false;
+				*/
+				return TileLoader.CanGrowModTree(type);
 		}
 	}
 
 	public static bool GrowTree(int i, int y)
 	{
 		int j;
-		for (j = y; Main.tile[i, j].type == 20; j++) {
+		for (j = y; TileID.Sets.TreeSapling[Main.tile[i, j].type]; j++) {
 		}
 
 		if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
@@ -18172,7 +_,7 @@
 
 	public static bool DefaultTreeWallTest(int wallType)
 	{
-		if (wallType >= 0 && wallType < WallID.Count && WallID.Sets.AllowsPlantsToGrow[wallType])
+		if (wallType >= 0 && WallID.Sets.AllowsPlantsToGrow[wallType])
 			return true;
 
 		return false;
@@ -18921,10 +_,12 @@
 		int num6 = genRand.Next(3);
 		bool flag3 = false;
 		bool flag4 = false;
+
+		//TML: Again, two CanGrowModTree inserted as ORs after 'type == 23'.
-		if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
+		if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i - 1, y].type)))
 			flag3 = true;
 
-		if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
+		if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147 || TileLoader.CanGrowModTree(Main.tile[i + 1, y].type)))
 			flag4 = true;
 
 		if (!flag3) {
@@ -19251,9 +_,11 @@
 				}
 
 				if (flag) {
+					// Extra patch context.
 					if (TileID.Sets.CommonSapling[Main.tile[i, j].type])
 						break;
 
+					/*
 					switch (Main.tile[i, j].type) {
 						case 3:
 						case 24:
@@ -19280,6 +_,11 @@
 						case 655:
 							continue;
 					}
+					*/
+
+					// Be sure to keep this set updated with IDs from the above.
+					if (TileID.Sets.IgnoredByGrowingSaplings[Main.tile[i, j].type])
+						continue;
 
 					return false;
 				}
@@ -19325,6 +_,9 @@
 
 	public static void smCallBack(object threadContext)
 	{
+		// Parts of this method will be converted to tasks/passes.
+		var hardmodeTasks = new List<GenPass>();
+
 		IsGeneratingHardMode = true;
 		TryProtectingSpawnedItems();
 		if (Main.rand == null)
@@ -19358,7 +_,8 @@
 			num3 = (int)((double)Main.maxTilesX * (1.0 - num2));
 		}
 
-		if (Main.remixWorld) {
+		void HardmodeGoodRemixTask(GenerationProgress progress, GameConfiguration configuration)
+		{
 			int num7 = Main.maxTilesX / 7;
 			int num8 = Main.maxTilesX / 14;
 			if (Main.dungeonX < Main.maxTilesX / 2) {
@@ -19382,11 +_,44 @@
 				}
 			}
 		}
-		else {
+
+		void HardmodeGoodTask(GenerationProgress progress, GameConfiguration configuration)
+		{
 			GERunner(num3, 0, 3 * num5, 5.0);
+		}
+
+		void HardmodeEvilTask(GenerationProgress progress, GameConfiguration configuration)
+		{
 			GERunner(num4, 0, 3 * -num5, 5.0, good: false);
 		}
 
+		var HardmodeGoodRemixPass = new PassLegacy("Hardmode Good Remix", HardmodeGoodRemixTask);
+		var HardmodeGoodPass = new PassLegacy("Hardmode Good", HardmodeGoodTask);
+		var HardmodeEvilPass = new PassLegacy("Hardmode Evil", HardmodeEvilTask);
+
+		hardmodeTasks.Add(HardmodeGoodRemixPass);
+		hardmodeTasks.Add(HardmodeGoodPass);
+		hardmodeTasks.Add(HardmodeEvilPass);
+
+		// Main.remixWorld checks removed from Pass code, we want all passes present in the list no matter what and disable those that don't apply for consistency with other tModLoader approaches and modder expectations. #3606 discussion
+		if (Main.remixWorld) {
+			HardmodeGoodPass.Disable();
+			HardmodeEvilPass.Disable();
+		}
+		else {
+			HardmodeGoodRemixPass.Disable();
+		}
+
+		hardmodeTasks.Add(new PassLegacy("Hardmode Walls", HardmodeWallsTask));
+		hardmodeTasks.Add(new PassLegacy("Hardmode Announcement", HardmodeAnnouncementTask));
+
+		// Call the split end portion of the method.
+		smCallback_End(hardmodeTasks);
+	}
+
+	// Split from smCallback
+	private static void HardmodeWallsTask(GenerationProgress progress, GameConfiguration configuration)
+	{
 		double num9 = (double)Main.maxTilesX / 4200.0;
 		int num10 = (int)(25.0 * num9);
 		ShapeData shapeData = new ShapeData();
@@ -19416,13 +_,28 @@
 				shapeData.Clear();
 			}
 		}
+	}
 
+	// Split from smCallback
+	private static void HardmodeAnnouncementTask(GenerationProgress progress, GameConfiguration configuration)
+	{
 		if (Main.netMode == 0)
 			Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
 		else if (Main.netMode == 2)
 			ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
 
 		AchievementsHelper.NotifyProgressionEvent(9);
+	}
+
+	// Split from smCallback
+	private static void smCallback_End(List<GenPass> hardmodeTasks)
+	{
+		SystemLoader.ModifyHardmodeTasks(hardmodeTasks);
+
+		foreach (GenPass task in hardmodeTasks) {
+			task.Apply(null, null);
+		}
+
 		if (Main.netMode == 2)
 			Netplay.ResetSections();
 
@@ -19470,7 +_,7 @@
 
 		int frameX = Main.tile[i, j].frameX;
 		Tile tile = Main.tile[i, j];
-		if (tile.type != 11)
+		if (TileLoader.CloseDoorID(Main.tile[i, j]) < 0)
 			return false;
 
 		int num4 = tile.frameY;
@@ -19517,13 +_,15 @@
 			}
 		}
 
+		ushort closeDoorID = (ushort)TileLoader.CloseDoorID(tile);
+
 		for (int l = num7; l < num7 + 2; l++) {
 			for (int m = num3; m < num3 + 3; m++) {
 				if (l == num2) {
 					if (Main.tile[l, m] == null)
 						Main.tile[l, m] = new Tile();
 
-					Main.tile[l, m].type = 10;
+					Main.tile[l, m].type = closeDoorID;
 					Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
 				}
 				else {
@@ -19693,7 +_,7 @@
 						bool flag2 = false;
 						for (int k = num6 - 8; k < num6 + 8; k++) {
 							for (int l = num7 - 8; l < num7 + 8; l++) {
-								if (Main.tile[k, l].active() && Main.tile[k, l].type == 4) {
+								if (Main.tile[k, l].active() && TileID.Sets.Torch[Main.tile[k, l].type]) {
 									flag2 = true;
 									break;
 								}
@@ -25584,6 +_,18 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Attempts to place a chest and fill it with typical loot according to the style (<paramref name="Style"/>) and depth. Without any parameters, a regular, gold, or locked shadow chest will be created, depending on the depth. You can pass in an item type (<paramref name="contain"/>) and the first item in the chest will be that item. Unlike <see cref="PlaceChest(int, int, ushort, bool, int)"/>, the resulting chest will be placed with the bottom right corner at the given coordinates (<paramref name="i"/>, <paramref name="j"/>). In addition, if the given <paramref name="j"/> coordinate isn't suitable, AddBuriedChest will search down from the given coordinate to find the first solid tile it encounters and attempt to place there. This method returns true if a chest was successfully placed, but be aware that the chest might not be exactly at the coordinates you provide. This makes further adjusting the chest contents directly difficult.
+	/// <para/> A video guide can be found on the <see href="https://github.com/tModLoader/tModLoader/wiki/World-Generation#terrariaworldgen-public-static-void-tilerunnerint-i-int-j-double-strength-int-steps-int-type-bool-addtile--false-float-speedx--0f-float-speedy--0f-bool-noychange--false-bool-override--true">World Generation wiki page</see>. It shows an example of running the method with the default parameters <c>WorldGen.AddBuriedChest(x, y);</c>. Notice how the chest style changes according to depth and how the chest is placed on the floor directly below the provided coordinates if possible.
+	/// </summary>
+	/// <param name="i"></param>
+	/// <param name="j"></param>
+	/// <param name="contain"></param>
+	/// <param name="notNearOtherChests"></param>
+	/// <param name="Style"></param>
+	/// <param name="trySlope"></param>
+	/// <param name="chestTileType"></param>
+	/// <returns></returns>
 	public static bool AddBuriedChest(int i, int j, int contain = 0, bool notNearOtherChests = false, int Style = -1, bool trySlope = false, ushort chestTileType = 0)
 	{
 		if (chestTileType == 0)
@@ -26845,9 +_,10 @@
 			Main.tile[i, j] = new Tile();
 
 		Tile tile = Main.tile[i, j];
-		if (tile.type != 10)
+		if (TileLoader.OpenDoorID(tile) < 0)
 			return false;
 
+		// Extra patch context.
 		if (IsLockedDoor(tile))
 			return false;
 
@@ -26910,8 +_,12 @@
 
 		int num8 = num4 % 36 * 54;
 		SoundEngine.PlaySound(8, i * 16, j * 16);
+
+		// All instances of type 11 are replaced with this below.
+		ushort openDoorID = (ushort)TileLoader.OpenDoorID(Main.tile[i, j]);
+
 		Main.tile[num6, num].active(active: true);
-		Main.tile[num6, num].type = 11;
+		Main.tile[num6, num].type = openDoorID;
 		Main.tile[num6, num].frameY = (short)num8;
 		Main.tile[num6, num].frameX = num2;
 		Main.tile[num6, num].UseBlockColors(cache);
@@ -26919,7 +_,7 @@
 			Main.tile[num6 + 1, num] = new Tile();
 
 		Main.tile[num6 + 1, num].active(active: true);
-		Main.tile[num6 + 1, num].type = 11;
+		Main.tile[num6 + 1, num].type = openDoorID;
 		Main.tile[num6 + 1, num].frameY = (short)num8;
 		Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
 		Main.tile[num6 + 1, num].UseBlockColors(cache);
@@ -26927,7 +_,7 @@
 			Main.tile[num6, num + 1] = new Tile();
 
 		Main.tile[num6, num + 1].active(active: true);
-		Main.tile[num6, num + 1].type = 11;
+		Main.tile[num6, num + 1].type = openDoorID;
 		Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
 		Main.tile[num6, num + 1].frameX = num2;
 		Main.tile[num6, num + 1].UseBlockColors(cache2);
@@ -26935,7 +_,7 @@
 			Main.tile[num6 + 1, num + 1] = new Tile();
 
 		Main.tile[num6 + 1, num + 1].active(active: true);
-		Main.tile[num6 + 1, num + 1].type = 11;
+		Main.tile[num6 + 1, num + 1].type = openDoorID;
 		Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
 		Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
 		Main.tile[num6 + 1, num + 1].UseBlockColors(cache2);
@@ -26943,7 +_,7 @@
 			Main.tile[num6, num + 2] = new Tile();
 
 		Main.tile[num6, num + 2].active(active: true);
-		Main.tile[num6, num + 2].type = 11;
+		Main.tile[num6, num + 2].type = openDoorID;
 		Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
 		Main.tile[num6, num + 2].frameX = num2;
 		Main.tile[num6, num + 2].UseBlockColors(cache3);
@@ -26951,7 +_,7 @@
 			Main.tile[num6 + 1, num + 2] = new Tile();
 
 		Main.tile[num6 + 1, num + 2].active(active: true);
-		Main.tile[num6 + 1, num + 2].type = 11;
+		Main.tile[num6 + 1, num + 2].type = openDoorID;
 		Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
 		Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
 		Main.tile[num6 + 1, num + 2].UseBlockColors(cache3);
@@ -27008,10 +_,12 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, j, type);
 		for (int k = 0; k < num; k++) {
 			if (Main.tile[x, num5 + k].type == type)
 				KillTile(x, num5 + k);
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 92)
 			Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
@@ -27239,6 +_,7 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = 0; m < num4; m++) {
 			if (Main.tile[num, num6 + m].type == type)
 				KillTile(num, num6 + m);
@@ -27246,6 +_,7 @@
 			if (Main.tile[num + 1, num6 + m].type == type)
 				KillTile(num + 1, num6 + m);
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 104) {
 			int num7 = frameX / 36;
@@ -28467,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, TileID.ChristmasTree);
 		for (int k = num; k < num + 4; k++) {
 			for (int l = num2; l < num2 + 8; l++) {
 				if (Main.tile[k, l].type == 171)
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
 		destroyObject = false;
@@ -28819,7 +_,9 @@
 		if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
 			flag = true;
 
-		if (Main.tile[x, num].type == 20) {
+		if (TileID.Sets.TreeSapling[Main.tile[x, num].type]) {
+			int originalType = Main.tile[x, num].type;
+			int newType = TileID.Saplings;
 			int num5 = Main.tile[x, num].frameX / 54;
 			int type2 = Main.tile[x, num + 2].type;
 			int num6 = -1;
@@ -28861,12 +_,21 @@
 				case 633:
 					num6 = 10;
 					break;
+				case int _ when TileLoader.SaplingGrowthType(type2, ref newType, ref num6):
+					break;
 				default:
 					flag = true;
 					break;
 			}
 
+			/*
 			if (!flag && num5 != num6) {
+			*/
+			if (!flag && (originalType != newType || num5 != num6)) {
+				// Added by TML:
+				Main.tile[x, num].type = (ushort)newType;
+				Main.tile[x, num + 1].type = (ushort)newType;
+
 				int num7 = 54 * num6;
 				num7 += genRand.Next(3) * 18;
 				Main.tile[x, num].frameX = (short)num7;
@@ -28878,11 +_,13 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, j, type);
 		if (Main.tile[x, num].type == type)
 			KillTile(x, num);
 
 		if (Main.tile[x, num + 1].type == type)
 			KillTile(x, num + 1);
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 216)
 			Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 970 + num3);
@@ -29067,6 +_,7 @@
 			}
 
 			destroyObject = true;
+			bool drop = TileLoader.Drop(x, y, type);
 			for (int m = num; m < num2; m++) {
 				for (int n = num3; n < num4; n++) {
 					if (Main.tile[m, n].type == type)
@@ -29076,6 +_,7 @@
 
 			if (type != 395)
 				Sign.KillSign(num7, num8);
+			using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 			switch (type) {
 				case 85: {
@@ -29614,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = num4; k < num4 + 3; k++) {
 			for (int l = num6; l < num6 + 3; l++) {
 				if (Main.tile[k, l] != null && Main.tile[k, l].type == type && Main.tile[k, l].active())
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 240:
@@ -29853,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = num3; k < num3 + 2; k++) {
 			for (int l = num4; l < num4 + 3; l++) {
 				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 245) {
 			if (num >= 19 && num <= 28) {
@@ -29967,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = num4; k < num4 + 3; k++) {
 			for (int l = num3; l < num3 + 2; l++) {
 				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 246) {
 			switch (num) {
@@ -30077,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = num4; k < num4 + 4; k++) {
 			for (int l = num3; l < num3 + 3; l++) {
 				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 241)
 			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1417);
@@ -30150,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = num5; k < num5 + 6; k++) {
 			for (int l = num4; l < num4 + 4; l++) {
 				if (Main.tile[k, l].type == type && Main.tile[k, l].active())
 					KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 242) {
 			switch (num) {
@@ -30300,6 +_,7 @@
 
 	public static void Check1x1(int x, int y, int type)
 	{
+		// could put here, but there are probably other situations KillTile is called?
 		if (Main.tile[x, y + 1] != null) {
 			if (!SolidTileAllowBottomSlope(x, y + 1))
 				KillTile(x, y);
@@ -30923,10 +_,12 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, j, type);
 		for (int k = 0; k < 3; k++) {
 			if (Main.tile[x, num + k].type == type)
 				KillTile(x, num + k);
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 91) {
 			int num4 = frameX / 18;
@@ -31140,6 +_,7 @@
 		}
 
 		destroyObject = true;
+		using var _disableNewItem = new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type));
 		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
 		TEWeaponsRack.Kill(num, num2);
 		for (int m = 0; m < 3; m++) {
@@ -31247,6 +_,7 @@
 			return;
 
 		destroyObject = true;
+		using var _disableNewItem = new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type));
 		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
 		for (int m = 0; m <= 1; m++) {
 			for (int n = 0; n <= 2; n++) {
@@ -31300,6 +_,7 @@
 			return;
 
 		destroyObject = true;
+		using var _disableNewItem = new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, Main.tile[i, j].type));
 		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
 		for (int m = 0; m <= 1; m++) {
 			for (int n = 0; n <= 2; n++) {
@@ -31316,7 +_,7 @@
 	public static void Place1x2(int x, int y, ushort type, int style)
 	{
 		short frameX = 0;
-		if (type == 20)
+		if (TileID.Sets.TreeSapling[type])
 			frameX = (short)(genRand.Next(3) * 18);
 
 		if (Main.tile[x, y - 1] == null)
@@ -31411,11 +_,13 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, j, type);
 		if (Main.tile[x, num].type == type)
 			KillTile(x, num);
 
 		if (Main.tile[x, num + 1].type == type)
 			KillTile(x, num + 1);
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 42: {
@@ -31578,6 +_,15 @@
 		destroyObject = false;
 	}
 
+	/// <summary>
+	/// Places <see cref="TileID.SmallPiles"/> tiles. This tile is special and doesn't follow the normal style rules and won't place with PlaceTile. i and j are the coordinates. X and Y are the count and row indexes of the specific tile in the texture file. Indexes count from left to right and start at 0. So for example the Sapphire Stash would have Y=1 (second row) and X=21 (22nd 2x1 tile).
+	/// </summary>
+	/// <param name="i"></param>
+	/// <param name="j"></param>
+	/// <param name="X"></param>
+	/// <param name="Y"></param>
+	/// <param name="type"></param>
+	/// <returns></returns>
 	public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
 	{
 		short frameY = (short)(Y * 18);
@@ -31653,7 +_,7 @@
 
 			int num = tile.frameX / 18;
 			Tile tile2 = Main.tile[i, y + 1];
-			if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= TileID.Count)
+			if (tile2 == null || !tile2.active() || tile2.type < 0)
 				return;
 
 			ushort type = tile2.type;
@@ -31766,7 +_,7 @@
 			num5 += (tile.frameY / 18 - 1) * 52;
 			for (int j = num; j < num + 2; j++) {
 				Tile tile2 = Main.tile[j, y + 1];
-				if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= TileID.Count)
+				if (tile2 == null || !tile2.active() || tile2.type < 0)
 					continue;
 
 				ushort type2 = tile2.type;
@@ -31804,11 +_,13 @@
 			frameX = Main.tile[num + 1, y].frameX;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, y, type);
 		if (Main.tile[num, y].type == type)
 			KillTile(num, y);
 
 		if (Main.tile[num + 1, y].type == type)
 			KillTile(num + 1, y);
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 16) {
 			if (num3 == 1)
@@ -32180,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 4; m++) {
 			for (int n = num2; n < num2 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 79) {
 			int num6 = 0;
@@ -32560,8 +_,18 @@
 		}
 	}
 
+	// Overload added by TML. Least amount of parameters.
+	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out int type)
+		=> GetCactusType(tileX, tileY, frameX, frameY, out _, out _, out _, out type);
+
 	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson)
+		=> GetCactusType(tileX, tileY, frameX, frameY, out evil, out good, out crimson, out _);
+
+	//TML: Method split and a new overload with the 'type' parameter added in.
+	public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson, out int type)
 	{
+		type = 0;
+
 		evil = false;
 		good = false;
 		crimson = false;
@@ -32595,6 +_,8 @@
 			tile = Main.tile[num, num2];
 		}
 
+		type = tile.type;
+
 		if (tile.type == 112)
 			evil = true;
 
@@ -32810,6 +_,7 @@
 					NPC.SpawnOnPlayer(plr, 262);
 			}
 
+			using var _disableNewItem = new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, type));
 			if (type == 236)
 				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
 
@@ -32862,6 +_,7 @@
 
 		_ = Main.tile[i, j].frameX;
 		destroyObject = true;
+		TileLoader.Drop(i, j, type);
 		for (int num17 = num12; num17 < num12 + 3; num17++) {
 			for (int num18 = num11; num18 < num11 + 3; num18++) {
 				if (Main.tile[num17, num18] == null)
@@ -32996,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int num11 = 0; num11 < width; num11++) {
 			for (int num12 = 0; num12 < height; num12++) {
 				if (Main.tile[num2 + num11, num3 + num12].type == type && Main.tile[num2 + num11, num3 + num12].active())
 					KillTile(num2 + num11, num3 + num12);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		int num13 = 0;
 		if (type == 376) {
@@ -33181,7 +_,7 @@
 
 			ushort type2 = Main.tile[num2, num6 - 1].type;
 			ushort type3 = Main.tile[num2 + 1, num6 - 1].type;
-			if (!TileID.Sets.BasicChest[type2] && !TileID.Sets.BasicChest[type3] && type2 != 88 && type3 != 88 && !TileID.Sets.BasicChestFake[type2] && !TileID.Sets.BasicChestFake[type3] && type2 != 470 && type3 != 470 && type2 != 475 && type3 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
+			if (!TileID.Sets.BasicChest[type2] && !TileID.Sets.BasicChest[type3] && !TileID.Sets.BasicDresser[type2] && !TileID.Sets.BasicDresser[type3] && !TileID.Sets.BasicChestFake[type2] && !TileID.Sets.BasicChestFake[type3] && type2 != 470 && type3 != 470 && type2 != 475 && type3 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
 				flag = true;
 		}
 		else if (type == 132) {
@@ -33246,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int num12 = num2; num12 < num2 + 2; num12++) {
 			for (int num13 = num6; num13 < num6 + 2; num13++) {
 				if (Main.tile[num12, num13].type == type && Main.tile[num12, num13].active())
 					KillTile(num12, num13);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		int num14 = 0;
 		switch (type) {
@@ -33602,6 +_,15 @@
 		return true;
 	}
 
+	/// <summary>
+	/// Similar to <see cref="TileRunner(int, int, double, int, int, bool, double, double, bool, bool, int)"/>, but without many of the options. OreRunner places small splotches of the specified tile (<paramref name="type"/>) starting at the coordinates (<paramref name="i"/> and <paramref name="j"/> in tile coordinates). OreRunner only replaces active tiles (<see cref="Tile.HasTile"/>) that are either <see cref="TileID.Sets.CanBeClearedDuringOreRunner"/> or <see cref="Main.tileMoss"/>, making it suitable to be used even after FrameImportant tiles (<see cref="Main.tileFrameImportant"/>) exist in the world.
+	/// <para/> If you have a tile that should be susceptible to being replaced when additional ores are spawned in the world, set <see cref="TileID.Sets.CanBeClearedDuringOreRunner"/> to true for that ModTile. Vanilla code only uses this method when spawning hardmode ores. This method is suitable for use in-game and in multiplayer as it both frames and syncs tile changes.
+	/// </summary>
+	/// <param name="i"></param>
+	/// <param name="j"></param>
+	/// <param name="strength"></param>
+	/// <param name="steps"></param>
+	/// <param name="type"></param>
 	public static void OreRunner(int i, int j, double strength, int steps, ushort type)
 	{
 		double num = strength;
@@ -33636,7 +_,13 @@
 
 			for (int k = num3; k < num4; k++) {
 				for (int l = num5; l < num6; l++) {
+					// TML:
+					// Implementation of TileID.Sets.CanBeClearedDuringOreRunner,
+					// Be sure to keep it up to date via this awfully horizontal patch.
+					/*
 					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (Main.tile[k, l].type == 0 || Main.tile[k, l].type == 1 || Main.tile[k, l].type == 23 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 40 || Main.tile[k, l].type == 53 || Main.tile[k, l].type == 57 || Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 117 || Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 164 || Main.tileMoss[Main.tile[k, l].type] || Main.tile[k, l].type == 199 || Main.tile[k, l].type == 200 || Main.tile[k, l].type == 203 || Main.tile[k, l].type == 234 || Main.tile[k, l].type == 396 || Main.tile[k, l].type == 397 || Main.tile[k, l].type == 401 || Main.tile[k, l].type == 403 || Main.tile[k, l].type == 400 || Main.tile[k, l].type == 398 || Main.tile[k, l].type == 399 || Main.tile[k, l].type == 402 || (Main.remixWorld && Main.tile[k, l].type == 230) || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
+					*/
+					if (Math.Abs((double)k - vector2D.X) + Math.Abs((double)l - vector2D.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (TileID.Sets.CanBeClearedDuringOreRunner[Main.tile[k, l].type] || (Main.remixWorld && Main.tile[k, l].type == 230) || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108))) {
 						Main.tile[k, l].type = type;
 						Main.tile[k, l].ClearBlockPaintAndCoating();
 						SquareTileFrame(k, l);
@@ -33829,7 +_,7 @@
 			if (Main.tile[k, j - 1] == null)
 				Main.tile[k, j - 1] = new Tile();
 
-			if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || Main.tile[k, j - 1].type == 88 || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
+			if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || TileID.Sets.BasicDresser[Main.tile[k, j - 1].type]  || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
 				return;
 
 			if (!SolidTileAllowBottomSlope(k, j + 1))
@@ -33841,6 +_,7 @@
 
 		_ = Main.tile[i, j].frameX;
 		destroyObject = true;
+		using var _disableNewItem = new Item.DisableNewItemMethod(!TileLoader.Drop(i, j, type));
 		if (type == 235)
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
 
@@ -33909,7 +_,10 @@
 						if (Main.tile[k, num8] != null && Main.tile[k, num8].active())
 							num9 = Main.tile[k, num8].type;
 
+						/*
 						if (num9 != 2 && num9 != 477 && num9 != 109 && num9 != 492)
+						*/
+						if (!TileObjectData.GetTileData(488, 0).AnchorValidTiles.Contains(num9))
 							flag = true;
 
 						break;
@@ -34038,6 +_,7 @@
 		if (flag2)
 			num8--;
 
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int num10 = num5; num10 < num5 + 3; num10++) {
 			for (int num11 = num; num11 < num + 3; num11++) {
 				if (Main.tile[num10, num11] == null)
@@ -34047,6 +_,7 @@
 					KillTile(num10, num11);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 14) {
 			int type2;
@@ -34734,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 3; m++) {
 			for (int n = num2; n < num2 + 4; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 101: {
@@ -34942,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 5; m++) {
 			for (int n = num2; n < num2 + 4; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 464)
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
@@ -34994,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 6; m++) {
 			for (int n = num2; n < num2 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 275)
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
@@ -35444,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 4; m++) {
 			for (int n = num3; n < num3 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		int type2 = 928;
 		switch (num2) {
@@ -35569,7 +_,7 @@
 				if (Main.tile[k, l] == null)
 					Main.tile[k, l] = new Tile();
 
-				if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35)) {
+				if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35 || TileLoader.IsModMusicBox(Main.tile[k, l]))) {
 					if (Main.tile[k, l].frameX < 36)
 						Main.tile[k, l].frameX += 36;
 					else
@@ -35742,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 2; m++) {
 			for (int n = num2; n < num2 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 35)
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
@@ -36004,8 +_,10 @@
 
 	public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1)
 	{
+		/*
 		if (type >= TileID.Count)
 			return false;
+		*/
 
 		if (!TileObject.CanPlace(x, y, type, style, direction, out var objectData))
 			return false;
@@ -36172,11 +_,13 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int i = x; i < x + num; i++) {
 			for (int j = y; j < y + num2; j++) {
 				KillTile(i, j);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		int type2 = 3239;
 		if (point.Y == 0)
@@ -36226,11 +_,13 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(x, y, type);
 		for (int k = x; k < x + width; k++) {
 			for (int l = y; l < y + height; l++) {
 				KillTile(k, l);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		int type2 = 3240;
 		if (point.Y == 0)
@@ -36589,7 +_,7 @@
 			}
 		}
 
-		if (type == 88) {
+		if (TileID.Sets.BasicDresser[type]) {
 			if (Chest.CreateChest(x - 1, y - 1) == -1)
 				flag2 = false;
 			else if (Main.netMode == 1)
@@ -36771,6 +_,7 @@
 
 		int frameX = Main.tile[i, j].frameX;
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num3; m < num3 + 2; m++) {
 			for (int n = num; n < num + 2; n++) {
 				if (Main.tile[m, n] == null)
@@ -36780,6 +_,7 @@
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 254:
@@ -37029,7 +_,10 @@
 					flag = false;
 			}
 
+			/*
 			if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
+			*/
+			if (!SolidTile(i, superY + 1) || !TileObjectData.GetTileData(type, 0).AnchorValidTiles.Contains(Main.tile[i, superY + 1].type) || TileID.Sets.Conversion.GolfGrass[Main.tile[i, superY + 1].type])
 				flag = false;
 		}
 
@@ -37086,7 +_,10 @@
 					flag = true;
 			}
 
+			/*
 			if (!SolidTile(k, num + 2) || (Main.tile[k, num + 2].type != 2 && Main.tile[k, num + 2].type != 477 && Main.tile[k, num + 2].type != 492 && Main.tile[k, num + 2].type != 109))
+			*/
+			if (!SolidTile(k, num + 2) || !TileObjectData.GetTileData(type, 0).AnchorValidTiles.Contains(Main.tile[k, num + 2].type))
 				flag = true;
 		}
 
@@ -37366,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + num3; m++) {
 			for (int n = num2; n < num2 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 454) {
 			switch (Main.rand.Next(9)) {
@@ -37649,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int n = num; n < num + 3; n++) {
 			for (int num8 = num2; num8 < num2 + 3; num8++) {
 				if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
 					KillTile(n, num8);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 106:
@@ -37809,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int n = num; n < num + 2; n++) {
 			for (int num7 = num2; num7 < num2 + 5; num7++) {
 				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
 					KillTile(n, num7);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (type) {
 			case 547:
@@ -37880,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int n = num; n < num + 3; n++) {
 			for (int num7 = num2; num7 < num2 + 5; num7++) {
 				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
 					KillTile(n, num7);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 613)
 			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4904 + num3);
@@ -37945,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int n = num; n < num + 3; n++) {
 			for (int num7 = num2; num7 < num2 + 6; num7++) {
 				if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
 					KillTile(n, num7);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (type == 548) {
 			if (num3 >= 7)
@@ -38164,7 +_,10 @@
 			if (Main.tile[k, num2 + 4] == null)
 				Main.tile[k, num2 + 4] = new Tile();
 
+			/*
 			if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 477 && Main.tile[k, num2 + 4].type != 492 && Main.tile[k, num2 + 4].type != 109 && Main.tile[k, num2 + 4].type != 60 && Main.tile[k, num2 + 4].type != 633))
+			*/
+			if (!Main.tile[k, num2 + 4].nactive() || !TileObjectData.GetTileData(type, 0).AnchorValidTiles.Contains(Main.tile[k, num2 + 4].type))
 				flag = true;
 
 			if (!SolidTile(k, num2 + 4))
@@ -38175,12 +_,14 @@
 			return;
 
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 2; m++) {
 			for (int n = num2; n < num2 + 4; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 63);
 		destroyObject = false;
@@ -38273,11 +_,13 @@
 
 		if (flag) {
 			destroyObject = true;
+			bool drop = TileLoader.Drop(x, j, num);
 			if (tileSafely.type == num)
 				KillTile(x, num2);
 
 			if (tileSafely2.type == num)
 				KillTile(x, num2 + 1);
+			using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 			Item.NewItem(GetItemSource_FromTileBreak(x, num2), x * 16, num2 * 16, 16, 32, 4609);
 			destroyObject = false;
@@ -38407,7 +_,7 @@
 			}
 		}
 
-		if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234)) {
+		if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[num2, num].type))) {
 			KillTile(i, j);
 			return true;
 		}
@@ -38418,7 +_,7 @@
 				return true;
 			}
 		}
-		else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234))) {
+		else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234 && !TileLoader.CanGrowModCactus(Main.tile[i, j + 1].type)))) {
 			KillTile(i, j);
 			return true;
 		}
@@ -38477,12 +_,14 @@
 		if (!destroyObject)
 			return;
 
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 2; m++) {
 			for (int n = num2; n < num2 + 2; n++) {
 				if (Main.tile[m, n] != null && Main.tile[m, n].type == type)
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		if (Main.netMode != 1 && !noTileActions) {
 			switch (type) {
@@ -38616,6 +_,9 @@
 		if (num2 == 112)
 			num2 = 53;
 
+		if (TileLoader.CanGrowModPalmTree(num2))
+			num2 = 53;
+
 		if (num2 != 53 && num2 != type)
 			KillTile(i, j);
 
@@ -39001,6 +_,9 @@
 		if (num4 == 492)
 			num4 = 2;
 
+		if (TileLoader.CanGrowModTree(num4))
+			num4 = 2;
+
 		if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
 			KillTile(i, j);
 
@@ -39303,7 +_,7 @@
 
 	public static bool TryKillingTreesAboveIfTheyWouldBecomeInvalid(int i, int j, int newFloorType)
 	{
-		if (newFloorType < 0 || newFloorType >= TileID.Count)
+		if (newFloorType < 0)
 			return false;
 
 		if (!InWorld(i, j, 2))
@@ -39342,6 +_,28 @@
 		return true;
 	}
 
+	/// <summary>
+	/// Converts biome variant tiles and walls to a target biome.<br/>
+	/// Converts a 9x9 square by default, but can be adjusted with the <paramref name="size"/> parameter.
+	/// </summary>
+	/// <remarks>
+	/// For an easily-viewable usage example, refer to the code for projectile AI style 31 (used for the Clentaminator's solutions).
+	/// </remarks>
+	/// <param name="i">The X coordinate of the target tile.</param>
+	/// <param name="j">The Y coordinate of the target tile.</param>
+	/// <param name="conversionType">The biome that you wish to convert to. See <see cref="BiomeConversionID"/>
+	/// Setting this to 0 (Purity) returns affected tiles to their default states (e.g. Ebonstone, Crimstone, and Pearlstone will be converted back into normal Stone Blocks).<br/>
+	/// </param>
+	/// <param name="size">
+	/// When using this method to convert tiles, a square centered on the target tile is converted into those of the target biome.<br/>
+	/// This optional parameter, which defaults to 4, determines the "radius" of that square in tiles, counting outward from the central tile.<br/>
+	/// Set to 0 if you only want to convert a single tile. In other cases, use this parameter wisely.
+	/// </param>
+	/*
+	TO-DO:
+	- ConvertTIle utility method which consolidates the three lines used for most conversions into a single call
+	- modder-friendliness extension; see #2738
+	*/
 	public static void Convert(int i, int j, int conversionType, int size = 4)
 	{
 		for (int k = i - size; k <= i + size; k++) {
@@ -39354,7 +_,7 @@
 				int wall = tile.wall;
 				switch (conversionType) {
 					case 4:
-						if (type <= TileID.Count && wall <= WallID.Count) {
+						if (type <= TileLoader.TileCount && wall <= WallLoader.WallCount) {
 							if (WallID.Sets.Conversion.Grass[wall] && wall != 81) {
 								tile.wall = 81;
 								SquareWallFrame(k, l);
@@ -39444,7 +_,7 @@
 						}
 						continue;
 					case 2:
-						if (type > TileID.Count || wall > WallID.Count)
+						if (type >= TileLoader.TileCount || wall >= WallLoader.WallCount)
 							continue;
 						if (WallID.Sets.Conversion.Grass[wall] && wall != 70) {
 							tile.wall = 70;
@@ -39538,7 +_,7 @@
 						}
 						continue;
 					case 1:
-						if (type <= TileID.Count && wall <= WallID.Count) {
+						if (type <= TileLoader.TileCount && wall <= WallLoader.WallCount) {
 							if (WallID.Sets.Conversion.Grass[wall] && wall != 69) {
 								tile.wall = 69;
 								SquareWallFrame(k, l);
@@ -39645,7 +_,7 @@
 						}
 						continue;
 					case 5:
-						if (type < 0 || type > TileID.Count || wall < 0 || wall > WallID.Count)
+						if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
 							continue;
 						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187) {
 							tile.wall = 187;
@@ -39685,7 +_,7 @@
 						}
 						continue;
 					case 6:
-						if (type < 0 || type > TileID.Count || wall < 0 || wall > WallID.Count)
+						if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
 							continue;
 						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71) {
 							tile.wall = 71;
@@ -39716,7 +_,7 @@
 						}
 						continue;
 					case 7:
-						if (type < 0 || type > TileID.Count || wall < 0 || wall > WallID.Count)
+						if (type < 0 || type >= TileLoader.TileCount || wall < 0 || wall >= WallLoader.WallCount)
 							continue;
 						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 1) {
 							tile.wall = 1;
@@ -40114,7 +_,7 @@
 		if ((!Main.remixWorld || !((double)j > Main.worldSurface)) && num3 / 255 > cactusWaterLimit)
 			return;
 
-		if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234) {
+		if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234 || TileLoader.CanGrowModCactus(Main.tile[i, j].type)) {
 			if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
 				return;
 
@@ -40132,7 +_,7 @@
 								return;
 						}
 
-						if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234)
+						if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234 || TileLoader.CanGrowModCactus(Main.tile[m, n].type))
 							num5++;
 					}
 					catch {
@@ -40309,12 +_,14 @@
 		else
 			SoundEngine.PlaySound(13, i * 16, j * 16);
 
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 2; m++) {
 			for (int n = num2; n < num2 + 2; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active())
 					KillTile(m, n);
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		switch (num4) {
 			case 0:
@@ -40927,6 +_,19 @@
 		}
 	}
 
+	/// <summary>
+	/// Attempts to place a chest at the given tile coordinates. The coordinate provided (<paramref name="x"/>, <paramref name="y"/>) will be the bottom left corner of the resulting chest, if the method succeeds. <paramref name="type"/> is the tile type to place, and <paramref name="style"/> is the tile style to place.
+	/// <para/> For vanilla chests, you can count from zero starting from the left in the <c>Tiles_21.png</c> image after <see href="https://github.com/tModLoader/tModLoader/wiki/Intermediate-Prerequisites#vanilla-texture-file-reference">extracting the vanilla textures</see> to find the style you want to place. Another option is to follow the <see href="https://github.com/tModLoader/tModLoader/wiki/Vanilla-Content-IDs#tile-ids">Tile IDs wiki guide</see> to find the style.
+	/// <para/> <paramref name="notNearOtherChests"/> can be set to true to prevent the chest from placing if another chest exists within 25 tiles left or right and 8 tiles up or down. This method returns the chest index (the index within <see cref="Main.chest"/>) of the chest that was successfully placed or -1 if placing the chest failed. Chest placement can fail for many reasons, such as if existing tiles block the space, or if there isn't 2 suitable solid tiles directly below the intended location.
+	/// <para/> See the <see href="https://github.com/tModLoader/tModLoader/wiki/World-Generation#try-until-success">"Try Until Success" section of the World Generation wiki guide</see> for an approach to using this method. See the <see href="https://github.com/tModLoader/tModLoader/wiki/World-Generation#try-until-success">"Placing Items in Chests" section of the World Generation wiki guide</see> for info on placing items in the chest.
+	/// <para/> The <see cref="AddBuriedChest(int, int, int, bool, int, bool, ushort)"/> method places a chest and fills it with the default items for that chest.
+	/// </summary>
+	/// <param name="x"></param>
+	/// <param name="y"></param>
+	/// <param name="type"></param>
+	/// <param name="notNearOtherChests"></param>
+	/// <param name="style"></param>
+	/// <returns></returns>
 	public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
 	{
 		int num = -1;
@@ -40953,9 +_,16 @@
 		if (num != -1 && Main.netMode == 1 && type == 467)
 			NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
 
+		// Mod chest sync?
+		if (num != 1 && Main.netMode == 1 && type >= TileID.Count && TileID.Sets.BasicChest[type])
+			NetMessage.SendData(34, -1, -1, null, 100, x, y, style, 0, type, 0);
+
 		return num;
 	}
 
+	/// <summary>
+	/// Used for network syncing. Modders should use <see cref="PlaceChest(int, int, ushort, bool, int)"/> if attempting to place a chest.
+	/// </summary>
 	public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
 	{
 		Chest.CreateChest(x, y - 1, id);
@@ -41066,6 +_,7 @@
 
 		int chestItemDrop = GetChestItemDrop(i, j, type);
 		destroyObject = true;
+		bool drop = TileLoader.Drop(i, j, type);
 		for (int m = num; m < num + 2; m++) {
 			for (int n = num2; n < num2 + 3; n++) {
 				if (Main.tile[m, n].type == type && Main.tile[m, n].active()) {
@@ -41074,6 +_,7 @@
 				}
 			}
 		}
+		using var _disableNewItem = new Item.DisableNewItemMethod(!drop);
 
 		Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, chestItemDrop);
 		destroyObject = false;
@@ -42131,14 +_,30 @@
 		return false;
 	}
 
+	/// <summary>
+	/// PlaceTile is the main way to place individual tiles while obeying anchor considerations. Most of the other PlaceX methods in the WorldGen class are called by this method. i and j are the tile coordinates. These coordinates relate to the origin of the tile, not necessarily the top left corner of the tile. Read <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Tile">the Basic Tile wiki guide</see> to familiarize yourself with the concepts of Anchors and Origins. <paramref name="mute"/> indicates if a sound should be made, this only applies to in-game usage as sounds are all muted during world gen. <paramref name="forced"/> attempts to place the tile even if other tiles are already at the coordinates, but it is unreliable. <paramref name="plr"/> does nothing except affect bathtubs. <paramref name="style"/> refers to the style of the tile type provided. Styles are explained in the Basic Tile guide.
+	/// <para/> PlaceTile returns a bool indicating placement success. Unfortunately, it doesn't work, don't use it. Checking the coordinates after calling PlaceTile is a good way to check if the placement was a success: <c>if(Main.tile[x, y].type == TileID.Campfire)</c>
+	/// <para/> PlaceTile doesn't expose everything. For example, attempting to place a tile with a specific style will be ignored by many of the underlying methods. Another issue is that it is impossible to place a tile that has left and right placement orientations facing right. In these situations, you might need to manually place each tile in the multitile or use <see cref="PlaceObject(int, int, int, bool, int, int, int, int)"/> instead. WorldGen.PlaceObject requires more input. For example, placing Coral with PlaceObject means you have to manually specify the style, as the random style (<see cref="TileObjectData.RandomStyleRange"/>) choosing is a feature of PlaceTile.
+	/// <para/> If called in-game, the changed tiles would need to be synced if placement is successful. See <see cref="NetMessage.SendTileSquare(int, int, int, int, int, TileChangeType)"/> for more information and examples.
+	/// </summary>
+	/// <param name="i"></param>
+	/// <param name="j"></param>
+	/// <param name="Type"></param>
+	/// <param name="mute"></param>
+	/// <param name="forced"></param>
+	/// <param name="plr"></param>
+	/// <param name="style"></param>
+	/// <returns></returns>
 	public static bool PlaceTile(int i, int j, int Type, bool mute = false, bool forced = false, int plr = -1, int style = 0)
 	{
 		int num = Type;
 		if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
 			return false;
 
+		/*
 		if (num >= TileID.Count)
 			return false;
+		*/
 
 		bool result = false;
 		if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY) {
@@ -42238,8 +_,12 @@
 							if (style != 8 && style != 11 && style != 17)
 								return false;
 							break;
+						case int _ when TileID.Sets.Torch[num]:
+							if (TileObjectData.GetTileData(num, style).WaterPlacement != LiquidPlacement.Allowed)
+								return false;
+							break;
 						case 3:
-						case 20:
+						case int _ when TileID.Sets.TreeSapling[num]:
 						case 24:
 						case 27:
 						case 32:
@@ -42313,7 +_,7 @@
 
 							tile.frameX = (short)(num2 * 18);
 						}
-						else if (tile.wall >= 0 && tile.wall < WallID.Count && WallID.Sets.AllowsPlantsToGrow[tile.wall] && Main.tile[i, j + 1].wall >= 0 && Main.tile[i, j + 1].wall < WallID.Count && WallID.Sets.AllowsPlantsToGrow[Main.tile[i, j + 1].wall]) {
+						else if (tile.wall >= 0 && WallID.Sets.AllowsPlantsToGrow[tile.wall] && Main.tile[i, j + 1].wall >= 0 && Main.tile[i, j + 1].wall < WallLoader.WallCount && WallID.Sets.AllowsPlantsToGrow[Main.tile[i, j + 1].wall]) {
 							if (genRand.Next(50) == 0 || ((num == 24 || num == 201) && genRand.Next(40) == 0)) {
 								tile.active(active: true);
 								tile.type = (ushort)num;
@@ -42505,7 +_,7 @@
 						SquareTileFrame(i, j);
 					}
 				}
-				else if (num == 4) {
+				else if (TileID.Sets.Torch[num]) {
 					if (Main.tile[i - 1, j] == null)
 						Main.tile[i - 1, j] = new Tile();
 
@@ -42641,7 +_,7 @@
 						case 26:
 						case 86:
 						case 87:
-						case 88:
+						case int _ when TileID.Sets.BasicDresser[num]:
 						case 89:
 						case 114:
 						case 186:
@@ -42662,13 +_,15 @@
 							PlaceJunglePlant(i, j, (ushort)num, 0, 0);
 							SquareTileFrame(i, j);
 							break;
-						case 20: {
+						case int _ when TileID.Sets.TreeSapling[num]: {
 							if (Main.tile[i, j + 1] == null)
 								Main.tile[i, j + 1] = new Tile();
 
 							int type = Main.tile[i, j + 1].type;
+							int dummyType = TileID.Saplings;
+							int dummyStyle = 0;
-							if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112)) {
+							if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112 || TileLoader.SaplingGrowthType(type, ref dummyType, ref dummyStyle))) {
-								Place1x2(i, j, (ushort)num, style);
+								Place1x2(i, j, (ushort)dummyType, dummyStyle);
 								SquareTileFrame(i, j);
 							}
 
@@ -42866,6 +_,9 @@
 										case 314:
 											Minecart.PlaceTrack(tile, style);
 											break;
+										case int _ when num >= TileID.Count && TileObjectData.GetTileData(num, style) != null:
+											PlaceObject(i, j, (ushort)num, mute, style);
+											break;
 										default:
 											tile.active(active: true);
 											tile.type = (ushort)num;
@@ -42885,7 +_,8 @@
 
 					SquareTileFrame(i, j);
 					result = true;
-					if (!mute) {
+					//TML: To fix a number of errors post-sound-rework, tile placements are now automagically muted during initial worldgen.
+					if (!mute && !generatingWorld) {
 						switch (num) {
 							case 127:
 								SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
@@ -42932,10 +_,15 @@
 			return;
 
 		fail = KillWall_CheckFailure(fail, tile);
+
+		WallLoader.KillWall(i, j, tile.wall, ref fail);
+
-		KillWall_PlaySounds(i, j, tile);
+		KillWall_PlaySounds(i, j, tile, fail);
 		int num = 10;
 		if (fail)
 			num = 3;
+
+		WallLoader.NumDust(i, j, tile.wall, fail, ref num);
 
 		for (int k = 0; k < num; k++) {
 			KillWall_MakeWallDust(i, j, tile);
@@ -42950,7 +_,7 @@
 		tile.wall = 0;
 		tile.ClearWallPaintAndCoating();
 		SquareWallFrame(i, j);
-		if (tile.type >= 0 && tile.type < TileID.Count && TileID.Sets.FramesOnKillWall[tile.type])
+		if (tile.type >= 0 && TileID.Sets.FramesOnKillWall[tile.type])
 			TileFrame(i, j);
 	}
 
@@ -42965,8 +_,12 @@
 		return fail;
 	}
 
-	private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
+	//TML: Added 'fail' parameter.
+	private static void KillWall_PlaySounds(int i, int j, Tile tileCache, bool fail = false)
 	{
+		if (!WallLoader.KillSound(i, j, tileCache.wall, fail))
+			return;
+
 		if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
 			SoundEngine.PlaySound(13, i * 16, j * 16);
 		else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
@@ -42978,7 +_,7 @@
 	private static void KillWall_DropItems(int i, int j, Tile tileCache)
 	{
 		int num = KillWall_GetItemDrops(tileCache);
-		if (num > 0)
+		if (WallLoader.Drop(i, j, Main.tile[i,j].wall, ref num) && num > 0)
 			Item.NewItem(GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, num);
 	}
 
@@ -44268,6 +_,12 @@
 		if (tileCache.wall == 245)
 			num = 195;
 
+		if (WallLoader.GetWall(tileCache.wall) is ModWall modWall)
+			num = modWall.DustType;
+
+		if (!WallLoader.CreateDust(i, j, tileCache.wall, ref num))
+			return;
+
 		if (tileCache.wall == 44 || tileCache.wall == 346) {
 			int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
 			Main.dust[num2].noGravity = true;
@@ -44346,11 +_,14 @@
 			return false;
 
 		Tile tile = Main.tile[i, j];
-		Tile tile2 = null;
+		Tile tile2 = default;
 		if (tile == null)
 			return false;
 
 		if (!tile.active())
+			return false;
+
+		if (!TileLoader.CanKillTile(i, j, tile.type, ref blockDamaged))
 			return false;
 
 		if (j >= 1)
@@ -44373,6 +_,8 @@
 				case 88:
 				case 467:
 				case 488:
+				case int _ when TileID.Sets.BasicDresser[type]:
+				case int _ when TileID.Sets.BasicChest[type]:
 					if (tile.type != type)
 						return false;
 					break;
@@ -44410,12 +_,18 @@
 
 				break;
 			}
+			/*
 			case 21:
 			case 467:
+			*/
+			case var t when TileID.Sets.BasicChest[t]:
 				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
 					return false;
 				break;
+			/*
 			case 88:
+			*/
+			case var t when TileID.Sets.BasicDresser[t]:
 				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
 					return false;
 				break;
@@ -44553,7 +_,7 @@
 				return true;
 		}
 
-		if (tile.type == 88) {
+		if (TileID.Sets.BasicDresser[tile.type]) {
 			int num2 = tile.frameX / 18;
 			int y3 = y - tile.frameY / 18;
 			num2 %= 3;
@@ -44573,7 +_,7 @@
 
 	public static bool ReplaceWall(int x, int y, ushort targetWall)
 	{
-		if (targetWall >= WallID.Count)
+		if (targetWall >= WallLoader.WallCount)
 			return false;
 
 		Tile tile = Main.tile[x, y];
@@ -44606,7 +_,7 @@
 			return false;
 
 		MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
-		int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
+		int num = KillTile_GetTileDustAmount(fail: false, tileSafely, x, y);
 		for (int i = 0; i < num; i++) {
 			KillTile_MakeTileDust(x, y, tileSafely);
 		}
@@ -44631,7 +_,7 @@
 		else if (TileID.Sets.BasicDresser[targetType]) {
 			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
 		}
-		else if (targetType == 215) {
+		else if (TileID.Sets.Campfire[targetType]) {
 			ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
 		}
 		else {
@@ -44647,7 +_,7 @@
 		if (TileID.Sets.Platforms[t.type])
 			t.frameY = (short)(targetStyle * 18);
 
-		if (t.type == 4)
+		if (TileID.Sets.Torch[t.type])
 			t.frameY = (short)(targetStyle * 22);
 
 		t.ClearBlockPaintAndCoating();
@@ -44663,6 +_,7 @@
 		if (Main.tenthAnniversaryWorld && !Main.remixWorld && (targetType == 53 || targetType == 396 || targetType == 397))
 			t.color(7);
 
+		TileFrame(topLeftX, topLeftY); // Fix #2835: block to platform swap under chest using old frameX and breaking chest because it sees the platform as a stair.
 		SquareTileFrame(topLeftX, topLeftY);
 	}
 
@@ -44708,7 +_,7 @@
 			y -= t.frameY % 36 / 18;
 		}
 
-		if (t.type == 215) {
+		if (TileID.Sets.Campfire[t.type]) {
 			x -= t.frameX % 54 / 18;
 			y -= t.frameY % 36 / 18;
 		}
@@ -44729,7 +_,7 @@
 	public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
 	{
 		Tile tile = Main.tile[x, y];
-		if (attemptingToReplaceWith >= TileID.Count)
+		if (attemptingToReplaceWith >= TileLoader.TileCount)
 			return false;
 
 		if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith] || attemptingToReplaceWith == 633)
@@ -44750,7 +_,7 @@
 		bool flag3 = !ReplaceTile_IsValidCampfire(attemptingToReplaceWith) || !ReplaceTile_IsValidCampfire(tile.type);
 		bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
 		bool flag4 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
-		bool flag5 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
+		bool flag5 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(x, y, tile);
 		bool flag6 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
 		return !(num && flag2 && flag3 && flag && flag4 && flag5 && flag6);
 	}
@@ -44767,8 +_,8 @@
 		return false;
 	}
 
-	private static bool ReplaceTile_IsValidTorch(int type) => type == 4;
-	private static bool ReplaceTile_IsValidCampfire(int type) => type == 215;
+	private static bool ReplaceTile_IsValidTorch(int type) => TileID.Sets.Torch[type];
+	private static bool ReplaceTile_IsValidCampfire(int type) => TileID.Sets.Campfire[type];
 	private static bool ReplaceTile_IsValidChest(int type) => TileID.Sets.BasicChest[type];
 	private static bool ReplaceTile_IsValidDresser(int type) => TileID.Sets.BasicDresser[type];
 	private static bool ReplaceTile_IsValidPlatform(int type) => TileID.Sets.Platforms[type];
@@ -44973,14 +_,26 @@
 					else if (i % 3 == 1) {
 						treeFrame += 3;
 					}
+					// Extra patch context.
 					else if (i % 3 == 2) {
 						treeFrame += 6;
 					}
 
 					return true;
 				}
+				default:
+					var tree = PlantLoader.Get<ModTree>(TileID.Trees, tile.type);
+					if (tree != null) {
+						tree.SetTreeFoliageSettings(tile, ref xoffset, ref treeFrame, ref floorY, ref topTextureFrameWidth, ref topTextureFrameHeight);
+						treeStyle = tile.type + ModTree.VanillaTopTextureCount;
+						return true;
+					}
+
+					break;
 			}
 		}
+
+		// Extra patch context.
 
 		return false;
 	}
@@ -45012,6 +_,10 @@
 
 	public static TreeTypes GetTreeType(int tileType)
 	{
+		TreeTypes modType = PlantLoader.GetModTreeType(tileType);
+		if (modType != TreeTypes.None)
+			return modType;
+
 		switch (tileType) {
 			case 2:
 			case 477:
@@ -45086,6 +_,8 @@
 		if (!IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
 			return;
 
+		bool createLeaves = true;
+		if (!PlantLoader.ShakeTree(x, y, Main.tile[x, num].type, ref createLeaves)) { } else
 		if (Main.getGoodWorld && genRand.Next(17) == 0) {
 			Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16, y * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Main.myPlayer, 16f, 16f);
 		}
@@ -45310,11 +_,18 @@
 			Item.NewItem(Type: (genRand.Next(2) != 0) ? 5278 : 5277, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
 		}
 
+		if (!createLeaves)
+			return;
+
 		int treeHeight = 0;
 		int treeFrame = 0;
 		int passStyle = 0;
 		GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, num], ref treeHeight, out treeFrame, out passStyle);
+
+		/*
 		if (passStyle != -1) {
+		*/
+		if (passStyle > 0) {
 			if (Main.netMode == 2)
 				NetMessage.SendData(112, -1, -1, null, 1, x, y, 1f, passStyle);
 
@@ -45397,6 +_,17 @@
 		fossilBreak = false;
 	}
 
+	/// <summary>
+	/// Attempts to destroy the tile at the provided tile coordinates.<para/>
+	/// Callers can use <paramref name="fail"/>, <paramref name="effectOnly"/>, and <paramref name="noItem"/> to dictate if the intention is to not actually kill the tile, only spawn kill tile effects, and not drop items respectively. For example, worms typically use <c>fail: true, effectOnly: true</c> to spawn dust indicating the worm burrowing through the ground. <para/>
+	/// <see cref="ModTile.KillTile(int, int, ref bool, ref bool, ref bool)"/> and <see cref="GlobalTile.KillTile(int, int, int, ref bool, ref bool, ref bool)"/> will be called to modify those values.<para/>
+	/// Note that this method will destroy a single tile and then call the tile framing code. The <paramref name="noItem"/> parameter is only relevant for 1x1 tiles, not multi-tiles. The tile framing code is what triggers multi-tiles to destroy all of their remaining tiles and drop their placement item. <see cref="GlobalTile.Drop(int, int, int)"/> must be used by the caller if the intention is to prevent item drops from a multi-tile.<para/>
+	/// </summary>
+	/// <param name="i"></param>
+	/// <param name="j"></param>
+	/// <param name="fail">Prevents the tile from being destroyed, but still plays a hit sound</param>
+	/// <param name="effectOnly">Prevents the tile from being destroyed but still spawns hit dust and prevents the hit sound.</param>
+	/// <param name="noItem">Prevents the item from dropping. Only relevant for 1x1 tiles.</param>
 	public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
 	{
 		if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
@@ -45415,11 +_,15 @@
 			Main.tile[i, j - 1] = new Tile();
 
 		int num = CheckTileBreakability(i, j);
+		// Extra patch context.
 		if (num == 1)
 			fail = true;
 
 		if (num == 2)
 			return;
+
+		// Placed before gen check on purpose.
+		TileLoader.KillTile(i, j, tile.type, ref fail, ref effectOnly, ref noItem);
 
 		if (gen)
 			noItem = true;
@@ -45562,7 +_,7 @@
 		if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
 			return;
 
-		int num16 = KillTile_GetTileDustAmount(fail, tile);
+		int num16 = KillTile_GetTileDustAmount(fail, tile, i, j);
 		for (int k = 0; k < num16; k++) {
 			KillTile_MakeTileDust(i, j, tile);
 		}
@@ -45756,9 +_,17 @@
 
 	private static Player GetPlayerForTile(int x, int y) => Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
 
+	// made internal, added includeAllModdedLargeObjectDrops param
-	private static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false)
+	internal static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false, bool includeAllModdedLargeObjectDrops = false)
 	{
+		if (!TileLoader.Drop(x, y, Main.tile[x, y].type, includeLargeObjectDrops))
+			return;
+
 		KillTile_GetItemDrops(x, y, tileCache, out var dropItem, out var dropItemStack, out var secondaryItem, out var secondaryItemStack, includeLargeObjectDrops);
+
+		TileLoader.GetItemDrops(x, y, tileCache, includeLargeObjectDrops, includeAllModdedLargeObjectDrops);
+
+		// TODO: support centering spawn location for multi-tiles? Vanilla code is inconsistent in doing this.
 		if (!Main.getGoodWorld || tileCache.active()) {
 			if (dropItem > 0) {
 				int num = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, dropItem, dropItemStack, noBroadcast: false, -1);
@@ -45772,7 +_,8 @@
 		}
 	}
 
+	// tML: Made internal because despite appearing pure, this method does have side effects. ItemDrops can't be safely queried unless more work is done.
-	public static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, bool includeLargeObjectDrops = false)
+	internal static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, bool includeLargeObjectDrops = false)
 	{
 		dropItem = 0;
 		dropItemStack = 1;
@@ -46858,13 +_,17 @@
 						case 234:
 							dropItem = 911;
 							break;
+						// Extra extra patch context.
 						case 116:
 							dropItem = 621;
 							break;
+						// Extra patch context.
 						case 112:
 							dropItem = 619;
 							break;
 					}
+
+					TileLoader.DropPalmTreeWood(Main.tile[x, j].type, ref dropItem);
 				}
 
 				break;
@@ -47881,7 +_,12 @@
 
 					if (Main.tile[i, k] != null) {
 						Tile tile = Main.tile[i, k];
+						bool vanillaResult = false;
 						if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23 || tile.type == 633) {
+							vanillaResult = true;
+						}
+						
+						if (vanillaResult || TileLoader.CanDropAcorn(tile.type)) {
 							dropItem = 9;
 							secondaryItem = 27;
 						}
@@ -47929,10 +_,13 @@
 					else
 						dropItem = 0;
 					break;
+				// Extra patch context.
 				case 147:
 					dropItem = 2503;
 					break;
 			}
+
+			TileLoader.DropTreeWood(Main.tile[x,y].type, ref dropItem);
 		}
 
 		int num = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
@@ -47959,6 +_,7 @@
 
 		if (tileCache.type == 73) {
 			num = 200;
+			// Patch note: this is 'grassHopperChance'
 			num2 = 50;
 			if (Main.player[num5].flowerBoots && tileCache.frameX >= 108) {
 				num *= 10000;
@@ -48003,9 +_,11 @@
 				num = 6;
 
 			if (tileCache.frameX <= 322)
+				// Patch note: this is 'wormChance'
 				num = 6;
 		}
 		else if (tileCache.type == 233) {
+			// Patch note: this is 'jungleGrubChance'
 			num3 = 10;
 		}
 
@@ -48013,6 +_,8 @@
 		if (Main.player[num5].ZoneGraveyard)
 			num6 = 606;
 
+		TileLoader.DropCritterChance(i, j, tileCache.type, ref num, ref num2, ref num3);
+
 		if (num > 0 && NPC.CountNPCS(num6) < 5 && genRand.Next(num) == 0) {
 			int type = num6;
 			if (num6 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
@@ -48075,6 +_,10 @@
 			return;
 
 		int type = tileCache.type;
+
+		if (!TileLoader.KillSound(i, j, type, fail))
+			return;
+
 		if (type == 127 || type == 623) {
 			SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
 		}
@@ -48207,7 +_,16 @@
 		return value;
 	}
 
+	public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache, int x, int y)
+	{
+		int result = KillTile_GetTileDustAmount_Vanilla(fail, tileCache);
+
+		TileLoader.NumDust(x, y, tileCache.type, fail, ref result);
+
+		return result;
+	}
+
-	public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
+	private static int KillTile_GetTileDustAmount_Vanilla(bool fail, Tile tileCache)
 	{
 		switch (tileCache.type) {
 			default:
@@ -49474,8 +_,11 @@
 					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 662)
 						num = 121;
 
+					// Extra patch context.
 					if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 147)
 						num = 122;
+
+					TileLoader.TreeDust(Main.tile[num15, k], ref num);
 				}
 			}
 		}
@@ -49494,8 +_,11 @@
 					if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
 						num = 79;
 
+					// Extra patch context.
 					if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
 						num = 77;
+
+					TileLoader.PalmTreeDust(Main.tile[i, l], ref num);
 				}
 			}
 		}
@@ -50136,7 +_,10 @@
 		if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
 			flag = true;
 
-		if (num >= 0) {
+		if (TileLoader.GetTile(tileCache.type) is ModTile modTile)
+			num = modTile.DustType;
+
+		if (TileLoader.CreateDust(i, j, tileCache.type, ref num) && num >= 0) {
 			if (tileCache.type == 627 || tileCache.type == 628 || (tileCache.type == 184 && tileCache.frameX / 22 == 10)) {
 				int num18 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB));
 				Main.dust[num18].noGravity = true;
@@ -50236,6 +_,10 @@
 		if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
 			return t.frameX < 54;
 
+		// something might be meant to go here but it's not this - Chicken Bones (I don't know what a "locked door" even is)
+		//if (TileLoader.OpenDoorID(t) < 0)
+		//	return true;
+
 		return false;
 	}
 
@@ -50555,7 +_,7 @@
 			return;
 
 		int type = Main.tile[i, j].type;
-		if (type > 0 && type < TileID.Count && TileID.Sets.CanGrowCrystalShards[type] && ((double)j > Main.rockLayer || Main.remixWorld) && genRand.Next(5) == 0) {
+		if (type > 0 && TileID.Sets.CanGrowCrystalShards[type] && ((double)j > Main.rockLayer || Main.remixWorld) && genRand.Next(5) == 0) {
 			int num = genRand.Next(4);
 			int num2 = 0;
 			int num3 = 0;
@@ -52049,9 +_,20 @@
 
 	public static void UpdateWorld()
 	{
+		// Extra patch context.
 		if (gen)
 			return;
 
+		SystemLoader.PreUpdateWorld();
+
+		UpdateWorld_Inner();
+
+		SystemLoader.PostUpdateWorld();
+	}
+
+	//TML: A split, obviously.
+	private static void UpdateWorld_Inner()
+	{
 		AllowedToSpreadInfections = true;
 		CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
 		if (power != null && power.GetIsUnlocked())
@@ -52083,7 +_,7 @@
 			Liquid.skipCount = 0;
 		}
 
-		int worldUpdateRate = GetWorldUpdateRate();
+		double worldUpdateRate = GetWorldUpdateRate();
 		if (worldUpdateRate == 0)
 			return;
 
@@ -52101,6 +_,9 @@
 			if (prioritizedTownNPCType != 37) {
 				for (int i = 0; i < 200; i++) {
 					if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].type != 368) {
+						if (Main.npc[i].ModNPC?.TownNPCStayingHomeless is true)
+							continue;
+
 						prioritizedTownNPCType = Main.npc[i].type;
 						break;
 					}
@@ -52141,7 +_,10 @@
 		if (Main.dayTime && !Main.remixWorld)
 			return;
 
+		/*
 		for (int m = 0; m < Main.dayRate; m++) {
+		*/
+		for (int m = 0; m < Main.worldEventUpdates; m++) {
 			double num7 = (double)Main.maxTilesX / 4200.0;
 			num7 *= (double)Star.starfallBoost;
 			if (!((double)Main.rand.Next(8000) < 10.0 * num7))
@@ -52170,14 +_,23 @@
 				num16 = (float)num8 / num16;
 				num14 *= num16;
 				num15 *= num16;
+
+				/*
 				Projectile.NewProjectile(new EntitySource_ByProjectileSourceId(11), position.X, position.Y, num14, num15, 720, 0, 0f, Main.myPlayer, 0f, num11);
+				*/
+				var source = new EntitySource_Misc(nameof(ProjectileSourceID.FallingStar));
+
+				Projectile.NewProjectile(source, position.X, position.Y, num14, num15, 720, 0, 0f, Main.myPlayer, 0f, num11);
+
+				// Extra patch context.
 			}
 		}
 	}
 
+	//TML: Changed return value from 'int' to 'double'.
-	public static int GetWorldUpdateRate()
+	public static double GetWorldUpdateRate()
 	{
-		int result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
+		double result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
 		if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
 			result = 0;
 
@@ -52186,6 +_,9 @@
 
 	private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
 	{
+		TileLoader.RandomUpdate(i, j, Main.tile[i, j].type);
+		WallLoader.RandomUpdate(i, j, Main.tile[i, j].wall);
+
 		int num = i - 1;
 		int num2 = i + 2;
 		int num3 = j - 1;
@@ -53002,7 +_,7 @@
 			return false;
 
 		ushort type = tile.type;
-		if (type < 0 || type >= TileID.Count)
+		if (type < 0)
 			return false;
 
 		if (type != 70 && type != 633 && !TileID.Sets.Conversion.Grass[type])
@@ -53061,7 +_,7 @@
 			return false;
 
 		ushort type = tile.type;
-		if (type < 0 || type >= TileID.Count)
+		if (type < 0)
 			return false;
 
 		if (type != 0 && type != 70 && type != 633 && type != 59 && type != 225 && !TileID.Sets.Conversion.Grass[type] && !TileID.Sets.Conversion.Stone[type] && !Main.tileMoss[type])
@@ -53111,6 +_,9 @@
 
 	private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
 	{
+		TileLoader.RandomUpdate(i, j, Main.tile[i, j].type);
+		WallLoader.RandomUpdate(i, j, Main.tile[i, j].wall);
+
 		int num = i - 1;
 		int num2 = i + 2;
 		int num3 = j - 1;
@@ -55722,6 +_,10 @@
 		}
 	}
 
+	/// <summary>
+	/// Places small splotches of the specified tile starting at the designated coordinates. This should only be used early in world generation code. <see cref="OreRunner(int, int, double, int, ushort)"/> is a safer version that can be used anytime without corrupting tiles.
+	/// <para/> More detailed information and a video guide can be found on the <see href="https://github.com/tModLoader/tModLoader/wiki/World-Generation#terrariaworldgen-public-static-void-tilerunnerint-i-int-j-double-strength-int-steps-int-type-bool-addtile--false-float-speedx--0f-float-speedy--0f-bool-noychange--false-bool-override--true">World Generation wiki page</see>
+	/// </summary>
 	public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, double speedX = 0.0, double speedY = 0.0, bool noYChange = false, bool overRide = true, int ignoreTileType = -1)
 	{
 		if (!GenVars.mudWall) {
@@ -58741,7 +_,7 @@
 			Main.tile[x, y + 1] = new Tile();
 
 		switch (Main.tile[x, y].type) {
-			case 10:
+			case ushort _ when TileLoader.IsClosedDoor(Main.tile[x, y].type):
 			case 48:
 			case 137:
 			case 138:
@@ -58764,6 +_,7 @@
 				}
 				if (Main.tile[x, y - 1].active()) {
 					switch (Main.tile[x, y - 1].type) {
+						case var t when TileID.Sets.BasicChest[t] || TileID.Sets.BasicDresser[t]:
 						case 21:
 						case 26:
 						case 77:
@@ -58780,6 +_,7 @@
 							return false;
 					}
 				}
+				// TODO: I don't think this is correct, hammering tiles isn't killing them.
 				return CanKillTile(x, y);
 		}
 	}
@@ -59247,7 +_,10 @@
 					Liquid.AddWater(i, j);
 
 				if (tile.active()) {
-					if (noBreak && Main.tileFrameImportant[tile.type] && tile.type != 4)
+					if (!TileLoader.TileFrame(i, j, tile.type, ref resetFrame, ref noBreak))
+						return;
+
+					if (noBreak && Main.tileFrameImportant[tile.type] && !TileID.Sets.Torch[tile.type])
 						return;
 
 					int num = tile.type;
@@ -59271,7 +_,10 @@
 							case 571:
 								CheckBamboo(i, j);
 								break;
+							/*
 							case 4:
+							*/
+							case int _ when TileID.Sets.Torch[num]:
 								CheckTorch(i, j);
 								break;
 							case 442:
@@ -59474,7 +_,7 @@
 
 											Tile tile3 = Main.tile[i, j + 1];
 											_ = Main.tile[i, j].frameY / 34;
-											if (tile3 == null || !tile3.active() || (tile3.type >= 0 && tile3.type < TileID.Count && !TileID.Sets.Conversion.Sand[tile3.type]))
+											if (tile3 == null || !tile3.active() || (tile3.type >= 0 && !TileID.Sets.Conversion.Sand[tile3.type]))
 												KillTile(i, j);
 
 											break;
@@ -59531,10 +_,10 @@
 													Minecart.FrameTrack(i, j, pound: false);
 													Tile tile2 = Main.tile[i, j - 1];
 													Tile tile3 = Main.tile[i, j + 1];
-													if (tile2 != null && tile2.type >= 0 && tile2.type < TileID.Count && Main.tileRope[tile2.type])
+													if (tile2 != null && tile2.type >= 0 && Main.tileRope[tile2.type])
 														TileFrame(i, j - 1);
 
-													if (tile3 != null && tile3.type >= 0 && tile3.type < TileID.Count && Main.tileRope[tile3.type])
+													if (tile3 != null && tile3.type >= 0 && Main.tileRope[tile3.type])
 														TileFrame(i, j + 1);
 
 													break;
@@ -59791,7 +_,10 @@
 														if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455 && num != 491 && num != 499 && num != 642) {
 															switch (num) {
 																case 15:
+																/*
 																case 20:
+																*/
+																case int _ when TileID.Sets.TreeSapling[num]:
 																case 216:
 																case 338:
 																case 390:
@@ -59868,7 +_,10 @@
 																				CheckOnTable1x1(i, j, num);
 																				return;
 																			default:
+																				/*
 																				if (TileID.Sets.BasicChest[num]) {
+																				*/
+																				if (TileID.Sets.BasicChest[num] && num < TileID.Count) {
 																					CheckChest(i, j, num);
 																					return;
 																				}
@@ -59899,7 +_,7 @@
 																						CheckXmasTree(i, j);
 																						break;
 																					default:
-																						if (!TileID.Sets.BasicChestFake[num] && num != 457) {
+																						if (!TileID.Sets.BasicChestFake[num] && num != 457 || num >= TileID.Count) {
 																							switch (num) {
 																								case 335:
 																								case 411:
@@ -60128,14 +_,20 @@
 																													case 323:
 																														CheckPalmTree(i, j);
 																														break;
+																													// Extra extra patch context
 																													case 567:
 																														CheckGnome(i, j);
 																														break;
+																													// Extra patch context
 																													case 630:
 																													case 631:
 																														CheckStinkbugBlocker(i, j);
 																														break;
 																												}
+
+																												//TODO: Test this. Not sure this is still correct.
+																												TileLoader.CheckModTile(i, j, num);
+
 																												return;
 																										}
 																									}
@@ -60345,13 +_,19 @@
 
 								TileMergeAttempt(0, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 								switch (num) {
+									/*
 									case 147:
+									*/
+									case int _ when TileID.Sets.Snow[num]:
 										TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 										break;
+									/*
 									case 161:
 									case 163:
 									case 164:
 									case 200:
+									*/
+									case int _ when TileID.Sets.Ices[num]:
 										TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 										break;
 									case 162:
@@ -60360,10 +_,13 @@
 									default:
 										if (Main.tileBrick[num]) {
 											switch (num) {
+												/*
 												case 60:
 												case 70:
 												case 661:
 												case 662:
+												*/
+												case int _ when TileID.Sets.GrassSpecial[num]:
 													TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 													break;
 												case 633:
@@ -60380,14 +_,20 @@
 										break;
 								}
 
+								/*
 								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && down == 165) {
+								*/
+								if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && down == 165) {
 									if (tile3 != null && tile3.frameY == 72)
 										down = num;
 									else if (tile3 != null && tile3.frameY == 0)
 										down = num;
 								}
 
+								/*
 								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && up == 165) {
+								*/
+								if ((TileID.Sets.Stone[num] || Main.tileMoss[num]) && up == 165) {
 									if (tile2 != null && tile2.frameY == 90)
 										up = num;
 									else if (tile2 != null && tile2.frameY == 54)
@@ -60402,7 +_,10 @@
 										up = num;
 								}
 
+								/*
 								if ((num == 200 || num == 161 || num == 147 || num == 163 || num == 164) && down == 165)
+								*/
+								if ((TileID.Sets.Ices[num] || num == 147) && down == 165)
 									down = num;
 
 								if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
@@ -60527,7 +_,10 @@
 										if (mergeDown)
 											up = num;
 									}
+									/*
 									else if (up == 147) {
+									*/
+									else if (up >= 0 && TileID.Sets.Snow[up]) {
 										TileFrame(i, j - 1);
 										if (mergeDown)
 											up = num;
@@ -60538,7 +_,10 @@
 										if (mergeUp)
 											down = num;
 									}
+									/*
 									else if (down == 147) {
+									*/
+									else if (down >= 0 && TileID.Sets.Snow[down]) {
 										TileFrame(i, j + 1);
 										if (mergeUp)
 											down = num;
@@ -60549,7 +_,10 @@
 										if (mergeRight)
 											left = num;
 									}
+									/*
 									else if (left == 147) {
+									*/
+									else if (left >= 0 && TileID.Sets.Snow[left]) {
 										TileFrame(i - 1, j);
 										if (mergeRight)
 											left = num;
@@ -60679,9 +_,12 @@
 								}
 								else {
 									switch (num) {
+										/*
 										case 58:
 										case 75:
 										case 76:
+										*/
+										case int _ when TileID.Sets.HellSpecial[num]:
 											TileMergeAttempt(-2, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											break;
 										case 57:
@@ -60689,7 +_,10 @@
 											TileMergeAttempt(num, 633, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											break;
+										/*
 										case 59:
+										*/
+										case int _ when TileID.Sets.Mud[num]:
 											if ((double)j > Main.rockLayer)
 												TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -60721,14 +_,20 @@
 											TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											break;
+										/*
 										case 147:
+										*/
+										case int _ when TileID.Sets.Snow[num]:
 											TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											break;
+										/*
 										case 161:
 										case 163:
 										case 164:
 										case 200:
 										case 224:
+										*/
+										case int _ when TileID.Sets.IcesSlush[num]:
 											TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 											break;
 										case 162:
@@ -60829,7 +_,7 @@
 								else if (TileID.Sets.Ore[num])
 									TileMergeAttempt(num, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 
-								if (num >= 0 && num < TileID.Count && TileID.Sets.Mud[num])
+								if (num >= 0 && TileID.Sets.Mud[num])
 									TileMergeAttempt(num, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 								else if (TileID.Sets.OreMergesWithMud[num])
 									TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -60848,11 +_,18 @@
 									tileMergeCullCache.CullBottomRight |= tile7 != null && tile7.invisibleBlock() != flag2;
 								}
 
+								/*
 								if (num == 2 || num == 23 || num == 661 || num == 662 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
+								*/
+								if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num]) {
 									flag = true;
 									TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 									int num32 = TileID.Sets.NeedsGrassFramingDirt[num];
+
+									/*
 									if (num == 60 || num == 70 || num == 661 || num == 662) {
+									*/
+									if (TileID.Sets.GrassSpecial[num]) {
 										num32 = 59;
 									}
 									else if (Main.tileMoss[num]) {
@@ -61903,9 +_,9 @@
 										}
 									}
 
-									if (num32 >= 0 && num32 < TileID.Count && TileID.Sets.Dirt[num32])
+									if (num32 >= 0 && TileID.Sets.Dirt[num32])
 										TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
-									else if (num32 >= 0 && num32 < TileID.Count && TileID.Sets.Mud[num32])
+									else if (num32 >= 0 && TileID.Sets.Mud[num32])
 										TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 									else
 										TileMergeAttempt(-2, num32, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
@@ -62292,7 +_,10 @@
 										}
 									}
 									else {
+										/*
 										if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492 && num != 633 && num != 661 && num != 662) {
+										*/
+										if (!TileID.Sets.Grass[num] && !TileID.Sets.GrassSpecial[num]) {
 											if (up == -1 && down == -2 && left == num && right == num) {
 												switch (num27) {
 													case 0:
@@ -62842,7 +_,10 @@
 										tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 									}
 
+									/*
 									if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || num == 633 || num == 661 || num == 662 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num]) {
+									*/
+									if (TileID.Sets.Grass[num] || TileID.Sets.GrassSpecial[num] || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num]) {
 										TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 										tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
 									}
@@ -63321,7 +_,7 @@
 			currentMerge = -1;
 	}
 
-	private static bool SpawnFallingBlockProjectile(int i, int j, Tile tileCache, Tile tileTopCache, Tile tileBottomCache, int type)
+	public static bool SpawnFallingBlockProjectile(int i, int j, Tile tileCache, Tile tileTopCache, Tile tileBottomCache, int type)
 	{
 		if (Main.netMode == 1)
 			return false;
@@ -63615,7 +_,8 @@
 		if (!SolidTile(tile) || !SolidTile(tile2)) {
 			flag = true;
 			destroyObject = true;
+			if (TileLoader.Drop(i, j, tileCache.type))
-			DropDoorItem(i, j, num4);
+				DropDoorItem(i, j, num4);
 		}
 
 		int num5 = num2;
@@ -63628,7 +_,8 @@
 					Tile tile3 = Main.tile[k, l];
 					if (!tile3.active() || tile3.type != 11) {
 						destroyObject = true;
+						if (TileLoader.Drop(i, j, tileCache.type))
-						DropDoorItem(i, j, num4);
+							DropDoorItem(i, j, num4);
 						flag = true;
 						k = num5;
 						l = num3;
@@ -63699,10 +_,12 @@
 
 			if (flag) {
 				destroyObject = true;
+				bool drop = TileLoader.Drop(i, j, type);
 				KillTile(i, num);
 				KillTile(i, num + 1);
 				KillTile(i, num + 2);
+				if (drop)
-				DropDoorItem(i, j, num2);
+					DropDoorItem(i, j, num2);
 			}
 
 			destroyObject = false;
@@ -63712,6 +_,7 @@
 	private static void GetSandfallProjData(int type, out int projType, out int dmg)
 	{
 		dmg = 10;
+		/*
 		switch (type) {
 			case 112:
 				projType = 56;
@@ -63753,6 +_,11 @@
 			default:
 				projType = 31;
 				break;
+		*/
+		projType = 31;
+		if (TileID.Sets.FallingBlockProjectile[type] is TileID.Sets.FallingBlockProjectileInfo data) {
+			projType = data.FallingProjectileType;
+			dmg = data.FallingProjectileDamage;
 		}
 	}
 
@@ -63768,7 +_,7 @@
 
 		if (!tile.nactive())
 			result = true;
-		else if (tile.type >= 0 && tile.type < TileID.Count && !Main.tileSolid[tile.type])
+		else if (tile.type >= 0 && !Main.tileSolid[tile.type])
 			result = true;
 
 		return result;
@@ -63800,7 +_,7 @@
 			return false;
 
 		bool result = true;
-		if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
+		if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || TileID.Sets.BasicDresser[tileTopCache.type] || TileID.Sets.PreventsSandfall[tileTopCache.type]))
 			result = false;
 
 		return result;
