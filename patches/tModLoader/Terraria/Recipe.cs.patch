--- src/TerrariaNetCore/Terraria/Recipe.cs
+++ src/tModLoader/Terraria/Recipe.cs
@@ -1,12 +_,15 @@
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Terraria.GameContent.Achievements;
 using Terraria.ID;
 using Terraria.Localization;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Utilities;
 
 namespace Terraria
 {
-	public class Recipe
+	public sealed partial class Recipe
 	{
 		private struct RequiredItemEntry
 		{
@@ -14,26 +_,27 @@
 			public int stack;
 		}
 
-		public static int maxRequirements = 15;
+		private static int maxVanillaRequirements = 15;
 		public static int maxRecipes = 3000;
 		public static int numRecipes;
-		private static Recipe currentRecipe = new Recipe();
+		private static Recipe currentRecipe;
 		public Item createItem = new Item();
+		public List<Item> requiredItem = new List<Item>();
-		public Item[] requiredItem = new Item[maxRequirements];
+		public List<int> requiredTile = new List<int>();
-		public int[] requiredTile = new int[maxRequirements];
+		public List<int> acceptedGroups = new List<int>();
-		public int[] acceptedGroups = new int[maxRequirements];
+		private RequiredItemEntry[] requiredItemQuickLookup;
-		private RequiredItemEntry[] requiredItemQuickLookup = new RequiredItemEntry[maxRequirements];
+
-		public bool needHoney;
+		internal bool needHoney;
-		public bool needWater;
+		internal bool needWater;
-		public bool needLava;
+		internal bool needLava;
-		public bool anyWood;
+		internal bool anyWood;
-		public bool anyIronBar;
+		internal bool anyIronBar;
-		public bool anyPressurePlate;
+		internal bool anyPressurePlate;
-		public bool anySand;
+		internal bool anySand;
-		public bool anyFragment;
+		internal bool anyFragment;
-		public bool alchemy;
+		internal bool alchemy;
-		public bool needSnowBiome;
+		internal bool needSnowBiome;
-		public bool needGraveyardBiome;
+		internal bool needGraveyardBiome;
 		public bool needEverythingSeed;
 		public bool notDecraftable;
 		public bool crimson;
@@ -41,13 +_,13 @@
 		private static bool _hasDelayedFindRecipes;
 		private static Dictionary<int, int> _ownedItems = new Dictionary<int, int>();
 
-		public void RequireGroup(string name) {
+		private void RequireGroup(string name) {
 			if (!RecipeGroup.recipeGroupIDs.TryGetValue(name, out int value))
 				return;
 
 			int num = 0;
 			while (true) {
-				if (num < maxRequirements) {
+				if (num < acceptedGroups.Count) {
 					if (acceptedGroups[num] == -1)
 						break;
 
@@ -61,10 +_,10 @@
 			acceptedGroups[num] = value;
 		}
 
-		public void RequireGroup(int id) {
+		private void RequireGroup(int id) {
 			int num = 0;
 			while (true) {
-				if (num < maxRequirements) {
+				if (num < acceptedGroups.Count) {
 					if (acceptedGroups[num] == -1)
 						break;
 
@@ -79,12 +_,8 @@
 		}
 
 		public bool ProcessGroupsForText(int type, out string theText) {
-			for (int i = 0; i < maxRequirements; i++) {
-				int num = acceptedGroups[i];
-				if (num == -1)
-					break;
-
-				if (RecipeGroup.recipeGroups[num].ValidItems.Contains(type)) {
+			foreach (int num in acceptedGroups) {
+				if (RecipeGroup.recipeGroups[num].ContainsItem(type)) {
 					theText = RecipeGroup.recipeGroups[num].GetText();
 					return true;
 				}
@@ -95,7 +_,7 @@
 		}
 
 		public bool AcceptsGroup(int groupId) {
-			for (int i = 0; i < maxRequirements; i++) {
+			for (int i = 0; i < acceptedGroups.Count; i++) {
 				int num = acceptedGroups[i];
 				if (num == -1)
 					break;
@@ -108,35 +_,34 @@
 		}
 
 		public bool AcceptedByItemGroups(int invType, int reqType) {
-			for (int i = 0; i < maxRequirements; i++) {
-				int num = acceptedGroups[i];
-				if (num == -1)
-					break;
-
-				if (RecipeGroup.recipeGroups[num].ValidItems.Contains(invType) && RecipeGroup.recipeGroups[num].ValidItems.Contains(reqType))
+			foreach (int num in acceptedGroups) {
+				if (RecipeGroup.recipeGroups[num].ContainsItem(invType) && RecipeGroup.recipeGroups[num].ContainsItem(reqType))
 					return true;
 			}
 
 			return false;
 		}
 
-		public Recipe() {
-			for (int i = 0; i < maxRequirements; i++) {
-				requiredItem[i] = new Item();
-				requiredTile[i] = -1;
-				acceptedGroups[i] = -1;
-			}
+		static Recipe() {
+			currentRecipe = new Recipe {
+				requiredItem = new List<Item>(),
+				requiredTile = Enumerable.Repeat(-1, maxVanillaRequirements).ToList(),
+				acceptedGroups = Enumerable.Repeat(-1, maxVanillaRequirements).ToList()
+			};
+			for (int i = 0; i < maxVanillaRequirements; i++) currentRecipe.requiredItem.Add(new Item());
+		}
+
+		internal Recipe(Mod mod = null) {
+			Mod = mod;
+			RecipeIndex = -1;
 		}
 
 		public void Create() {
+			RecipeLoader.ConsumedItems.Clear(); // just in case something throws or breaks and the 'clear after craft' doesn't run
+
 			Item[] array = null;
 			Item item = null;
-			Item item2 = null;
-			for (int i = 0; i < maxRequirements; i++) {
-				item2 = requiredItem[i];
-				if (item2.type == 0)
-					break;
-
+			foreach (Item item2 in requiredItem) {
 				int num = item2.stack;
 				if (alchemy && Main.player[Main.myPlayer].alchemyTable) {
 					if (num > 1) {
@@ -153,6 +_,8 @@
 					}
 				}
 
+				RecipeLoader.ConsumeItem(this, item2.type, ref num);
+
 				if (num <= 0)
 					continue;
 
@@ -164,10 +_,13 @@
 
 					if (item.IsTheSameAs(item2) || useWood(item.type, item2.type) || useSand(item.type, item2.type) || useFragment(item.type, item2.type) || useIronBar(item.type, item2.type) || usePressurePlate(item.type, item2.type) || AcceptedByItemGroups(item.type, item2.type)) {
 						if (item.stack > num) {
+							RecipeLoader.ConsumedItems.Add(item.Clone());
+							RecipeLoader.ConsumedItems[^1].stack = num;
 							item.stack -= num;
 							num = 0;
 						}
 						else {
+							RecipeLoader.ConsumedItems.Add(item);
 							num -= item.stack;
 							array[k] = new Item();
 						}
@@ -223,6 +_,8 @@
 						continue;
 
 					if (item.stack > num) {
+						RecipeLoader.ConsumedItems.Add(item.Clone());
+						RecipeLoader.ConsumedItems[^1].stack = num;
 						item.stack -= num;
 						if (Main.netMode == 1 && Main.player[Main.myPlayer].chest >= 0)
 							NetMessage.SendData(32, -1, -1, null, Main.player[Main.myPlayer].chest, m);
@@ -230,6 +_,7 @@
 						num = 0;
 					}
 					else {
+						RecipeLoader.ConsumedItems.Add(item);
 						num -= item.stack;
 						array[m] = new Item();
 						if (Main.netMode == 1 && Main.player[Main.myPlayer].chest >= 0)
@@ -243,7 +_,7 @@
 			FindRecipes();
 		}
 
-		public bool useWood(int invType, int reqType) {
+		private bool useWood(int invType, int reqType) {
 			if (!anyWood)
 				return false;
 
@@ -276,7 +_,7 @@
 			}
 		}
 
-		public bool useIronBar(int invType, int reqType) {
+		private bool useIronBar(int invType, int reqType) {
 			if (!anyIronBar)
 				return false;
 
@@ -289,7 +_,7 @@
 			return true;
 		}
 
-		public bool useSand(int invType, int reqType) {
+		private bool useSand(int invType, int reqType) {
 			if (reqType != 169 && reqType != 408 && reqType != 1246 && reqType != 370 && reqType != 3272 && reqType != 3338 && reqType != 3274 && reqType != 3275)
 				return false;
 
@@ -299,7 +_,7 @@
 			return false;
 		}
 
-		public bool useFragment(int invType, int reqType) {
+		private bool useFragment(int invType, int reqType) {
 			if (reqType != 3458 && reqType != 3456 && reqType != 3457 && reqType != 3459)
 				return false;
 
@@ -309,7 +_,7 @@
 			return false;
 		}
 
-		public bool usePressurePlate(int invType, int reqType) {
+		private bool usePressurePlate(int invType, int reqType) {
 			if (!anyPressurePlate)
 				return false;
 
@@ -370,7 +_,7 @@
 				if (recipe.createItem.type == 0)
 					break;
 
-				if (PlayerMeetsTileRequirements(localPlayer, recipe) && PlayerMeetsEnvironmentConditions(localPlayer, recipe) && CollectedEnoughItemsToCraftRecipeNew(recipe))
+				if (!recipe.Disabled && PlayerMeetsTileRequirements(localPlayer, recipe) && PlayerMeetsEnvironmentConditions(localPlayer, recipe) && CollectedEnoughItemsToCraftRecipeNew(recipe) && RecipeLoader.RecipeAvailable(recipe))
 					AddToAvailableRecipes(i);
 			}
 
@@ -384,7 +_,7 @@
 		}
 
 		public static bool CollectedEnoughItemsToCraftRecipeOld(Recipe tempRec) {
-			for (int i = 0; i < maxRequirements; i++) {
+			for (int i = 0; i < tempRec.requiredItem.Count; i++) {
 				Item item = tempRec.requiredItem[i];
 				if (item.type == 0)
 					break;
@@ -409,7 +_,7 @@
 		}
 
 		public static bool CollectedEnoughItemsToCraftRecipeNew(Recipe tempRec) {
-			for (int i = 0; i < maxRequirements; i++) {
+			for (int i = 0; i < tempRec.requiredItem.Count; i++) {
 				RequiredItemEntry requiredItemEntry = tempRec.requiredItemQuickLookup[i];
 				if (requiredItemEntry.itemIdOrRecipeGroup == 0)
 					break;
@@ -425,7 +_,7 @@
 		}
 
 		private static bool PlayerMeetsEnvironmentConditions(Player player, Recipe tempRec) {
-			bool num = !tempRec.needWater || player.adjWater || player.adjTile[172];
+			bool num = !tempRec.needWater || player.adjWater;
 			bool flag = !tempRec.needHoney || tempRec.needHoney == player.adjHoney;
 			bool flag2 = !tempRec.needLava || tempRec.needLava == player.adjLava;
 			bool flag3 = !tempRec.needSnowBiome || player.ZoneSnow;
@@ -435,7 +_,7 @@
 		}
 
 		private static bool PlayerMeetsTileRequirements(Player player, Recipe tempRec) {
-			for (int i = 0; i < maxRequirements && tempRec.requiredTile[i] != -1; i++) {
+			for (int i = 0; i < tempRec.requiredTile.Count && tempRec.requiredTile[i] != -1; i++) {
 				if (!player.adjTile[tempRec.requiredTile[i]])
 					return false;
 			}
@@ -495,7 +_,10 @@
 				if (recipe.createItem.type == 0)
 					break;
 
+				if (recipe.Disabled)
+					continue;
+
-				for (int j = 0; j < maxRequirements; j++) {
+				for (int j = 0; j < recipe.requiredItem.Count; j++) {
 					Item item = recipe.requiredItem[j];
 					if (item.type == 0)
 						break;
@@ -584,6 +_,8 @@
 			RecipeGroupID.Fragment = RecipeGroup.RegisterGroup("Fragment", rec);
 			rec = new RecipeGroup(() => "replaceme pressureplate", 852, 543, 542, 541, 1151, 529, 853, 4261);
 			RecipeGroupID.PressurePlate = RecipeGroup.RegisterGroup("PressurePlate", rec);
+			RecipeGroupHelper.AddOldVanillaGroups();
+			RecipeGroupHelper.AddRecipeGroups();
 		}
 
 		public static void UpdateItemVariants() {
@@ -14462,11 +_,16 @@
 			AddRecipe();
 			CreateReverseWallRecipes();
 			CreateReversePlatformRecipes();
+			RecipeLoader.AddRecipes();
+			RecipeLoader.PostAddRecipes();
+			RecipeLoader.OrderRecipes();
 			UpdateWhichItemsAreMaterials();
 			UpdateWhichItemsAreCrafted();
 			UpdateMaterialFieldForAllRecipes();
 			ReplaceItemUseFlagsWithRecipeGroups();
+			FixRecipeGroups();
 			CreateRequiredItemQuickLookups();
+			Item.PopulateMaterialCache(); // is this needed anymore?
 		}
 
 		private static void ReplaceItemUseFlagsWithRecipeGroups() {
@@ -14488,19 +_,15 @@
 		private static void CreateRequiredItemQuickLookups() {
 			for (int i = 0; i < numRecipes; i++) {
 				Recipe recipe = Main.recipe[i];
+				recipe.requiredItemQuickLookup = new RequiredItemEntry[recipe.requiredItem.Count];
-				for (int j = 0; j < maxRequirements; j++) {
+				for (int j = 0; j < recipe.requiredItem.Count; j++) {
 					Item item = recipe.requiredItem[j];
-					if (item.IsAir)
-						break;
 
 					RequiredItemEntry requiredItemEntry = default(RequiredItemEntry);
 					requiredItemEntry.itemIdOrRecipeGroup = item.type;
 					requiredItemEntry.stack = item.stack;
 					RequiredItemEntry requiredItemEntry2 = requiredItemEntry;
-					int[] array = recipe.acceptedGroups;
-					foreach (int num in array) {
+					foreach (int num in recipe.acceptedGroups) {
-						if (num < 0)
-							break;
 
 						RecipeGroup recipeGroup = RecipeGroup.recipeGroups[num];
 						if (recipeGroup.ValidItems.Contains(item.type))
@@ -14512,10 +_,28 @@
 			}
 		}
 
+		private static void FixRecipeGroups() {
+			// Remove recipe group assignments to recipes that don't actually have any items in the recipe groups anymore for one reason or another.
+			for (int i = 0; i < numRecipes; i++) {
+				Recipe recipe = Main.recipe[i];
+				if (recipe.acceptedGroups.Count > 0) {
+					var toRemove = new List<int>();
+					foreach (int num in recipe.acceptedGroups) {
+						if (!RecipeGroup.recipeGroups[num].ValidItems.Intersect(recipe.requiredItem.Select(x => x.type)).Any()) {
+							toRemove.Add(num);
+						}
+					}
+					foreach (var group in toRemove) {
+						recipe.acceptedGroups.Remove(group);
+					}
+				}
+			}
+		}
+
 		private static void UpdateMaterialFieldForAllRecipes() {
 			for (int i = 0; i < numRecipes; i++) {
-				for (int j = 0; Main.recipe[i].requiredItem[j].type > 0; j++) {
-					Main.recipe[i].requiredItem[j].material = ItemID.Sets.IsAMaterial[Main.recipe[i].requiredItem[j].type];
+				foreach (Item item in Main.recipe[i].requiredItem) {
+					item.material = ItemID.Sets.IsAMaterial[item.type];
 				}
 
 				Main.recipe[i].createItem.material = ItemID.Sets.IsAMaterial[Main.recipe[i].createItem.type];
@@ -14523,7 +_,7 @@
 		}
 
 		public static void UpdateWhichItemsAreMaterials() {
-			for (int i = 0; i < 5453; i++) {
+			for (int i = 0; i < ItemLoader.ItemCount; i++) {
 				Item item = new Item();
 				item.SetDefaults(i, noMatCheck: true);
 				item.checkMat();
@@ -15672,23 +_,24 @@
 		private static void CreateReversePlatformRecipes() {
 			int num = numRecipes;
 			for (int i = 0; i < num; i++) {
-				if (Main.recipe[i].createItem.createTile >= 0 && TileID.Sets.Platforms[Main.recipe[i].createItem.createTile] && Main.recipe[i].requiredItem[1].type == 0) {
+				if (Main.recipe[i].createItem.createTile >= 0 && TileID.Sets.Platforms[Main.recipe[i].createItem.createTile] && Main.recipe[i].requiredItem.Count == 1) {
 					currentRecipe.createItem.SetDefaults(Main.recipe[i].requiredItem[0].type);
 					currentRecipe.createItem.stack = Main.recipe[i].requiredItem[0].stack;
 					currentRecipe.requiredItem[0].SetDefaults(Main.recipe[i].createItem.type);
 					currentRecipe.requiredItem[0].stack = Main.recipe[i].createItem.stack;
-					for (int j = 0; j < currentRecipe.requiredTile.Length; j++) {
-						currentRecipe.requiredTile[j] = Main.recipe[i].requiredTile[j];
-					}
+					currentRecipe.requiredTile = new List<int>(Main.recipe[i].requiredTile);
 
 					AddRecipe();
 					Recipe recipe = Main.recipe[numRecipes - 1];
 					for (int num2 = numRecipes - 2; num2 > i; num2--) {
-						Main.recipe[num2 + 1] = Main.recipe[num2];
+						Recipe switchedRecipe = Main.recipe[num2];
+						Main.recipe[num2 + 1] = switchedRecipe;
+						switchedRecipe.RecipeIndex = num2 + 1;
 					}
 
 					Main.recipe[i + 1] = recipe;
 					Main.recipe[i + 1].notDecraftable = true;
+					recipe.RecipeIndex = i + 1;
 				}
 			}
 		}
@@ -15696,28 +_,29 @@
 		private static void CreateReverseWallRecipes() {
 			int num = numRecipes;
 			for (int i = 0; i < num; i++) {
-				if (Main.recipe[i].createItem.createWall > 0 && Main.recipe[i].requiredItem[1].type == 0 && Main.recipe[i].requiredItem[0].createWall == -1) {
+				if (Main.recipe[i].createItem.createWall > 0 && Main.recipe[i].requiredItem.Count == 1 && Main.recipe[i].requiredItem[0].createWall == -1) {
 					currentRecipe.createItem.SetDefaults(Main.recipe[i].requiredItem[0].type);
 					currentRecipe.createItem.stack = Main.recipe[i].requiredItem[0].stack;
 					currentRecipe.requiredItem[0].SetDefaults(Main.recipe[i].createItem.type);
 					currentRecipe.requiredItem[0].stack = Main.recipe[i].createItem.stack;
-					for (int j = 0; j < currentRecipe.requiredTile.Length; j++) {
-						currentRecipe.requiredTile[j] = Main.recipe[i].requiredTile[j];
-					}
+					currentRecipe.requiredTile = new List<int>(Main.recipe[i].requiredTile);
 
 					AddRecipe();
 					Recipe recipe = Main.recipe[numRecipes - 1];
 					for (int num2 = numRecipes - 2; num2 > i; num2--) {
-						Main.recipe[num2 + 1] = Main.recipe[num2];
+						Recipe switchedRecipe = Main.recipe[num2];
+						Main.recipe[num2 + 1] = switchedRecipe;
+						switchedRecipe.RecipeIndex = num2 + 1;
 					}
 
 					Main.recipe[i + 1] = recipe;
 					Main.recipe[i + 1].notDecraftable = true;
+					recipe.RecipeIndex = i + 1;
 				}
 			}
 		}
 
-		public void SetIngredients(params int[] ingredients) {
+		private void SetIngredients(params int[] ingredients) {
 			if (ingredients.Length == 1) {
 				ingredients = new int[2] {
 					ingredients[0],
@@ -15735,18 +_,50 @@
 			}
 		}
 
-		public void SetCraftingStation(params int[] tileIDs) {
+		private void SetCraftingStation(params int[] tileIDs) {
 			for (int i = 0; i < tileIDs.Length; i++) {
 				requiredTile[i] = tileIDs[i];
 			}
 		}
 
 		private static void AddRecipe() {
-			if (currentRecipe.requiredTile[0] == 13)
-				currentRecipe.alchemy = true;
+			if (currentRecipe.requiredTile.Count > 0 && currentRecipe.requiredTile[0] == TileID.Bottles)
+				currentRecipe.AddConsumeItemCallback(ConsumptionRules.Alchemy);
+
+			static void ReplaceCondition(ref bool field, Recipe.Condition cond) {
+				if (field)
+					currentRecipe.AddCondition(cond);
+
+				field = false;
+			}
+
+			ReplaceCondition(ref currentRecipe.needGraveyardBiome, Condition.InGraveyardBiome);
+			ReplaceCondition(ref currentRecipe.needSnowBiome, Condition.InSnow);
+			ReplaceCondition(ref currentRecipe.needWater, Condition.NearWater);
+			ReplaceCondition(ref currentRecipe.needLava, Condition.NearLava);
+			ReplaceCondition(ref currentRecipe.needHoney, Condition.NearHoney);
+
+			currentRecipe.requiredItem.RemoveAll(item => item.IsAir);
+			currentRecipe.requiredTile.RemoveAll(tile => tile == -1);
+			currentRecipe.acceptedGroups.RemoveAll(group => group == -1);
 
 			Main.recipe[numRecipes] = currentRecipe;
-			currentRecipe = new Recipe();
+			currentRecipe.RecipeIndex = numRecipes;
+
+			if (RecipeLoader.FirstRecipeForItem[currentRecipe.createItem.type] == null) {
+				RecipeLoader.FirstRecipeForItem[currentRecipe.createItem.type] = currentRecipe;
+			}
+
+			// The following resets the currentRecipe field
+			currentRecipe = new Recipe {
+				requiredItem = new List<Item>(),
+				requiredTile = Enumerable.Repeat(-1, maxVanillaRequirements).ToList(),
+				acceptedGroups = Enumerable.Repeat(-1, maxVanillaRequirements).ToList()
+			};
+
+			for (int i = 0; i < maxVanillaRequirements; i++)
+				currentRecipe.requiredItem.Add(new Item());
+
 			numRecipes++;
 		}
 
