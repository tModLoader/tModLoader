--- src/TerrariaNetCore/Terraria/Recipe.cs
+++ src/tModLoader/Terraria/Recipe.cs
@@ -1,13 +_,16 @@
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Terraria.GameContent;
 using Terraria.GameContent.Achievements;
 using Terraria.ID;
 using Terraria.Localization;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Utilities;
 
 namespace Terraria;
 
-public class Recipe
+public sealed partial class Recipe
 {
 	private struct RequiredItemEntry
 	{
@@ -15,40 +_,41 @@
 		public int stack;
 	}
 
-	public static int maxRequirements = 15;
+	private static int maxVanillaRequirements = 15;
 	public static int maxRecipes = 3000;
 	public static int numRecipes;
-	private static Recipe currentRecipe = new Recipe();
+	private static Recipe currentRecipe;
 	public Item createItem = new Item();
-	public Item[] requiredItem = new Item[maxRequirements];
-	public int[] requiredTile = new int[maxRequirements];
-	public int[] acceptedGroups = new int[maxRequirements];
-	private RequiredItemEntry[] requiredItemQuickLookup = new RequiredItemEntry[maxRequirements];
+	public List<Item> requiredItem = new List<Item>();
+	public List<int> requiredTile = new List<int>();
+	public List<int> acceptedGroups = new List<int>();
+	private RequiredItemEntry[] requiredItemQuickLookup;
 	public List<Item> customShimmerResults;
+
-	public bool needHoney;
+	internal bool needHoney;
-	public bool needWater;
+	internal bool needWater;
-	public bool needLava;
+	internal bool needLava;
-	public bool anyWood;
+	internal bool anyWood;
-	public bool anyIronBar;
+	internal bool anyIronBar;
-	public bool anyPressurePlate;
+	internal bool anyPressurePlate;
-	public bool anySand;
+	internal bool anySand;
-	public bool anyFragment;
+	internal bool anyFragment;
-	public bool alchemy;
+	internal bool alchemy;
-	public bool needSnowBiome;
+	internal bool needSnowBiome;
-	public bool needGraveyardBiome;
+	internal bool needGraveyardBiome;
-	public bool needEverythingSeed;
+	internal bool needEverythingSeed;
-	public bool notDecraftable;
+	internal bool notDecraftable;
-	public bool crimson;
+	internal bool crimson;
-	public bool corruption;
+	internal bool corruption;
 	private static bool _hasDelayedFindRecipes;
 	private static Dictionary<int, int> _ownedItems = new Dictionary<int, int>();
 
-	public void RequireGroup(string name)
+	private void RequireGroup(string name)
 	{
 		if (!RecipeGroup.recipeGroupIDs.TryGetValue(name, out var value))
 			return;
 
-		for (int i = 0; i < maxRequirements; i++) {
+		for (int i = 0; i < acceptedGroups.Count; i++) {
 			if (acceptedGroups[i] == -1) {
 				acceptedGroups[i] = value;
 				break;
@@ -58,7 +_,7 @@
 
 	public void RequireGroup(int id)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
+		for (int i = 0; i < acceptedGroups.Count; i++) {
 			if (acceptedGroups[i] == -1) {
 				acceptedGroups[i] = id;
 				break;
@@ -68,12 +_,8 @@
 
 	public bool ProcessGroupsForText(int type, out string theText)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
-			int num = acceptedGroups[i];
-			if (num == -1)
-				break;
-
-			if (RecipeGroup.recipeGroups[num].ValidItems.Contains(type)) {
+		foreach (int num in acceptedGroups) {
+			if (RecipeGroup.recipeGroups[num].ContainsItem(type)) {
 				theText = RecipeGroup.recipeGroups[num].GetText();
 				return true;
 			}
@@ -85,7 +_,7 @@
 
 	public bool AcceptsGroup(int groupId)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
+		for (int i = 0; i < acceptedGroups.Count; i++) {
 			int num = acceptedGroups[i];
 			if (num == -1)
 				break;
@@ -99,19 +_,15 @@
 
 	public bool AcceptedByItemGroups(int invType, int reqType)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
-			int num = acceptedGroups[i];
-			if (num == -1)
-				break;
-
-			if (RecipeGroup.recipeGroups[num].ValidItems.Contains(invType) && RecipeGroup.recipeGroups[num].ValidItems.Contains(reqType))
+		foreach (int num in acceptedGroups) {
+			if (RecipeGroup.recipeGroups[num].ContainsItem(invType) && RecipeGroup.recipeGroups[num].ContainsItem(reqType))
 				return true;
 		}
 
 		return false;
 	}
 
-	public Item AddCustomShimmerResult(int itemType, int itemStack = 1)
+	public Recipe AddCustomShimmerResult(int itemType, int itemStack = 1)
 	{
 		if (customShimmerResults == null)
 			customShimmerResults = new List<Item>();
@@ -120,28 +_,32 @@
 		item.SetDefaults(itemType);
 		item.stack = itemStack;
 		customShimmerResults.Add(item);
-		return item;
-	}
-
-	public Recipe()
-	{
-		for (int i = 0; i < maxRequirements; i++) {
-			requiredItem[i] = new Item();
-			requiredTile[i] = -1;
-			acceptedGroups[i] = -1;
-		}
+		return this;
+	}
+
+	static Recipe()
+	{
+		currentRecipe = new Recipe {
+			requiredItem = new List<Item>(),
+			requiredTile = Enumerable.Repeat(-1, maxVanillaRequirements).ToList(),
+			acceptedGroups = Enumerable.Repeat(-1, maxVanillaRequirements).ToList()
+		};
+		for (int i = 0; i < maxVanillaRequirements; i++) currentRecipe.requiredItem.Add(new Item());
+	}
+
+	internal Recipe(Mod mod = null)
+	{
+		Mod = mod;
+		RecipeIndex = -1;
 	}
 
 	public void Create()
 	{
+		RecipeLoader.ConsumedItems.Clear(); // just in case something throws or breaks and the 'clear after craft' doesn't run
+
 		Item[] array = null;
 		Item item = null;
-		Item item2 = null;
-		for (int i = 0; i < maxRequirements; i++) {
-			item2 = requiredItem[i];
-			if (item2.type == 0)
-				break;
-
+		foreach (Item item2 in requiredItem) {
 			int num = item2.stack;
 			if (alchemy && Main.player[Main.myPlayer].alchemyTable) {
 				if (num > 1) {
@@ -158,6 +_,8 @@
 				}
 			}
 
+			RecipeLoader.ConsumeItem(this, item2.type, ref num);
+
 			if (num <= 0)
 				continue;
 
@@ -169,10 +_,13 @@
 
 				if (item.IsTheSameAs(item2) || useWood(item.type, item2.type) || useSand(item.type, item2.type) || useFragment(item.type, item2.type) || useIronBar(item.type, item2.type) || usePressurePlate(item.type, item2.type) || AcceptedByItemGroups(item.type, item2.type)) {
 					if (item.stack > num) {
+						RecipeLoader.ConsumedItems.Add(item.Clone());
+						RecipeLoader.ConsumedItems[^1].stack = num;
 						item.stack -= num;
 						num = 0;
 					}
 					else {
+						RecipeLoader.ConsumedItems.Add(item);
 						num -= item.stack;
 						array[k] = new Item();
 					}
@@ -228,6 +_,8 @@
 					continue;
 
 				if (item.stack > num) {
+					RecipeLoader.ConsumedItems.Add(item.Clone());
+					RecipeLoader.ConsumedItems[^1].stack = num;
 					item.stack -= num;
 					if (Main.netMode == 1 && Main.player[Main.myPlayer].chest >= 0)
 						NetMessage.SendData(32, -1, -1, null, Main.player[Main.myPlayer].chest, m);
@@ -235,6 +_,7 @@
 					num = 0;
 				}
 				else {
+					RecipeLoader.ConsumedItems.Add(item);
 					num -= item.stack;
 					array[m] = new Item();
 					if (Main.netMode == 1 && Main.player[Main.myPlayer].chest >= 0)
@@ -248,7 +_,7 @@
 		FindRecipes();
 	}
 
-	public bool useWood(int invType, int reqType)
+	private bool useWood(int invType, int reqType)
 	{
 		if (!anyWood)
 			return false;
@@ -282,7 +_,7 @@
 		}
 	}
 
-	public bool useIronBar(int invType, int reqType)
+	private bool useIronBar(int invType, int reqType)
 	{
 		if (!anyIronBar)
 			return false;
@@ -296,7 +_,7 @@
 		return true;
 	}
 
-	public bool useSand(int invType, int reqType)
+	private bool useSand(int invType, int reqType)
 	{
 		if (reqType != 169 && reqType != 408 && reqType != 1246 && reqType != 370 && reqType != 3272 && reqType != 3338 && reqType != 3274 && reqType != 3275)
 			return false;
@@ -307,7 +_,7 @@
 		return false;
 	}
 
-	public bool useFragment(int invType, int reqType)
+	private bool useFragment(int invType, int reqType)
 	{
 		if (reqType != 3458 && reqType != 3456 && reqType != 3457 && reqType != 3459)
 			return false;
@@ -318,7 +_,7 @@
 		return false;
 	}
 
-	public bool usePressurePlate(int invType, int reqType)
+	private bool usePressurePlate(int invType, int reqType)
 	{
 		if (!anyPressurePlate)
 			return false;
@@ -382,7 +_,7 @@
 			if (recipe.createItem.type == 0)
 				break;
 
-			if (PlayerMeetsTileRequirements(localPlayer, recipe) && PlayerMeetsEnvironmentConditions(localPlayer, recipe) && CollectedEnoughItemsToCraftRecipeNew(recipe))
+			if (!recipe.Disabled && PlayerMeetsTileRequirements(localPlayer, recipe) && PlayerMeetsEnvironmentConditions(localPlayer, recipe) && CollectedEnoughItemsToCraftRecipeNew(recipe) && RecipeLoader.RecipeAvailable(recipe))
 				AddToAvailableRecipes(i);
 		}
 
@@ -398,7 +_,7 @@
 
 	public static bool CollectedEnoughItemsToCraftRecipeOld(Recipe tempRec)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
+		for (int i = 0; i < tempRec.requiredItem.Count; i++) {
 			Item item = tempRec.requiredItem[i];
 			if (item.type == 0)
 				break;
@@ -424,7 +_,7 @@
 
 	public static bool CollectedEnoughItemsToCraftRecipeNew(Recipe tempRec)
 	{
-		for (int i = 0; i < maxRequirements; i++) {
+		for (int i = 0; i < tempRec.requiredItem.Count; i++) {
 			RequiredItemEntry requiredItemEntry = tempRec.requiredItemQuickLookup[i];
 			if (requiredItemEntry.itemIdOrRecipeGroup == 0)
 				break;
@@ -441,7 +_,7 @@
 
 	private static bool PlayerMeetsEnvironmentConditions(Player player, Recipe tempRec)
 	{
-		bool num = !tempRec.needWater || player.adjWater || player.adjTile[172];
+		bool num = !tempRec.needWater || player.adjWater;
 		bool flag = !tempRec.needHoney || tempRec.needHoney == player.adjHoney;
 		bool flag2 = !tempRec.needLava || tempRec.needLava == player.adjLava;
 		bool flag3 = !tempRec.needSnowBiome || player.ZoneSnow;
@@ -452,7 +_,7 @@
 
 	private static bool PlayerMeetsTileRequirements(Player player, Recipe tempRec)
 	{
-		for (int i = 0; i < maxRequirements && tempRec.requiredTile[i] != -1; i++) {
+		for (int i = 0; i < tempRec.requiredTile.Count && tempRec.requiredTile[i] != -1; i++) {
 			if (!player.adjTile[tempRec.requiredTile[i]])
 				return false;
 		}
@@ -516,7 +_,10 @@
 			if (recipe.createItem.type == 0)
 				break;
 
+			if (recipe.Disabled)
+				continue;
+
-			for (int j = 0; j < maxRequirements; j++) {
+			for (int j = 0; j < recipe.requiredItem.Count; j++) {
 				Item item = recipe.requiredItem[j];
 				if (item.type == 0)
 					break;
@@ -613,6 +_,8 @@
 		RecipeGroupID.Fragment = RecipeGroup.RegisterGroup("Fragment", rec);
 		rec = new RecipeGroup(() => "replaceme pressureplate", 852, 543, 542, 541, 1151, 529, 853, 4261);
 		RecipeGroupID.PressurePlate = RecipeGroup.RegisterGroup("PressurePlate", rec);
+		RecipeGroupHelper.AddOldVanillaGroups();
+		RecipeGroupHelper.AddRecipeGroups();
 	}
 
 	public static void UpdateItemVariants()
@@ -620,8 +_,9 @@
 		for (int i = 0; i < maxRecipes; i++) {
 			Recipe obj = Main.recipe[i];
 			obj.createItem.Refresh();
+
-			Item[] array = obj.requiredItem;
+			var array = obj.requiredItem;
-			for (int j = 0; j < array.Length; j++) {
+			for (int j = 0; j < array.Count; j++) {
 				array[j].Refresh();
 			}
 		}
@@ -14518,10 +_,14 @@
 		AddRecipe();
 		CreateReverseWallRecipes();
 		CreateReversePlatformRecipes();
+		RecipeLoader.AddRecipes();
+		RecipeLoader.PostAddRecipes();
+		RecipeLoader.OrderRecipes();
 		UpdateWhichItemsAreMaterials();
 		UpdateWhichItemsAreCrafted();
 		UpdateMaterialFieldForAllRecipes();
 		ReplaceItemUseFlagsWithRecipeGroups();
+		FixRecipeGroups();
 		CreateRequiredItemQuickLookups();
 		ShimmerTransforms.UpdateRecipeSets();
 	}
@@ -14546,21 +_,17 @@
 
 	private static void CreateRequiredItemQuickLookups()
 	{
-		for (int i = 0; i < numRecipes; i++) {
+		for (int i = 0; i < Main.recipe.Length; i++) {
 			Recipe recipe = Main.recipe[i];
+			recipe.requiredItemQuickLookup = new RequiredItemEntry[recipe.requiredItem.Count];
-			for (int j = 0; j < maxRequirements; j++) {
+			for (int j = 0; j < recipe.requiredItem.Count; j++) {
 				Item item = recipe.requiredItem[j];
-				if (item.IsAir)
-					break;
 
 				RequiredItemEntry requiredItemEntry = default(RequiredItemEntry);
 				requiredItemEntry.itemIdOrRecipeGroup = item.type;
 				requiredItemEntry.stack = item.stack;
 				RequiredItemEntry requiredItemEntry2 = requiredItemEntry;
-				int[] array = recipe.acceptedGroups;
-				foreach (int num in array) {
+				foreach (int num in recipe.acceptedGroups) {
-					if (num < 0)
-						break;
 
 					RecipeGroup recipeGroup = RecipeGroup.recipeGroups[num];
 					if (recipeGroup.ValidItems.Contains(item.type))
@@ -14572,11 +_,30 @@
 		}
 	}
 
+	private static void FixRecipeGroups()
+	{
+		// Remove recipe group assignments to recipes that don't actually have any items in the recipe groups anymore for one reason or another.
+		for (int i = 0; i < numRecipes; i++) {
+			Recipe recipe = Main.recipe[i];
+			if (recipe.acceptedGroups.Count > 0) {
+				var toRemove = new List<int>();
+				foreach (int num in recipe.acceptedGroups) {
+					if (!RecipeGroup.recipeGroups[num].ValidItems.Intersect(recipe.requiredItem.Select(x => x.type)).Any()) {
+						toRemove.Add(num);
+					}
+				}
+				foreach (var group in toRemove) {
+					recipe.acceptedGroups.Remove(group);
+				}
+			}
+		}
+	}
+
 	private static void UpdateMaterialFieldForAllRecipes()
 	{
 		for (int i = 0; i < numRecipes; i++) {
-			for (int j = 0; Main.recipe[i].requiredItem[j].type > 0; j++) {
-				Main.recipe[i].requiredItem[j].material = ItemID.Sets.IsAMaterial[Main.recipe[i].requiredItem[j].type];
+			foreach (Item item in Main.recipe[i].requiredItem) {
+				item.material = ItemID.Sets.IsAMaterial[item.type];
 			}
 
 			Main.recipe[i].createItem.material = ItemID.Sets.IsAMaterial[Main.recipe[i].createItem.type];
@@ -14585,17 +_,47 @@
 
 	public static void UpdateWhichItemsAreMaterials()
 	{
+		for (int i = 0; i < Recipe.numRecipes; i++) {
+			if (Main.recipe[i].Disabled)
+				continue;
+
+			foreach (Item item in Main.recipe[i].requiredItem) {
+				ItemID.Sets.IsAMaterial[item.type] = true;
+			}
+		}
+
+		// TODO: Check that each group is used at least once?
+		foreach (RecipeGroup recipeGroup in RecipeGroup.recipeGroups.Values) {
+			foreach (var item in recipeGroup.ValidItems) {
+				ItemID.Sets.IsAMaterial[item] = true;
+			}
+		}
+
+		// These come from the removed Item.checkMat. Coins and Void Bag. Void Bag is removed since it would be odd to have the Material tooltip appear on the open bag and not be present on the closed bag
+		ItemID.Sets.IsAMaterial[71] = false;
+		ItemID.Sets.IsAMaterial[72] = false;
+		ItemID.Sets.IsAMaterial[73] = false;
+		ItemID.Sets.IsAMaterial[74] = false;
+		ItemID.Sets.IsAMaterial[4076] = false;
+		ItemID.Sets.IsAMaterial[4131] = false;
+		ItemID.Sets.IsAMaterial[5325] = false;
+
+		/*
 		for (int i = 0; i < 5456; i++) {
 			Item item = new Item();
 			item.SetDefaults(i, noMatCheck: true);
 			item.checkMat();
 			ItemID.Sets.IsAMaterial[i] = item.material;
 		}
+		*/
 	}
 
 	public static void UpdateWhichItemsAreCrafted()
 	{
 		for (int i = 0; i < numRecipes; i++) {
+			if (Main.recipe[i].Disabled)
+				continue;
+
 			if (!Main.recipe[i].notDecraftable)
 				ItemID.Sets.IsCrafted[Main.recipe[i].createItem.type] = i;
 
@@ -15747,23 +_,24 @@
 	{
 		int num = numRecipes;
 		for (int i = 0; i < num; i++) {
-			if (Main.recipe[i].createItem.createTile >= 0 && TileID.Sets.Platforms[Main.recipe[i].createItem.createTile] && Main.recipe[i].requiredItem[1].type == 0) {
+			if (Main.recipe[i].createItem.createTile >= 0 && TileID.Sets.Platforms[Main.recipe[i].createItem.createTile] && Main.recipe[i].requiredItem.Count == 1) {
 				currentRecipe.createItem.SetDefaults(Main.recipe[i].requiredItem[0].type);
 				currentRecipe.createItem.stack = Main.recipe[i].requiredItem[0].stack;
 				currentRecipe.requiredItem[0].SetDefaults(Main.recipe[i].createItem.type);
 				currentRecipe.requiredItem[0].stack = Main.recipe[i].createItem.stack;
-				for (int j = 0; j < currentRecipe.requiredTile.Length; j++) {
-					currentRecipe.requiredTile[j] = Main.recipe[i].requiredTile[j];
-				}
+				currentRecipe.requiredTile = new List<int>(Main.recipe[i].requiredTile);
 
 				AddRecipe();
 				Recipe recipe = Main.recipe[numRecipes - 1];
 				for (int num2 = numRecipes - 2; num2 > i; num2--) {
-					Main.recipe[num2 + 1] = Main.recipe[num2];
+					Recipe switchedRecipe = Main.recipe[num2];
+					Main.recipe[num2 + 1] = switchedRecipe;
+					switchedRecipe.RecipeIndex = num2 + 1;
 				}
 
 				Main.recipe[i + 1] = recipe;
 				Main.recipe[i + 1].notDecraftable = true;
+				recipe.RecipeIndex = i + 1;
 			}
 		}
 	}
@@ -15772,28 +_,29 @@
 	{
 		int num = numRecipes;
 		for (int i = 0; i < num; i++) {
-			if (Main.recipe[i].createItem.createWall > 0 && Main.recipe[i].requiredItem[1].type == 0 && Main.recipe[i].requiredItem[0].createWall == -1) {
+			if (Main.recipe[i].createItem.createWall > 0 && Main.recipe[i].requiredItem.Count == 1 && Main.recipe[i].requiredItem[0].createWall == -1) {
 				currentRecipe.createItem.SetDefaults(Main.recipe[i].requiredItem[0].type);
 				currentRecipe.createItem.stack = Main.recipe[i].requiredItem[0].stack;
 				currentRecipe.requiredItem[0].SetDefaults(Main.recipe[i].createItem.type);
 				currentRecipe.requiredItem[0].stack = Main.recipe[i].createItem.stack;
-				for (int j = 0; j < currentRecipe.requiredTile.Length; j++) {
-					currentRecipe.requiredTile[j] = Main.recipe[i].requiredTile[j];
-				}
+				currentRecipe.requiredTile = new List<int>(Main.recipe[i].requiredTile);
 
 				AddRecipe();
 				Recipe recipe = Main.recipe[numRecipes - 1];
 				for (int num2 = numRecipes - 2; num2 > i; num2--) {
-					Main.recipe[num2 + 1] = Main.recipe[num2];
+					Recipe switchedRecipe = Main.recipe[num2];
+					Main.recipe[num2 + 1] = switchedRecipe;
+					switchedRecipe.RecipeIndex = num2 + 1;
 				}
 
 				Main.recipe[i + 1] = recipe;
 				Main.recipe[i + 1].notDecraftable = true;
+				recipe.RecipeIndex = i + 1;
 			}
 		}
 	}
 
-	public void SetIngredients(params int[] ingredients)
+	private void SetIngredients(params int[] ingredients)
 	{
 		if (ingredients.Length == 1) {
 			ingredients = new int[2] {
@@ -15812,7 +_,7 @@
 		}
 	}
 
-	public void SetCraftingStation(params int[] tileIDs)
+	private void SetCraftingStation(params int[] tileIDs)
 	{
 		for (int i = 0; i < tileIDs.Length; i++) {
 			requiredTile[i] = tileIDs[i];
@@ -15821,11 +_,44 @@
 
 	private static void AddRecipe()
 	{
-		if (currentRecipe.requiredTile[0] == 13)
-			currentRecipe.alchemy = true;
+		if (currentRecipe.requiredTile.Count > 0 && currentRecipe.requiredTile[0] == TileID.Bottles)
+			currentRecipe.AddConsumeItemCallback(ConsumptionRules.Alchemy);
+
+		static void ReplaceCondition(ref bool field, Recipe.Condition cond) {
+			if (field)
+				currentRecipe.AddCondition(cond);
+
+			field = false;
+		}
+
+		ReplaceCondition(ref currentRecipe.needGraveyardBiome, Condition.InGraveyardBiome);
+		ReplaceCondition(ref currentRecipe.needSnowBiome, Condition.InSnow);
+		ReplaceCondition(ref currentRecipe.needWater, Condition.NearWater);
+		ReplaceCondition(ref currentRecipe.needLava, Condition.NearLava);
+		ReplaceCondition(ref currentRecipe.needHoney, Condition.NearHoney);
+		ReplaceCondition(ref currentRecipe.needEverythingSeed, Condition.EverythingSeed);
+
+		currentRecipe.requiredItem.RemoveAll(item => item.IsAir);
+		currentRecipe.requiredTile.RemoveAll(tile => tile == -1);
+		currentRecipe.acceptedGroups.RemoveAll(group => group == -1);
 
 		Main.recipe[numRecipes] = currentRecipe;
-		currentRecipe = new Recipe();
+		currentRecipe.RecipeIndex = numRecipes;
+
+		if (RecipeLoader.FirstRecipeForItem[currentRecipe.createItem.type] == null) {
+			RecipeLoader.FirstRecipeForItem[currentRecipe.createItem.type] = currentRecipe;
+		}
+
+		// The following resets the currentRecipe field
+		currentRecipe = new Recipe {
+			requiredItem = new List<Item>(),
+			requiredTile = Enumerable.Repeat(-1, maxVanillaRequirements).ToList(),
+			acceptedGroups = Enumerable.Repeat(-1, maxVanillaRequirements).ToList()
+		};
+
+		for (int i = 0; i < maxVanillaRequirements; i++)
+			currentRecipe.requiredItem.Add(new Item());
+
 		numRecipes++;
 	}
 
