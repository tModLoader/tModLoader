--- src/TerrariaNetCore/Terraria/Main.cs
+++ src/tModLoader/Terraria/Main.cs
@@ -3,7 +_,10 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+// Don't reimport, this causes Microsoft.Xna.Framework.Color import conflict
+/*
 using System.Drawing;
+*/
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -64,9 +_,16 @@
 using Terraria.IO;
 using Terraria.Localization;
 using Terraria.Map;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Core;
+using Terraria.ModLoader.Default;
+using Terraria.ModLoader.Engine;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
 using Terraria.Net;
 using Terraria.ObjectData;
 using Terraria.Social;
+using Terraria.Social.Steam;
 using Terraria.UI;
 using Terraria.UI.Chat;
 using Terraria.UI.Gamepad;
@@ -86,9 +_,9 @@
 #endif
 
 #if SERVER
-public class Main : Terraria.Server.Game
+public partial class Main : Terraria.Server.Game
 #else
-public class Main : Game
+public partial class Main : Game
 #endif
 {
 	public delegate void OnPlayerSelected(PlayerFileData player);
@@ -143,20 +_,31 @@
 		private int _lastScreenHeight;
 		private InputMode _lastInputMode;
 
-		public string[] TextLines { get; private set; }
+		// Added by TML.
+		private Color originalColor;
+
+		public List<List<TextSnippet>> TextLines { get; private set; } // Changed from string[]
 
 		public int AmountOfLines { get; private set; }
 
-		public void PrepareCache(string text)
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		// Added baseColor parameter
+		public void PrepareCache(string text, Color baseColor)
 		{
-			if (false | (screenWidth != _lastScreenWidth) | (screenHeight != _lastScreenHeight) | (_originalText != text) | (PlayerInput.CurrentInputMode != _lastInputMode)) {
+			if (false | (screenWidth != _lastScreenWidth) | (screenHeight != _lastScreenHeight) | (_originalText != text) | (PlayerInput.CurrentInputMode != _lastInputMode) | (originalColor != baseColor)) {
 				_lastScreenWidth = screenWidth;
 				_lastScreenHeight = screenHeight;
 				_originalText = text;
 				_lastInputMode = PlayerInput.CurrentInputMode;
 				text = Lang.SupportGlyphs(text);
+				originalColor = baseColor;
+
+				/*
 				TextLines = Utils.WordwrapString(text, FontAssets.MouseText.Value, 460, 10, out var lineAmount);
 				AmountOfLines = lineAmount;
+				*/
+				TextLines = Utils.WordwrapStringSmart(text, baseColor, FontAssets.MouseText.Value, 460, 10);
+				AmountOfLines = TextLines.Count;
 			}
 		}
 	}
@@ -258,7 +_,7 @@
 	public static bool zenithWorld = false;
 	public static Vector2 destroyerHB = new Vector2(0f, 0f);
 	public static FavoritesFile LocalFavoriteData = new FavoritesFile(SavePath + "/favorites.json", isCloud: false);
-	public static FavoritesFile CloudFavoritesData = new FavoritesFile("favorites.json", isCloud: true);
+	public static FavoritesFile CloudFavoritesData = new FavoritesFile("ModLoader/favorites.json", true); // Added "Modloader/" prefix
 	public static FileMetadata WorldFileMetadata;
 	public static FileMetadata MapFileMetadata;
 	public static PingMapLayer Pings = new PingMapLayer();
@@ -487,12 +_,17 @@
 	public static bool showSplash = true;
 	public static bool ignoreErrors = true;
 	public static string defaultIP = "";
+
+	/// <summary>
+	/// The rate at which <see cref="time"/> updates per tick.
+	/// <br/> Can be modified using <see cref="ModSystem.ModifyTimeRate(ref double, ref double, ref double)"/>. Capped at <c>86,400.0</c>.
+	/// </summary>
-	public static int dayRate = 1;
+	public static double dayRate = 1;
-	public static int desiredWorldTilesUpdateRate = 1;
+	public static double desiredWorldTilesUpdateRate = 1;
 	public static int maxScreenW = 1920;
 	public static int maxScreenH = 1200;
 	public static int minScreenW = 800;
-	public static int minScreenH = 600;
+	public static int minScreenH = 720; // Used to be '600'
 	public static float iS = 1f;
 	public static bool render;
 	public static int qaStyle;
@@ -501,13 +_,58 @@
 	public static float musicPitch = 0f;
 	public static bool[] projHostile = new bool[ProjectileID.Count];
 	public static bool[] projHook = new bool[ProjectileID.Count];
+
+	/// <summary>
+	/// Indexed by <see cref="BuffID"/>. If <see langword="true"/> for a given <see cref="BuffID"/>, then that buff can be applied to players by other players in PvP.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public static bool[] pvpBuff = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Allows status effects for which this is set to true to persist after the afflicted player's death.<br/>
+	/// Defaults to false; all vanilla flask effects have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] persistentBuff = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being from vanity pets, preventing them from overlapping with other vanity pet status effects.<br/>
+	/// Defaults to false; all vanilla vanity pets have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] vanityPet = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being tied to a light pet, preventing them from overlapping with other light pet status effects.<br/>
+	/// Defaults to false; all vanilla light pets have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] lightPet = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being from flasks, preventing them from overlapping with other flask status effects.<br/>
+	/// Defaults to false; all vanilla flask effects have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] meleeBuff = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being debuffs instead of buffs.<br/>
+	/// This has multiple effects on gameplay:<br/>
+	/// - the Nurse can remove the status effect when healing the afflicted player (to prevent this, refer to <see cref="BuffID.Sets.NurseCannotRemoveDebuff"/>)<br/>
+	/// - the status effect cannot be cleared from overflowing the status effect cap (buffs will be cleared instead)<br/>
+	/// - the status effect cannot be cleared by right-clicking it (which can be done for all other status effect types)<br/>
+	/// Defaults to false; all vanilla debuffs have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] debuff = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Indexed by <see cref="BuffID"/>. If <see langword="true"/> for a given <see cref="BuffID"/>, then that buff will not be saved when exiting a world.
+	/// <br/> Vanilla sets this for DoT effects (<see cref="BuffID.Poisoned"/>), short item buffs (<see cref="BuffID.Panic"/>), mount buffs, and conditionally-applied buffs (<see cref="BuffID.Campfire"/>, <see cref="BuffID.Werewolf"/>).
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public static bool[] buffNoSave = new bool[BuffID.Count];
+
+	/// <summary>
+	/// Prevents status effects which have their entries set to true from displaying the amount of time they have left.<br/>
+	/// Defaults to false; most, if not all, status effects which have their entries set to true here are related to mounts, pets, and summons.<br/>
+	/// </summary>
 	public static bool[] buffNoTimeDisplay = new bool[BuffID.Count];
 	public static bool[] buffDoubleApply = new bool[BuffID.Count];
 	public static int maxMP = 10;
@@ -519,7 +_,7 @@
 	public static int instantBGTransitionCounter = 2;
 	public static int bgDelay;
 	public static int bgStyle;
-	private const int BG_STYLES_COUNT = 14;
+	internal const int BG_STYLES_COUNT = 14;
 	public static float[] bgAlphaFrontLayer = new float[14];
 	public static float[] bgAlphaFarBackLayer = new float[14];
 	public static int[] bgFrame = new int[14];
@@ -533,13 +_,13 @@
 	public static int wofDrawAreaBottom;
 	public static int wofDrawFrameIndex;
 	public static int offScreenRange = 200;
-	private RenderTarget2D backWaterTarget;
+	public RenderTarget2D backWaterTarget;
 	public static RenderTarget2D waterTarget;
-	private RenderTarget2D tileTarget;
+	public RenderTarget2D tileTarget;
-	private RenderTarget2D blackTarget;
+	public RenderTarget2D blackTarget;
-	private RenderTarget2D tile2Target;
+	public RenderTarget2D tile2Target;
-	private RenderTarget2D wallTarget;
+	public RenderTarget2D wallTarget;
-	private RenderTarget2D backgroundTarget;
+	public RenderTarget2D backgroundTarget;
 	public static RenderTarget2D screenTarget;
 	public static RenderTarget2D screenTargetSwap;
 	public static int maxMapUpdates = 250000;
@@ -560,8 +_,8 @@
 	public static bool clearMap;
 	public static int mapTargetX = 5;
 	public static int mapTargetY = 2;
-	private RenderTarget2D[,] mapTarget = new RenderTarget2D[mapTargetX, mapTargetY];
+	public RenderTarget2D[,] mapTarget = new RenderTarget2D[mapTargetX, mapTargetY];
-	private RenderTarget2D mapSectionTexture;
+	public RenderTarget2D mapSectionTexture;
 	public static bool[,] initMap = new bool[mapTargetX, mapTargetY];
 	public static bool[,] mapWasContentLost = new bool[mapTargetX, mapTargetY];
 	public const int numInfoIcons = 13;
@@ -592,12 +_,12 @@
 	private int lastTileX;
 	private int firstTileY;
 	private int lastTileY;
-	private double bgParallax;
+	internal double bgParallax;
-	private int bgStartX;
+	internal int bgStartX;
-	private int bgLoops;
+	internal int bgLoops;
 	private int bgStartY;
 	private int bgLoopsY;
-	private int bgTopY;
+	internal int bgTopY;
 	public static int renderCount = 99;
 	private const int MF_BYPOSITION = 1024;
 	public static GraphicsDeviceManager graphics;
@@ -671,7 +_,15 @@
 	public static float rightWorld = 134400f;
 	public static float topWorld = 0f;
 	public static float bottomWorld = 38400f;
+
+	/// <summary>
+	/// The width of the currently-loaded world in tiles.
+	/// </summary>
 	public static int maxTilesX = (int)rightWorld / 16 + 1;
+
+	/// <summary>
+	/// The height of the currently-loaded world in tiles.
+	/// </summary>
 	public static int maxTilesY = (int)bottomWorld / 16 + 1;
 	public const int sectionWidth = 200;
 	public const int sectionHeight = 150;
@@ -683,12 +_,12 @@
 	public const int maxItemText = 20;
 	public const int maxPlayers = 255;
 	public static int maxNetPlayers = 255;
-	public const int maxChests = 8000;
+	public static readonly int maxChests = 8000;
-	public const int maxItems = 400;
+	public static readonly int maxItems = 400;
-	public const int maxProjectiles = 1000;
+	public static readonly int maxProjectiles = 1000;
-	public const int maxNPCs = 200;
+	public static readonly int maxNPCs = 200;
-	private static UICharacterSelect _characterSelectMenu = new UICharacterSelect();
+	internal static UICharacterSelect _characterSelectMenu = new UICharacterSelect();
-	private static UIWorldSelect _worldSelectMenu = new UIWorldSelect();
+	internal static UIWorldSelect _worldSelectMenu = new UIWorldSelect();
 	public static UIManageControls ManageControlsMenu = new UIManageControls();
 	public static UIAchievementsMenu AchievementsMenu = new UIAchievementsMenu();
 	public static int maxRain = 750;
@@ -743,19 +_,48 @@
 	public static int LogoA = 255;
 	public static int LogoB;
 	public static bool LogoT;
+
+	//TML: Turned into a property to log every change of it.
-	public static string statusText = "";
+	private static string _statusText = "";
+	public static string statusText {
+		get => _statusText;
+		set {
+			Logging.LogStatusChange(_statusText, value);
+			_statusText = value;
+		}
+	}
+
 	public static string worldName = "";
 	public static int worldID;
 	public static int background;
 	public static int caveBackground = 0;
 	public static float ugBackTransition;
 	public static Microsoft.Xna.Framework.Color tileColor;
+
+	/// <summary>
+	/// The y-coordinate of the top of the dirt layer, in tile coordinates. Corresponds to 0' on the Depth Meter.
+	/// </summary>
+	/// <remarks>Players under the surface will have <see cref="Player.ZoneDirtLayerHeight"/> set to <see langword="true"/>.</remarks>
 	public static double worldSurface;
+
+	/// <summary>
+	/// The y-coordinate of the top of the caverns layer, in tile coordinates.
+	/// </summary>
+	/// <remarks>Players in this layer will have <see cref="Player.ZoneRockLayerHeight"/> set to <see langword="true"/>.</remarks>
 	public static double rockLayer;
 	public static Microsoft.Xna.Framework.Color[] teamColor = new Microsoft.Xna.Framework.Color[6];
 	public const double dayLength = 54000.0;
 	public const double nightLength = 32400.0;
 	public static bool dayTime = true;
+
+	/// <summary>
+	/// The time that has passed since it last became day/night.
+	/// <br/> Increased by <see cref="dayRate"/> every tick.
+	/// <br/> If it is <see cref="dayTime"/>, this caps at <see cref="dayLength"/>. Otherwise, this caps at <see cref="nightLength"/>.
+	/// </summary>
+	/// <remarks>
+	/// If you need 24-hour time, use <see cref="Utils.GetDayTimeAs24FloatStartingFromMidnight"/>.
+	/// </remarks>
 	public static double time = 13500.0;
 	public static double timeForVisualEffects;
 	public static int moonPhase;
@@ -768,7 +_,7 @@
 	public static float cloudAlpha;
 	public static float maxRaining;
 	public static float oldMaxRaining;
-	public static int rainTime;
+	public static double rainTime;
 	public static bool raining;
 	public static bool eclipse;
 	public static float eclipseLight;
@@ -777,6 +_,13 @@
 	public static int BartenderHelpTextIndex = 0;
 	public static bool autoGen;
 	public static bool autoPause = false;
+
+	/// <summary>
+	/// Indicates how many frames of animation are in each projectile type spritesheet.<br/>
+	/// Use <see cref="Projectile.frame"/> to animate the projectile.<br/>
+	/// The <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Projectile#animationmultiple-frames">Basic Projectile Guide</see> teaches how to animate projectiles.<br/>
+	/// Indexed by <see cref="Projectile.type"/>. Defaults to 1.
+	/// </summary>
 	public static int[] projFrames = new int[ProjectileID.Count];
 	public static bool[] projPet = new bool[ProjectileID.Count];
 	public static float demonTorch = 1f;
@@ -807,8 +_,15 @@
 	public static int fadeCounter;
 	public static float invAlpha = 1f;
 	public static float invDir = 1f;
+
+	//TML: Turned into a property for null safety.
 	[ThreadStatic]
-	public static UnifiedRandom rand;
+	public static UnifiedRandom _rand;
+	public static UnifiedRandom rand {
+		get => _rand ??= new UnifiedRandom();
+		set => _rand = value;
+	}
+
 	public static bool allChestStackHover;
 	public static bool inventorySortMouseOver;
 	public static float GraveyardVisualIntensity;
@@ -829,29 +_,67 @@
 	public static float ambientVolume = 1f;
 	public static float soundVolume = 1f;
 	public static ServerMode MenuServerMode = ServerMode.Lobby | ServerMode.FriendsCanJoin;
+
+	/// <summary>
+	/// Indexed by <see cref="TileID"/>. If <see langword="true"/> for a given <see cref="TileID"/>, then that tile produces light.
+	/// <br/> You can set the light color for tile using <see cref="ModBlockType.ModifyLight(int, int, ref float, ref float, ref float)"/> or <see cref="GlobalBlockType.ModifyLight(int, int, int, ref float, ref float, ref float)"/>.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public static bool[] tileLighted = new bool[TileID.Count];
+
+	/// <summary>
+	/// Indexed by <see cref="TileID"/>. If <see langword="true"/> for a given <see cref="TileID"/>, then that tile has frames for merging with <see cref="TileID.Dirt"/>.
+	/// <br/> Defaults to <see langword="false"/>.
+	/// </summary>
 	public static bool[] tileMergeDirt = new bool[TileID.Count];
+	/// <summary>
+	/// If true, Tiles of the indexed Tile Type will be destroyed by weapons and projectiles.
+	/// </summary>
 	public static bool[] tileCut = new bool[TileID.Count];
 	public static bool[] tileAlch = new bool[TileID.Count];
+	/// <summary>
+	/// How rarely tiny ambient dust appear from this tile. Larger values mean less frequently
+	/// </summary>
 	public static int[] tileShine = new int[TileID.Count];
+	/// <summary>
+	/// If true, the tile will be drawn to be slightly more bright. 
+	/// </summary>
 	public static bool[] tileShine2 = new bool[TileID.Count];
+	/// <summary>
+	/// If true, the wall is considered "safe" for enemy spawning purposes.
+	/// </summary>
 	public static bool[] wallHouse = new bool[WallID.Count];
 	public static bool[] wallDungeon = new bool[WallID.Count];
 	public static bool[] wallLight = new bool[WallID.Count];
 	public static int[] wallBlend = new int[WallID.Count];
 	public static bool[] tileStone = new bool[TileID.Count];
+	/// <summary>
+	/// If true for the given tile type, tiles of the type are mined using an axe instead of pickaxe.
+	/// </summary>
 	public static bool[] tileAxe = new bool[TileID.Count];
 	public static bool[] tileHammer = new bool[TileID.Count];
+	/// <summary>
+	/// If true for the given tile type, tiles of the type will be destroyed if in contact with water. <see cref="TileObjectData.WaterDeath"/> supersedes this if a <see cref="TileObjectData"/> is available.
+	/// </summary>
 	public static bool[] tileWaterDeath = new bool[TileID.Count];
+	/// <summary>
+	/// If true for the given tile type, tiles of the type will be destroyed if in contact with lava. <see cref="TileObjectData.LavaDeath"/> supersedes this if a <see cref="TileObjectData"/> is available. Use <see cref="tileObsidianKill"/> instead if the tile should only be killed by obsidian forming over it.
+	/// </summary>
 	public static bool[] tileLavaDeath = new bool[TileID.Count];
 	public static bool[] tileTable = new bool[TileID.Count];
 	public static bool[] tileBlockLight = new bool[TileID.Count];
 	public static bool[] tileNoSunLight = new bool[TileID.Count];
 	public static bool[] tileDungeon = new bool[TileID.Count];
+	/// <summary>
+	/// If true for the given tile type, tiles will be drawn much brighter and give off additional dust if the player is under the effects of the Spelunker buff, magic lantern, or similar effect. 
+	/// </summary>
 	public static bool[] tileSpelunker = new bool[TileID.Count];
 	public static bool[] tileSolidTop = new bool[TileID.Count];
 	public static bool[] tileSolid = new bool[TileID.Count];
 	public static bool[] tileBouncy = new bool[TileID.Count];
+	/// <summary>
+	/// The priority of this tile in relation to the Metal Detector. The tile with the highest priority in range will show the corresponding map entry. The <see href="https://terraria.wiki.gg/wiki/Metal_Detector">Metal Detector wiki page</see> lists existing values to use as reference.
+	/// </summary>
 	public static short[] tileOreFinderPriority = new short[TileID.Count];
 	public static byte[] tileLargeFrames = new byte[TileID.Count];
 	public static byte[] wallLargeFrames = new byte[WallID.Count];
@@ -861,7 +_,12 @@
 	public static bool[] tileNoAttach = new bool[TileID.Count];
 	public static bool[] tileNoFail = new bool[TileID.Count];
 	public static bool[] tileCracked = new bool[TileID.Count];
+	/// <summary>
+	/// If true for the given tile type, tiles of the type will be destroyed if obsidian would generate at it's location because of lava and water mixing. Automatically set to true if <see cref="tileLavaDeath"/> is true. Many tiles are immune to lava but break if obsidian kills it, such as Statues and Anvils.
+	/// </summary>
 	public static bool[] tileObsidianKill = new bool[TileID.Count];
+	/// <summary> Set to true if this is not a typical Terrain tile. Terrain tiles are 1x1 tiles that automatically adjust their frame values to nearby tiles. They don't have a TileObjectData.
+	/// <br/> All non-1x1 tiles should set this to true. All 1x1 tiles that have a TileObjectData or that should preserve frame data should set this to true. </summary>
 	public static bool[] tileFrameImportant = new bool[TileID.Count];
 	public static bool[] tilePile = new bool[TileID.Count];
 	public static bool[] tileBlendAll = new bool[TileID.Count];
@@ -941,7 +_,15 @@
 	public static int[] grasshopperCageFrame = new int[cageFrames];
 	public static int[] grasshopperCageFrameCounter = new int[cageFrames];
 	public static bool[] tileSand = new bool[TileID.Count];
+	/// <summary>If true, indicates that a tile has a flame texture that will draw over the tile. Modded tiles should not use this. <see cref="ModBlockType.PostDraw(int, int, SpriteBatch)"/> can be used to manually draw a flame texture.</summary>
 	public static bool[] tileFlame = new bool[TileID.Count];
+
+	/// <summary>
+	/// Used to denote an NPC as being catchable by bug nets and similar.<br/>
+	/// Contrary to its name, this array isn't actually used for catching logic at all.<br/>
+	/// It is instead used to determine if an NPC can be released back into the world after being caught.<br/>
+	/// These NPC will be forced <see cref="NPC.friendly"/> for 1.5 seconds if naturally spawned.<br/>
+	/// </summary>
 	public static bool[] npcCatchable = new bool[NPCID.Count];
 	public static int[] tileFrame = new int[TileID.Count];
 	public static int[] tileFrameCounter = new int[TileID.Count];
@@ -952,7 +_,10 @@
 	public static HairstyleUnlocksHelper Hairstyles = new HairstyleUnlocksHelper();
 	public static bool tilesLoaded = false;
 	public static WorldMap Map;
+	/*
 	public static Tile[,] tile = new Tile[maxTilesX, maxTilesY];
+	*/
+	public static Tilemap tile = new((ushort)maxTilesX, (ushort)maxTilesY);
 	public static Dust[] dust = new Dust[6001];
 	public static Star[] star = new Star[400];
 	public static Item[] item = new Item[401];
@@ -972,6 +_,10 @@
 	private static DrawAnimation _coinOnWorldAnimation = new DrawAnimationVertical(6, 8);
 	private static DrawAnimation _monkStaffT3OnWorldAnimation = new DrawAnimationVertical(5, 3);
 	public static List<int> itemAnimationsRegistered = new List<int>();
+	/// <summary>
+	/// The position of the top left corner of the screen in world coordinates. Modify in <see cref="ModSystem.ModifyScreenPosition"/> or <see cref="ModPlayer.ModifyScreenPosition"/>. Also consider using <c>Main.instance.CameraModifiers.Add(CameraModifier);</c> as shown in ExampleMods MinionBossBody for screen shakes.<br/><br/>
+	/// When manually drawing, subtracting Main.screenPosition from the world position of the thing being drawn will result in the correct screen coordinates for use in <see cref="SpriteBatch"/>.Draw methods. When drawing tiles or walls, an additional offset calculated as <c>Vector2 zero = Main.drawToScreen? Vector2.Zero : new Vector2(Main.offScreenRange, Main.offScreenRange);</c> needs to be added to the coordinates.
+	/// </summary>
 	public static Vector2 screenPosition;
 	public static Vector2 screenLastPosition;
 	public static int screenWidth = 1152;
@@ -1001,6 +_,10 @@
 		0.75f,
 		0.75f
 	};
+	/// <summary>
+	/// A value that oscillates between 190 and 255. It is used to drive the slight pulsing color effect seen in much of the text shown in-game. The value is used to create <see cref="Color"/>s by passing in this value as either all 4 parameters or just the alpha parameter.<br/><br/>
+	/// <see cref="Main.MouseTextColorReal"/> can be used to access the typical pulsing white <see cref="Color"/> value.
+	/// </summary>
 	public static byte mouseTextColor;
 	public static int mouseTextColorChange = 1;
 	public static bool mouseLeftRelease;
@@ -1026,6 +_,11 @@
 	public static float[] availableRecipeY = new float[Recipe.maxRecipes];
 	public static int numAvailableRecipes;
 	public static int focusRecipe;
+
+	/// <summary>
+	/// The index in <see cref="player"/> of this client's Player.
+	/// <br/> If this is <c>255</c>, this client is the server.
+	/// </summary>
 	public static int myPlayer;
 	public static Player[] player = new Player[256];
 	public static Player[] playerVisualClone = new Player[256];
@@ -1044,8 +_,11 @@
 	public static bool npcChatFocus3;
 	public static bool npcChatFocus4;
 	public static int oldNPCShop;
+	/// <summary>
+	/// The item type of the item icon to display at the bottom right corner of the NPC chat window. The Angler uses this functionality to display the fishing quest fish item, but it can be used to show any item. Assign during <see cref="ModNPC.GetChat"/>. Defaults to 0.
+	/// </summary>
 	public static int npcChatCornerItem;
-	public Chest[] shop = new Chest[100];
+	public Chest[] shop = new Chest[2]; // technically only need a single Chest for the shop, but npcShop 0 is used for 'no shop' and we don't want to patch 20 places
 	public static ItemShopSellbackHelper shopSellbackHelper = new ItemShopSellbackHelper();
 	public static int[] travelShop = new int[40];
 	public static List<string> anglerWhoFinishedToday = new List<string>();
@@ -1139,9 +_,9 @@
 	public static List<WorldFileData> WorldList = new List<WorldFileData>();
 	public static WorldFileData ActiveWorldFileData = new WorldFileData();
 	public static string WorldPath = Path.Combine(SavePath, "Worlds");
-	public static string CloudWorldPath = "worlds";
+	public static string CloudWorldPath = Program.SaveFolderName + "/worlds";
 	public static string PlayerPath = Path.Combine(SavePath, "Players");
-	public static string CloudPlayerPath = "players";
+	public static string CloudPlayerPath = Program.SaveFolderName + "/players";
 	public static Preferences Configuration = new Preferences(SavePath + Path.DirectorySeparatorChar + "config.json");
 	public static Preferences InputProfiles = new Preferences(SavePath + Path.DirectorySeparatorChar + "input profiles.json");
 	public static KeyboardState inputText;
@@ -1860,11 +_,19 @@
 	public static float exitScale = 0.8f;
 	public static bool mouseReforge;
 	public static float reforgeScale = 0.8f;
+	/// <summary>
+	/// Used internally for network syncing. Use <see cref="Main.LocalPlayer"/> to access the player for the local user.
+	/// </summary>
 	public static Player clientPlayer = new Player();
 	public static string getIP = defaultIP;
 	public static string getPort = Convert.ToString(Netplay.ListenPort);
 	public static bool menuMultiplayer;
 	public static bool menuServer;
+	/// <summary>
+	/// Denotes the current network mode: <b>0</b> for single player client, <b>1</b> for multiplayer client, and <b>2</b> for server.<br/>
+	/// Using <see cref="ID.NetmodeID"/> entries instead of 0, 1, and 2 will greatly enhance code readability.<br/>
+	/// Modders must properly use netMode to selectively run code. Following examples in ExampleMod and Terraria code as well as reading the <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Netcode">Basic Netcode guide</see> are the best way to learn how to use netMode correctly.<br/>
+	/// </summary>
 	public static int netMode;
 	private static int _targetNetMode;
 	private static bool _hasPendingNetmodeChange;
@@ -1970,7 +_,7 @@
 	public static bool _shouldUseWindyDayMusic = false;
 	public static bool _shouldUseStormMusic = false;
 	private int lastMusicPlayed = -1;
-	private bool playOldTile;
+	public bool playOldTile;
 	private static float _minWind = 0.34f;
 	private static float _maxWind = 0.4f;
 	private static float _minRain = 0.4f;
@@ -1985,8 +_,11 @@
 	public static float ambientLavaY = -1f;
 	public static float ambientLavaStrength;
 	public static int ambientCounter;
+	//TML: No longer of use due to changes in Main.Ambience().
+	/*
 	private static bool _isWaterfallMusicPlaying = false;
 	private static bool _isLavafallMusicPlaying = false;
+	*/
 	public static IChatMonitor chatMonitor = new RemadeChatMonitor();
 	public static int ProjectileUpdateLoopIndex = -1;
 	public static GameTipsDisplay gameTips;
@@ -2007,17 +_,17 @@
 	private int selectedMenu2 = -1;
 	public static int selectedPlayer = 0;
 	public static int selectedWorld;
-	public static int menuMode;
+	public static int menuMode = Interface.loadModsID; // 0 -> loadModsID, Start mods menu on load
 	public static int menuSkip;
 	private static bool _needsLanguageSelect = true;
-	private static Item tooltipPrefixComparisonItem = new Item();
+	public static Item tooltipPrefixComparisonItem = new Item();
 	private MouseTextCache _mouseTextCache;
 	public int textBlinkerCount;
 	public int textBlinkerState;
 	public static string newWorldName = "";
 	private static Vector3 shimmerShine = new Vector3(1f, 0.5f, 1f);
-	private static int[] specX = new int[1000];
+	public static int[] specX = new int[1000];
-	private static int[] specY = new int[1000];
+	public static int[] specY = new int[1000];
 	public TilePaintSystemV2 TilePaintSystem;
 	public TileDrawing TilesRenderer;
 	public WallDrawing WallsRenderer;
@@ -2036,7 +_,7 @@
 	private bool _imeToggle;
 	private static int _lastHoveredLoadoutIndex = -1;
 	private List<int> _npcTypesThatAlreadyDrewAHead = new List<int>();
-	private int[] _npcIndexWhoHoldsHeadIndex = new int[NPCHeadID.Count];
+	internal int[] _npcIndexWhoHoldsHeadIndex = new int[NPCHeadID.Count];
 	private static List<string> _requiredObjecsForCraftingText = new List<string>();
 	private static bool _preventCraftingBecauseClickWasUsedToChangeFocusedRecipe;
 	private static int _currentRecipeBeingCrafted = -1;
@@ -2046,7 +_,7 @@
 	public static Microsoft.Xna.Framework.Color inventoryBack = new Microsoft.Xna.Framework.Color(220, 220, 220, 220);
 	public static bool mouseText;
 	private static int mH;
-	private static int rare;
+	public static int rare;
 	public static int hairStart;
 	private static int oldHairStyle;
 	private static Microsoft.Xna.Framework.Color oldHairColor;
@@ -2058,7 +_,7 @@
 	public static Player dresserInterfaceDummy;
 	private bool _needToSetupDrawInterfaceLayers = true;
 	private List<GameInterfaceLayer> _gameInterfaceLayers;
-	private static GameTime _drawInterfaceGameTime;
+	public static GameTime _drawInterfaceGameTime;
 	private byte instrumentMouseFixHack;
 	private static bool _settingsButtonIsPushedToSide;
 	private static bool _MouseOversCanClear;
@@ -2116,13 +_,13 @@
 	};
 	private static float backgroundLayerTransitionSpeed = 0.05f;
 	public static float atmo;
-	private static float bgScale = 1f;
+	internal static float bgScale = 1f;
-	private static int bgWidthScaled = (int)(1024f * bgScale);
+	internal static int bgWidthScaled = (int)(1024f * bgScale);
 	public static Microsoft.Xna.Framework.Color ColorOfTheSkies;
-	private static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsBase = Microsoft.Xna.Framework.Color.White;
+	internal static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsBase = Microsoft.Xna.Framework.Color.White;
-	private static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsModified = Microsoft.Xna.Framework.Color.White;
+	internal static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsModified = Microsoft.Xna.Framework.Color.White;
-	private float screenOff;
+	internal float screenOff;
-	private float scAdj;
+	internal float scAdj;
 	private float cTop;
 	private bool _isDrawingOrUpdating;
 	public static List<INeedRenderTargetContent> ContentThatNeedsRenderTargets = new List<INeedRenderTargetContent>();
@@ -2132,7 +_,7 @@
 	public static int starsHit = 0;
 	private static string _oldNetplayStatusText;
 	private static TextSnippet[] _netplayStatusTextSnippets;
-	public static int ladyBugRainBoost = 0;
+	public static double ladyBugRainBoost = 0; // int -> double
 	private static bool _canShowMeteorFall;
 	private static bool _isResizingAndRemakingTargets = false;
 
@@ -2268,8 +_,16 @@
 	[Old("Transform is deprecated. Please use GameViewMatrix & GUIViewMatrix")]
 	public static Matrix Transform => GameViewMatrix.TransformationMatrix;
 
+	/// <summary>
+	/// Fetches the position of the mouse cursor on the screen.<br/>
+	/// Useful for making things visually happen near the cursor.<br/>
+	/// </summary>
 	public static Vector2 MouseScreen => new Vector2(mouseX, mouseY);
 
+	/// <summary>
+	/// Fetches the position of the mouse cursor in the world.<br/>
+	/// Useful for making things functionally happen near the cursor, such as projectile or NPC spawns.<br/>
+	/// </summary>
 	public static Vector2 MouseWorld {
 		get {
 			Vector2 result = MouseScreen + screenPosition;
@@ -2311,15 +_,23 @@
 		}
 	}
 
+	/// <summary>
+	/// The y-coordinate of the top of the underworld, in tile coordinates.
+	/// </summary>
+	/// <remarks>Player in this layer will have <see cref="Player.ZoneUnderworld"/> set to <see langword="true"/>.</remarks>
 	public static int UnderworldLayer => maxTilesY - 200;
 
 	public static float WindForVisuals => windSpeedCurrent;
 
+	/// <summary>
+	/// Retrieves the <see cref="Player"/> object for the local user. Shorthand for <c><see cref="player"/>[<see cref="myPlayer"/>]</c>.<br/>
+	/// Many gameplay elements such as recipes, UI, TownNPC chat, and Biome logic are only executed locally, <see cref="LocalPlayer"/> is suitable for code relating to those situations. If the hook has a <see cref="Player"/> parameter, it is likely not suitable to use <see cref="LocalPlayer"/> in it.
+	/// </summary>
 	public static Player LocalPlayer => player[myPlayer];
 
 	public static CreativeUnlocksTracker LocalPlayerCreativeTracker => player[myPlayer].creativeTracker;
 
-	public static int npcShop { get; private set; }
+	public static int npcShop { get; internal set; }
 
 	public static string playerPathName => ActivePlayerFileData.Path;
 
@@ -2831,6 +_,8 @@
 		}
 
 		result.X = num;
+
+		ItemLoader.HoldoutOffset(gravdir, itemtype, ref result);
 		return result;
 	}
 
@@ -2842,12 +_,34 @@
 			tileMerge[i] = new bool[count];
 		}
 
+		SetupAllBlockMerge();
+	}
+
+	// internal split to be called by TileLoader, to avoid tileMerge reset (handled by ResizeArrays)
+	internal static void SetupAllBlockMerge()
+	{
-		for (int j = 0; j < TileID.Count; j++) {
+		for (int j = 0; j < TileLoader.TileCount; j++) {
+			// TML: moved these cases into BlockMergesWithMergeAllBlockOverride
 			bool flag = j == 10 || j == 387 || j == 541;
+			if (TileID.Sets.BlockMergesWithMergeAllBlockOverride[j] is bool mergeOverride) {
+				TileID.Sets.BlockMergesWithMergeAllBlock[j] = mergeOverride;
+				continue;
+			}
+
+			// TML: 10 is the closed door tile, so make modded closed doors also match. This code runs after they have set their OpenDoorID
+			if (TileLoader.IsClosedDoor(j))
+				flag = true;
+
 			TileID.Sets.BlockMergesWithMergeAllBlock[j] = !flag && tileSolid[j] && !tileSolidTop[j];
 		}
 	}
 
+	/// <summary>
+	/// Registers an animation for an item type to draw inside UI (not world or held item on player).
+	/// To enable its animation in the world, use ItemID.Sets.AnimatesAsSoul in conjunction with this
+	/// </summary>
+	/// <param name="index">Item type</param>
+	/// <param name="animation">Draw animation</param>
 	public static void RegisterItemAnimation(int index, DrawAnimation animation)
 	{
 		if (!itemAnimationsRegistered.Contains(index))
@@ -2896,6 +_,8 @@
 		}
 	}
 
+	// Disabled, TML only supports HiDef.
+	/*
 	public static void SetGraphicsProfile(GraphicsProfile profile, bool forceSet)
 	{
 		if (_currentGraphicsProfile != profile || forceSet) {
@@ -2949,6 +_,7 @@
 				field.SetValue(field2.GetValue(null), 8192);
 		}
 	}
+	*/
 
 	public static void AnglerQuestSwap()
 	{
@@ -2962,6 +_,7 @@
 		while (flag2) {
 			flag2 = false;
 			anglerQuest = rand.Next(anglerQuestItemNetIDs.Length);
+			// Patch note: ↑flag2 and num↓ are used below.
 			int num = anglerQuestItemNetIDs[anglerQuest];
 			if (num == 2454 && (!hardMode || WorldGen.crimson))
 				flag2 = true;
@@ -3004,6 +_,8 @@
 
 			if ((num == 2476 || num == 2453 || num == 2473) && !flag)
 				flag2 = true;
+
+			ItemLoader.IsAnglerQuestAvailable(num, ref flag2);
 		}
 
 		NetMessage.SendAnglerQuest(-1);
@@ -3160,7 +_,9 @@
 	{
 		Utils.TryCreatingDirectory(SavePath);
 		try {
+			//TML: Added this check before SetAttributes attempts.
+			if (File.Exists(SavePath + Path.DirectorySeparatorChar + "servers.dat"))
-			File.SetAttributes(SavePath + Path.DirectorySeparatorChar + "servers.dat", FileAttributes.Normal);
+				File.SetAttributes(SavePath + Path.DirectorySeparatorChar + "servers.dat", FileAttributes.Normal);
 		}
 		catch {
 		}
@@ -3248,6 +_,7 @@
 		configuration.Put("UseHeatDistortion", UseHeatDistortion);
 		configuration.Put("WaveQuality", WaveQuality);
 		configuration.Put("Support4K", Support4K);
+		configuration.Put("Support8K", Support8K); // Added by TML.
 		configuration.Put("MouseColor", new Dictionary<string, byte> {
 			{ "R", mouseColor.R },
 			{ "G", mouseColor.G },
@@ -3273,6 +_,9 @@
 		configuration.Put("HoverControlMode", Player.Settings.HoverControl);
 		configuration.Put("WaterfallDrawLimit", instance.waterfallManager.maxWaterfallCount);
 		configuration.Put("DisableIntenseVisualEffects", DisableIntenseVisualEffects);
+
+		ModLoader.ModLoader.SaveConfiguration();
+
 		if (Configuration.Save())
 			return PlayerInput.Save();
 
@@ -3282,6 +_,9 @@
 	protected void CheckBunny()
 	{
 		try {
+			if (!OperatingSystem.IsWindows())
+				return;
+
 			RegistryKey currentUser = Registry.CurrentUser;
 			currentUser = currentUser.CreateSubKey("Software\\Terraria");
 			if (currentUser != null && currentUser.GetValue("Bunny") != null && currentUser.GetValue("Bunny").ToString() == "1")
@@ -3352,14 +_,40 @@
 		int currentValue3 = graphics.PreferredBackBufferHeight;
 		configuration.Get("DisplayWidth", ref currentValue2);
 		configuration.Get("DisplayHeight", ref currentValue3);
+
+		//Solxan: This is for properly settings the Screen Max Width & Max Height for large displays.
+		// Iterates to find the largest display and assumes that is allowed.
+		for (int i = 0; i < SDL2.SDL.SDL_GetNumVideoDisplays(); i++) {
+			int displayModeIndex = 0;
+			while (SDL2.SDL.SDL_GetDisplayMode(displayModeIndex++, i, out var sdlMode) == 0) {
+				maxScreenW = Math.Max(sdlMode.w, maxScreenW);
+				maxScreenH = Math.Max(sdlMode.h, maxScreenH);
+			}
+		}
+
+		Logging.tML.Info($"Maximum Resolution is {maxScreenW} x {maxScreenH}");
+
+		// Update the _renderTargetMaxSize to correctly find max offscreen space: Note, this is bigger than Vanilla!
+		// Solxan: Setting to exact maxScreenW leads to lag, but too big impacts performance. Needs to be sizeable to include ultrawide displays
+		_renderTargetMaxSize = maxScreenW + 200 * 2 * maxScreenW / 1920;
+
 		LastLoadedResolution = new Microsoft.Xna.Framework.Point(currentValue2, currentValue3);
 		if (!startFullscreen) {
 			if (PendingBorderlessState)
 				screenBorderlessPendingResizes = 1;
 
 			SetDisplayMode(currentValue2, currentValue3, fullscreen: false);
+
+			// moved below
+			/*
 			TryPickingDefaultUIScale(currentValue3);
+			*/
 		}
+		else {
+			FullscreenStartup();
+		}
+
+		TryPickingDefaultUIScale(graphics.GraphicsDevice.Adapter.CurrentDisplayMode.Height);
 
 		configuration.Get("SmartCursorToggle", ref cSmartCursorModeIsToggleAndNotHold);
 		configuration.Get("MapEnabled", ref mapEnabled);
@@ -3652,6 +_,8 @@
 			};
 		}
 
+		ModLoader.ModLoader.LoadConfiguration();
+
 		PlayerInput.Load();
 		if (currentValue < 165) {
 			try {
@@ -3664,8 +_,16 @@
 		mouseColorSlider.SetHSL(mouseColor);
 		mouseBorderColorSlider.SetHSL(MouseBorderColor);
 		mouseBorderColorSlider.Alpha = (float)(int)MouseBorderColor.A / 255f;
-		if (currentValue != 279)
+
+		DateTime now = DateTime.UtcNow;
+		// If you are on preview, and the tmodloader YYYY.MM version has changed, then show the notification.
+		if (BuildInfo.IsPreview && ModLoader.ModLoader.LastPreviewFreezeNotificationSeen != BuildInfo.tMLVersion.MajorMinor()) {
+			ModLoader.ModLoader.PreviewFreezeNotification = true;
+		}
+		if (currentValue != Main.curRelease || ModLoader.ModLoader.LastLaunchedTModLoaderVersion != BuildInfo.tMLVersion || (BuildInfo.Purpose == BuildInfo.BuildPurpose.Dev && ModLoader.ModLoader.LastLaunchedTModLoaderAlphaSha != BuildInfo.CommitSHA)) {
+			ModLoader.ModLoader.MigrateSettings();
 			SaveSettings();
+		}
 
 		IsInTheMiddleOfLoadingSettings = false;
 	}
@@ -3793,9 +_,12 @@
 		try {
 			FileUtilities.Delete(PlayerList[i].Path, PlayerList[i].IsCloudSave);
 			FileUtilities.Delete(PlayerList[i].Path + ".bak", PlayerList[i].IsCloudSave);
+			// Extra patch context.
 		}
 		catch {
 		}
+
+		PlayerIO.ErasePlayer(PlayerList[i].Path, PlayerList[i].IsCloudSave);
 
 		try {
 			string text = PlayerList[i].Path.Substring(0, PlayerList[i].Path.Length - 4);
@@ -3819,9 +_,12 @@
 				}
 			}
 			else if (SocialAPI.Cloud != null) {
+				// Extra patch context.
 				SocialAPI.Cloud.Delete(WorldList[i].Path);
 			}
 
+			WorldIO.EraseWorld(WorldList[i].Path, WorldList[i].IsCloudSave);
+
 			LoadWorlds();
 		}
 		catch {
@@ -3830,6 +_,12 @@
 
 	public static string GetPlayerPathFromName(string playerName, bool cloudSave)
 	{
+		// #3298
+		string invalidFilePattern = @"^(con|prn|aux|nul|com[1-9]|lpt[1-9])$";
+		if (Regex.IsMatch(playerName, invalidFilePattern, RegexOptions.IgnoreCase)) {
+			playerName += "_";
+		}
+
 		char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
 		string text = "";
 		playerName = playerName.Replace(".", "_");
@@ -3856,6 +_,12 @@
 
 	public static string GetWorldPathFromName(string worldName, bool cloudSave)
 	{
+		// #3298
+		string invalidFilePattern = @"^(con|prn|aux|nul|com[1-9]|lpt[1-9])$";
+		if (Regex.IsMatch(worldName, invalidFilePattern, RegexOptions.IgnoreCase)) {
+			worldName += "_";
+		}
+
 		char[] invalidFileNameChars = Path.GetInvalidFileNameChars();
 		string text = "";
 		foreach (char c in worldName) {
@@ -3933,8 +_,10 @@
 						new FileInfo(text2);
 						autoGenFileLocation = text2;
 						ActiveWorldFileData = WorldFile.GetAllMetadata(text2, cloudSave: false);
+						ActiveWorldFileData ??= new();
 					}
 					catch {
+						ActiveWorldFileData = new();
 					}
 				}
 
@@ -4023,6 +_,14 @@
 				if (text.Length >= 10 && text.Substring(0, 10).ToLower() == "worldname=")
 					worldName = text.Substring(10);
 
+				// Added by TML.
+				if (text.Length >= 8 && text.Substring(0, 8).ToLower() == "modpath=")
+					ModOrganizer.modPath = text.Substring(8);
+
+				// Added by TML.
+				if (text.Length >= 8 && text.Substring(0, 8).ToLower() == "modpack=")
+					ModOrganizer.commandLineModPack = text.Substring(8);
+
 				if (text.Length >= 5 && text.Substring(0, 5).ToLower() == "seed=")
 					AutogenSeedName = text.Substring(5);
 
@@ -4087,6 +_,9 @@
 	public void SetWorld(string world, bool cloud)
 	{
 		ActiveWorldFileData = WorldFile.GetAllMetadata(world, cloud);
+
+		//TML: Avoid nulls.
+		ActiveWorldFileData ??= new();
 	}
 
 	public void SetWorldName(string world)
@@ -4110,20 +_,52 @@
 		autoPass = true;
 	}
 
-	public void AutoJoin(string IP)
+	//TML: Added 'player' parameter.
+	public void AutoJoin(string IP, string player = null)
 	{
 		defaultIP = IP;
 		getIP = IP;
 		Netplay.SetRemoteIP(defaultIP);
+		/*
 		autoJoin = true;
+		*/
+
+		ModLoader.ModLoader.OnSuccessfulLoad += () => {
+			IO.PlayerFileData fileData = null;
+
+			if (player is not null) {
+				if (System.IO.File.Exists(player)) {
+					fileData = Player.GetFileData(player, false);
+				}
+				else {
+					Main.LoadPlayers();
+					fileData = Main.PlayerList.FirstOrDefault(p => p.Name == player);
+				}
+			}
+
+			if (fileData is not null) {
+				fileData.SetAsActive();
+				Main.menuMode = 10;
+				Netplay.StartTcpClient();
+				return;
+			}
+
+			Main.OpenPlayerSelect(fileData => {
+				fileData.SetAsActive();
+				Main.menuMode = 10;
+				Netplay.StartTcpClient();
+			});
+		};
 	}
 
 	public void AutoHost()
 	{
+		ModLoader.ModLoader.OnSuccessfulLoad += () => { // Fix #3742
 		menuMultiplayer = true;
 		menuServer = true;
 		ClearPendingPlayerSelectCallbacks();
 		menuMode = 1;
+		};
 	}
 
 	public void loadLib(string path)
@@ -4148,7 +_,7 @@
 	{
 		NeverSleep();
 		rand = new UnifiedRandom();
-		if (autoShutdown) {
+		if (autoShutdown && !showServerConsole) {
 			string lpWindowName = (Console.Title = "terraria" + rand.Next(int.MaxValue));
 			if (Platform.IsWindows) {
 				IntPtr intPtr = FindWindow(null, lpWindowName);
@@ -4157,17 +_,32 @@
 			}
 		}
 		else {
-			Console.Title = "Terraria Server " + versionNumber2;
+			Console.Title = "Terraria Server " + versionNumber2 + " - " + ModLoader.ModLoader.versionedName;
 		}
 
 		dedServ = true;
 		showSplash = false;
 		Initialize();
+
+		bool reloadMods;
+
+		do {
+			ModLoader.ModLoader.Reload();
+			DedServ_PostModLoad(out reloadMods);
+		}
+		while (reloadMods);
+	}
+
+	//TML: This method split exists to allow mods to hook into this method with MonoMod correctly, at any load-time.
+	private void DedServ_PostModLoad(out bool reloadMods)
+	{
+		reloadMods = false;
+
 		while (worldPathName == null || worldPathName == "") {
 			bool flag = true;
 			while (flag) {
 				LoadWorlds();
-				Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+				Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 				Console.WriteLine("");
 				for (int i = 0; i < WorldList.Count; i++) {
 					Console.WriteLine(i + 1 + "\t\t" + WorldList[i].Name);
@@ -4180,6 +_,8 @@
 				textValue2 = textValue2 + new string('\t', num - textValue2.Length / 8) + Language.GetTextValue("CLI.DeleteWorld_Description");
 				Console.WriteLine(textValue);
 				Console.WriteLine(textValue2);
+				Console.WriteLine("m\t\tMods Menu");
+				//Console.WriteLine("b\t\tMod Browser"); // Not functional in the 1.4 Steam Workshop Environment 
 				Console.WriteLine("");
 				Console.Write(Language.GetTextValue("CLI.ChooseWorld"));
 				string text2 = ReadLineInput();
@@ -4197,7 +_,7 @@
 						int length = Language.GetTextValue("CLI.DeleteWorld_Command").Length;
 						int num2 = Convert.ToInt32(text2.Substring(length + 1)) - 1;
 						if (num2 < WorldList.Count) {
-							Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+							Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 							Console.WriteLine("");
 							Console.WriteLine(Language.GetTextValue("CLI.DeleteConfirmation", WorldList[num2].Name));
 							Console.Write("({0}/{1}): ", Language.GetTextValue("CLI.ShortYes"), Language.GetTextValue("CLI.ShortNo"));
@@ -4220,7 +_,7 @@
 				if (text2 == "n" || text2 == "N") {
 					bool flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("UI.WorldSizeSmall"));
 						Console.WriteLine("2\t" + Language.GetTextValue("UI.WorldSizeMedium"));
@@ -4259,7 +_,7 @@
 
 					flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("UI.Normal"));
 						Console.WriteLine("2\t" + Language.GetTextValue("UI.Expert"));
@@ -4300,7 +_,7 @@
 
 					flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("CLI.Random"));
 						Console.WriteLine("2\t" + Language.GetTextValue("CLI.Corrupt"));
@@ -4335,7 +_,7 @@
 					}
 
 					flag2 = true;
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					while (flag2) {
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.EnterWorldName"));
@@ -4367,7 +_,7 @@
 
 					string text3 = "";
 					flag2 = true;
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					while (flag2) {
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.EnterSeed"));
@@ -4431,6 +_,22 @@
 
 					continue;
 				}
+				else if (text2 == "m" || text2 == "M") {
+					Interface.ServerModMenu(out reloadMods);
+
+					if (reloadMods) {
+						return;
+					}
+
+					continue;
+				}
+				// Not functional in the 1.4 Steam Workshop Environment
+				/*
+				else if (text2 == "b" || text2 == "b") {
+					Interface.ServerModBrowserMenu();
+					continue;
+				}
+				*/
 
 				try {
 					int num3 = Convert.ToInt32(text2);
@@ -4440,7 +_,7 @@
 
 					bool flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.SetInitialMaxPlayers"));
 						string text4 = ReadLineInput();
@@ -4468,7 +_,7 @@
 
 					flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.SetInitialPort"));
 						string text5 = ReadLineInput();
@@ -4494,7 +_,7 @@
 
 					flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.AutomaticPortForward", Language.GetTextValue("CLI.ShortYes"), Language.GetTextValue("CLI.ShortNo")));
 						string text6 = ReadLineInput();
@@ -4518,7 +_,7 @@
 						}
 					}
 
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					Console.WriteLine("");
 					Console.Write(Language.GetTextValue("CLI.EnterServerPassword"));
 					Netplay.ServerPassword = ReadLineInput();
@@ -4563,6 +_,11 @@
 		catch {
 		}
 
+		// Run one tick to JIT all the game content now rather than when a player connects
+		Logging.ServerConsoleLine("Running one update...");
+		Logging.tML.Info($"Server starting with AllowVanillaClients set to {ModNet.AllowVanillaClients}");
+		Update(new GameTime());
+
 		if (WorldGen.loadFailed || !WorldGen.loadSuccess) {
 			WriteFancyWorldLoadErrorToConsole();
 			if (!autoShutdown)
@@ -4574,28 +_,39 @@
 
 		Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber));
 		Console.WriteLine("");
-		Console.WriteLine(Language.GetTextValue("CLI.ListeningOnPort", Netplay.ListenPort));
+		Logging.ServerConsoleLine(Language.GetTextValue("CLI.ListeningOnPort", Netplay.ListenPort));
 		Console.WriteLine(Language.GetTextValue("CLI.HelpHint"));
 		Console.WriteLine("");
 		Console.Title = "Terraria Server: " + worldName;
 		Stopwatch stopwatch = new Stopwatch();
-		if (!autoShutdown)
+		if (!autoShutdown || showServerConsole)
 			startDedInput();
 
 		stopwatch.Start();
+		// Rewrite server sleep timer logic to be simpler and better at tracking 60 ticks per second
+		/*
 		double num6 = 16.666666666666668;
 		double num7 = 0.0;
 		int num8 = 0;
 		new Stopwatch().Start();
+		*/
+		double delta = 1000 / 60D;
+		double target = delta;
+
 		Netplay.StartServer();
+		AddSignalTraps(); // Added by TML
 		gameMenu = false;
 		while (!Netplay.Disconnect) {
+			ServerHangWatchdog.Checkin();
+			/*
 			double totalMilliseconds = stopwatch.Elapsed.TotalMilliseconds;
 			if (totalMilliseconds + num7 >= num6) {
 				num8++;
 				num7 += totalMilliseconds - num6;
 				stopwatch.Reset();
 				stopwatch.Start();
+			*/
+			{
 				if (oldStatusText != statusText) {
 					oldStatusText = statusText;
 					Console.WriteLine(statusText);
@@ -4609,6 +_,7 @@
 				if (Main.OnTickForThirdPartySoftwareOnly != null)
 					Main.OnTickForThirdPartySoftwareOnly();
 
+				/*
 				double num9 = stopwatch.Elapsed.TotalMilliseconds + num7;
 				if (num9 < num6) {
 					int num10 = (int)(num6 - num9) - 1;
@@ -4620,9 +_,23 @@
 						}
 					}
 				}
+				*/
+				double now = stopwatch.ElapsedMilliseconds;
+				double remaining = target - now;
+				target += delta; // New target
+				
+				// Reset target if can't catch up.
+				// TODO: warning in the logs/console?
+				if (target < now) 
+					target = now + delta;
+
+				// TODO, should this be if remaining > 0? Do we actually want to risk relinquishing our time-slice if we're struggling to keep up?
+				Thread.Sleep(Math.Max((int)remaining, 0));
 			}
 
+			/*
 			Thread.Sleep(0);
+			*/
 		}
 
 		if (Netplay.SaveOnServerExit) {
@@ -4630,6 +_,8 @@
 			WorldFile.SaveWorld();
 		}
 
+		SystemLoader.OnWorldUnload();
+
 		YouCanSleepNow();
 	}
 
@@ -4650,8 +_,22 @@
 	public static void startDedInputCallBack()
 	{
 		while (!Netplay.Disconnect) {
+			string text = Console.ReadLine(); //ReadLineInput();
+			if (text == null) { // Fix for #2644 where Docker would steal lines from the active console.
+				Logging.tML.Warn("Console input not connected, ignoring...");
+				break;
+			}
+
+			ExecuteCommand(text, new ConsoleCommandCaller());
+		}
+	}
+
+	public static void ExecuteCommand(string text, CommandCaller commandCaller)
+	{
+		// Used a 'do {...} while (false)' loop so we don't have to change all the 'continue;' statements to 'return;'
+		// when moving the loop body into a separate function
+		do {
 			Console.Write(": ");
-			string text = ReadLineInput();
 			string text2 = text;
 			text = text.ToLower();
 			try {
@@ -4691,12 +_,23 @@
 							num = text3.Length;
 					}
 
+					var modHelpList = CommandLoader.GetHelp(CommandType.Console);
+					foreach (var entry in modHelpList) {
+						if (entry.Item1.Length > num)
+							num = entry.Item1.Length;
+					}
+
 					int num2 = (num + 1) / 8;
 					for (int j = 0; j < list.Count; j++) {
 						string text4 = (Language.Exists("CLI." + list[j] + "_Example") ? Language.GetTextValue("CLI." + list[j] + "_Example") : Language.GetTextValue("CLI." + list[j] + "_Command"));
 						Console.WriteLine(text4 + new string('\t', num2 - text4.Length / 8) + Language.GetTextValue("CLI." + list[j] + "_Description"));
 					}
+
+					foreach (var entry in modHelpList) {
+						Console.WriteLine(entry.Item1 + new string('\t', num2 - entry.Item1.Length / 8) + entry.Item2);
+					}
 				}
+				else if (CommandLoader.HandleCommand(text, commandCaller)) { }
 				else if (text == Language.GetTextValue("CLI.Settle_Command")) {
 					if (!Liquid.panicMode)
 						Liquid.StartPanic();
@@ -4781,11 +_,12 @@
 					Console.WriteLine(Language.GetTextValue("CLI.Port", Netplay.ListenPort));
 				}
 				else if (text == Language.GetTextValue("CLI.Version_Command")) {
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber) + " - " + ModLoader.ModLoader.versionedName);
 				}
 				else if (text == Language.GetTextValue("CLI.Clear_Command")) {
 					try {
 						Console.Clear();
+						Logging.ResetPastExceptions(); // "CLI.Clear_Command" above.
 					}
 					catch {
 					}
@@ -4908,6 +_,7 @@
 				Console.WriteLine(Language.GetTextValue("CLI.InvalidCommand"));
 			}
 		}
+		while (false);
 	}
 
 	private static string ReadLineInput()
@@ -4958,9 +_,21 @@
 
 	public static void UpdateTimeRate()
 	{
+		UpdateTimeRate_Inner();
+
+		SystemLoader.ModifyTimeRate(ref dayRate, ref desiredWorldTilesUpdateRate, ref desiredWorldEventsUpdateRate);
+		if (dayRate > 86400)
+			dayRate = 86400;
+	}
+
+	public static void UpdateTimeRate_Inner()
+	{
+		// desiredWorldEventsUpdateRate in this method added by TML
+
 		if (IsFastForwardingTime()) {
 			dayRate = 60;
 			desiredWorldTilesUpdateRate = 1;
+			desiredWorldEventsUpdateRate = 60;
 			return;
 		}
 
@@ -4976,9 +_,11 @@
 
 		dayRate = num;
 		desiredWorldTilesUpdateRate = num;
+		desiredWorldEventsUpdateRate = num;
 		if (gameMenu) {
 			dayRate = 1;
 			desiredWorldTilesUpdateRate = 1;
+			desiredWorldEventsUpdateRate = 1;
 		}
 	}
 
@@ -4991,7 +_,13 @@
 			Map = new WorldMap(maxTilesX, maxTilesY);
 			Configuration.Load();
 			graphics = new GraphicsDeviceManager(((object)this) as Game);
+			/*
 			base.Content.RootDirectory = "Content";
+			*/
+
+			//TML: Use HiDef by default.
+			graphics.GraphicsProfile = GraphicsProfile.HiDef;
+			FNALogging.GraphicsInit(graphics);
 		}
 	}
 
@@ -5017,6 +_,7 @@
 		if (!dedServ) {
 			_cachedTitle = Lang.GetRandomGameTitle();
 			Platform.Get<IWindowService>().SetUnicodeTitle(base.Window, _cachedTitle);
+			Platform.Get<IWindowService>().SetIcon(base.Window); // Added by TML
 		}
 	}
 
@@ -5063,6 +_,8 @@
 
 	protected override void Initialize()
 	{
+		InitTMLContentManager();
+
 		musicFade[50] = 1f;
 		if (dedServ)
 			netMode = 2;
@@ -5095,6 +_,7 @@
 			if (!dedServ)
 				Lighting.Clear();
 		};
+		WorldGen.AddGenPasses();
 
 		DontStarveSeed.Initialize();
 		ResourceSetsManager = new PlayerResourceSetsManager();
@@ -5108,11 +_,20 @@
 		BindSettingsTo(Configuration);
 		if (dedServ) {
 			Initialize_AlmostEverything();
+
+			// Allow keeping TML configs on/for server
+			Configuration.Load();
+			ModLoader.ModLoader.LoadConfiguration();
 			return;
 		}
 
 		TimeLogger.Initialize();
+
+		// HiDef graphics profile set in Main ctor
+		/*
 		LoadContent_TryEnteringHiDef();
+		*/
+
 		ClientInitialize();
 		base.Initialize();
 	}
@@ -5239,11 +_,18 @@
 		}
 
 		shop[0] = new Chest();
+		shop[1] = new Chest(); // Added by tML, only 1 shop actually needed
 		Chest.SetupTravelShop();
+		/*
 		for (int m = 1; m < 100; m++) {
 			shop[m] = new Chest();
+
+			if (m >= NPCLoader.shopToNPC.Length)
+				continue;
+
 			shop[m].SetupShop(m);
 		}
+		*/
 
 		teamColor[0] = Microsoft.Xna.Framework.Color.White;
 		teamColor[1] = new Microsoft.Xna.Framework.Color(218, 59, 59);
@@ -7706,13 +_,24 @@
 		persistentBuff[77] = true;
 		persistentBuff[78] = true;
 		persistentBuff[79] = true;
+
+		Initialize_BuffDataFromMountData();
+		Initialize_TileAndNPCData1_Part2();
+	}
+
+	// Split so it can be called by TML separately
+	internal static void Initialize_BuffDataFromMountData()
+	{
 		for (int l = 0; l < BuffID.Sets.BasicMountData.Length; l++) {
 			if (BuffID.Sets.BasicMountData[l] != null) {
 				buffNoTimeDisplay[l] = true;
 				buffNoSave[l] = true;
 			}
 		}
+	}
 
+	private static void Initialize_TileAndNPCData1_Part2()
+	{
 		vanityPet[40] = true;
 		vanityPet[41] = true;
 		vanityPet[42] = true;
@@ -9051,13 +_,21 @@
 	{
 	}
 
+	//TML: 'private' -> 'internal static'
-	private void OnceFailedLoadingAnAsset(string assetPath, Exception e)
+	internal static void OnceFailedLoadingAnAsset(string assetPath, Exception e)
 	{
+		Logging.Terraria.Error($"Failed to load asset: \"{assetPath}\"", e);
 		FancyErrorPrinter.ShowFailedToLoadAssetError(e, assetPath);
 	}
 
 	protected override void LoadContent()
 	{
+		// Added by TML.
+		Asset<Texture2D>.DefaultValue = new Texture2D(base.GraphicsDevice, 1, 1) {
+			Name = "Asynchronously-loaded Asset Dummy Texture (do not dispose or modify!)"
+		};
+		Asset<Texture2D>.DefaultValue.SetData(new Color[] { Color.Transparent }); // AMD graphics cards on Linux/Mac don't initialize textures to transparent by default (#1918)
+
 		SoundEngine.Initialize();
 		if (base.Services.Get<IAssetRepository>() == null)
 			AssetInitializer.CreateAssetServices(base.Services);
@@ -9081,7 +_,10 @@
 			audioSystem = new DisabledAudioSystem();
 
 		AssetSourceController = new AssetSourceController(Assets, new IContentSource[1] {
+			/*
 			new XnaContentSource(base.Content.RootDirectory)
+			*/
+			new XnaDirectContentSource(((TMLContentManager)Content).RootDirectories),
 		});
 
 		VanillaContentValidator.Instance = new VanillaContentValidator("Terraria.IO.Data.ResourcePacksDefaultInfo.tsv");
@@ -9093,8 +_,11 @@
 		AssetInitializer.LoadSplashAssets(asyncLoadForSounds: true);
 		ChromaInitializer.Load();
 		_gameContentLoadProcess = LoadContent_Deferred();
+
+		ModLoader.ModLoader.PrepareAssets();
 	}
 
+	/*
 	private void LoadContent_TryEnteringHiDef()
 	{
 		Configuration.Load();
@@ -9109,6 +_,7 @@
 		else if (Program.IsFna)
 			SetGraphicsProfile(GraphicsProfile.HiDef, forceSet: true);
 	}
+	*/
 
 	protected IEnumerator LoadContent_Deferred()
 	{
@@ -9601,6 +_,9 @@
 
 				if (SceneMetrics.ActiveMusicBox == 87)
 					newMusic = 91;
+
+				if (SceneMetrics.ActiveMusicBox >= maxMusic)
+					newMusic = SceneMetrics.ActiveMusicBox;
 			}
 
 			if (gameMenu || musicVolume == 0f) {
@@ -9626,12 +_,12 @@
 					curMusic = 0;
 				}
 
-				if (NPC.MoonLordCountdown == 1 && curMusic >= 1 && curMusic < maxMusic)
+				if (NPC.MoonLordCountdown == 1 && curMusic >= 1 && curMusic < musicFade.Length)
 					musicFade[curMusic] = 0f;
 			}
 
 			bool isMainTrackAudible = musicFade[curMusic] > 0.25f;
-			for (int i = 1; i < maxMusic; i++) {
+			for (int i = 1; i < musicFade.Length; i++) {
 				float num2 = musicFade[i] * musicVolume * num;
 				if (i >= 62 && i <= 88) {
 					num2 *= 0.9f;
@@ -9764,7 +_,11 @@
 		bool flag15 = false;
 		bool flag16 = false;
 		bool flag17 = false;
-		if (!showSplash) {
+
+		int modMusic = -1;
+		ModLoader.SceneEffectPriority modPriority = ModLoader.SceneEffectPriority.None;
+
+		if (!gameMenu) { // showSplash -> gameMenu. Fix crash iterating active NPCs while unloading mods
 			Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)screenPosition.X, (int)screenPosition.Y, screenWidth, screenHeight);
 			int num = 5000;
 			for (int i = 0; i < 200; i++) {
@@ -9871,7 +_,8 @@
 						break;
 				}
 
-				if (NPCID.Sets.BelongsToInvasionOldOnesArmy[npc[i].type])
+				//TML: Added bounds check
+				if (npc[i].type < NPCID.Sets.BelongsToInvasionOldOnesArmy.Length && NPCID.Sets.BelongsToInvasionOldOnesArmy[npc[i].type])
 					num2 = 12;
 
 				if (remixWorld && getGoodWorld && (npc[i].type == 127 || npc[i].type == 134 || npc[i].type == 125 || npc[i].type == 126))
@@ -9880,11 +_,16 @@
 				if (num2 == 0 && npc[i].boss)
 					num2 = 1;
 
-				if (num2 == 0)
+				if (num2 == 0 && (npc[i].ModNPC == null || npc[i].ModNPC.Music < 0))
 					continue;
 
 				Microsoft.Xna.Framework.Rectangle value = new Microsoft.Xna.Framework.Rectangle((int)(npc[i].position.X + (float)(npc[i].width / 2)) - num, (int)(npc[i].position.Y + (float)(npc[i].height / 2)) - num, num * 2, num * 2);
 				if (rectangle.Intersects(value)) {
+					//TODO: Can we simplify these two Decide music methods?
+					if (npc[i].ModNPC != null && npc[i].ModNPC.Music >= 0 && (modMusic < 0 || npc[i].ModNPC.SceneEffectPriority > modPriority)) {
+						modMusic = npc[i].ModNPC.Music;
+						modPriority = npc[i].ModNPC.SceneEffectPriority;
+					}
 					switch (num2) {
 						case 1:
 							flag = true;
@@ -9939,9 +_,11 @@
 							break;
 					}
 
-					break;
+					// break; Allow priority to take effect despite spawn order.
 				}
 			}
+
+			LoaderManager.Get<SceneEffectLoader>().UpdateMusic(ref modMusic, ref modPriority);
 		}
 
 		_ = (screenPosition.X + (float)(screenWidth / 2)) / 16f;
@@ -9949,6 +_,30 @@
 			newMusic = 0;
 			return;
 		}
+
+		//TODO: Re-implement game menu/menuloader audio in Other World soundtrack???
+        /*if (gameMenu) {
+			if (netMode != 2) {
+				if (WorldGen.drunkWorldGen) {
+					newMusic = 60;
+				}
+				else if (menuMode == 3000) {
+					newMusic = 89;
+				}
+				else {
+					newMusic = MenuLoader.CurrentMenu.Music;
+				}
+				if (_isAsyncLoadComplete && newMusic == 50 && !audioSystem.IsTrackPlaying(50)) {
+					newMusic = 51;
+					if (musicNoCrossFade[51])
+						musicFade[51] = 1f;
+				}
+			}
+			else {
+				newMusic = 0;
+			}
+			return;
+		}*/
 
 		float num3 = (float)maxTilesX / 4200f;
 		num3 *= num3;
@@ -9956,12 +_,18 @@
 		if (CreditsRollEvent.IsEventOngoing) {
 			newMusic = 89;
 		}
+		else if (modPriority >= SceneEffectPriority.BossHigh) {
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].happyFunTorchTime) {
 			newMusic = 87;
 		}
 		else if (flag8) {
 			newMusic = 84;
 		}
+		else if (modPriority >= SceneEffectPriority.BossMedium) {
+			newMusic = modMusic;
+		}
 		else if (flag17) {
 			newMusic = 81;
 		}
@@ -9974,6 +_,9 @@
 		else if (flag7) {
 			newMusic = 85;
 		}
+		else if (modPriority >= SceneEffectPriority.BossLow) {
+			newMusic = modMusic;
+		}
 		else if (flag15) {
 			newMusic = 80;
 		}
@@ -10001,6 +_,9 @@
 		else if (flag2) {
 			newMusic = 80;
 		}
+		else if (modPriority >= SceneEffectPriority.Event) {
+			newMusic = modMusic;
+		}
 		else if (flag9) {
 			newMusic = 82;
 		}
@@ -10009,6 +_,9 @@
 		}
 		else if (flag13) {
 			newMusic = 82;
+		}
+		else if (modPriority >= SceneEffectPriority.Environment) {
+			newMusic = modMusic;
 		}
 		else if (eclipse && (double)player[myPlayer].position.Y < worldSurface * 16.0 + (double)(screenHeight / 2)) {
 			newMusic = 79;
@@ -10034,6 +_,9 @@
 		else if (num4 < 1f) {
 			newMusic = 70;
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeHigh) {
+			newMusic = modMusic;
+		}
 		else if (tile[(int)(player[myPlayer].Center.X / 16f), (int)(player[myPlayer].Center.Y / 16f)].wall == 87) {
 			newMusic = 69;
 		}
@@ -10063,6 +_,9 @@
 			else
 				newMusic = 75;
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeMedium) {
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].ZoneMeteor) {
 			newMusic = 79;
 		}
@@ -10094,6 +_,9 @@
 				newMusic = 72;
 			}
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeLow) {
+			newMusic = modMusic;
+		}
 		else if ((double)player[myPlayer].position.Y >= worldSurface * 16.0 + (double)(screenHeight / 2) && !WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			if (remixWorld && (double)player[myPlayer].position.Y >= rockLayer * 16.0 + (double)(screenHeight / 2)) {
 				if (player[myPlayer].ZoneUndergroundDesert)
@@ -10199,7 +_,11 @@
 		if (lastMusicPlayed == 50)
 			musicNoCrossFade[51] = true;
 
+		int modMusic = -1;
+		ModLoader.SceneEffectPriority modPriority = ModLoader.SceneEffectPriority.None;
+
+		//TML: showSplash -> gameMenu. Fixes crashes when iterating active NPCs while unloading mods.
-		if (!showSplash) {
+		if (!gameMenu) {
 			Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)screenPosition.X, (int)screenPosition.Y, screenWidth, screenHeight);
 			int num2 = 5000;
 			for (int j = 0; j < 200; j++) {
@@ -10219,12 +_,15 @@
 					case 131:
 						num3 = 1;
 						break;
+					/*
 					case 26:
 					case 27:
 					case 28:
 					case 29:
 					case 111:
 					case 471:
+					*/
+					case int _ when NPCID.Sets.BelongsToInvasionGoblinArmy[npc[j].type] && NPCID.Sets.InvasionSlotCount[npc[j].type] > 0:
 						num3 = 11;
 						break;
 					case 113:
@@ -10236,18 +_,24 @@
 					case 134:
 					case 135:
 					case 136:
+					/*
 					case 143:
 					case 144:
 					case 145:
+					*/
+					case int _ when NPCID.Sets.BelongsToInvasionFrostLegion[npc[j].type] && NPCID.Sets.InvasionSlotCount[npc[j].type] > 0:
 					case 266:
 						num3 = 3;
 						break;
+					/*
 					case 212:
 					case 213:
 					case 214:
 					case 215:
 					case 216:
 					case 491:
+					*/
+					case int _ when NPCID.Sets.BelongsToInvasionPirate[npc[j].type] && NPCID.Sets.InvasionSlotCount[npc[j].type] > 0:
 						num3 = 8;
 						break;
 					case 245:
@@ -10261,6 +_,7 @@
 					case 264:
 						num3 = 6;
 						break;
+					/*
 					case 381:
 					case 382:
 					case 383:
@@ -10272,6 +_,9 @@
 					case 391:
 					case 395:
 					case 520:
+					*/
+					// No 387 tesla turret, handled via NoInvasionMusic below 
+					case int _ when NPCID.Sets.BelongsToInvasionMartianMadness[npc[j].type] && NPCID.Sets.InvasionSlotCount[npc[j].type] > 0:
 						num3 = 9;
 						break;
 					case 398:
@@ -10309,6 +_,9 @@
 				if (NPCID.Sets.BelongsToInvasionOldOnesArmy[npc[j].type])
 					num3 = 12;
 
+				if (NPCID.Sets.NoInvasionMusic[npc[j].type] && NPC.GetNPCInvasionGroup(npc[j].type) != 0)
+					num3 = 0;
+
 				if (num3 == 0 && npc[j].boss)
 					num3 = 1;
 
@@ -10320,6 +_,12 @@
 
 				Microsoft.Xna.Framework.Rectangle value = new Microsoft.Xna.Framework.Rectangle((int)(npc[j].position.X + (float)(npc[j].width / 2)) - num2, (int)(npc[j].position.Y + (float)(npc[j].height / 2)) - num2, num2 * 2, num2 * 2);
 				if (rectangle.Intersects(value)) {
+					//TODO: Should this be wrapped inside the new SceneEffect stuff? Not at this time, left for legacy.
+					if (npc[j].ModNPC != null && npc[j].ModNPC.Music >= 0 && (modMusic < 0 || npc[j].ModNPC.SceneEffectPriority > modPriority)) {
+						modMusic = npc[j].ModNPC.Music;
+						modPriority = npc[j].ModNPC.SceneEffectPriority;
+					}
+
 					switch (num3) {
 						case 1:
 							flag = true;
@@ -10374,9 +_,11 @@
 							break;
 					}
 
-					break;
+					// break; Allow priority to take effect despite spawn order.
 				}
 			}
+
+			LoaderManager.Get<SceneEffectLoader>().UpdateMusic(ref modMusic, ref modPriority);
 		}
 
 		_ = (screenPosition.X + (float)(screenWidth / 2)) / 16f;
@@ -10402,6 +_,7 @@
 				else if (WorldGen.tenthAnniversaryWorldGen) {
 					newMusic = 11;
 				}
+				/*
 				else if (playOldTile) {
 					newMusic = 6;
 				}
@@ -10409,6 +_,12 @@
 					newMusic = 50;
 				}
 				else if (!audioSystem.IsTrackPlaying(50)) {
+				*/
+				else {
+					newMusic = MenuLoader.CurrentMenu.Music;
+				}
+
+				if (_isAsyncLoadComplete && newMusic == 50 && !audioSystem.IsTrackPlaying(50)) {
 					newMusic = 51;
 					if (musicNoCrossFade[51])
 						musicFade[51] = 1f;
@@ -10427,12 +_,18 @@
 		if (CreditsRollEvent.IsEventOngoing) {
 			newMusic = 89;
 		}
+		else if (modPriority >= SceneEffectPriority.BossHigh) { // Should this be before credits or nah?
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].happyFunTorchTime) {
 			newMusic = 13;
 		}
 		else if (flag8) {
 			newMusic = 38;
 		}
+		else if (modPriority >= SceneEffectPriority.BossMedium) {
+			newMusic = modMusic;
+		}
 		else if (flag17) {
 			newMusic = 81;
 		}
@@ -10445,6 +_,9 @@
 		else if (flag7) {
 			newMusic = 24;
 		}
+		else if (modPriority >= SceneEffectPriority.BossLow) {
+			newMusic = modMusic;
+		}
 		else if (flag15) {
 			newMusic = 57;
 		}
@@ -10472,6 +_,9 @@
 		else if (flag2) {
 			newMusic = 90;
 		}
+		else if (modPriority >= SceneEffectPriority.Event) {
+			newMusic = modMusic;
+		}
 		else if (flag9) {
 			newMusic = 35;
 		}
@@ -10481,6 +_,9 @@
 		else if (flag13) {
 			newMusic = 41;
 		}
+		else if (modPriority >= SceneEffectPriority.Environment) {
+			newMusic = modMusic;
+		}
 		else if (eclipse && !remixWorld && (double)player[myPlayer].position.Y < worldSurface * 16.0 + (double)(screenHeight / 2)) {
 			newMusic = 27;
 		}
@@ -10514,6 +_,9 @@
 		else if (num5 < 1f) {
 			newMusic = (dayTime ? 42 : 15);
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeHigh) {
+			newMusic = modMusic;
+		}
 		else if (tile[(int)(player[myPlayer].Center.X / 16f), (int)(player[myPlayer].Center.Y / 16f)].wall == 87) {
 			newMusic = 26;
 		}
@@ -10543,6 +_,9 @@
 			else
 				newMusic = 16;
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeMedium) {
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].ZoneMeteor) {
 			newMusic = 2;
 		}
@@ -10590,6 +_,9 @@
 				newMusic = 14;
 			}
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeLow) {
+			newMusic = modMusic;
+		}
 		else if ((double)player[myPlayer].position.Y >= worldSurface * 16.0 + (double)(screenHeight / 2) && (remixWorld || !WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16))) {
 			if (player[myPlayer].ZoneHallow) {
 				if (remixWorld && (double)player[myPlayer].position.Y >= rockLayer * 16.0 + (double)(screenHeight / 2))
@@ -10866,12 +_,15 @@
 		float num3 = Math.Max(1f, 1f + 4f * cloudAlpha);
 		if (cloudBGActive > 0f) {
 			if (cloudBGActive > 1f)
-				cloudBGActive -= (float)dayRate / num3;
+				cloudBGActive -= (float)desiredWorldEventsUpdateRate / num3;
 
 			if (cloudBGActive < 1f)
 				cloudBGActive = 1f;
 
+			/*
 			if (cloudBGActive == 1f && rand.Next((int)((float)(num2 * 2 / Math.Max(dayRate, 1)) * num3)) == 0) {
+			*/
+			if (cloudBGActive == 1f && rand.NextDouble() <= desiredWorldEventsUpdateRate / (num2 * 2 * num3)) {
 				cloudBGActive = -rand.Next(num2 * 4, num * 4);
 				if (netMode == 2)
 					NetMessage.SendData(7);
@@ -10881,15 +_,18 @@
 		}
 
 		if (cloudBGActive < 0f) {
-			cloudBGActive += (float)dayRate * num3;
+			cloudBGActive += (float)desiredWorldEventsUpdateRate * num3;
 			if (raining)
-				cloudBGActive += (float)(2 * dayRate) * num3;
+				cloudBGActive += (float)(2 * desiredWorldEventsUpdateRate) * num3;
 		}
 
 		if (cloudBGActive > 0f)
 			cloudBGActive = 0f;
 
+		/*
 		if (cloudBGActive == 0f && rand.Next((int)((float)(num2 * 12 / ((dayRate == 0) ? 1 : dayRate)) / num3)) == 0) {
+		*/
+		if (cloudBGActive == 0f && rand.NextDouble() <= num3 * desiredWorldEventsUpdateRate / (num2 * 12)) {
 			cloudBGActive = rand.Next(num2 * 3, num * 2);
 			if (netMode == 2)
 				NetMessage.SendData(7);
@@ -11113,6 +_,9 @@
 		}
 	}
 
+	// Added by TML, used below.
+	private static SlotId waterfallSoundSlot, lavafallSoundSlot;
+
 	public static void Ambience()
 	{
 		ambientCounter++;
@@ -11121,6 +_,36 @@
 
 		ambientCounter = 0;
 		Microsoft.Xna.Framework.Point point = LocalPlayer.Center.ToPoint();
+
+		// Added by TML. Improves handling of waterfall and lavafall sounds for the new unified audio system.
+		static void HandleAmbientSound(in SoundStyle soundStyle, ref SlotId slot, float volume, Vector2 position)
+		{
+			SoundEngine.TryGetActiveSound(slot, out var activeSound);
+
+			if (volume > 0f) {
+				if (activeSound == null) {
+					slot = SoundEngine.PlaySound(soundStyle, position);
+
+					if (!SoundEngine.TryGetActiveSound(slot, out activeSound)) {
+						return;
+					}
+				}
+
+				activeSound.Volume = volume;
+				activeSound.Position = position;
+			}
+			else if (activeSound != null) {
+				activeSound.Stop();
+
+				slot = SlotId.Invalid;
+			}
+		}
+
+		float usedWaterVolume = MathHelper.Clamp((ambientWaterfallStrength / 50f) * (1f - Main.shimmerAlpha), 0f, 1f);
+
+		HandleAmbientSound(in SoundID.Waterfall, ref waterfallSoundSlot, usedWaterVolume, new Vector2(ambientWaterfallX, ambientWaterfallY));
+
+		/*
 		if (ambientWaterfallStrength > 0f) {
 			SoundEngine.PlaySound(34, (int)ambientWaterfallX, (int)ambientWaterfallY, (int)ambientWaterfallStrength);
 			_isWaterfallMusicPlaying = true;
@@ -11131,6 +_,7 @@
 
 			_isWaterfallMusicPlaying = false;
 		}
+		*/
 
 		float num = Math.Abs(ambientLavaX - (screenPosition.X + (float)(screenWidth / 2))) + Math.Abs(ambientLavaY - (screenPosition.Y + (float)(screenHeight / 2)));
 		float num2 = Math.Abs(ambientLavafallX - (screenPosition.X + (float)(screenWidth / 2))) + Math.Abs(ambientLavafallY - (screenPosition.Y + (float)(screenHeight / 2)));
@@ -11142,6 +_,15 @@
 		}
 
 		float num5 = ambientLavafallStrength + ambientLavaStrength;
+		// Vanilla uses the above local for adjusting lava sounds' volume, but only uses lavafall strength when checking if the sound should be playing at all.
+		// This has been confirmed as intentional.
+		float usedLavaVolume = ambientLavaStrength > 0f
+			? MathHelper.Clamp(num5 / 50f, 0f, 1f)
+			: 0f;
+
+		HandleAmbientSound(in SoundID.Lavafall, ref lavafallSoundSlot, usedLavaVolume, new Vector2(num3, num4));
+
+		/*
 		if (ambientLavafallStrength > 0f) {
 			SoundEngine.PlaySound(35, (int)num3, (int)num4, (int)num5);
 			_isLavafallMusicPlaying = true;
@@ -11152,6 +_,7 @@
 			SoundEngine.PlaySound(35, point.X, point.Y, 0);
 
 		_isLavafallMusicPlaying = false;
+		*/
 	}
 
 	public static void AnimateTiles_CritterCages()
@@ -13362,6 +_,14 @@
 
 	public static void DoUpdate_AnimateItemIcons()
 	{
+		//TML: Lock the collection to avoid race conditions during mod loading & unloading.
+		lock (itemAnimationsRegistered) {
+			DoUpdate_AnimateItemIcons_Inner();
+		}
+	}
+
+	private static void DoUpdate_AnimateItemIcons_Inner()
+	{
 		for (int i = 0; i < itemAnimationsRegistered.Count; i++) {
 			int num = itemAnimationsRegistered[i];
 			if (itemAnimations[num] != null)
@@ -13392,7 +_,15 @@
 
 		if (!_isDrawingOrUpdating) {
 			_isDrawingOrUpdating = true;
+
+			//TML: Wrapped in a try-catch.
+			try {
-			DoUpdate(ref gameTime);
+				DoUpdate(ref gameTime);
+			}
+			catch (Exception e) {
+				// Logging.Terraria.Error(e); Removed, duplicate log messages.
+			}
+
 			CinematicManager.Instance.Update(gameTime);
 			if (netMode == 2) {
 				for (int i = 0; i < 256; i++) {
@@ -13526,6 +_,7 @@
 			}
 		}
 
+		LocalizationLoader.Update();
 		DoUpdate_AutoSave();
 		if (!dedServ) {
 			ChromaInitializer.UpdateEvents();
@@ -13705,6 +_,11 @@
 
 				mouseLeftRelease = false;
 				mouseRightRelease = false;
+				// Reset TML-introduced extra buttons
+				mouseMiddleRelease = false;
+				mouseXButton1Release = false;
+				mouseXButton2Release = false;
+
 				if (gameMenu)
 					UpdateMenu();
 
@@ -13766,6 +_,8 @@
 
 		if (CanPauseGame()) {
 			DoUpdate_WhilePaused();
+			PlayerLoader.UpdateAutopause(player[myPlayer]);
+
 			gamePaused = true;
 			return;
 		}
@@ -13787,10 +_,21 @@
 		if (netMode != 1)
 			updateCloudLayer();
 
+		if (desiredWorldEventsUpdateRate <= 0)
+			goto skipWeatherUpdates;
+
+		_partialWorldEventUpdates += Main.desiredWorldEventsUpdateRate;
+		worldEventUpdates = (int)_partialWorldEventUpdates;
+		_partialWorldEventUpdates -= worldEventUpdates;
+
+		/*
 		for (int i = 0; i < dayRate; i++) {
+		*/
+		for (int i = 0; i < worldEventUpdates; i++) {
 			UpdateWeather(gameTime, i);
 		}
 
+		skipWeatherUpdates:
 		UnpausedUpdateSeed = Utils.RandomNextSeed(UnpausedUpdateSeed);
 		Ambience();
 		if (netMode != 2) {
@@ -13805,6 +_,8 @@
 			Sandstorm.EmitDust();
 		}
 
+		SystemLoader.PreUpdateEntities();
+
 		if (netMode != 2) {
 			if ((double)screenPosition.Y < worldSurface * 16.0 + 16.0) {
 				Star.UpdateStars();
@@ -13867,6 +_,7 @@
 		if (netMode == 0) {
 			flag |= ingameOptionsWindow;
 			flag |= InGameUI.IsVisible && (InGameUI.CurrentState == ManageControlsMenu || InGameUI.CurrentState == AchievementsMenu);
+			flag |= InGameUI.IsVisible && (InGameUI.CurrentState == Interface.modConfigList || InGameUI.CurrentState == Interface.modConfig); // Check mod config states too
 			if (autoPause) {
 				flag |= playerInventory;
 				flag |= LocalPlayer.sign >= 0;
@@ -13907,6 +_,10 @@
 		if (playerInventory) {
 			Main.player[myPlayer].RefreshInfoAccs();
 			Recipe.GetThroughDelayedFindRecipes();
+
+			if (PlayerInput.MouseInModdedUI.Count != 0)
+				goto noScrollOnLocked;
+
 			int num = PlayerInput.ScrollWheelDelta / 120;
 			bool flag = true;
 			if (recBigList) {
@@ -13947,6 +_,9 @@
 					focusRecipe = 0;
 			}
 
+			noScrollOnLocked:
+			PlayerInput.MouseInModdedUI.Clear();
+
 			Main.player[myPlayer].dropItemCheck();
 		}
 
@@ -13991,7 +_,17 @@
 			InGameUI.Update(gameTime);
 
 		CreativeMenu.Update(gameTime);
+
+		SystemLoader.UpdateUI(gameTime);		
+		PlayerInput.ScrollWheelDeltaForUI = 0; //TODO: Should this be before PlayerInput.ResetInputsOnActiveStateChange()?
+		BossBarLoader.HandleStyle(); // Has to be outside of the !gameMenu check because it deals with switching and saving the boss style in menus, including the main menu
+
+		//TML: Don't update IBigProgressBars in the main menu to avoid IOOB during unload when modded NPCs were alive --direwolf420
+		if (gameMenu)
+			goto SkipBossBarUpdate;
+
 		BigBossProgressBar.Update();
+		SkipBossBarUpdate:;
 	}
 
 	private void DoDebugFunctions()
@@ -14013,7 +_,7 @@
 		Player player = clientPlayer;
 		bool syncedAnyInventoryContents = false;
 		for (int i = 0; i < 59; i++) {
-			if (Main.player[myPlayer].inventory[i].IsNotTheSameAs(player.inventory[i])) {
+			if (Main.player[myPlayer].inventory[i].IsNetStateDifferent(player.inventory[i])) {
 				syncedAnyInventoryContents = true;
 				NetMessage.SendData(5, -1, -1, null, myPlayer, PlayerItemSlotID.Inventory0 + i, (int)Main.player[myPlayer].inventory[i].prefix);
 			}
@@ -14025,7 +_,7 @@
 		TrySyncingItemArray(ref syncedAnyInventoryContents, Main.player[myPlayer].miscDyes, player.miscDyes, PlayerItemSlotID.MiscDye0);
 		TrySyncingItemArray(ref syncedAnyInventoryContents, Main.player[myPlayer].bank.item, player.bank.item, PlayerItemSlotID.Bank1_0);
 		TrySyncingItemArray(ref syncedAnyInventoryContents, Main.player[myPlayer].bank2.item, player.bank2.item, PlayerItemSlotID.Bank2_0);
-		if (Main.player[myPlayer].trashItem.IsNotTheSameAs(player.trashItem)) {
+		if (Main.player[myPlayer].trashItem.IsNetStateDifferent(player.trashItem)) {
 			syncedAnyInventoryContents = true;
 			NetMessage.SendData(5, -1, -1, null, myPlayer, PlayerItemSlotID.TrashItem, (int)Main.player[myPlayer].trashItem.prefix);
 		}
@@ -14077,6 +_,9 @@
 		if ((byte)Main.player[myPlayer].zone5 != (byte)player.zone5)
 			flag = true;
 
+		if (!BiomeLoader.CustomBiomesMatch(Main.player[myPlayer], player))
+			flag = true;
+
 		if (flag)
 			NetMessage.SendData(36, -1, -1, null, myPlayer);
 
@@ -14137,13 +_,15 @@
 		if (syncedAnyInventoryContents)
 			NetMessage.SendData(138);
 
+		PlayerLoader.SendClientChanges(Main.player[myPlayer], clientPlayer);
+
 		clientPlayer = Main.player[myPlayer].clientClone();
 	}
 
 	private static void TrySyncingItemArray(ref bool syncedAnyInventoryContents, Item[] my, Item[] other, int slotOffset)
 	{
 		for (int i = 0; i < my.Length; i++) {
-			if (my[i].IsNotTheSameAs(other[i])) {
+			if (my[i].IsNetStateDifferent(other[i])) {
 				syncedAnyInventoryContents = true;
 				NetMessage.SendData(5, -1, -1, null, myPlayer, slotOffset + i, (int)my[i].prefix);
 			}
@@ -14156,6 +_,10 @@
 	{
 		UpdateParticleSystems();
 		tileSolid[379] = false;
+
+		NPCShopDatabase.Test();
+		SystemLoader.PreUpdatePlayers();
+
 		int num = 0;
 		int num2 = 0;
 		sittingManager.ClearPlayerAnchors();
@@ -14189,7 +_,12 @@
 			}
 		}
 
+		SystemLoader.PostUpdatePlayers();
+
 		_gameUpdateCount++;
+
+		SystemLoader.PreUpdateNPCs();
+
 		NPC.RevengeManager.Update();
 		if (netMode != 1) {
 			if (remixWorld)
@@ -14267,6 +_,10 @@
 		}
 
 		CurrentFrameFlags.AnyActiveBossNPC = anyActiveBossNPC;
+
+		SystemLoader.PostUpdateNPCs();
+		SystemLoader.PreUpdateGores();
+
 		for (int m = 0; m < 600; m++) {
 			if (ignoreErrors) {
 				try {
@@ -14281,6 +_,9 @@
 			}
 		}
 
+		SystemLoader.PostUpdateGores();
+		SystemLoader.PreUpdateProjectiles();
+
 		LockOnHelper.SetUP();
 		CurrentFrameFlags.HadAnActiveInteractibleProjectile = false;
 		PreUpdateAllProjectiles();
@@ -14302,6 +_,10 @@
 		ProjectileUpdateLoopIndex = -1;
 		PostUpdateAllProjectiles();
 		LockOnHelper.SetDOWN();
+
+		SystemLoader.PostUpdateProjectiles();
+		SystemLoader.PreUpdateItems();
+
 		Item.numberOfNewItems = 0;
 		for (int num4 = 0; num4 < 400; num4++) {
 			if (ignoreErrors) {
@@ -14317,6 +_,9 @@
 			}
 		}
 
+		SystemLoader.PostUpdateItems();
+		SystemLoader.PreUpdateDusts();
+
 		if (ignoreErrors) {
 			try {
 				Dust.UpdateDust();
@@ -14332,11 +_,15 @@
 			Dust.UpdateDust();
 		}
 
+		SystemLoader.PostUpdateDusts();
+
 		if (netMode != 2) {
 			CombatText.UpdateCombatText();
 			PopupText.UpdateItemText();
 		}
 
+		SystemLoader.PreUpdateTime();
+
 		if (ignoreErrors) {
 			try {
 				UpdateTime();
@@ -14349,6 +_,8 @@
 			UpdateTime();
 		}
 
+		SystemLoader.PostUpdateTime();
+
 		tileSolid[379] = true;
 		if (gameMenu && netMode != 2)
 			return;
@@ -14389,6 +_,8 @@
 				UpdateClient();
 		}
 
+		SystemLoader.PostUpdateEverything();
+
 		chatMonitor.Update();
 		upTimer = (float)sw.Elapsed.TotalMilliseconds;
 		if (upTimerMaxDelay > 0f)
@@ -14508,6 +_,7 @@
 	private static void DoUpdate_Enter_ToggleChat()
 	{
 		if (keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.Enter) && !keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.LeftAlt) && !keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.RightAlt) && hasFocus) {
+			if (InGameUI.IsVisible || ingameOptionsWindow) { } else // Prevent opening chat when in modded UI or options window
 			if (chatRelease && !drawingPlayerChat && !editSign && !editChest && !gameMenu && !keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.Escape)) {
 				SoundEngine.PlaySound(10);
 				OpenPlayerChat();
@@ -14582,7 +_,8 @@
 		if (!inputTextEnter || !chatRelease)
 			return;
 
-		if (chatText != "") {
+		bool handled = chatText.Length > 0 && chatText[0] == '/' && CommandLoader.HandleCommand(chatText, new ChatCommandCaller());
+		if (chatText != "" && !handled) {
 			ChatMessage message = ChatManager.Commands.CreateOutgoingMessage(chatText);
 			if (netMode == 1)
 				ChatHelper.SendChatMessageFromClient(message);
@@ -14599,6 +_,9 @@
 	private void DoUpdate_HandleInput()
 	{
 		PlayerInput.UpdateInput();
+
+		SystemLoader.PostUpdateInput();
+
 		UpdateViewZoomKeys();
 		PlayerInput.SetZoom_Unscaled();
 		UILinkPointNavigator.Update();
@@ -14667,7 +_,20 @@
 		if (keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.F8) && !drawingPlayerChat && !editSign && !editChest) {
 			if (netRelease) {
 				SoundEngine.PlaySound(12);
+				// TML: Logic changed to cycle modes
+				/*
 				shouldDrawNetDiagnosticsUI = !shouldDrawNetDiagnosticsUI;
+				*/
+				if (!shouldDrawNetDiagnosticsUI && !ModNet.ShouldDrawModNetDiagnosticsUI)
+					shouldDrawNetDiagnosticsUI = true; // From off to on (vanilla)
+				else {
+					if (shouldDrawNetDiagnosticsUI && !ModNet.ShouldDrawModNetDiagnosticsUI) {
+						shouldDrawNetDiagnosticsUI = false; // From on (vanilla) to off (vanilla)
+						ModNet.ShouldDrawModNetDiagnosticsUI = true; // +on (modded)
+					}
+					else if (ModNet.ShouldDrawModNetDiagnosticsUI)
+						ModNet.ShouldDrawModNetDiagnosticsUI = false; // From on (modded) to off (all)
+				}
 			}
 
 			netRelease = false;
@@ -15288,6 +_,8 @@
 		if (tileFrameCounter[493] < 0)
 			tileFrameCounter[493] += 120;
 
+		TileLoader.AnimateTiles();
+
 		AnimateTiles_CritterCages();
 	}
 
@@ -15388,6 +_,8 @@
 		if (++wallFrameCounter[243] >= num2 * 8)
 			wallFrameCounter[243] = 0;
 
+		WallLoader.AnimateWalls();
+
 		wallFrameCounter[144]++;
 		int num3 = 5;
 		int num4 = 10;
@@ -15989,15 +_,19 @@
 			X += 34;
 
 		new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
+		Vector2 vector = FontAssets.MouseText.Value.MeasureString(cursorText);
 		if (HoverItem.type > 0) {
 			MouseText_DrawItemTooltip(info, num, diff, X, Y);
 			return;
 		}
 
 		if (info.buffTooltip != null && info.buffTooltip != "")
-			MouseText_DrawBuffTooltip(info.buffTooltip, ref X, ref Y);
+			MouseText_DrawBuffTooltip(info.buffTooltip, ref X, ref Y, (int)vector.Y);
 
+		// Moved above.
+		/*
 		Vector2 vector = FontAssets.MouseText.Value.MeasureString(cursorText);
+		*/
 		if (hackedScreenHeight != -1 && hackedScreenWidth != -1) {
 			if ((float)X + vector.X + 4f > (float)hackedScreenWidth)
 				X = (int)((float)hackedScreenWidth - vector.X - 4f);
@@ -16015,8 +_,11 @@
 
 		float num2 = (float)(int)mouseTextColor / 255f;
 		Microsoft.Xna.Framework.Color baseColor = new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
+
+		/*
 		if (num == -13)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(masterColor * 200f * num2), 0, mouseTextColor);
+		*/
 
 		if (num == -11)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(175f * num2), (byte)(0f * num2), mouseTextColor);
@@ -16057,12 +_,24 @@
 		if (num == 10)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(40f * num2), (byte)(100f * num2), mouseTextColor);
 
+		/*
 		if (num >= 11)
+		*/
+		if (num == 11)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(180f * num2), (byte)(40f * num2), (byte)(255f * num2), mouseTextColor);
 
+		// Mod rarities
+		if (num > 11)
+			baseColor = RarityLoader.GetRarity(num).RarityColor * num2;
+
+		// Expert
 		if (HoverItem.expert || num == -12)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)((float)DiscoR * num2), (byte)((float)DiscoG * num2), (byte)((float)DiscoB * num2), mouseTextColor);
 
+		// Master (new item field)
+		if (HoverItem.master || num == ItemRarityID.Master)
+			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(masterColor * 200f * num2), 0, mouseTextColor);
+
 		if (diff == 1)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)((float)(int)mcColor.R * num2), (byte)((float)(int)mcColor.G * num2), (byte)((float)(int)mcColor.B * num2), mouseTextColor);
 
@@ -16104,7 +_,10 @@
 			array3[i] = false;
 		}
 
+		// This array will be filled with internal names assigned to vanilla tooltips.
+		string[] tooltipNames = new string[num2];
+
-		MouseText_DrawItemTooltip_GetLinesInfo(hoverItem, ref yoyoLogo, ref researchLine, knockBack, ref numLines, array, array2, array3);
+		MouseText_DrawItemTooltip_GetLinesInfo(hoverItem, ref yoyoLogo, ref researchLine, knockBack, ref numLines, array, array2, array3, tooltipNames, out int prefixlineIndex);
 		float num3 = (float)(int)mouseTextColor / 255f;
 		float num4 = num3;
 		int a = mouseTextColor;
@@ -16112,6 +_,7 @@
 			LocalPlayer.GetItemExpectedPrice(hoverItem, out var calcForSelling, out var calcForBuying);
 			long num5 = ((hoverItem.isAShopItem || hoverItem.buyOnce) ? calcForBuying : calcForSelling);
 			if (hoverItem.shopSpecialCurrency != -1) {
+				tooltipNames[numLines] = "SpecialPrice";
 				CustomCurrencyManager.GetPriceText(hoverItem.shopSpecialCurrency, array, ref numLines, num5);
 				color = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(255f * num4), (byte)(255f * num4), a);
 			}
@@ -16172,6 +_,7 @@
 				else
 					array[numLines] = Lang.tip[50].Value + " " + text;
 
+				tooltipNames[numLines] = "Price";
 				numLines++;
 				if (num6 > 0)
 					color = new Microsoft.Xna.Framework.Color((byte)(220f * num4), (byte)(220f * num4), (byte)(198f * num4), a);
@@ -16184,12 +_,18 @@
 			}
 			else if (hoverItem.type != 3817) {
 				array[numLines] = Lang.tip[51].Value;
+				tooltipNames[numLines] = "Price";
 				numLines++;
 				color = new Microsoft.Xna.Framework.Color((byte)(120f * num4), (byte)(120f * num4), (byte)(120f * num4), a);
 			}
 		}
 
 		Vector2 zero = Vector2.Zero;
+
+		// TML's abstractions over tooltip arrays.
+		List<TooltipLine> lines = ItemLoader.ModifyTooltips(HoverItem, ref numLines, tooltipNames, ref array, ref array2, ref array3, ref yoyoLogo, out Color?[] overrideColor, prefixlineIndex);
+		List<DrawableTooltipLine> drawableLines = lines.Select((TooltipLine x, int i) => new DrawableTooltipLine(x, i, 0, 0, Color.White)).ToList();
+
 		int num12 = 0;
 		for (int j = 0; j < numLines; j++) {
 			Vector2 stringSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, array[j], Vector2.One);
@@ -16228,14 +_,32 @@
 			Utils.DrawInvBG(spriteBatch, new Microsoft.Xna.Framework.Rectangle(X - num17, Y - num18, (int)zero.X + num17 * 2, (int)zero.Y + num18 + num18 / 2), new Microsoft.Xna.Framework.Color(23, 25, 81, 255) * 0.925f);
 		}
 
+		bool globalCanDraw = ItemLoader.PreDrawTooltip(HoverItem, lines.AsReadOnly(), ref X, ref Y);
+
 		for (int k = 0; k < numLines; k++) {
+			drawableLines[k].OriginalX = X;
+			drawableLines[k].OriginalY = Y + num16;
+
+			/*
 			if (k == yoyoLogo) {
+			*/
+			if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "OneDropLogo") {
 				float num19 = 1f;
 				int num20 = (int)((float)(int)mouseTextColor * num19);
 				Microsoft.Xna.Framework.Color color2 = Microsoft.Xna.Framework.Color.Black;
+
+				drawableLines[k].Color = new Color(num20, num20, num20, num20);
+				if (!ItemLoader.PreDrawTooltipLine(HoverItem, drawableLines[k], ref num12) || !globalCanDraw)
+					goto PostDraw;
+
 				for (int l = 0; l < 5; l++) {
+					/*
 					int num21 = X;
 					int num22 = Y + num16;
+					*/
+					int num21 = drawableLines[k].X;
+					int num22 = drawableLines[k].Y;
+
 					if (l == 4)
 						color2 = new Microsoft.Xna.Framework.Color(num20, num20, num20, num20);
 
@@ -16254,15 +_,24 @@
 							break;
 					}
 
+					/*
 					spriteBatch.Draw(TextureAssets.OneDropLogo.Value, new Vector2(num21, num22), null, color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+					*/
+					Color drawColor2 = drawableLines[k].OverrideColor ?? drawableLines[k].Color;
+					spriteBatch.Draw(TextureAssets.OneDropLogo.Value, new Vector2(num21, num22), null, (l != 4) ? color2 : drawColor2, drawableLines[k].Rotation, drawableLines[k].Origin, (drawableLines[k].BaseScale.X + drawableLines[k].BaseScale.Y) / 2f, SpriteEffects.None, 0f);
 				}
 			}
 			else {
 				Microsoft.Xna.Framework.Color black = Microsoft.Xna.Framework.Color.Black;
 				black = new Microsoft.Xna.Framework.Color(num4, num4, num4, num4);
+				/*
 				if (k == 0) {
+				*/
+				if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "ItemName") {
+					/*
 					if (rare == -13)
 						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(masterColor * 200f * num4), 0, a);
+					*/
 
 					if (rare == -11)
 						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(175f * num4), (byte)(0f * num4), a);
@@ -16300,9 +_,15 @@
 					if (rare == 10)
 						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(40f * num4), (byte)(100f * num4), a);
 
+					/*
 					if (rare >= 11)
+					*/
+					if (rare == 11)
 						black = new Microsoft.Xna.Framework.Color((byte)(180f * num4), (byte)(40f * num4), (byte)(255f * num4), a);
 
+					if (rare > 11)
+						black = RarityLoader.GetRarity(rare).RarityColor * num4;
+
 					if (diff == 1)
 						black = new Microsoft.Xna.Framework.Color((byte)((float)(int)mcColor.R * num4), (byte)((float)(int)mcColor.G * num4), (byte)((float)(int)mcColor.B * num4), a);
 
@@ -16311,47 +_,92 @@
 
 					if (hoverItem.expert || rare == -12)
 						black = new Microsoft.Xna.Framework.Color((byte)((float)DiscoR * num4), (byte)((float)DiscoG * num4), (byte)((float)DiscoB * num4), a);
+
+					// Handle new master mode field.
+					if (hoverItem.master || rare == -13)
+						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(masterColor * 200f * num4), 0, a);
 				}
 				else if (array2[k]) {
 					black = ((!array3[k]) ? new Microsoft.Xna.Framework.Color((byte)(120f * num4), (byte)(190f * num4), (byte)(120f * num4), a) : new Microsoft.Xna.Framework.Color((byte)(190f * num4), (byte)(120f * num4), (byte)(120f * num4), a));
 				}
+				/*
 				else if (k == numLines - 1) {
+				*/
+				else if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "Price") {
 					black = color;
 				}
 
+				/*
 				if (k == researchLine)
+				*/
+				if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "JourneyResearch")
 					black = Colors.JourneyMode;
 
+				/*
 				ChatManager.DrawColorCodedStringWithShadow(spriteBatch, FontAssets.MouseText.Value, array[k], new Vector2(X, Y + num16), black, 0f, Vector2.Zero, Vector2.One);
+				*/
+				drawableLines[k].Color = black;
+				Color realLineColor = black;
+
+				if (overrideColor[k].HasValue) {
+					realLineColor = overrideColor[k].Value * num4;
+					drawableLines[k].OverrideColor = realLineColor;
+				}
+
+				if (!ItemLoader.PreDrawTooltipLine(HoverItem, drawableLines[k], ref num12) || !globalCanDraw)
+					goto PostDraw;
+
+				ChatManager.DrawColorCodedStringWithShadow(spriteBatch, drawableLines[k].Font, drawableLines[k].Text, new Vector2(drawableLines[k].X, drawableLines[k].Y), realLineColor, drawableLines[k].Rotation, drawableLines[k].Origin, drawableLines[k].BaseScale, drawableLines[k].MaxWidth, drawableLines[k].Spread);
 			}
 
+			PostDraw:
+			ItemLoader.PostDrawTooltipLine(HoverItem, drawableLines[k]);
+
-			num16 += (int)(FontAssets.MouseText.Value.MeasureString(array[k]).Y + (float)num12);
+			num16 += (int)(FontAssets.MouseText.Value.MeasureString(drawableLines[k].Text).Y + (float)num12);
 		}
+
+		ItemLoader.PostDrawTooltip(HoverItem, drawableLines.AsReadOnly());
 	}
 
-	public static void MouseText_DrawItemTooltip_GetLinesInfo(Item item, ref int yoyoLogo, ref int researchLine, float oldKB, ref int numLines, string[] toolTipLine, bool[] preFixLine, bool[] badPreFixLine)
+	public static void MouseText_DrawItemTooltip_GetLinesInfo(Item item, ref int yoyoLogo, ref int researchLine, float oldKB, ref int numLines, string[] toolTipLine, bool[] preFixLine, bool[] badPreFixLine, string[] toolTipNames, out int prefixlineIndex)
 	{
+		prefixlineIndex = -1;
 		toolTipLine[0] = item.HoverName;
+		toolTipNames[0] = "ItemName";
 		if (item.favorited) {
 			toolTipLine[numLines++] = Lang.tip[56].Value;
+			toolTipNames[numLines - 1] = "Favorite";
 			toolTipLine[numLines++] = Lang.tip[57].Value;
+			toolTipNames[numLines - 1] = "FavoriteDesc";
 			if (LocalPlayer.chest != -1) {
 				ChestUI.GetContainerUsageInfo(out var _, out var chestinv);
-				if (ChestUI.IsBlockedFromTransferIntoChest(item, chestinv))
+				if (ChestUI.IsBlockedFromTransferIntoChest(item, chestinv)) {
 					toolTipLine[numLines++] = Language.GetTextValue("UI.ItemCannotBePlacedInsideItself");
+					toolTipNames[numLines - 1] = "NoTransfer";
+				}
 			}
 		}
 
 		if (item.social) {
 			toolTipLine[numLines] = Lang.tip[0].Value;
+			toolTipNames[numLines] = "Social";
 			numLines++;
 			toolTipLine[numLines] = Lang.tip[1].Value;
+			toolTipNames[numLines] = "SocialDesc";
 			numLines++;
 		}
 		else {
-			if (item.damage > 0 && (!item.notAmmo || item.useStyle != 0) && (item.type < 71 || item.type > 74 || player[myPlayer].HasItem(905))) {
-				float num = 5E-06f;
-				int damage = item.damage;
+			if (item.damage > 0 && (!item.notAmmo || item.useStyle != 0) && (item.type < 71 || item.type > 74 || player[myPlayer].HasItem(905)) && item.DamageType.ShowStatTooltipLine(player[myPlayer], "Damage")) {
+				LocalizedText tip;
+				if (item.DamageType != null) {
+					bool addLeadingSpace = item.DamageType is not VanillaDamageClass;
+					tip = new LocalizedText("", (addLeadingSpace ? " " : "") + item.DamageType.DisplayName);
+				}
+				else {
+					tip = Lang.tip[55]; // No damage class
+				}
+				int damage = player[myPlayer].GetWeaponDamage(item, true);
+				/*
 				damage = (int)((float)damage * ItemID.Sets.ToolTipDamageMultiplier[item.type]);
 				if (item.melee) {
 					toolTipLine[numLines] = string.Concat((int)(LocalPlayer.meleeDamage * (float)damage + num));
@@ -16389,8 +_,12 @@
 					toolTipLine[numLines] = string.Concat(damage);
 					toolTipLine[numLines] += Lang.tip[55].Value;
 				}
+				*/
+				toolTipLine[numLines] = damage + tip.Value;
+				toolTipNames[numLines] = "Damage";
 
 				numLines++;
+				/*
 				if (item.melee) {
 					int num3 = player[myPlayer].meleeCrit - player[myPlayer].inventory[player[myPlayer].selectedItem].crit + item.crit;
 					toolTipLine[numLines] = num3 + Lang.tip[5].Value;
@@ -16406,8 +_,20 @@
 					toolTipLine[numLines] = num5 + Lang.tip[5].Value;
 					numLines++;
 				}
+				*/
+				if (item.DamageType.UseStandardCritCalcs && item.DamageType.ShowStatTooltipLine(player[myPlayer], "CritChance")) {
+					int crit = player[myPlayer].GetWeaponCrit(item);
+					if (crit > 0) { // Fix #3895, see comments for justification.
+						toolTipLine[numLines] = crit + Lang.tip[5].Value;
+						toolTipNames[numLines] = "CritChance";
+						numLines++;
+					}
+				}
 
+				/*
 				if (item.useStyle != 0 && !item.summon) {
+				*/
+				if (item.useStyle != 0 && item.DamageType.ShowStatTooltipLine(player[myPlayer], "Speed")) {
 					if (item.useAnimation <= 8)
 						toolTipLine[numLines] = Lang.tip[6].Value;
 					else if (item.useAnimation <= 20)
@@ -16425,9 +_,37 @@
 					else
 						toolTipLine[numLines] = Lang.tip[13].Value;
 
+					toolTipNames[numLines] = "Speed";
 					numLines++;
+
+					// TML:
+					// These lines add a degree of transparency which vanilla doesn't provide by telling the player what
+					// does and doesn't get affected by attack speed bonuses, as well as if the item in question has any
+					// special scaling rules. they're TML-specific, and can be messed with at the will of the modder.
+					// 
+					// As for why they're differently named: preparation for when that tooltip rework comes out.
+					// - Thomas
+					if (item.DamageType == DamageClass.MeleeNoSpeed || ItemID.Sets.BonusAttackSpeedMultiplier[item.type] == 0f) {
+						if (ModLoader.ModLoader.attackSpeedScalingTooltipVisibility == 0) {
+							toolTipLine[numLines] = Language.GetTextValue("tModLoader.NoAttackSpeedScaling");
+							toolTipNames[numLines] = "NoSpeedScaling";
+							numLines++;
+						}
+					}
+					else if (ItemID.Sets.BonusAttackSpeedMultiplier[item.type] != 1f) {
+						if (ModLoader.ModLoader.attackSpeedScalingTooltipVisibility <= 1) {
+							int attackSpeedScaling = (int)(ItemID.Sets.BonusAttackSpeedMultiplier[item.type] * 100);
+							toolTipLine[numLines] = Language.GetTextValue("tModLoader.SpecialAttackSpeedScaling", attackSpeedScaling);
+							toolTipNames[numLines] = "SpecialSpeedScaling";
+							numLines++;
+						}
+					}
 				}
 
+				if (!item.DamageType.ShowStatTooltipLine(player[myPlayer], "Knockback"))
+					goto SkipKnockbackTooltipLine;
+
+				/*
 				float num6 = item.knockBack;
 				if (item.summon)
 					num6 += player[myPlayer].minionKB;
@@ -16437,6 +_,8 @@
 
 				if (player[myPlayer].inventory[player[myPlayer].selectedItem].type == 3106 && item.type == 3106)
 					num6 += num6 * (1f - player[myPlayer].stealth);
+				*/
+				float num6 = player[myPlayer].GetWeaponKnockback(item, item.knockBack);
 
 				if (num6 == 0f)
 					toolTipLine[numLines] = Lang.tip[14].Value;
@@ -16457,18 +_,23 @@
 				else
 					toolTipLine[numLines] = Lang.tip[22].Value;
 
+				toolTipNames[numLines] = "Knockback";
 				numLines++;
 			}
+			SkipKnockbackTooltipLine:
 
 			if (item.fishingPole > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.PrecentFishingPower", item.fishingPole);
+				toolTipNames[numLines] = "FishingPower";
 				numLines++;
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.BaitRequired");
+				toolTipNames[numLines] = "NeedsBait";
 				numLines++;
 			}
 
 			if (item.bait > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.BaitPower", item.bait);
+				toolTipNames[numLines] = "BaitPower";
 				numLines++;
 			}
 
@@ -16478,41 +_,49 @@
 				else
 					toolTipLine[numLines] = Lang.tip[23].Value;
 
+				toolTipNames[numLines] = "Equipable";
 				numLines++;
 			}
 
 			if (item.tileWand > 0) {
 				toolTipLine[numLines] = Lang.tip[52].Value + Lang.GetItemNameValue(item.tileWand);
+				toolTipNames[numLines] = "WandConsumes";
 				numLines++;
 			}
 
 			if (item.questItem) {
 				toolTipLine[numLines] = Lang.inter[65].Value;
+				toolTipNames[numLines] = "Quest";
 				numLines++;
 			}
 
 			if (item.vanity) {
 				toolTipLine[numLines] = Lang.tip[24].Value;
+				toolTipNames[numLines] = "Vanity";
 				numLines++;
 			}
 
 			if (item.defense > 0) {
 				toolTipLine[numLines] = item.defense + Lang.tip[25].Value;
+				toolTipNames[numLines] = "Defense";
 				numLines++;
 			}
 
 			if (item.pick > 0) {
 				toolTipLine[numLines] = item.pick + Lang.tip[26].Value;
+				toolTipNames[numLines] = "PickPower";
 				numLines++;
 			}
 
 			if (item.axe > 0) {
 				toolTipLine[numLines] = item.axe * 5 + Lang.tip[27].Value;
+				toolTipNames[numLines] = "AxePower";
 				numLines++;
 			}
 
 			if (item.hammer > 0) {
 				toolTipLine[numLines] = item.hammer + Lang.tip[28].Value;
+				toolTipNames[numLines] = "HammerPower";
 				numLines++;
 			}
 
@@ -16523,6 +_,7 @@
 				else
 					toolTipLine[numLines] = tileBoost + Lang.tip[54].Value;
 
+				toolTipNames[numLines] = "TileBoost";
 				numLines++;
 			}
 
@@ -16536,36 +_,51 @@
 					toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.RestoresLife", item.healLife);
 				}
 
+				toolTipNames[numLines] = "HealLife";
 				numLines++;
 			}
 
 			if (item.healMana > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.RestoresMana", item.healMana);
+				toolTipNames[numLines] = "HealMana";
 				numLines++;
 			}
 
+			/* TML: Show mana cost based on Player.GetManaCost method and show UseMana tooltip on Space Gun with Meteor Armor. There has been suggestions to show "Uses X mana (Y% reduction)", but that seems more suited for a mod. This change brings ModifyManaCost behavior in line with Player.manaCost behavior.
 			if (item.mana > 0 && (item.type != 127 || !player[myPlayer].spaceGun)) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.UsesMana", (int)((float)item.mana * player[myPlayer].manaCost));
+				toolTipNames[numLines] = "UseMana";
+				numLines++;
+			}
+			*/
+
+			if (item.mana > 0) {
+				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.UsesMana", player[myPlayer].GetManaCost(item));
+				toolTipNames[numLines] = "UseMana";
 				numLines++;
 			}
 
 			if (item.createWall > 0 || item.createTile > -1) {
 				if (item.type != 213 && item.type != 5295 && item.tileWand < 1) {
 					toolTipLine[numLines] = Lang.tip[33].Value;
+					toolTipNames[numLines] = "Placeable";
 					numLines++;
 				}
 			}
 			else if (item.ammo > 0 && !item.notAmmo) {
 				toolTipLine[numLines] = Lang.tip[34].Value;
+				toolTipNames[numLines] = "Ammo";
 				numLines++;
 			}
 			else if (item.consumable && !item.chlorophyteExtractinatorConsumable) {
 				toolTipLine[numLines] = Lang.tip[35].Value;
+				toolTipNames[numLines] = "Consumable";
 				numLines++;
 			}
 
 			if (item.material) {
 				toolTipLine[numLines] = Lang.tip[36].Value;
+				toolTipNames[numLines] = "Material";
 				numLines++;
 			}
 
@@ -16573,10 +_,12 @@
 				for (int i = 0; i < item.ToolTip.Lines; i++) {
 					if (i == 0 && ItemID.Sets.UsesCursedByPlanteraTooltip[item.type] && !NPC.downedPlantBoss) {
 						toolTipLine[numLines] = Lang.tip[59].Value;
+						toolTipNames[numLines] = "Tooltip" + i.ToString();
 						numLines++;
 					}
 					else {
 						toolTipLine[numLines] = item.ToolTip.GetLine(i);
+						toolTipNames[numLines] = "Tooltip" + i.ToString();
 						numLines++;
 					}
 				}
@@ -16604,16 +_,19 @@
 
 			if ((item.type == 3818 || item.type == 3819 || item.type == 3820 || item.type == 3824 || item.type == 3825 || item.type == 3826 || item.type == 3829 || item.type == 3830 || item.type == 3831 || item.type == 3832 || item.type == 3833 || item.type == 3834) && !player[myPlayer].downedDD2EventAnyDifficulty) {
 				toolTipLine[numLines] = Lang.misc[104].Value;
+				toolTipNames[numLines] = "EtherianManaWarning";
 				numLines++;
 			}
 
 			if (item.buffType > 0 && BuffID.Sets.IsWellFed[item.buffType] && expertMode) {
 				toolTipLine[numLines] = Lang.misc[40].Value;
+				toolTipNames[numLines] = "WellFedExpert";
 				numLines++;
 			}
 
 			if (item.buffTime > 0) {
 				string text = ((item.buffTime / 60 < 60) ? Language.GetTextValue("CommonItemTooltip.SecondDuration", Math.Round((double)item.buffTime / 60.0)) : Language.GetTextValue("CommonItemTooltip.MinuteDuration", Math.Round((double)(item.buffTime / 60) / 60.0)));
+				toolTipNames[numLines] = "BuffTime";
 				toolTipLine[numLines] = text;
 				numLines++;
 			}
@@ -16621,6 +_,7 @@
 			if (item.type == 3262 || item.type == 3282 || item.type == 3283 || item.type == 3284 || item.type == 3285 || item.type == 3286 || item.type == 3316 || item.type == 3315 || item.type == 3317 || item.type == 3291 || item.type == 3389) {
 				toolTipLine[numLines] = " ";
 				yoyoLogo = numLines;
+				toolTipNames[numLines] = "OneDropLogo";
 				numLines++;
 			}
 
@@ -16644,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixDamage";
 					numLines++;
 				}
 
@@ -16661,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixSpeed";
 					numLines++;
 				}
 
@@ -16675,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixCritChance";
 					numLines++;
 				}
 
@@ -16691,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixUseMana";
 					numLines++;
 				}
 
@@ -16707,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixSize";
 					numLines++;
 				}
 
@@ -16723,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixShootSpeed";
 					numLines++;
 				}
 
@@ -16739,137 +_,165 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixKnockback";
 					numLines++;
 				}
 
 				if (item.prefix == 62) {
 					toolTipLine[numLines] = "+1" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 63) {
 					toolTipLine[numLines] = "+2" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 64) {
 					toolTipLine[numLines] = "+3" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 65) {
 					toolTipLine[numLines] = "+4" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 66) {
 					toolTipLine[numLines] = "+20 " + Lang.tip[31].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMaxMana";
 					numLines++;
 				}
 
 				if (item.prefix == 67) {
 					toolTipLine[numLines] = "+2" + Lang.tip[5].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccCritChance";
 					numLines++;
 				}
 
 				if (item.prefix == 68) {
 					toolTipLine[numLines] = "+4" + Lang.tip[5].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccCritChance";
 					numLines++;
 				}
 
 				if (item.prefix == 69) {
 					toolTipLine[numLines] = "+1" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 70) {
 					toolTipLine[numLines] = "+2" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 71) {
 					toolTipLine[numLines] = "+3" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 72) {
 					toolTipLine[numLines] = "+4" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 73) {
 					toolTipLine[numLines] = "+1" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 74) {
 					toolTipLine[numLines] = "+2" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 75) {
 					toolTipLine[numLines] = "+3" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 76) {
 					toolTipLine[numLines] = "+4" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 77) {
 					toolTipLine[numLines] = "+1" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 78) {
 					toolTipLine[numLines] = "+2" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 79) {
 					toolTipLine[numLines] = "+3" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 80) {
 					toolTipLine[numLines] = "+4" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
+
+				prefixlineIndex = numLines;
 			}
 
 			if (item.wornArmor && player[myPlayer].setBonus != "") {
 				toolTipLine[numLines] = Lang.tip[48].Value + " " + player[myPlayer].setBonus;
+				toolTipNames[numLines] = "SetBonus";
 				numLines++;
 			}
 		}
 
 		if (item.expert) {
 			toolTipLine[numLines] = Language.GetTextValue("GameUI.Expert");
+			toolTipNames[numLines] = "Expert";
 			numLines++;
 		}
 
+		/*
 		if (item.rare == -13) {
+		*/
+		if (item.master) {
 			toolTipLine[numLines] = Language.GetTextValue("GameUI.Master");
+			toolTipNames[numLines] = "Master";
 			numLines++;
 		}
 
@@ -16878,8 +_,22 @@
 			if (amountNeeded - sacrificeCount > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.CreativeSacrificeNeeded", amountNeeded - sacrificeCount);
 				researchLine = numLines;
+				toolTipNames[numLines] = "JourneyResearch";
 				numLines++;
 			}
+		}
+
+		if (item.StatsModifiedBy.Count > 0) {
+			if (keyState.PressingShift()) {
+				var modNames = string.Join(", ", item.StatsModifiedBy.Select(m => m.DisplayName));
+				toolTipLine[numLines] = Language.GetTextValue("tModLoader.ModifiedByMods") + modNames;
+			}
+			else {
+				toolTipLine[numLines] = Language.GetTextValue("tModLoader.ModifiedByModsHoldSHIFT");
+			}
+
+			toolTipNames[numLines] = "ModifiedByMods";
+			numLines++;
 		}
 
 		string bestiaryNotes = item.BestiaryNotes;
@@ -16887,11 +_,13 @@
 			string[] array = bestiaryNotes.Split('\n');
 			foreach (string text2 in array) {
 				toolTipLine[numLines++] = text2;
+				toolTipNames[numLines - 1] = "BestiaryNotes";
 			}
 		}
 	}
 
+	//TML: Added 'buffNameHeight' parameter.
-	private void MouseText_DrawBuffTooltip(string buffString, ref int X, ref int Y)
+	private void MouseText_DrawBuffTooltip(string buffString, ref int X, ref int Y, int buffNameHeight)
 	{
 		Microsoft.Xna.Framework.Point p = new Microsoft.Xna.Framework.Point(X, Y);
 		int num = 220;
@@ -16899,7 +_,12 @@
 		int num3 = -1;
 		float num4 = 1f;
 		List<Vector2> list = new List<Vector2>();
+
+		/*
 		Vector2 vector = FontAssets.MouseText.Value.MeasureString(buffString);
+		*/
+		Vector2 vector = Terraria.UI.Chat.ChatManager.GetStringSize(FontAssets.MouseText.Value, buffString, Vector2.One);
+
 		list.Add(vector);
 		int num5 = (int)((float)(screenHeight - Y - 24 - num2) * num4) / 20;
 		if (num5 < 1)
@@ -16907,7 +_,7 @@
 
 		if (bannerMouseOver) {
 			int num6 = 0;
-			for (int i = 0; i < 290; i++) {
+			for (int i = 0; i < NPCLoader.NPCCount; i++) {
 				if (Item.BannerToNPC(i) != 0 && player[myPlayer].HasNPCBannerBuff(i)) {
 					num6++;
 					string nPCNameValue = Lang.GetNPCNameValue(Item.BannerToNPC(i));
@@ -16927,11 +_,14 @@
 						break;
 					}
 
+					// Extra patch context.
 					list.Add(new Vector2(num7, num8) + vector2 - p.ToVector2());
 				}
 			}
 		}
 
+		BuffLoader.CustomBuffTipSize(buffString, list);
+
 		Vector2 zero = Vector2.Zero;
 		foreach (Vector2 item in list) {
 			if (zero.X < item.X)
@@ -16947,6 +_,9 @@
 		if ((float)Y + zero.Y + 4f > (float)screenHeight * num4)
 			Y = (int)((float)screenHeight * num4 - zero.Y - 4f);
 
+		Color color = new Color(Main.mouseTextColor, Main.mouseTextColor, Main.mouseTextColor, 255); // 255 needed for black check in item tags
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, FontAssets.MouseText.Value, buffString, new Vector2(X, Y + buffNameHeight), color, 0f, Vector2.Zero, Vector2.One);
+		/*
 		for (int k = 0; k < 5; k++) {
 			int num11 = X;
 			int num12 = Y + (int)FontAssets.MouseText.Value.MeasureString(buffString).Y;
@@ -16967,16 +_,18 @@
 				default:
 					color = new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
 					break;
+				// Extra patch context.
 			}
 
 			spriteBatch.DrawString(FontAssets.MouseText.Value, buffString, new Vector2(num11, num12), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 		}
+		*/
 
 		if (!bannerMouseOver)
 			return;
 
 		int num13 = 0;
-		for (int l = 0; l < 290; l++) {
+		for (int l = 0; l < NPCLoader.NPCCount; l++) {
 			if (Item.BannerToNPC(l) == 0 || !player[myPlayer].HasNPCBannerBuff(l))
 				continue;
 
@@ -17015,12 +_,16 @@
 					}
 				}
 
+				// Extra patch context.
 				spriteBatch.DrawString(FontAssets.MouseText.Value, text, new Vector2(num14, num15), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 			}
 
+			// TODO: BuffLoader.DrawCustomBuffTip here? This is new to fix too many banner buffs I think.
 			if (flag)
 				break;
 		}
+
+		BuffLoader.DrawCustomBuffTip(buffString, spriteBatch, X, Y + (int)FontAssets.MouseText.Value.MeasureString(buffString).Y);
 	}
 
 	protected void DrawFPS()
@@ -17055,11 +_,13 @@
 			float num = 35f;
 			float num2 = 1f;
 			Vector2 baseScale = new Vector2(num2);
+
+			// Adjust y position to prevent overlap with extra TML version text in main menu
 			if (gameMenu)
-				num = 55f;
+				num = 90f; //55f
 
 			if (menuMode == 0)
-				num += 32f;
+				num += 55f; //32f
 
 			Vector2 stringSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, text, new Vector2(1f));
 			float t = num2;
@@ -17277,10 +_,15 @@
 		}
 	}
 
-	public static bool IsTileSpelunkable(Tile t) => IsTileSpelunkable(t.type, t.frameX, t.frameY);
+	//TML: Added x/y to IsTileSpelunkable methods for hook compatibility, made internal. Public variant is in Main.TML.cs.
+	internal static bool IsTileSpelunkable(int tileX, int tileY, Tile t) => IsTileSpelunkable(tileX, tileY, t.type, t.frameX, t.frameY);
 
-	public static bool IsTileSpelunkable(ushort typeCache, short tileFrameX, short tileFrameY)
+	internal static bool IsTileSpelunkable(int tileX, int tileY, ushort typeCache, short tileFrameX, short tileFrameY)
 	{
+		bool? modded = TileLoader.IsTileSpelunkable(tileX, tileY, typeCache);
+		if (modded.HasValue)
+			return modded.Value;
+
 		if (tileSpelunker[typeCache])
 			return true;
 
@@ -17293,8 +_,16 @@
 		return false;
 	}
 
+	// TML: Added x/y to IsTileBiomeSightable methods for hook compatibility, made internal. Public variant is in Main.TML.cs.
+	internal static bool IsTileBiomeSightable(int tileX, int tileY, Tile t, ref Microsoft.Xna.Framework.Color sightColor) =>
+		IsTileBiomeSightable(tileX, tileY, t.type, t.frameX, t.frameY, ref sightColor);
+
-	public static bool IsTileBiomeSightable(ushort type, short tileFrameX, short tileFrameY, ref Microsoft.Xna.Framework.Color sightColor)
+	internal static bool IsTileBiomeSightable(int tileX, int tileY, ushort type, short tileFrameX, short tileFrameY, ref Microsoft.Xna.Framework.Color sightColor)
 	{
+		bool? modded = TileLoader.IsTileBiomeSightable(tileX, tileY, type, ref sightColor);
+		if (modded.HasValue)
+			return modded.Value;
+
 		if (TileID.Sets.CorruptBiomeSight[type] || (remixWorld && type == 474)) {
 			sightColor = new Microsoft.Xna.Framework.Color(200, 100, 240);
 			return true;
@@ -17325,19 +_,25 @@
 				continue;
 
 			bool flag = false;
+
+			/*
 			if (((gore[i].type >= 706 && gore[i].type <= 717) || gore[i].type == 943 || gore[i].type == 1147 || (gore[i].type >= 1160 && gore[i].type <= 1162)) && (gore[i].frame < 7 || gore[i].frame > 9))
+			*/
+			if (GoreID.Sets.DrawBehind[gore[i].type] && (gore[i].type >= GoreID.Count || gore[i].frame is < 7 or > 9))
 				flag = true;
 
 			if (flag) {
 				LoadGore(gore[i].type);
+
+				//TML: Added '+ gore[i].drawOffset' to draw calls below
 				if (gore[i].Frame.ColumnCount > 1 || gore[i].Frame.RowCount > 1) {
 					Microsoft.Xna.Framework.Rectangle sourceRectangle = gore[i].Frame.GetSourceRectangle(TextureAssets.Gore[gore[i].type].Value);
 					Microsoft.Xna.Framework.Color alpha = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)sourceRectangle.Width * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)sourceRectangle.Height * 0.5) / 16.0)));
-					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f), sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
+					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f) + gore[i].drawOffset, sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
 				}
 				else {
 					Microsoft.Xna.Framework.Color alpha2 = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)TextureAssets.Gore[gore[i].type].Width() * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)TextureAssets.Gore[gore[i].type].Height() * 0.5) / 16.0)));
-					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
+					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)) + gore[i].drawOffset, new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
 				}
 			}
 		}
@@ -17350,30 +_,51 @@
 			if (!gore[i].active || gore[i].type <= 0)
 				continue;
 
+			/*
 			if (((gore[i].type >= 706 && gore[i].type <= 717) || gore[i].type == 943 || gore[i].type == 1147 || (gore[i].type >= 1160 && gore[i].type <= 1162)) && (gore[i].frame < 7 || gore[i].frame > 9)) {
+			*/
+			if (GoreID.Sets.DrawBehind[gore[i].type] && (gore[i].type >= GoreID.Count || gore[i].frame is < 7 or > 9)) {
 				drawBackGore = true;
 				continue;
 			}
 
 			LoadGore(gore[i].type);
+
+			//TML: Added '+ gore[i].drawOffset' to draw calls below
 			if (gore[i].Frame.ColumnCount > 1 || gore[i].Frame.RowCount > 1) {
 				Microsoft.Xna.Framework.Rectangle sourceRectangle = gore[i].Frame.GetSourceRectangle(TextureAssets.Gore[gore[i].type].Value);
 				Vector2 vector = new Vector2(0f, 0f);
 				if (gore[i].type == 1217)
 					vector.Y += 4f;
 
+				vector += gore[i].drawOffset;
 				Microsoft.Xna.Framework.Color alpha = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)sourceRectangle.Width * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)sourceRectangle.Height * 0.5) / 16.0)));
 				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f) + vector, sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
 			}
 			else {
 				Microsoft.Xna.Framework.Color alpha2 = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)TextureAssets.Gore[gore[i].type].Width() * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)TextureAssets.Gore[gore[i].type].Height() * 0.5) / 16.0)));
-				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
+				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)) + gore[i].drawOffset, new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
 			}
 		}
 
 		TimeLogger.DetailedDrawTime(24);
 	}
 
+	/// <summary>
+	/// Draws a small health bar.
+	/// <br/> <see cref="spriteBatch"/> should <strong>already be started</strong> before calling this method.
+	/// </summary>
+	/// <param name="X">The x-coordinate of the health bar in world coordinates.</param>
+	/// <param name="Y">The y-coordinate of the health bar in world coordinates.</param>
+	/// <param name="Health">
+	/// The current health displayed. The health bar is drawn <c><paramref name="Health"/> / <paramref name="MaxHealth"/></c> percent full.
+	/// <br/> If <c><paramref name="Health"/> &lt;= 0</c>, no health bar is drawn.
+	/// <br/> If <c><paramref name="Health"/> &gt; <paramref name="MaxHealth"/></c>, the health bar will not exceed max capacity.
+	/// </param>
+	/// <param name="MaxHealth">The maximum health displayed. The health bar is drawn <c><paramref name="Health"/> / <paramref name="MaxHealth"/></c> percent full.</param>
+	/// <param name="alpha">The opacity of the healthbar, where <c>0f</c> is transparent and <c>1f</c> is opaque.</param>
+	/// <param name="scale">The visual scale of the health bar.</param>
+	/// <param name="noFlip">If <see langword="true"/>, then the health bar will not adjust its y-position for players with reversed gravity.</param>
 	public void DrawHealthBar(float X, float Y, int Health, int MaxHealth, float alpha, float scale = 1f, bool noFlip = false)
 	{
 		if (Health <= 0)
@@ -17456,6 +_,8 @@
 		float num = 0f;
 		if (theNPC.type == 125)
 			num = 30f;
+		else if (theNPC.ModNPC != null)
+			num = theNPC.ModNPC.DrawOffsetY;
 		else if (theNPC.type == 54)
 			num = 2f;
 		else if (theNPC.type == 205)
@@ -17672,7 +_,7 @@
 		Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)screenPosition.X - 800, (int)screenPosition.Y - 800, screenWidth + 1600, screenHeight + 1600);
 		for (int num = 199; num >= 0; num--) {
 			try {
-				if (npc[num].active && npc[num].type > 0 && npc[num].type < NPCID.Count && !npc[num].hide) {
+				if (npc[num].active && npc[num].type > 0 && !npc[num].hide) {
 					npc[num].position += npc[num].netOffset;
 					if (npc[num].behindTiles == behindTiles) {
 						if (npc[num].type == 125 || npc[num].type == 126) {
@@ -17789,13 +_,13 @@
 		}
 	}
 
-	protected void DrawNPCCheckAlt(NPC n)
+	public void DrawNPCCheckAlt(NPC n)
 	{
-		if (TownNPCProfiles.Instance.GetProfile(n.type, out var profile))
+		if (TownNPCProfiles.Instance.GetProfile(n, out var profile))
 			TextureAssets.Npc[n.type] = profile.GetTextureNPCShouldUse(n);
 	}
 
-	protected void DrawNPC(int iNPCIndex, bool behindTiles)
+	public void DrawNPC(int iNPCIndex, bool behindTiles)
 	{
 		NPC rCurrentNPC = npc[iNPCIndex];
 		Vector2 screenPos = screenPosition;
@@ -18186,6 +_,18 @@
 			}
 		}
 
+		NPCLoader.DrawEffects(rCurrentNPC, ref npcColor); //TODO: Effects were previously done before drawing, here, but 1.4 moved them to updates in UpdateNPC_BuffApplyVFX(). Should this hook be moved and renamed? --Mirsario
+
+		if (NPCLoader.PreDraw(rCurrentNPC, spriteBatch, screenPos, npcColor)) {
+			DrawNPCDirect_Inner(spriteBatch, rCurrentNPC, behindTiles, screenPos, ref npcColor);
+		}
+
+		NPCLoader.PostDraw(rCurrentNPC, spriteBatch, screenPos, npcColor);
+	}
+
+	private void DrawNPCDirect_Inner(SpriteBatch mySpriteBatch, NPC rCurrentNPC, bool behindTiles, Vector2 screenPos, ref Color npcColor)
+	{
+		int type = rCurrentNPC.type;
 		npcColor = rCurrentNPC.GetNPCColorTintedByBuffs(npcColor);
 		if (type == 50) {
 			Vector2 zero = Vector2.Zero;
@@ -21675,6 +_,12 @@
 		spriteBatch.Draw(itemTexture, new Vector2(rCurrentNPC.Center.X - screenPosition.X + num8, rCurrentNPC.Center.Y - screenPosition.Y + rCurrentNPC.gfxOffY + num9), rectangle, npcColor, num11, rectangle.Size() / 2f, num2, SpriteEffects.None, 0f);
 	}
 
+	/// <summary>
+	/// Gets the texture and frame of the given item type (<see cref="Item.type"/>).
+	/// </summary>
+	/// <param name="item">The item type to use.</param>
+	/// <param name="itemTexture">The <see cref="Texture2D"/> in <see cref="TextureAssets.Item"/> of <paramref name="item"/>.</param>
+	/// <param name="itemFrame">The <see cref="Rectangle"/> covering this item's current frame on <paramref name="itemTexture"/>.</param>
 	public static void GetItemDrawFrame(int item, out Texture2D itemTexture, out Microsoft.Xna.Framework.Rectangle itemFrame)
 	{
 		instance.LoadItem(item);
@@ -21985,6 +_,7 @@
 					if (n.ai[2] < -0.1f)
 						num11 = 28;
 
+					// Patch note: num11 and num10 are used below.
 					num10 = 0.75f;
 				}
 			}
@@ -21992,6 +_,7 @@
 			Vector2 vector4 = DrawPlayerItemPos(1f, itemtype);
 			GetItemDrawFrame(itemtype, out var itemTexture, out var value2);
 			int num12 = (int)vector4.X - num11;
+			NPCLoader.DrawTownAttackGun(n, ref itemTexture, ref value2, ref num10, ref num12);
 			Vector2 origin2 = new Vector2(-num12, value2.Height / 2);
 			if (n.spriteDirection == -1)
 				origin2 = new Vector2(value2.Width + num12, value2.Height / 2);
@@ -22048,6 +_,7 @@
 			}
 			else if (n.type == 441) {
 				num15 = 3351;
+				// Patch note: num13 used below.
 				num13 = 28;
 				num14 = 0.1f;
 				if (!beforeDraw)
@@ -22058,6 +_,9 @@
 			}
 
 			GetItemDrawFrame(num15, out var itemTexture2, out var rectangle3);
+
+			NPCLoader.DrawTownAttackSwing(n, ref itemTexture2, ref rectangle3, ref num13, ref num14, ref zero);
+
 			Tuple<Vector2, float> swingStats = n.GetSwingStats(NPCID.Sets.AttackTime[n.type] * 2, (int)n.ai[1], n.spriteDirection, num13, num13);
 			Vector2 vector6 = swingStats.Item1 + (swingStats.Item1 - n.Center) * num14 + zero;
 			Vector2 origin4 = rectangle3.Size() * new Vector2((n.spriteDirection != 1) ? 1 : 0, 1f);
@@ -22533,6 +_,12 @@
 	public void DrawProjDirect(Projectile proj)
 	{
 		PrepareDrawnProjectileDrawing(proj);
+
+		DrawProj_Inner(proj);
+	}
+
+	private void DrawProj_DrawVoidLens(Projectile proj, ref bool earlyReturn)
+	{
 		if (proj.type == 734) {
 			VoidLensHelper voidLensHelper = new VoidLensHelper(proj);
 			_voidLensData.Clear();
@@ -22547,6 +_,11 @@
 			}
 		}
 
+		earlyReturn = false;
+	}
+
+	private void DrawProj_Inner(Projectile proj)
+	{
 		float polePosX = 0f;
 		float polePosY = 0f;
 		LoadProjectile(proj.type);
@@ -22554,6 +_,16 @@
 		if (Main.player[proj.owner].mount.Active && Main.player[proj.owner].mount.Type == 52)
 			mountedCenter += new Vector2(Main.player[proj.owner].direction * 14, -10f);
 
+		if (ProjectileLoader.PreDrawExtras(proj)) {
+			DrawProj_DrawYoyoString(proj, mountedCenter);
+			DrawProj_DrawExtras(proj, mountedCenter, ref polePosX, ref polePosY);
+		}
+
+		DrawProj_Inner_DoDrawProj(proj, mountedCenter, polePosX, polePosY);
+	}
+
+	private void DrawProj_DrawYoyoString(Projectile proj, Vector2 mountedCenter)
+	{
 		if (proj.aiStyle == 99) {
 			Vector2 vector = mountedCenter;
 			vector.Y += Main.player[proj.owner].gfxOffY;
@@ -22660,6 +_,12 @@
 			}
 		}
 		else {
+		}
+	}
+
+	private void DrawProj_DrawSpecialProjs(Projectile proj, ref bool earlyReturn)
+	{
+		{
 			if (proj.aiStyle == 160) {
 				DrawKite(proj);
 				return;
@@ -22872,6 +_,11 @@
 			return;
 		}
 
+		earlyReturn = false;
+	}
+
+	private void DrawProj_DrawExtras(Projectile proj, Vector2 mountedCenter, ref float polePosX, ref float polePosY)
+	{
 		if (proj.bobber && Main.player[proj.owner].inventory[Main.player[proj.owner].selectedItem].holdStyle != 0) {
 			DrawProj_FishingLine(proj, ref polePosX, ref polePosY, mountedCenter);
 		}
@@ -23942,7 +_,10 @@
 		else if (proj.aiStyle == 15) {
 			DrawProj_FlailChains(proj, mountedCenter);
 		}
+	}
 
+	private void DrawProj_Inner_DoDrawProj(Projectile proj, Vector2 mountedCenter, float polePosX, float polePosY)
+	{
 		Microsoft.Xna.Framework.Color projectileColor = Lighting.GetColor((int)((double)proj.position.X + (double)proj.width * 0.5) / 16, (int)(((double)proj.position.Y + (double)proj.height * 0.5) / 16.0));
 		if (proj.hide && !ProjectileID.Sets.DontAttachHideToAlpha[proj.type])
 			projectileColor = Lighting.GetColor((int)mountedCenter.X / 16, (int)(mountedCenter.Y / 16f));
@@ -23950,6 +_,26 @@
 		if (proj.type == 14)
 			projectileColor = Microsoft.Xna.Framework.Color.White;
 
+		if (ProjectileLoader.PreDraw(proj, ref projectileColor)) {
+			bool earlyReturn = true;
+			DrawProj_DrawVoidLens(proj, ref earlyReturn);
+			if (earlyReturn)
+				goto PostDraw;
+
+			earlyReturn = true;
+			DrawProj_DrawSpecialProjs(proj, ref earlyReturn);
+			if (earlyReturn)
+				goto PostDraw;
+
+			DrawProj_DrawNormalProjs(proj, polePosX, polePosY, mountedCenter, ref projectileColor);
+		}
+
+		PostDraw:
+		ProjectileLoader.PostDraw(proj, projectileColor);
+	}
+
+	private void DrawProj_DrawNormalProjs(Projectile proj, float polePosX, float polePosY, Vector2 mountedCenter, ref Color projectileColor)
+	{
 		int num136 = 0;
 		int num137 = 0;
 		if (proj.type == 175)
@@ -24347,11 +_,14 @@
 			num138 -= 1f;
 			num136 = -2;
 			num137 = -2;
+			// Patch note: All these locals are used below.
 		}
 
 		if (proj.type == 398)
 			num136 = 8;
 
+		ProjectileLoader.DrawOffset(proj, ref num137, ref num136, ref num138);
+
 		SpriteEffects dir = SpriteEffects.None;
 		if (proj.spriteDirection == -1)
 			dir = SpriteEffects.FlipHorizontally;
@@ -27659,10 +_,26 @@
 					}
 
 					vector109 += (vector111 - vector110).SafeNormalize(Vector2.Zero) * num412;
+					// Patch note: num136, num137, num138, num408, y27 - used below.
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY) + vector108, new Microsoft.Xna.Framework.Rectangle(0, num408, TextureAssets.Projectile[proj.type].Width(), num408 - 1), alpha12, proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY) + vector108 + vector109, new Microsoft.Xna.Framework.Rectangle(0, num408 * 2, TextureAssets.Projectile[proj.type].Width(), num408 - 1), alpha12, proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 				}
 
+				var modProjectile = proj.ModProjectile;
+
+				//TODO: Preload this!
+				if (modProjectile != null && ModContent.RequestIfExists<Texture2D>(modProjectile.GlowTexture, out var glowTexture, AssetRequestMode.ImmediateLoad)) {
+					EntitySpriteDraw(
+						glowTexture.Value,
+						proj.position + screenPosition + new Vector2(num138 + num137, proj.height / 2 + proj.gfxOffY),
+						new Rectangle(0, y27, TextureAssets.Projectile[proj.type].Width(), num408 - 1),
+						new Color(250, 250, 250, proj.alpha), proj.rotation,
+						new Vector2(num138, proj.height / 2 + num136),
+						proj.scale,
+						dir
+					);
+				}
+
 				if (proj.type == 335)
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, y27, TextureAssets.Projectile[proj.type].Width(), num408 - 1), new Microsoft.Xna.Framework.Color(100, 100, 100, 0), proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 
@@ -27856,7 +_,7 @@
 			}
 
 			if (proj.bobber) {
-				if (proj.ai[1] > 0f && proj.ai[1] < (float)ItemID.Count && proj.ai[0] == 1f) {
+				if (proj.ai[1] > 0f && proj.ai[0] == 1f) {
 					int num436 = (int)proj.ai[1];
 					Vector2 center5 = proj.Center;
 					float rotation31 = proj.rotation;
@@ -27915,8 +_,25 @@
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Projectile[proj.type].Width(), TextureAssets.Projectile[proj.type].Height()), new Microsoft.Xna.Framework.Color(255, 255, 0, 0), proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 
 				if (proj.type >= 511 && proj.type <= 513)
+					// Patch note: num136, num137, num138 - used below.
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Projectile[proj.type].Width(), TextureAssets.Projectile[proj.type].Height()), proj.GetAlpha(projectileColor) * 0.25f, proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale * (1f + proj.Opacity * 1.75f), dir);
 
+				ModProjectile modProjectile = proj.ModProjectile;
+
+				//TODO: Preload this!
+				if (modProjectile != null && ModContent.RequestIfExists<Texture2D>(modProjectile.GlowTexture, out var glowTexture)) {
+					EntitySpriteDraw(
+						glowTexture.Value,
+						proj.position - screenPosition + new Vector2(num138 + num137, proj.height / 2 + proj.gfxOffY),
+						new Rectangle(0, 0, TextureAssets.Projectile[proj.type].Width(), TextureAssets.Projectile[proj.type].Height()),
+						new Color(250, 250, 250, proj.alpha),
+						proj.rotation,
+						new Vector2(num138, proj.height / 2 + num136),
+						proj.scale,
+						dir
+					);
+				}
+
 				if (proj.type == 312) {
 					ulong seed3 = TileFrameSeed;
 					for (int num439 = 0; num439 < 4; num439++) {
@@ -28416,6 +_,8 @@
 		if (type == 4442)
 			stringColor = new Microsoft.Xna.Framework.Color(100, 100, 200, 100);
 
+		ProjectileLoader.ModifyFishingLine(proj, ref polePosX, ref polePosY, ref stringColor);
+
 		stringColor = TryApplyingPlayerStringColor(Main.player[proj.owner].stringColor, stringColor);
 		float gravDir = Main.player[proj.owner].gravDir;
 		switch (type) {
@@ -30272,10 +_,13 @@
 			}
 			else if (npc[i].type == 516 || npc[i].type == 519) {
 				DrawCacheNPCProjectiles.Add(i);
+				//Extra patch context.
 			}
 			else if (npc[i].type == 548) {
 				DrawCacheNPCsBehindNonSolidTiles.Add(i);
 			}
+
+			NPCLoader.DrawBehind(Main.npc[i], i);
 		}
 	}
 
@@ -30310,7 +_,7 @@
 				DrawCacheProjsBehindNPCs.Add(i);
 
 			if (projectile[i].type != 636 && projectile[i].type != 598 && projectile[i].type != 971)
-				continue;
+				goto PostProjDrawCache;
 
 			bool flag = true;
 			if (projectile[i].ai[0] == 1f) {
@@ -30327,6 +_,9 @@
 
 			if (flag)
 				DrawCacheProjsBehindProjectiles.Add(i);
+
+			PostProjDrawCache:
+			ProjectileLoader.DrawBehind(projectile[i], i, DrawCacheProjsBehindNPCsAndTiles, DrawCacheProjsBehindNPCs, DrawCacheProjsBehindProjectiles, DrawCacheProjsOverPlayers, DrawCacheProjsOverWiresUI);
 		}
 	}
 
@@ -30705,6 +_,7 @@
 		Vector2 vector = frame.Size() / 2f;
 		Vector2 vector2 = new Vector2((float)(item.width / 2) - vector.X, item.height - frame.Height);
 		Vector2 vector3 = item.position - screenPosition + vector + vector2;
+		// Patch note: 'num' used below.
 		float num = item.velocity.X * 0.2f;
 		if (item.shimmered)
 			num = 0f;
@@ -30726,6 +_,10 @@
 		}
 
 		ItemSlot.GetItemLight(ref currentColor, ref scale, item);
+
+		if (!ItemLoader.PreDrawInWorld(item, spriteBatch, color, currentColor, ref num, ref scale, whoami))
+			goto PostDraw;
+
 		int num2 = item.glowMask;
 		if (!gamePaused && base.IsActive && (item.IsACoin || item.type == 58 || item.type == 109) && color.R > 60 && (float)rand.Next(500) - (Math.Abs(item.velocity.X) + Math.Abs(item.velocity.Y)) * 10f < (float)((int)color.R / 50)) {
 			int type = 43;
@@ -30847,6 +_,9 @@
 			Microsoft.Xna.Framework.Rectangle rectangle = value.Frame();
 			spriteBatch.Draw(value, vector3 + vector4 + frame.Size().RotatedBy(num) * 0.45f * item.scale, rectangle, currentColor, num, rectangle.Size() / 2f, 1f, SpriteEffects.None, 0f);
 		}
+
+		PostDraw:
+		ItemLoader.PostDrawInWorld(item, spriteBatch, color, currentColor, num, scale, whoami);
 	}
 
 	public void DrawItems()
@@ -30870,7 +_,18 @@
 				if (shimmerAlpha > 0f)
 					color *= 1f - shimmerAlpha;
 
+				if (rain.waterStyle >= maxLiquidTypes) {
+					value2 = LoaderManager.Get<WaterStylesLoader>().Get(rain.waterStyle).GetRainTexture().Value;
+					if (value2 == null)
+						goto justUpdateRain;
+				}
+				else {
+					value2 = TextureAssets.Rain.Value;
+				}
+
 				spriteBatch.Draw(value2, rain.position - screenPosition, value, color, rain.rotation, zero, rain.scale, SpriteEffects.None, 0f);
+
+				justUpdateRain:
 				if (flag)
 					rain.Update();
 			}
@@ -30999,6 +_,18 @@
 				if (dust.type == 213)
 					scale = 1f;
 
+				ModDust modDust = DustLoader.GetDust(dust.type);
+
+				if (modDust != null) {
+					if(modDust.PreDraw(dust))
+						modDust.Draw(dust, newColor, scale);
+
+					if (newColor == Color.Black)
+						dust.active = false;
+
+					continue;
+				}
+
 				spriteBatch.Draw(TextureAssets.Dust.Value, dust.position - screenPosition, dust.frame, newColor, dust.GetVisualRotation(), new Vector2(4f, 4f), scale, SpriteEffects.None, 0f);
 				if (dust.color.PackedValue != 0) {
 					Microsoft.Xna.Framework.Color color6 = dust.GetColor(newColor);
@@ -31022,11 +_,17 @@
 	private static void HelpText()
 	{
 		bool flag = false;
+		/*
 		if (player[myPlayer].statLifeMax > 100)
+		*/
+		if (player[myPlayer].ConsumedLifeCrystals > 0)
 			flag = true;
 
 		bool flag2 = false;
+		/*
 		if (player[myPlayer].statManaMax > 20)
+		*/
+		if (player[myPlayer].ConsumedManaCrystals > 0)
 			flag2 = true;
 
 		bool flag3 = true;
@@ -31453,7 +_,10 @@
 				return;
 			}
 
+			/*
 			if (helpText == 202 && !hardMode && player[myPlayer].statLifeMax >= 140) {
+			*/
+			if (helpText == 202 && !hardMode && player[myPlayer].ConsumedLifeCrystals >= 2) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1120");
 				return;
 			}
@@ -31463,12 +_,18 @@
 				return;
 			}
 
+			/*
 			if (helpText == 204 && !NPC.downedGoblins && player[myPlayer].statLifeMax >= 200 && WorldGen.shadowOrbSmashed) {
+			*/
+			if (helpText == 204 && !NPC.downedGoblins && player[myPlayer].ConsumedLifeCrystals >= 5 && WorldGen.shadowOrbSmashed) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1122");
 				return;
 			}
 
+			/*
 			if (helpText == 205 && hardMode && !NPC.downedPirates && player[myPlayer].statLifeMax >= 200) {
+			*/
+			if (helpText == 205 && hardMode && !NPC.downedPirates && player[myPlayer].ConsumedLifeCrystals >= 5) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1123");
 				return;
 			}
@@ -31547,7 +_,10 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1050 && !NPC.downedBoss1 && player[myPlayer].statLifeMax < 200) {
+			*/
+			if (helpText == 1050 && !NPC.downedBoss1 && player[myPlayer].ConsumedLifeCrystals < 5) {
 				npcChatText = Lang.dialog(211);
 				return;
 			}
@@ -31557,22 +_,34 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1052 && !NPC.downedBoss1 && player[myPlayer].statLifeMax >= 200 && player[myPlayer].statDefense > 10) {
+			*/
+			if (helpText == 1052 && !NPC.downedBoss1 && player[myPlayer].ConsumedLifeCrystals >= 5 && player[myPlayer].statDefense > 10) {
 				npcChatText = Lang.dialog(WorldGen.crimson ? 404 : 213);
 				return;
 			}
 
+			/*
 			if (helpText == 1053 && NPC.downedBoss1 && !NPC.downedBoss2 && player[myPlayer].statLifeMax < 300) {
+			*/
+			if (helpText == 1053 && NPC.downedBoss1 && !NPC.downedBoss2 && player[myPlayer].ConsumedLifeCrystals < 10) {
 				npcChatText = Lang.dialog(214);
 				return;
 			}
 
+			/*
 			if (helpText == 1054 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			*/
+			if (helpText == 1054 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Lang.dialog(215);
 				return;
 			}
 
+			/*
 			if (helpText == 1055 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			*/
+			if (helpText == 1055 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Lang.dialog(216);
 				return;
 			}
@@ -31582,22 +_,34 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1057 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax < 400) {
+			*/
+			if (helpText == 1057 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals < Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(218);
 				return;
 			}
 
+			/*
 			if (helpText == 1058 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			*/
+			if (helpText == 1058 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(219);
 				return;
 			}
 
+			/*
 			if (helpText == 1059 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			*/
+			if (helpText == 1059 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(220);
 				return;
 			}
 
+			/*
 			if (helpText == 1060 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			*/
+			if (helpText == 1060 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(221);
 				return;
 			}
@@ -31612,12 +_,18 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1140 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			*/
+			if (helpText == 1140 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1140");
 				return;
 			}
 
+			/*
 			if (helpText == 1141 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			*/
+			if (helpText == 1141 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1141");
 				return;
 			}
@@ -31627,7 +_,10 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1143 && NPC.downedBoss2 && !NPC.downedQueenBee && player[myPlayer].statLifeMax >= 300) {
+			*/
+			if (helpText == 1143 && NPC.downedBoss2 && !NPC.downedQueenBee && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1143");
 				return;
 			}
@@ -31657,7 +_,10 @@
 				return;
 			}
 
+			/*
 			if (helpText == 1149 && hardMode && NPC.downedMechBossAny && player[myPlayer].statLifeMax < 500) {
+			*/
+			if (helpText == 1149 && hardMode && NPC.downedMechBossAny && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax && player[myPlayer].ConsumedLifeFruit < Player.LifeFruitMax) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1149");
 				return;
 			}
@@ -31743,8 +_,12 @@
 			textValue = Language.GetTextValue("StardewTalk.PlayerHasColaAndIsHoldingIt");
 
 		bool flag2 = player[myPlayer].talkNPC != -1;
+		/*
 		_textDisplayCache.PrepareCache(textValue);
 		string[] textLines = _textDisplayCache.TextLines;
+		*/
+		_textDisplayCache.PrepareCache(textValue, color2);
+		List<List<TextSnippet>> textLines = _textDisplayCache.TextLines;
 		int amountOfLines = _textDisplayCache.AmountOfLines;
 		bool flag3 = false;
 		if (editSign) {
@@ -31758,16 +_,25 @@
 				textBlinkerCount = 0;
 			}
 
-			if (textBlinkerState == 1)
+			if (textBlinkerState == 1) {
 				flag3 = true;
+
+				textLines[amountOfLines - 1].Add(new TextSnippet("|", Microsoft.Xna.Framework.Color.White, 1f));
+			}
 
 			instance.DrawWindowsIMEPanel(new Vector2(screenWidth / 2, 90f), 0.5f);
 		}
 
+		/*
 		amountOfLines++;
+		*/
 		spriteBatch.Draw(TextureAssets.ChatBack.Value, new Vector2(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.ChatBack.Width(), (amountOfLines + 1) * 30), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 		spriteBatch.Draw(TextureAssets.ChatBack.Value, new Vector2(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100 + (amountOfLines + 1) * 30), new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.ChatBack.Height() - 30, TextureAssets.ChatBack.Width(), 30), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		TextSnippet hoveredSnippet = null;
 		for (int i = 0; i < amountOfLines; i++) {
+			/*
 			string text = textLines[i];
 			if (text != null) {
 				if (i == amountOfLines - 1 && flag3)
@@ -31778,6 +_,23 @@
 				else
 					Utils.DrawBorderStringFourWay(spriteBatch, FontAssets.MouseText.Value, text, 170 + (screenWidth - 800) / 2, 120 + i * 30, color2, Microsoft.Xna.Framework.Color.Black, Vector2.Zero);
 			}
+			*/
+			List<TextSnippet> text = textLines[i];
+			ChatManager.DrawColorCodedStringWithShadow(spriteBatch, FontAssets.MouseText.Value, text.ToArray(), new Vector2(170 + (screenWidth - 800) / 2, 120 + i * 30), 0f, color2, Color.Black, Vector2.Zero, Vector2.One, out int hoveredSnippetNum);
+
+			if (hoveredSnippetNum > -1)
+				hoveredSnippet = text[hoveredSnippetNum];
+		}
+
+		if (flag3)
+			textLines[amountOfLines - 1].RemoveAt(textLines[amountOfLines - 1].Count - 1);
+
+		// Added on-hover and on-click callbacks as well
+		if (hoveredSnippet is not null) {
+			hoveredSnippet.OnHover();
+
+			if (mouseLeft && mouseLeftRelease)
+				hoveredSnippet.OnClick();
 		}
 
 		Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100, TextureAssets.ChatBack.Width(), (amountOfLines + 2) * 30);
@@ -31820,13 +_,20 @@
 		color2 = new Microsoft.Xna.Framework.Color(num, (int)((double)num / 1.1), num / 2, num);
 		string focusText = "";
 		string focusText2 = "";
+		// Patch note: 'num5' used much below in PostNurseHeal call.
 		int num5 = player[myPlayer].statLifeMax2 - player[myPlayer].statLife;
 		for (int j = 0; j < Player.maxBuffs; j++) {
 			int num6 = player[myPlayer].buffType[j];
-			if (debuff[num6] && player[myPlayer].buffTime[j] > 60 && (num6 < 0 || num6 >= BuffID.Count || !BuffID.Sets.NurseCannotRemoveDebuff[num6]))
+			if (debuff[num6] && player[myPlayer].buffTime[j] > 60 && (num6 < 0 || !BuffID.Sets.NurseCannotRemoveDebuff[num6]))
 				num5 += 100;
 		}
 
+		// TML locals.
+		int health = LocalPlayer.statLifeMax2 - LocalPlayer.statLife;
+		bool removeDebuffs = true;
+		string reason = "";
+		bool canHeal = true;
+
 		if (NPC.downedGolemBoss)
 			num5 *= 200;
 		else if (NPC.downedPlantBoss)
@@ -31997,6 +_,10 @@
 			if (num16 > 0 && num16 < 1)
 				num16 = 1;
 
+			reason = Language.GetTextValue("tModLoader.DefaultNurseCantHealChat");
+			canHeal = PlayerLoader.ModifyNurseHeal(player[myPlayer], LocalPlayer.TalkNPC, ref health, ref removeDebuffs, ref reason);
+			PlayerLoader.ModifyNursePrice(player[myPlayer], LocalPlayer.TalkNPC, health, removeDebuffs, ref num16);
+
 			if (num16 < 0)
 				num16 = 0;
 
@@ -32047,8 +_,11 @@
 			else {
 				text5 = text5.Substring(0, text5.Length - 1);
 				focusText = Lang.inter[54].Value + " (" + text5 + ")";
+				// Extra patch context.
 			}
 		}
+
+		NPCLoader.SetChatButtons(ref focusText, ref focusText2);
 
 		if (!flag) {
 			DrawNPCChatButtons(num, color2, amountOfLines, focusText, focusText2);
@@ -32083,11 +_,26 @@
 					SubmitSignText();
 				else
 					IngameFancyUI.OpenVirtualKeyboard(1);
+
+				// Added by TML.
+				return;
 			}
 			else if (NPCID.Sets.IsTownPet[npc[player[myPlayer].talkNPC].type]) {
 				player[myPlayer].PetAnimal(player[myPlayer].talkNPC);
+
+				// Added by TML.
+				return;
 			}
+			/*
 			else if (npc[player[myPlayer].talkNPC].type == 369) {
+			*/
+
+			if (!NPCLoader.PreChatButtonClicked(true))
+				return;
+
+			NPCLoader.OnChatButtonClicked(true);
+
+			if (npc[player[myPlayer].talkNPC].type == 369) {
 				npcChatCornerItem = 0;
 				SoundEngine.PlaySound(12);
 				bool flag4 = false;
@@ -32259,10 +_,19 @@
 
 				SoundEngine.PlaySound(12);
 				if (num5 > 0) {
+					if (!canHeal) {
+						npcChatText = reason;
+						return;
+					}
+
 					if (player[myPlayer].BuyItem(num5)) {
 						AchievementsHelper.HandleNurseService(num5);
 						SoundEngine.PlaySound(SoundID.Item4);
+
+						/*
 						player[myPlayer].HealEffect(player[myPlayer].statLifeMax2 - player[myPlayer].statLife);
+						*/
+						player[myPlayer].HealEffect(health, true);
 						if ((double)player[myPlayer].statLife < (double)player[myPlayer].statLifeMax2 * 0.25)
 							npcChatText = Lang.dialog(227);
 						else if ((double)player[myPlayer].statLife < (double)player[myPlayer].statLifeMax2 * 0.5)
@@ -32272,14 +_,23 @@
 						else
 							npcChatText = Lang.dialog(230);
 
+						/*
 						player[myPlayer].statLife = player[myPlayer].statLifeMax2;
+						*/
+						player[myPlayer].statLife += health;
+						if (!removeDebuffs)
+							goto SkipDebuffRemoval;
+
 						for (int l = 0; l < Player.maxBuffs; l++) {
 							int num25 = player[myPlayer].buffType[l];
-							if (debuff[num25] && player[myPlayer].buffTime[l] > 0 && (num25 < 0 || num25 >= BuffID.Count || !BuffID.Sets.NurseCannotRemoveDebuff[num25])) {
+							if (debuff[num25] && player[myPlayer].buffTime[l] > 0 && (num25 < 0 || !BuffID.Sets.NurseCannotRemoveDebuff[num25])) {
 								player[myPlayer].DelBuff(l);
 								l = -1;
 							}
 						}
+
+						SkipDebuffRemoval:
+						PlayerLoader.PostNurseHeal(LocalPlayer, LocalPlayer.TalkNPC, health, removeDebuffs, num5);
 					}
 					else {
 						int num26 = rand.Next(3);
@@ -32321,6 +_,11 @@
 			if (!npcChatFocus3 || player[myPlayer].talkNPC < 0)
 				return;
 
+			if (!NPCLoader.PreChatButtonClicked(false))
+				return;
+
+			NPCLoader.OnChatButtonClicked(false);
+
 			if (npc[player[myPlayer].talkNPC].type == 20) {
 				SoundEngine.PlaySound(12);
 				npcChatText = Lang.GetDryadWorldStatusDialog(out var worldIsEntirelyPure);
@@ -32405,8 +_,9 @@
 		playerInventory = true;
 		stackSplit = 9999;
 		npcChatText = "";
-		SetNPCShopIndex(shopIndex);
+		SetNPCShopIndex(1);
-		shop[npcShop].SetupShop(npcShop);
+		shop[npcShop].SetupShop(shopIndex);
+		
 		SoundEngine.PlaySound(12);
 	}
 
@@ -32451,8 +_,12 @@
 			npcChatFocus2 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus2) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus2) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		if (text.Length > 0) {
 			UILinkPointNavigator.SetPosition(2500, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsLeft = true;
@@ -32482,8 +_,12 @@
 			npcChatFocus1 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus1) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus1) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		if (text.Length > 0) {
 			UILinkPointNavigator.SetPosition(2501, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsMiddle = true;
@@ -32519,8 +_,12 @@
 				npcChatFocus3 = false;
 			}
 
+			// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+			ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus3) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+			/*
 			ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus3) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 			ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+			*/
 			UILinkPointNavigator.SetPosition(2502, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsRight = true;
 		}
@@ -32559,8 +_,12 @@
 			npcChatFocus4 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus4) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus4) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		UILinkPointNavigator.SetPosition(2503, vector2 + stringSize * 0.5f);
 		UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsRight2 = true;
 	}
@@ -32869,8 +_,12 @@
 			}
 		}
 
+		/*
 		GetBuilderAccsCountToShow(LocalPlayer, out var _, out var _, out var totalDrawnIcons);
 		bool pushSideToolsUp = totalDrawnIcons >= 10;
+		*/
+		int activeToggles = BuilderToggleLoader.ActiveBuilderToggles();
+		bool pushSideToolsUp = activeToggles / 12 != BuilderToggleLoader.BuilderTogglePage || activeToggles % 12 >= 10;
 		if (!PlayerInput.UsingGamepad)
 			DrawHotbarLockIcon(num, num2, pushSideToolsUp);
 
@@ -33145,17 +_,25 @@
 					if (num34 == 147)
 						bannerMouseOver = true;
 
+					/*
 					if (meleeBuff[num34])
 						MouseTextHackZoom(buffName, -10, 0, buffTooltip);
 					else
 						MouseTextHackZoom(buffName, buffTooltip);
+					*/
+					int rare = 0;
+					if (meleeBuff[num34])
+						rare = -10;
+
+					BuffLoader.ModifyBuffText(num34, ref buffName, ref buffTooltip, ref rare);
+					MouseTextHackZoom(buffName, rare, diff: 0, buffTooltip);
 				}
 			}
 		}
 		else if (EquipPage == 1) {
 			DrawNPCHousesInUI();
 		}
-		else {
+		else if (EquipPage == 0) { // Added 'if (EquipPage == 0)' to add custom equip pages
 			int num35 = 4;
 			if (mouseX > screenWidth - 64 - 28 && mouseX < (int)((float)(screenWidth - 64 - 28) + 56f * inventoryScale) && mouseY > num20 && mouseY < (int)((float)num20 + 448f * inventoryScale) && !PlayerInput.IgnoreMouseInterface)
 				player[myPlayer].mouseInterface = true;
@@ -33173,7 +_,12 @@
 			Microsoft.Xna.Framework.Color color2 = new Microsoft.Xna.Framework.Color(80, 80, 80, 80);
 			DrawLoadoutButtons(num20, flag5, flag6);
 			int num39 = -1;
+
+			// Vanilla acc (not armor) slot drawing moved to AccessorySlotLoader.DrawAccSlots
+			/*
 			for (int num40 = 0; num40 < 10; num40++) {
+			*/
+			for (int num40 = 0; num40 < 3; num40++) {
 				if ((num40 == 8 && !flag5) || (num40 == 9 && !flag6))
 					continue;
 
@@ -33194,6 +_,8 @@
 					context2 = 10;
 				}
 
+				// Moved below, after modded acc slots have drawn
+				/*
 				if (num39 == num38 && !_achievementAdvisor.CanDrawAboveCoins) {
 					_achievementAdvisor.DrawOneAchievement(spriteBatch, new Vector2(num41 - 10 - 47 - 47 - 14 - 14, num42 + 8), large: false);
 					UILinkPointNavigator.SetPosition(1570, new Vector2(num41 - 10 - 47 - 47 - 14 - 14, num42 + 8) + new Vector2(20f) * inventoryScale);
@@ -33201,6 +_,7 @@
 
 				if (num39 == num37)
 					DrawDefenseCounter(num41, num42);
+				*/
 
 				Texture2D value3 = TextureAssets.InventoryTickOn.Value;
 				if (player[myPlayer].hideVisibleAccessory[num40])
@@ -33247,7 +_,12 @@
 				player[myPlayer].mouseInterface = true;
 
 			num39 = -1;
+
+			// Vanilla acc (not armor) slot drawing moved to AccessorySlotLoader.DrawAccSlots
+			/*
 			for (int num46 = 10; num46 < 20; num46++) {
+			*/
+			for (int num46 = 10; num46 < 13; num46++) {
 				if ((num46 == 18 && !flag5) || (num46 == 19 && !flag6))
 					continue;
 
@@ -33288,7 +_,12 @@
 				player[myPlayer].mouseInterface = true;
 
 			num39 = -1;
+
+			// Vanilla acc (not armor) slot drawing moved to AccessorySlotLoader.DrawAccSlots
+			/*
 			for (int num50 = 0; num50 < 10; num50++) {
+			*/
+			for (int num50 = 0; num50 < 3; num50++) {
 				if ((num50 == 8 && !flag5) || (num50 == 9 && !flag6))
 					continue;
 
@@ -33323,9 +_,25 @@
 			}
 
 			inventoryBack = color;
+
+			// Moved from above [[
+			var defPos = AccessorySlotLoader.DefenseIconPosition;
+			DrawDefenseCounter((int)defPos.X, (int)defPos.Y);
+
+			if (!_achievementAdvisor.CanDrawAboveCoins) {
+				var achievePos = new Vector2(defPos.X - 10 - 47 - 47 - 14 - 14, defPos.Y - 56 * inventoryScale * 0.5f);
+				_achievementAdvisor.DrawOneAchievement(spriteBatch, achievePos , large: false);
+				UILinkPointNavigator.SetPosition(1570, achievePos + new Vector2(20f) * inventoryScale);
+			}
+
+			inventoryBack = color;
+			// ]]
+
 			inventoryScale = num36;
 		}
 
+		LoaderManager.Get<AccessorySlotLoader>().DrawAccSlots(num20);
+
 		int num54 = (screenHeight - 600) / 2;
 		int num55 = (int)((float)screenHeight / 600f * 250f);
 		if (screenHeight < 700) {
@@ -33369,11 +_,22 @@
 				string text = Lang.inter[46].Value + ": ";
 				if (reforgeItem.type > 0) {
 					int num58 = reforgeItem.value;
+					num58 *= reforgeItem.stack; // #StackablePrefixWeapons: scale with current stack size
+
+					bool canApplyDiscount = true;
+					if (!ItemLoader.ReforgePrice(reforgeItem, ref num58, ref canApplyDiscount))
+						goto skipVanillaPricing;
+
+					/*
 					if (player[myPlayer].discountAvailable)
+					*/
+					if (canApplyDiscount && LocalPlayer.discountAvailable)
 						num58 = (int)((double)num58 * 0.8);
 
 					num58 = (int)((double)num58 * player[myPlayer].currentShoppingSettings.PriceAdjustment);
 					num58 /= 3;
+					skipVanillaPricing:
+
 					string text2 = "";
 					int num59 = 0;
 					int num60 = 0;
@@ -33431,11 +_,21 @@
 
 						mouseReforge = true;
 						player[myPlayer].mouseInterface = true;
+
+						/*
 						if (mouseLeftRelease && mouseLeft && player[myPlayer].BuyItem(num58)) {
+						*/
+						if (mouseLeftRelease && mouseLeft && player[myPlayer].CanAfford(num58) && ItemLoader.CanReforge(reforgeItem)) {
+							player[myPlayer].BuyItem(num58);
+							ItemLoader.PreReforge(reforgeItem); // After BuyItem just in case
+
 							reforgeItem.ResetPrefix();
 							reforgeItem.Prefix(-2);
 							reforgeItem.position.X = player[myPlayer].position.X + (float)(player[myPlayer].width / 2) - (float)(reforgeItem.width / 2);
 							reforgeItem.position.Y = player[myPlayer].position.Y + (float)(player[myPlayer].height / 2) - (float)(reforgeItem.height / 2);
+
+							ItemLoader.PostReforge(reforgeItem);
+
 							PopupText.NewText(PopupTextContext.ItemReforge, reforgeItem, reforgeItem.stack, noStack: true);
 							SoundEngine.PlaySound(SoundID.Item37);
 						}
@@ -33490,6 +_,10 @@
 
 		CreativeMenu.Draw(spriteBatch);
 		bool flag10 = CreativeMenu.Enabled && !CreativeMenu.Blocked;
+
+		// Added by TML.
+		flag10 |= hidePlayerCraftingMenu;
+
 		if (!InReforgeMenu && !LocalPlayer.tileEntityAnchor.InUse && !flag10) {
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = -1;
@@ -33572,7 +_,7 @@
 			if (numAvailableRecipes > 0) {
 				UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
 				UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = -1;
-				for (int num72 = 0; num72 < Recipe.maxRequirements; num72++) {
+				for (int num72 = 0; num72 < recipe[availableRecipe[focusRecipe]].requiredItem.Count; num72++) {
 					if (recipe[availableRecipe[focusRecipe]].requiredItem[num72].type == 0) {
 						UILinkPointNavigator.Shortcuts.CRAFT_CurrentIngredientsCount = num72 + 1;
 						break;
@@ -33617,7 +_,13 @@
 					UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = 1 + num72;
 					Microsoft.Xna.Framework.Color color5 = inventoryBack;
 					inventoryBack = new Microsoft.Xna.Framework.Color((byte)num75, (byte)num75, (byte)num75, (byte)num75);
+
+					//TML: Ref a local copy variable instead of the data in the array.
+					/*
 					ItemSlot.Draw(spriteBatch, ref recipe[availableRecipe[focusRecipe]].requiredItem[num72], 22, new Vector2(num73, num74));
+					*/
+					Item tempItem = recipe[availableRecipe[focusRecipe]].requiredItem[num72];
+					ItemSlot.Draw(spriteBatch, ref tempItem, 22, new Vector2(num73, num74));
 					inventoryBack = color5;
 				}
 			}
@@ -33651,6 +_,9 @@
 			}
 		}
 
+		// Added by TML
+		hidePlayerCraftingMenu = false;
+
 		if (recBigList && !flag10) {
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = -1;
@@ -33990,8 +_,11 @@
 
 		for (int j = 0; j < 200; j++) {
 			if (npc[j].active && !_npcTypesThatAlreadyDrewAHead.Contains(npc[j].type)) {
+				if (npc[j].ModNPC?.TownNPCStayingHomeless is true)
+					continue;
+				
 				int headIndexSafe = TownNPCProfiles.GetHeadIndexSafe(npc[j]);
-				if (headIndexSafe > 0 && headIndexSafe <= NPCHeadID.Count && !NPCHeadID.Sets.CannotBeDrawnInHousingUI[headIndexSafe] && _npcIndexWhoHoldsHeadIndex[headIndexSafe] == -1) {
+				if (headIndexSafe > 0 && !NPCHeadID.Sets.CannotBeDrawnInHousingUI[headIndexSafe] && _npcIndexWhoHoldsHeadIndex[headIndexSafe] == -1) {
 					_npcIndexWhoHoldsHeadIndex[headIndexSafe] = j;
 					_npcTypesThatAlreadyDrewAHead.Add(npc[j].type);
 				}
@@ -34097,7 +_,7 @@
 		else {
 			text = Lang.inter[21].Value + " " + guideItem.Name;
 			Recipe recipe = Main.recipe[availableRecipe[focusRecipe]];
-			for (int i = 0; i < Recipe.maxRequirements; i++) {
+			for (int i = 0; i < recipe.requiredTile.Count; i++) {
 				int num = recipe.requiredTile[i];
 				if (num == -1)
 					break;
@@ -34122,6 +_,9 @@
 			if (recipe.needGraveyardBiome)
 				_requiredObjecsForCraftingText.Add(Lang.inter[124].Value);
 
+			//TML: Display recipe conditions' descriptions
+			_requiredObjecsForCraftingText.AddRange(recipe.Conditions.Select(x => x.Description.Value));
+
 			if (_requiredObjecsForCraftingText.Count == 0) {
 				string value = Lang.inter[23].Value;
 				_requiredObjecsForCraftingText.Add(value);
@@ -34159,7 +_,7 @@
 			spriteBatch.DrawString(FontAssets.MouseText.Value, Lang.inter[22].Value, new Vector2(inventoryX, inventoryY + 118), craftingTipColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 			int num3 = focusRecipe;
 			int num4 = 0;
-			for (int i = 0; i < Recipe.maxRequirements; i++) {
+			for (int i = 0; i < recipe[availableRecipe[num3]].requiredTile.Count; i++) {
 				int num5 = (i + 1) * 26;
 				if (recipe[availableRecipe[num3]].requiredTile[i] == -1) {
 					if (i == 0 && !recipe[availableRecipe[num3]].needWater && !recipe[availableRecipe[num3]].needHoney && !recipe[availableRecipe[num3]].needLava && !recipe[availableRecipe[num3]].needSnowBiome && !recipe[availableRecipe[num3]].needGraveyardBiome)
@@ -34264,6 +_,10 @@
 		if (mouseItem.IsAir)
 			return true;
 
+		// #StackablePrefixWeapons: Gameplay impact: Prevent crafted prefix application by blocking crafting if mouse item is prefixed
+		if (mouseItem.maxStack > 1 && mouseItem.AllowReforgeForStackableItem && mouseItem.prefix > 0)
+			return false;
+
 		if (mouseItem.IsTheSameAs(currentRecipe.createItem) && mouseItem.stack + currentRecipe.createItem.stack <= mouseItem.maxStack)
 			return true;
 
@@ -34293,6 +_,11 @@
 			inventoryScale = 0.755f;
 			num += 5;
 		}
+		else if ((player[myPlayer].chest == -1 || npcShop == -1) && trashSlotOffset != Point16.Zero) {
+			num += trashSlotOffset.X;
+			num2 += trashSlotOffset.Y;
+			inventoryScale = 0.755f;
+		}
 
 		new Microsoft.Xna.Framework.Color(150, 150, 150, 150);
 		if (mouseX >= num && (float)mouseX <= (float)num + (float)TextureAssets.InventoryBack.Width() * inventoryScale && mouseY >= num2 && (float)mouseY <= (float)num2 + (float)TextureAssets.InventoryBack.Height() * inventoryScale && !PlayerInput.IgnoreMouseInterface) {
@@ -34461,6 +_,8 @@
 			spriteBatch.Draw(value, new Vector2(pivotTopLeftX, num), value.Frame(2, 1, 1), OurFavoriteColor, 0f, default(Vector2), num2, SpriteEffects.None, 0f);
 	}
 
+	// These 2 methods are no longer necessary because they had hardcoded values and did nearly the same thing. Builder Toggles are now much more flexible and dynamic
+	/*
 	private void DrawBlockReplacementIcon(int pivotTopLeftX, int pivotTopLeftY, bool pushSideToolsUp, int gamepadPointOffset)
 	{
 		if (!playerInventory)
@@ -34530,20 +_,43 @@
 
 		UILinkPointNavigator.SetPosition(6000 + gamepadPointOffset, vector + rectangle.Size() * 0.65f);
 	}
+	*/
 
 	public static void CraftItem(Recipe r)
 	{
+		// #OnStackHook
+		/*
 		int stack = mouseItem.stack;
 		mouseItem = r.createItem.Clone();
 		mouseItem.stack += stack;
 		mouseItem.OnCreated(new RecipeItemCreationContext(r));
 		if (stack <= 0)
 			mouseItem.Prefix(-1);
+		*/
+
+		if (mouseItem.stack > 0 && !ItemLoader.CanStack(mouseItem, r.createItem))
+			return;
+
+		Item crafted = r.createItem.Clone();
+		crafted.Prefix(-1);
+		r.Create();
+		RecipeLoader.OnCraft(crafted, r, mouseItem);
+
+		if (mouseItem.stack > 0) {
+			ItemLoader.StackItems(mouseItem, crafted, out _);
+		}
+		else {
+			mouseItem = crafted;
+		}
 
 		mouseItem.position.X = player[myPlayer].position.X + (float)(player[myPlayer].width / 2) - (float)(mouseItem.width / 2);
 		mouseItem.position.Y = player[myPlayer].position.Y + (float)(player[myPlayer].height / 2) - (float)(mouseItem.height / 2);
 		PopupText.NewText(PopupTextContext.ItemCraft, mouseItem, r.createItem.stack);
+
+		// Moved above
+		/*
 		r.Create();
+		*/
 		if (mouseItem.type > 0 || r.createItem.type > 0)
 			SoundEngine.PlaySound(7);
 	}
@@ -34727,6 +_,10 @@
 					if (item[i].expert)
 						rare = -12;
 
+					// Field added by TML.
+					if (item[i].master)
+						rare = -13;
+
 					MouseTextHackZoom(text, rare, 0);
 					mouseText = true;
 					break;
@@ -34815,6 +_,10 @@
 		Player player = Main.player[myPlayer];
 		for (int i = 0; i < 200; i++) {
 			NPC nPC = npc[i];
+
+			if (!nPC.ShowNameOnHover)
+				continue;
+
 			if (!(nPC.active & (nPC.shimmerTransparency == 0f || nPC.CanApplyHunterPotionEffects())))
 				continue;
 
@@ -34825,6 +_,8 @@
 			if (nPC.type >= 87 && nPC.type <= 92)
 				value = new Microsoft.Xna.Framework.Rectangle((int)((double)nPC.position.X + (double)nPC.width * 0.5 - 32.0), (int)((double)nPC.position.Y + (double)nPC.height * 0.5 - 32.0), 64, 64);
 
+			NPCLoader.ModifyHoverBoundingBox(nPC, ref value);
+
 			bool flag = mouseRectangle.Intersects(value);
 			bool flag2 = flag || (SmartInteractShowingGenuine && SmartInteractNPC == i);
 			if (flag2 && ((nPC.type != 85 && nPC.type != 341 && nPC.type != 629 && nPC.aiStyle != 87) || nPC.ai[0] != 0f) && nPC.type != 488) {
@@ -34849,7 +_,12 @@
 				}
 				else {
 					bool flag3 = SmartInteractShowingGenuine && SmartInteractNPC == i;
+					bool vanillaCanChat = false;
 					if (nPC.townNPC || nPC.type == 105 || nPC.type == 106 || nPC.type == 123 || nPC.type == 354 || nPC.type == 376 || nPC.type == 579 || nPC.type == 453 || nPC.type == 589) {
+						vanillaCanChat = true;
+					}
+
+					if (NPCLoader.CanChat(nPC) ?? vanillaCanChat) {
 						Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)(player.position.X + (float)(player.width / 2) - (float)(Player.tileRangeX * 16)), (int)(player.position.Y + (float)(player.height / 2) - (float)(Player.tileRangeY * 16)), Player.tileRangeX * 16 * 2, Player.tileRangeY * 16 * 2);
 						Microsoft.Xna.Framework.Rectangle value2 = new Microsoft.Xna.Framework.Rectangle((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
 						if (rectangle.Intersects(value2))
@@ -35027,10 +_,18 @@
 			if (num5 == 147)
 				bannerMouseOver = true;
 
+			/*
 			if (meleeBuff[num5])
 				MouseTextHackZoom(buffName, -10, 0, buffTooltip);
 			else
 				MouseTextHackZoom(buffName, buffTooltip);
+			*/
+			int rare = 0;
+			if (meleeBuff[num5])
+				rare = -10;
+
+			BuffLoader.ModifyBuffText(num5, ref buffName, ref buffTooltip, ref rare);
+			MouseTextHackZoom(buffName, rare, 0, buffTooltip);
 		}
 	}
 
@@ -35060,6 +_,14 @@
 		return text;
 	}
 
+	/// <summary>
+	/// Checks if the buff at index <paramref name="buffSlotOnPlayer"/> is allowed to draw a "remaining time" text, and sets <paramref name="buffTimeValue"/> to it.
+	/// <para>Check <paramref name="buffTimeValue"/> > 2 afterwards if you want to mirror text draw logic.</para>
+	/// </summary>
+	/// <param name="buffSlotOnPlayer">The index for buffType and buffTime</param>
+	/// <param name="buffTimeValue">The "remaining time" in ticks</param>
+	/// <returns><see langword="true"/> if <paramref name="buffTimeValue"/> is set, otherwise <see langword="false"/></returns>
+	// TO-DO: add a hook for drawing time left probably?
 	public static bool TryGetBuffTime(int buffSlotOnPlayer, out int buffTimeValue)
 	{
 		int num = player[myPlayer].buffType[buffSlotOnPlayer];
@@ -35072,6 +_,16 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Draws the buff icon corresponding to the buff in Main.LocalPlayer.buffType[<paramref name="buffSlotOnPlayer"/>].
+	/// <para>Calls TML hooks related to drawing and clicking.</para>
+	/// <para>Has two exclusive contexts: Below the accessory slots (Main.EquipPage == 2), and regular under-the-inventory.</para>
+	/// </summary>
+	/// <param name="drawBuffText">The return from a previous DrawBuffIcon call, -1 if first drawn buff</param>
+	/// <param name="buffSlotOnPlayer">The index for buffType and buffTime</param>
+	/// <param name="x">Top-left draw position on the x-axis</param>
+	/// <param name="y">Top-left draw position on the y-axis</param>
+	/// <returns>The index of the currently mouseovered buff icon, equal to <paramref name="buffSlotOnPlayer"/> if it's currently mouseovered, -1 otherwise</returns>
 	public static int DrawBuffIcon(int drawBuffText, int buffSlotOnPlayer, int x, int y)
 	{
 		int num = player[myPlayer].buffType[buffSlotOnPlayer];
@@ -35079,13 +_,46 @@
 			return drawBuffText;
 
 		Microsoft.Xna.Framework.Color color = new Microsoft.Xna.Framework.Color(buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer]);
+
+		/*
 		spriteBatch.Draw(TextureAssets.Buff[num].Value, new Vector2(x, y), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Buff[num].Width(), TextureAssets.Buff[num].Height()), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+		*/
+
+		// Drawing made customizable through tML hooks
+		Asset<Texture2D> buffAsset = TextureAssets.Buff[num];
+		Texture2D texture = buffAsset.Value;
+		Vector2 drawPosition = new Vector2(x, y);
+		int width = buffAsset.Width();
+		int height = buffAsset.Height();
+		Vector2 textPosition = new Vector2(x, y + height);
+		Rectangle sourceRectangle = new Rectangle(0, 0, width, height);
+		Rectangle mouseRectangle = new Rectangle(x, y, width, height);
+		Color drawColor = color;
+
+		BuffDrawParams drawParams = new BuffDrawParams(texture, drawPosition, textPosition, sourceRectangle, mouseRectangle, drawColor);
+
+		bool skipped = !BuffLoader.PreDraw(spriteBatch, num, buffSlotOnPlayer, ref drawParams);
+
+		(texture, drawPosition, textPosition, sourceRectangle, mouseRectangle, drawColor) = drawParams;
+
+		if (!skipped)
+			spriteBatch.Draw(texture, drawPosition, sourceRectangle, drawColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
+		BuffLoader.PostDraw(spriteBatch, num, buffSlotOnPlayer, drawParams);
+
 		if (TryGetBuffTime(buffSlotOnPlayer, out var buffTimeValue) && buffTimeValue > 2) {
 			string text = Lang.LocalizedDuration(new TimeSpan(0, 0, buffTimeValue / 60), abbreviated: true, showAllAvailableUnits: false);
+
+			/*
 			spriteBatch.DrawString(FontAssets.ItemStack.Value, text, new Vector2(x, y + TextureAssets.Buff[num].Height()), color, 0f, default(Vector2), 0.8f, SpriteEffects.None, 0f);
+			*/
+			spriteBatch.DrawString(FontAssets.ItemStack.Value, text, textPosition, color, 0f, default(Vector2), 0.8f, SpriteEffects.None, 0f);
 		}
 
+		/*
 		if (mouseX < x + TextureAssets.Buff[num].Width() && mouseY < y + TextureAssets.Buff[num].Height() && mouseX > x && mouseY > y) {
+		*/
+		if (mouseRectangle.Contains(new Point(mouseX, mouseY))) {
 			drawBuffText = buffSlotOnPlayer;
 			buffAlpha[buffSlotOnPlayer] += 0.1f;
 			bool flag = mouseRight && mouseRightRelease;
@@ -35099,6 +_,9 @@
 			}
 
 			if (flag)
+				flag &= BuffLoader.RightClick(num, buffSlotOnPlayer);
+
+			if (flag)
 				TryRemovingBuff(buffSlotOnPlayer, num);
 		}
 		else {
@@ -35116,6 +_,11 @@
 		return drawBuffText;
 	}
 
+	/// <summary>
+	/// Calls Player.DelBuff with index i after checking Main.debuff of buff type b. Will toggle Player.hideMisc for pet and light pet.
+	/// </summary>
+	/// <param name="i">The index for buffType and buffTime</param>
+	/// <param name="b">The buff type</param>
 	public static void TryRemovingBuff(int i, int b)
 	{
 		bool flag = false;
@@ -35410,7 +_,13 @@
 			return;
 		}
 
+		if (hairstylesUpdatedForThisInteraction)
+			goto SkipUpdateUnlocks;
+
+		hairstylesUpdatedForThisInteraction = true;
 		Hairstyles.UpdateUnlocks();
+		SkipUpdateUnlocks:;
+
 		int count = Hairstyles.AvailableHairstyles.Count;
 		int num = screenHeight / 2 + 60;
 		int num2 = screenWidth / 2 - TextureAssets.HairStyleBack.Width() / 2;
@@ -36393,10 +_,21 @@
 			SetupDrawInterfaceLayers();
 
 		PlayerInput.SetZoom_UI();
+		
+		/*
 		using (List<GameInterfaceLayer>.Enumerator enumerator = _gameInterfaceLayers.GetEnumerator()) {
 			while (enumerator.MoveNext() && enumerator.Current.Draw()) {
 			}
 		}
+		*/
+
+		var interfaceLayers = new List<GameInterfaceLayer>(_gameInterfaceLayers);
+		SystemLoader.ModifyInterfaceLayers(interfaceLayers);
+		
+		foreach (var layer in interfaceLayers) {
+			if(!layer.Draw())
+				break;
+		}
 
 		PlayerInput.SetZoom_World();
 	}
@@ -36758,6 +_,9 @@
 
 	private void DrawInterface_33_MouseText()
 	{
+		//TODO: UI Sorting and selective disable support - move this to new one between 32 and 33
+		SystemLoader.PostDrawInterface(spriteBatch);
+
 		if (mouseItem.stack <= 0)
 			mouseItem.type = 0;
 
@@ -36841,7 +_,8 @@
 				num4 += num5;
 			}
 
+			//TML: Remove the Setting button being moved when player has too many slots. The ModAccessorySlot rework fixed this in a better fashion.
-			if (amountOfExtraAccessorySlotsToShow >= 1 && (screenHeight < num3 || (screenHeight < num4 && mapStyle == 1))) {
+			if (false && amountOfExtraAccessorySlotsToShow >= 1 && (screenHeight < num3 || (screenHeight < num4 && mapStyle == 1))) {
 				num -= 140;
 				num2 -= PlayerInput.SettingsForUI.PushEquipmentAreaUp.ToInt() * 30;
 				_settingsButtonIsPushedToSide = true;
@@ -37010,6 +_,8 @@
 	{
 		if (hairWindow)
 			DrawHairWindow();
+		else
+			hairstylesUpdatedForThisInteraction = false;
 	}
 
 	private static void DrawInterface_20_MultiplayerPlayerNames()
@@ -37178,10 +_,17 @@
 		num22 = 240;
 		text9 = $"{upTimerMax:F2}ms";
 		spriteBatch.DrawString(FontAssets.MouseText.Value, text9, new Vector2(num22, num23), Microsoft.Xna.Framework.Color.White, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
+		spriteBatch.DrawString(FontAssets.MouseText.Value, Localization.Language.GetTextValue("tModLoader.PressXToClose", Microsoft.Xna.Framework.Input.Keys.F7), new Vector2(20, num23 + 32), Color.White, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 	}
 
 	private static void DrawInterface_17_DiagnoseNet()
 	{
+		if (ModNet.ShouldDrawModNetDiagnosticsUI) {
+			ModNet.ModNetDiagnosticsUI.Draw(spriteBatch);
+			return;
+		}
+		
 		if (shouldDrawNetDiagnosticsUI)
 			ActiveNetDiagnosticsUI.Draw(spriteBatch);
 	}
@@ -37306,6 +_,12 @@
 					if (HealthBarDrawSettings == 2)
 						num3 -= 34f;
 
+					if (!NPCLoader.DrawHealthBar(npc[num2], ref scale)) {
+						npc[num2].position -= npc[num2].netOffset;
+						continue;
+					}
+
+					// Patch note: 'num2', used above, can be seen here:
 					if ((!expertMode || type != 266) && ((type != 439 && type != 440) || npc[num2].ai[0] != 5f)) {
 						if (type >= 134 && type <= 136) {
 							scale = 1.5f;
@@ -38044,6 +_,7 @@
 		if (!CanShowInfoAccs)
 			return;
 
+#pragma warning disable CS0219
 		bool flag = false;
 		bool flag2 = false;
 		bool flag3 = false;
@@ -38056,6 +_,7 @@
 		bool flag10 = false;
 		bool flag11 = false;
 		bool flag12 = false;
+#pragma warning restore CS0219
 		int num = -1;
 		int num2 = -10;
 		int num3 = 0;
@@ -38068,12 +_,27 @@
 		}
 
 		Microsoft.Xna.Framework.Color color = new Microsoft.Xna.Framework.Color(100, 100, 100, mouseTextColor);
+
+		InfoDisplayPageHandler(startX, ref text, out int startingDisplay, out int endingDisplay);
+
+		/*
 		for (int i = 0; i < 12; i++) {
+		*/
+		for (int i = startingDisplay; i < endingDisplay; i++) {
 			string text2 = "";
 			string text3 = "";
 			Microsoft.Xna.Framework.Color infoTextColor = new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
 			Microsoft.Xna.Framework.Color infoTextShadowColor = Microsoft.Xna.Framework.Color.Black;
+
+			InfoDisplay info = InfoDisplayLoader.InfoDisplays[i];
+
+			if (!InfoDisplayLoader.Active(info) || (player[myPlayer].hideInfo[info.Type] && !playerInventory))
+				continue;
+
+			/*
 			if (player[myPlayer].accWatch > 0 && !flag && (!player[myPlayer].hideInfo[0] || playerInventory)) {
+			*/
+			if (info == InfoDisplay.Watches) {
 				num = 0;
 				text3 = Lang.inter[95].Value;
 				string textValue = Language.GetTextValue("GameUI.TimeAtMorning");
@@ -38111,7 +_,10 @@
 				text2 = num7 + ":" + text4 + " " + textValue;
 				flag = true;
 			}
+			/*
 			else if (player[myPlayer].accWeatherRadio && !flag5 && (!player[myPlayer].hideInfo[1] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.WeatherRadio) {
 				num = 1;
 				text3 = Lang.inter[96].Value;
 				string text5 = "";
@@ -38132,7 +_,10 @@
 
 				flag5 = true;
 			}
+			/*
 			else if (player[myPlayer].accCalendar && !flag8 && (!player[myPlayer].hideInfo[7] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.Sextant) {
 				num = ((bloodMoon && !dayTime) ? 8 : ((!eclipse || !dayTime) ? 7 : 8));
 				text3 = Lang.inter[102].Value;
 				if (moonPhase == 0)
@@ -38154,7 +_,10 @@
 
 				flag8 = true;
 			}
+			/*
 			else if (player[myPlayer].accFishFinder && !flag4 && (!player[myPlayer].hideInfo[2] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.FishFinder) {
 				bool flag13 = false;
 				num = 2;
 				text3 = Lang.inter[97].Value;
@@ -38175,7 +_,10 @@
 
 				flag4 = true;
 			}
+			/*
 			else if (player[myPlayer].accOreFinder && !flag10 && (!player[myPlayer].hideInfo[10] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.MetalDetector) {
 				num = 10;
 				text3 = Lang.inter[104].Value;
 				if (SceneMetrics.bestOre <= 0) {
@@ -38201,7 +_,10 @@
 
 				flag10 = true;
 			}
+			/*
 			else if (player[myPlayer].accCritterGuide && !flag11 && (!player[myPlayer].hideInfo[11] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.LifeformAnalyzer) {
 				flag11 = true;
 				num = 11;
 				text3 = Lang.inter[105].Value;
@@ -38233,7 +_,10 @@
 					infoTextColor = color;
 				}
 			}
+			/*
 			else if (player[myPlayer].accThirdEye && !flag6 && (!player[myPlayer].hideInfo[5] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.Radar) {
 				flag6 = true;
 				num = 5;
 				text3 = Lang.inter[100].Value;
@@ -38258,7 +_,10 @@
 					infoTextColor = color;
 				}
 			}
+			/*
 			else if (player[myPlayer].accJarOfSouls && !flag7 && (!player[myPlayer].hideInfo[6] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.TallyCounter) {
 				flag7 = true;
 				num = 6;
 				text3 = Lang.inter[101].Value;
@@ -38271,7 +_,10 @@
 					text2 = Lang.GetNPCNameValue(Item.BannerToNPC(lastCreatureHit)) + ": " + NPC.killCount[lastCreatureHit];
 				}
 			}
+			/*
 			else if (player[myPlayer].accDreamCatcher && !flag12 && (!player[myPlayer].hideInfo[12] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.DPSMeter) {
 				num = 12;
 				text3 = Lang.inter[106].Value;
 				player[myPlayer].checkDPSTime();
@@ -38285,7 +_,10 @@
 					text2 = Language.GetTextValue("GameUI.DPS", player[myPlayer].getDPS());
 				}
 			}
+			/*
 			else if (player[myPlayer].accStopwatch && !flag9 && (!player[myPlayer].hideInfo[9] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.Stopwatch) {
 				num = 9;
 				text3 = Lang.inter[103].Value;
 				Vector2 vector = player[myPlayer].velocity + player[myPlayer].instantMovementAccumulatedThisFrame;
@@ -38323,14 +_,20 @@
 				text2 = Language.GetTextValue("GameUI.Speed", Math.Round(num20));
 				flag9 = true;
 			}
+			/*
 			else if (player[myPlayer].accCompass > 0 && !flag3 && (!player[myPlayer].hideInfo[3] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.Compass) {
 				num = 3;
 				text3 = Lang.inter[98].Value;
 				int num21 = (int)((player[myPlayer].position.X + (float)(player[myPlayer].width / 2)) * 2f / 16f - (float)maxTilesX);
 				text2 = ((num21 > 0) ? Language.GetTextValue("GameUI.CompassEast", num21) : ((num21 >= 0) ? Language.GetTextValue("GameUI.CompassCenter") : Language.GetTextValue("GameUI.CompassWest", -num21)));
 				flag3 = true;
 			}
+			/*
 			else if (player[myPlayer].accDepthMeter > 0 && !flag2 && (!player[myPlayer].hideInfo[4] || playerInventory)) {
+			*/
+			else if (info == InfoDisplay.DepthMeter) {
 				num = 4;
 				text3 = Lang.inter[99].Value;
 				int num22 = (int)((double)((player[myPlayer].position.Y + (float)player[myPlayer].height) * 2f / 16f) - worldSurface * 2.0);
@@ -38346,27 +_,49 @@
 				text2 = text7 + " " + text6;
 				flag2 = true;
 			}
+			else {
+				num = info.Type;
+				text2 = info.DisplayValue(ref infoTextColor, ref infoTextShadowColor);
+				text3 = info.DisplayName.ToString();
+			}
+
+			InfoDisplayLoader.ModifyDisplayValue(info, ref text2);
+			InfoDisplayLoader.ModifyDisplayName(info, ref text3);
+			InfoDisplayLoader.ModifyDisplayColor(info, ref infoTextColor, ref infoTextShadowColor);
+			InfoDisplayLoader.ModifyDisplayParameters(info, ref text2, ref text3, ref infoTextColor, ref infoTextShadowColor);
 
 			if (!(text2 != ""))
 				continue;
 
+			// An alias to not get lost.
+			ref int drawnCount = ref num3;
+
 			GetInfoAccIconPosition(num3, startX, out var X, out var Y);
 			if (num >= 0) {
+				// Moved to end (drawnCount++)
+				/*
 				num3++;
+				*/
 				int num26 = 22;
 				if (screenHeight < 650)
 					num26 = 20;
 
+				/*
 				Vector2 vector2 = new Vector2(X, Y + 74 + num26 * i + 52);
 				int num27 = num;
 				if (num27 == 8)
 					num27 = 7;
+				*/
+				Vector2 vector2 = new Vector2(X, Y + 74 + num26 * num3 + 52);
+				int num27 = info.Type;
+				Texture2D icon = ModContent.Request<Texture2D>(info.Texture).Value;
+				Texture2D iconHover = ModContent.Request<Texture2D>(info.HoverTexture).Value;
 
 				Microsoft.Xna.Framework.Color color2 = Microsoft.Xna.Framework.Color.White;
 				bool flag14 = false;
 				if (playerInventory) {
 					vector2 = new Vector2(X, Y);
-					if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)TextureAssets.InfoIcon[num].Width() && (float)mouseY <= vector2.Y + (float)TextureAssets.InfoIcon[num].Height() && !PlayerInput.IgnoreMouseInterface) {
+					if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)icon.Width && (float)mouseY <= vector2.Y + (float)icon.Height && !PlayerInput.IgnoreMouseInterface) {
 						flag14 = true;
 						player[myPlayer].mouseInterface = true;
 						if (mouseLeft && mouseLeftRelease) {
@@ -38384,23 +_,32 @@
 					if (player[myPlayer].hideInfo[num27])
 						color2 = new Microsoft.Xna.Framework.Color(80, 80, 80, 70);
 				}
-				else if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)TextureAssets.InfoIcon[num].Width() && (float)mouseY <= vector2.Y + (float)TextureAssets.InfoIcon[num].Height() && !mouseText) {
-					num2 = i;
+				else if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)icon.Width && (float)mouseY <= vector2.Y + (float)icon.Height && !mouseText) {
+					//TML: 'i' replaced with 'drawnCount'.
+					num2 = drawnCount;
 					text = text3;
 					mouseText = true;
 				}
 
+				/*
 				UILinkPointNavigator.SetPosition(1558 + num3 - 1, vector2 + TextureAssets.InfoIcon[num].Value.Size() * 0.75f);
 				spriteBatch.Draw(TextureAssets.InfoIcon[num].Value, vector2, new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.InfoIcon[num].Width(), TextureAssets.InfoIcon[num].Height()), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+				*/
+				if (drawnCount <= InfoDisplayLoader.DefaultDisplayCount) // This check is a quick fix until someone works on controller support
+					UILinkPointNavigator.SetPosition(1558 + drawnCount - 1, vector2 + icon.Size() * 0.75f);
+
+				spriteBatch.Draw(icon, vector2, new Microsoft.Xna.Framework.Rectangle(0, 0, icon.Width, icon.Height), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
 				if (flag14)
-					spriteBatch.Draw(TextureAssets.InfoIcon[13].Value, vector2 - Vector2.One * 2f, null, OurFavoriteColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+					spriteBatch.Draw(iconHover, vector2 - Vector2.One * 2f, null, OurFavoriteColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 
 				X += 20;
 			}
 
 			UILinkPointNavigator.Shortcuts.INFOACCCOUNT = num3;
+
 			if (playerInventory)
-				continue;
+				goto endThisIcon; //continue;
 
 			Vector2 scale = new Vector2(1f);
 			Vector2 vector3 = FontAssets.MouseText.Value.MeasureString(text2);
@@ -38429,15 +_,20 @@
 				if (n == 4)
 					color3 = infoTextColor;
 
+				//TML: 'i' replaced with 'drawnCount'.
-				if (i > num2 && i < num2 + 2)
+				if (drawnCount > num2 && drawnCount < num2 + 2)
 					color3 = new Microsoft.Xna.Framework.Color((int)color3.R / 3, (int)color3.G / 3, (int)color3.B / 3, (int)color3.A / 3);
 
 				int num30 = 22;
 				if (screenHeight < 650)
 					num30 = 20;
 
+				//TML: 'i' replaced with 'drawnCount'.
-				spriteBatch.DrawString(FontAssets.MouseText.Value, text2, new Vector2(X + num28, Y + 74 + num30 * i + num29 + 48), color3, 0f, default(Vector2), scale, SpriteEffects.None, 0f);
+				spriteBatch.DrawString(FontAssets.MouseText.Value, text2, new Vector2(X + num28, Y + 74 + num30 * drawnCount + num29 + 48), color3, 0f, default(Vector2), scale, SpriteEffects.None, 0f);
 			}
+
+			endThisIcon:
+			drawnCount++; // Moved here due to calculation changes
 		}
 
 		if (!string.IsNullOrEmpty(text)) {
@@ -38471,8 +_,12 @@
 				Y += 261;
 		}
 		else if (ShouldDrawInfoIconsHorizontally) {
+			/*
 			X = screenWidth - 280 + 20 * drawnCount - 10;
 			Y = 94;
+			*/
+			X = screenWidth - 280 + 20 * (drawnCount % 12) - 10;
+			Y = 94 + (20 * (drawnCount / 12));
 			if (mapStyle == 1 && mapEnabled)
 				Y += 261;
 		}
@@ -38513,6 +_,7 @@
 		if (false || Main.player[myPlayer].sign >= 0)
 			return;
 
+		/*
 		int num = 0;
 		Player player = Main.player[myPlayer];
 		int[] builderAccStatus = Main.player[myPlayer].builderAccStatus;
@@ -38700,6 +_,8 @@
 		}
 
 		UILinkPointNavigator.Shortcuts.BUILDERACCCOUNT = num;
+		*/
+		DrawBuilderAccToggles_Inner(start);
 	}
 
 	private static void GetBuilderAccsCountToShow(Player plr, out int blockReplaceIcons, out int torchGodIcons, out int totalDrawnIcons)
@@ -39089,6 +_,11 @@
 	private static void TryDisposingEverything()
 	{
 		ChromaInitializer.DisableAllDeviceGroups();
+
+		// Added by TML.
+		SteamedWraps.OnGameExitCleanup();
+		TerrariaSteamClient.Shutdown();
+
 		CaptureManager.Instance.Dispose();
 		audioSystem.Dispose();
 	}
@@ -39408,8 +_,11 @@
 		screenLastPosition = screenPosition;
 		screenPosition.Y = (float)(worldSurface * 16.0 - (double)screenHeight);
 		MenuXMovement = 4f;
-		if (alreadyGrabbingSunOrMoon) {
+		if (alreadyGrabbingSunOrMoon && !playOldTile && MenuLoader.CurrentMenu == MenuLoader.MenuJourneysEnd) { // Added && !playOldTile. Added check for MenuJourneysEnd to limit easter egg to only the vanilla logo/menu
 			playOldTile = true;
+
+			MenuLoader.ActivateOldVanillaMenu();
+
 			if (starGame)
 				playOldTile = false;
 		}
@@ -39497,13 +_,18 @@
 				logoScaleSpeed -= 1f;
 		}
 
+		MenuLoader.UpdateAndDrawModMenu(spriteBatch, gameTime, color, logoRotation, logoScale);
+
 		Microsoft.Xna.Framework.Color color2 = new Microsoft.Xna.Framework.Color((byte)((float)(int)color.R * ((float)LogoA / 255f)), (byte)((float)(int)color.G * ((float)LogoA / 255f)), (byte)((float)(int)color.B * ((float)LogoA / 255f)), (byte)((float)(int)color.A * ((float)LogoA / 255f)));
 		Microsoft.Xna.Framework.Color color3 = new Microsoft.Xna.Framework.Color((byte)((float)(int)color.R * ((float)LogoB / 255f)), (byte)((float)(int)color.G * ((float)LogoB / 255f)), (byte)((float)(int)color.B * ((float)LogoB / 255f)), (byte)((float)(int)color.A * ((float)LogoB / 255f)));
+		/*
 		if (playOldTile) {
+		*/
+		if (MenuLoader.MenuOldVanilla.IsSelected) {
 			spriteBatch.Draw(TextureAssets.Logo3.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color2, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 			spriteBatch.Draw(TextureAssets.Logo4.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color3, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 		}
-		else {
+		else if (MenuLoader.MenuJourneysEnd.IsSelected) {
 			spriteBatch.Draw(TextureAssets.Logo.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color2, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 			spriteBatch.Draw(TextureAssets.Logo2.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color3, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 		}
@@ -39558,12 +_,30 @@
 			array7[i] = 1f;
 		}
 
+		// Extra patch context.
 		string[] array9 = new string[maxMenuItems];
 		if (menuMode == -1)
 			menuMode = 0;
 
-		if (Program.LoadedEverything)
+		if (Program.LoadedEverything) {
 			GamepadMainMenuHandler.CanRun = true;
+		}
+		else { // Added by TML
+			array9[0] = string.Format("{0}  {1}", Language.GetTextValue("UI.LoadingCode"), Program.LoadedPercentage.ToString("P0"));
+
+			if (!ModLoader.ModLoader.skipLoad) {
+				array9[1] = "Click to skip loading mods";
+				array7[1] = 0.5f;
+				num5 = 2;
+
+				if (selectedMenu == 1) {
+					ModLoader.ModLoader.skipLoad = true;
+				}
+			}
+
+			// The label should be somewhere after the following if-else chain.
+			goto SkipMenuEnumeration;
+		}
 
 		if (menuMode == 1212) {
 			array9[0] = Lang.menu[102].Value;
@@ -39600,7 +_,12 @@
 			if (selectedMenu >= 1) {
 				changeTheTitle = true;
 				LanguageManager.Instance.SetLanguage(selectedMenu);
+
+				/*
 				menuMode = 0;
+				*/
+				menuMode = Interface.loadModsID;
+
 				SoundEngine.PlaySound(10);
 				SaveSettings();
 			}
@@ -39740,7 +_,10 @@
 				OnSubmitServerPasswordFromRequest();
 			}
 		}
+		/*
 		else if ((netMode == 1 && menuMode != 888) || menuMode == 14) {
+		*/
+		else if (netMode == 1 && menuMode < 10000 && menuMode != 888 || menuMode == 14) {
 			num5 = 2;
 			array9[0] = statusText;
 			array[0] = true;
@@ -39851,6 +_,13 @@
 			array4[4] = 70;
 			array4[5] = 70;
 			num5 = 6;
+			
+			// Add server console toggle" button.
+			int serverConsoleToggleId = num5++;			
+			array4[serverConsoleToggleId] = 70;
+			array9[serverConsoleToggleId] = Language.GetTextValue(showServerConsole ? "tModLoader.MPShowServerConsoleYes" : "tModLoader.MPShowServerConsoleNo");
+			array7[serverConsoleToggleId] = 0.5f;
+
 			array9[0] = Lang.menu[135].Value;
 			array9[4] = Lang.menu[144].Value;
 			array9[5] = Lang.menu[5].Value;
@@ -39911,6 +_,11 @@
 					menuMode = 6;
 					SoundEngine.PlaySound(11);
 					break;
+				// Server console toggle button.
+				case int _ when selectedMenu == serverConsoleToggleId:
+					showServerConsole = !showServerConsole;
+					SoundEngine.PlaySound(12, -1, -1, 1, 1f, 0f);
+					break;
 			}
 		}
 		else if (menuMode == 15) {
@@ -39931,16 +_,27 @@
 		else if (menuMode == 200) {
 			num5 = 3;
 			array9[0] = Lang.menu[9].Value;
+
+			if (WorldIO.customDataFail != null)
+				array9[0] = $"{WorldIO.customDataFail.modName}: {array9[0]}";
+
 			array[0] = true;
 			num2 -= 30;
 			array4[1] = 70;
 			array4[2] = 50;
 			array9[1] = Lang.menu[10].Value;
 			array9[2] = Lang.menu[6].Value;
+
+			if (WorldIO.customDataFail != null)
+				array9[2] = Language.GetTextValue("tModLoader.OpenLogs");
+
 			if (selectedMenu == 1) {
 				if (FileUtilities.Exists(worldPathName + ".bak", ActiveWorldFileData.IsCloudSave)) {
 					FileUtilities.Move(worldPathName, worldPathName + ".bad", ActiveWorldFileData.IsCloudSave);
 					FileUtilities.Move(worldPathName + ".bak", worldPathName, ActiveWorldFileData.IsCloudSave);
+
+					WorldIO.LoadBackup(worldPathName, ActiveWorldFileData.IsCloudSave);
+
 					SoundEngine.PlaySound(10);
 					WorldGen.playWorld();
 					menuMode = 10;
@@ -39955,13 +_,29 @@
 			if (selectedMenu == 2 || flag5) {
 				flag5 = false;
 				SoundEngine.PlaySound(11);
+
+				/*
 				menuMode = 0;
+				*/
+				if (WorldIO.customDataFail == null) {
+					menuMode = 0;
+				}
+				else {
+					Logging.tML.Error(Language.GetTextValue("tModLoader.WorldIODataException"), WorldIO.customDataFail.InnerException);
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenFolder(Logging.LogDir);
+				}
+
 				netMode = 0;
 			}
 		}
 		else if (menuMode == 201) {
 			num5 = 3;
 			array9[0] = Lang.menu[9].Value;
+
+			if (WorldIO.customDataFail != null)
+				array9[0] = WorldIO.customDataFail.modName + ": " + array9[0];
+
 			array[0] = true;
 			array[1] = true;
 			num2 -= 30;
@@ -39969,9 +_,23 @@
 			array4[2] = 50;
 			array9[1] = Lang.menu[11].Value;
 			array9[2] = Lang.menu[5].Value;
+
+			if (WorldIO.customDataFail != null)
+				array9[2] = Language.GetTextValue("tModLoader.OpenLogs");
+
 			if (selectedMenu == 2 || flag5) {
 				flag5 = false;
 				SoundEngine.PlaySound(11);
+
+				if (WorldIO.customDataFail == null) {
+					menuMode = 0;
+				}
+				else {
+					Logging.tML.Error(Language.GetTextValue("tModLoader.WorldIODataException"), WorldIO.customDataFail.InnerException);
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenFolder(Logging.LogDir);
+				}
+
 				menuMode = 0;
 				netMode = 0;
 			}
@@ -40029,7 +_,9 @@
 			}
 
 			num11++;
-			if (SocialAPI.Workshop != null) {
+
+			// The workshop hub itself will no longer be exclusive to Steam versions.
+			if (true || SocialAPI.Workshop != null) {
 				array9[num11] = Language.GetText("UI.Workshop").Value;
 				if (selectedMenu == num11) {
 					SoundEngine.PlaySound(10);
@@ -40048,6 +_,9 @@
 			}
 
 			num11++;
+
+			Interface.AddMenuButtons(this, selectedMenu, array9, array7, ref num2, ref num4, ref num11, ref num5);
+
 			array9[num11] = Lang.menu[14].Value;
 			if (selectedMenu == num11) {
 				SoundEngine.PlaySound(10);
@@ -40676,6 +_,8 @@
 				num2 = 210;
 				num4 = 37;
 				num5 = 8;
+				num5++; // Room for tModLoader settings option.
+
 				array4[num5 - 1] = 8;
 				for (int num19 = 0; num19 < num5; num19++) {
 					array7[num19] = 0.75f;
@@ -40730,6 +_,14 @@
 					menuMode = 1213;
 				}
 
+				// TML settings
+				num20++;
+				array9[num20] = Language.GetTextValue("tModLoader.tModLoaderSettings");
+				if (selectedMenu == num20) {
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					menuMode = Interface.tModLoaderSettingsID;
+				}
+
 				num20++;
 				array9[num20] = Lang.menu[5].Value;
 				if (selectedMenu == num20 || flag5) {
@@ -40809,6 +_,8 @@
 				num2 = 210;
 				num4 = 32;
 				num5 = 10;
+				num5++; // Room for tModLoader BossBarStyle option.
+
 				array4[num5 - 1] = 18;
 				for (int num23 = 0; num23 < num5; num23++) {
 					array7[num23] = 0.7f;
@@ -40872,8 +_,12 @@
 					MinimapFrameManagerInstance.CycleSelection();
 
 				num24++;
+
+				/*
 				string activeSetKeyName = ResourceSetsManager.ActiveSetKeyName;
 				string textValue2 = Language.GetTextValue("UI.HealthManaStyle_" + activeSetKeyName);
+				*/
+				string textValue2 = ResourceSetsManager.ActiveSet.DisplayedName;
 				array9[num24] = Language.GetTextValue("UI.SelectHealthStyle", textValue2);
 				if (selectedMenu == num24)
 					ResourceSetsManager.CycleResourceSet();
@@ -40883,6 +_,12 @@
 				if (selectedMenu == num24)
 					BigProgressBarSystem.ToggleShowText();
 
+				// BossBarStyle option
+				num24++;
+				array9[num24] = BossBarLoader.InsertMenu(out Action onClick);
+				if (selectedMenu == num24)
+					onClick();
+
 				num24++;
 				array9[num24] = Lang.menu[5].Value;
 				if (selectedMenu == num24 || flag5) {
@@ -41051,19 +_,32 @@
 				num4 = 55;
 				int num30 = 0;
 				array9[num30] = Lang.menu[73].Value + ": " + PendingResolutionWidth + "x" + PendingResolutionHeight;
-				if (selectedMenu == num30) {
+				if (selectedMenu == num30 || selectedMenu2 == num30) { // Add '|| selectedMenu2 == num30' to allow back-cycling with right click
 					SoundEngine.PlaySound(12);
 					int num31 = 0;
 					for (int num32 = 0; num32 < numDisplayModes; num32++) {
+						// See BorderedHeight patch below
+						/*
 						if (displayWidth[num32] == PendingResolutionWidth && displayHeight[num32] == PendingResolutionHeight) {
+						*/
+						if (displayWidth[num32] == PendingResolutionWidth && BorderedHeight(displayHeight[num32], graphics.IsFullScreen) == PendingResolutionHeight) {
 							num31 = num32;
 							break;
 						}
 					}
 
+					// Add back-cycling with right click
+					/*
 					num31 = (num31 + 1) % numDisplayModes;
+					*/
+					num31 = Utils.Repeat(num31 + ((selectedMenu == num30) ? 1 : -1), Main.numDisplayModes);
 					PendingResolutionWidth = displayWidth[num31];
+
+					// Limit the resolution when going from fullscreen to windowed to be less than the full monitor size so that the key window edges are accessible
+					/*
 					PendingResolutionHeight = displayHeight[num31];
+					*/
+					PendingResolutionHeight = BorderedHeight(displayHeight[num31], graphics.IsFullScreen);
 				}
 
 				num30++;
@@ -41829,7 +_,11 @@
 					}
 				}
 			}
+			else {
+				Interface.ModLoaderMenus(this, selectedMenu, array9, array7, array4, ref num2, ref num4, ref num5, ref flag5);
+			}
 		}
+		SkipMenuEnumeration:
 
 		if (menuMode == 888) {
 			if (!_blockFancyUIWhileLoading)
@@ -42539,6 +_,8 @@
 		if (!WorldGen.drunkWorldGen && menuMode == 0) {
 			DrawSocialMediaButtons(color, num110);
 			num110 += 32f;
+
+			DrawtModLoaderSocialMediaButtons(color, num110);
 		}
 
 		if (!WorldGen.drunkWorldGen) {
@@ -42576,6 +_,22 @@
 		else
 			mouseRightRelease = true;
 
+		// Handle the extra mouse buttons added by TML.
+		if (mouseMiddle)
+			mouseMiddleRelease = false;
+		else
+			mouseMiddleRelease = true;
+
+		if (mouseXButton1)
+			mouseXButton1Release = false;
+		else
+			mouseXButton1Release = true;
+
+		if (mouseXButton2)
+			mouseXButton2Release = false;
+		else
+			mouseXButton2Release = true;
+
 		if (menuMode == num)
 			GamepadMainMenuHandler.LastDrew = num;
 	}
@@ -42624,7 +_,15 @@
 
 		text = ((!ActiveWorldFileData.IsCloudSave) ? (text + SanitizePathArgument("world", worldPathName)) : (text + SanitizePathArgument("cloudworld", worldPathName)));
 		text = text + " -worldrollbackstokeep " + WorldRollingBackupsCountToKeep;
+
+		// TML options
+		text += $@" -modpath ""{ModOrganizer.modPath}""";
+		if (showServerConsole)
+			text += " -showserverconsole";
+
 		tServer = new Process();
+
+		/*
 		if (Platform.IsLinux)
 			tServer.StartInfo.FileName = "TerrariaServer";
 		else if (Platform.IsOSX)
@@ -42633,13 +_,22 @@
 			tServer.StartInfo.FileName = "TerrariaServer.exe";
 
 		tServer.StartInfo.Arguments = text;
+		*/
+		tServer.StartInfo.FileName = Environment.ProcessPath;
+		tServer.StartInfo.Arguments = "tModLoader.dll -server " + text;
 		if (libPath != "") {
 			ProcessStartInfo startInfo = tServer.StartInfo;
 			startInfo.Arguments = startInfo.Arguments + " -loadlib " + libPath;
 		}
 
+		/*
 		tServer.StartInfo.UseShellExecute = false;
 		tServer.StartInfo.CreateNoWindow = true;
+		*/
+		tServer.StartInfo.UseShellExecute = true;
+		if (!showServerConsole)
+			tServer.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
+
 		if (SocialAPI.Network != null)
 			SocialAPI.Network.LaunchLocalServer(tServer, MenuServerMode);
 		else
@@ -42703,7 +_,22 @@
 
 	private static void DrawVersionNumber(Microsoft.Xna.Framework.Color menuColor, float upBump)
 	{
+		string supportMessage = Language.GetTextValue("tModLoader.PatreonSupport");
+		string patreonShortURL = @"patreon.com/tModLoader";
+		bool showPatreon = SocialAPI.Mode != SocialMode.Steam;
+
+		// Show number of mods - 1 such as to show number of enabled mods that are not tModLoader itself
+		string modsMessage = Language.GetTextValue("tModLoader.MenuModsEnabled", Math.Max(0, ModLoader.ModLoader.Mods.Length - 1));
+		
+		//TODO: FUTURE
+		//if (ModLoader.Core.GOGModUpdateChecker.ModUpdatesAvailable > 0) {
+		//	modsMessage += " " + Language.GetTextValue("tModLoader.MenuModUpdatesAvailable", ModLoader.Core.GOGModUpdateChecker.ModUpdatesAvailable);
+		//}
+
+		/*
 		string text = versionNumber;
+		*/
+		string text = ModLoader.ModLoader.versionedName + (showPatreon ? Environment.NewLine + supportMessage : "") + (menuMode == 0 ? Environment.NewLine : "") + Environment.NewLine + "Terraria " + versionNumber;
 		Vector2 origin = FontAssets.MouseText.Value.MeasureString(text);
 		origin.X *= 0.5f;
 		origin.Y *= 0.5f;
@@ -42732,7 +_,59 @@
 				num2 = 2;
 
 			spriteBatch.DrawString(FontAssets.MouseText.Value, text, new Vector2(origin.X + (float)num + 10f, (float)screenHeight - origin.Y + (float)num2 - 2f - upBump), color, 0f, origin, 1f, SpriteEffects.None, 0f);
+
+			// Developer mode button.
+			if (menuMode == 0 /*&& !ModCompile.DeveloperMode*/) {
+				string developerModeText = Language.GetTextValue("tModLoader.SwitchVersionInfoButton");
+
+				// measure and draw text from bottom right
+				var textSize = FontAssets.MouseText.Value.MeasureString(developerModeText);
+				var pos = new Vector2(screenWidth - 10f + num, screenHeight - 2f + num2);
+				var d_color = color;
+
+				float scale = 1.2f;
+
+				// final draw
+				if (i == 4) {
+					var rect = new Rectangle((int)(pos.X - textSize.X * scale), (int)(pos.Y - textSize.Y * scale), (int)(textSize.X * scale), (int)(textSize.Y * scale));
+					bool mouseover = rect.Contains(mouseX, mouseY);
+					d_color = mouseover ? highVersionColor : d_color;
+
+					if (mouseover && mouseLeftRelease && mouseLeft) {
+						SoundEngine.PlaySound(SoundID.MenuOpen);
+						Utils.OpenToURL("https://github.com/tModLoader/tModLoader/wiki/tModLoader-guide-for-players#beta-branches");
+					}
+				}
+
+				spriteBatch.DrawString(FontAssets.MouseText.Value, developerModeText, pos, d_color, 0f, textSize, 1.2f, SpriteEffects.None, 0f);
+			}
+
+			// TML Patreon.
+			if (showPatreon) {
+				var font = FontAssets.MouseText.Value;
+				var patreonOrigin = font.MeasureString(supportMessage);
+				Vector2 urlSize = font.MeasureString(patreonShortURL);
+
+				spriteBatch.DrawString(font, patreonShortURL, new Vector2(patreonOrigin.X + num + 10f, screenHeight - patreonOrigin.Y + num2 - 2f - (int)upBump), color, 0f, Vector2.Zero, 1f, SpriteEffects.None, 0f);
+
+				if (i == 4 && mouseLeftRelease && mouseLeft && new Microsoft.Xna.Framework.Rectangle((int)patreonOrigin.X + 10, screenHeight - (int)urlSize.Y - 2 - (int)upBump, (int)urlSize.X, (int)patreonOrigin.Y).Contains(new Microsoft.Xna.Framework.Point(mouseX, mouseY)) && hasFocus) {
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenToURL("https://www.patreon.com/tModLoader");
+				}
+			}
+
+			// ModPack
+			if (ModOrganizer.ModPackActive != null) {
+				var font = FontAssets.MouseText.Value;
+				string modpackText = Language.GetTextValue("tModLoader.CurrentModPack", Path.GetFileNameWithoutExtension(ModOrganizer.ModPackActive));
+				var packOrigin = font.MeasureString(modpackText);
+
+				spriteBatch.DrawString(font, modpackText, new Vector2(packOrigin.X + num + 10f, screenHeight - packOrigin.Y + num2 - 2f - (int)upBump), color, 0f, Vector2.Zero, 1f, SpriteEffects.None, 0f);
+			}
 		}
+
+		// End of DrawVersionNumber
+		HandleNews(menuColor);
 	}
 
 	private static void ClearVisualPostProcessEffects()
@@ -42830,6 +_,10 @@
 		CreditsRollEvent.Reset();
 		maxRaining = 0f;
 		raining = false;
+
+		//Added by tML.
+		Graphics.Effects.Filters.Scene.DeactivateAll();
+		SkyManager.Instance.DeactivateAll();
 	}
 
 	private static void PostDrawMenu(Microsoft.Xna.Framework.Point screenSizeCache, Microsoft.Xna.Framework.Point screenSizeCacheAfterScaling)
@@ -43330,9 +_,17 @@
 		float value = (float)((double)(screenPosition.Y - (float)(screenHeight / 2) + 200f) - rockLayer * 16.0) / 300f;
 		value = MathHelper.Clamp(value, 0f, 1f);
 		int num8 = (int)((screenPosition.X + (float)(screenWidth / 2)) / 16f);
+
+		LoaderManager.Get<UndergroundBackgroundStylesLoader>().ChooseStyle(out var modBG, out var priority);
+
 		int num9 = 3;
 		num9 = ((num8 <= caveBackX[0]) ? caveBackStyle[0] : ((num8 <= caveBackX[1]) ? caveBackStyle[1] : ((num8 > caveBackX[2]) ? caveBackStyle[3] : caveBackStyle[2])));
 		num9 += 3;
+
+		if (priority == SceneEffectPriority.BiomeLow) {
+			num9 = modBG;
+		}
+
 		if (SceneMetrics.SnowTileCount > SceneMetrics.SnowTileThreshold && (screenPosition.Y + (float)screenHeight + 1200f) / 16f < (float)(maxTilesY - 250))
 			num9 = 1;
 
@@ -43346,6 +_,10 @@
 			}
 		}
 
+		if (priority == SceneEffectPriority.BiomeMedium) {
+			num9 = modBG;
+		}
+
 		if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenHeight / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			num9 = (player[myPlayer].ZoneCorrupt ? 19 : (player[myPlayer].ZoneCrimson ? 21 : ((!player[myPlayer].ZoneHallow) ? 18 : 20)));
 		}
@@ -43372,6 +_,16 @@
 		if (player[myPlayer].ZoneGlowshroom)
 			num9 = 2;
 
+		if (priority >= SceneEffectPriority.BiomeHigh) {
+			num9 = modBG;
+		}
+
+		if (GlobalBackgroundStyleLoader.loaded) {
+			foreach (var hook in GlobalBackgroundStyleLoader.HookChooseUndergroundBackgroundStyle) {
+				hook(ref num9);
+			}
+		}
+
 		if (num9 != undergroundBackground) {
 			oldUndergroundBackground = undergroundBackground;
 			undergroundBackground = num9;
@@ -43390,6 +_,7 @@
 		int[] array = new int[7];
 		int[] array2 = new int[7];
 		for (int i = 0; i < 2; i++) {
+			// patch context, num10 below
 			int num10 = undergroundBackground;
 			if (i == 1)
 				num10 = oldUndergroundBackground;
@@ -43580,6 +_,9 @@
 				array3[5] = 127;
 
 			array3[6] = 185 + hellBackStyle;
+
+			LoaderManager.Get<UndergroundBackgroundStylesLoader>().FillTextureArray(num10, array3);
+
 			LoadBackground(array3[0]);
 			LoadBackground(array3[1]);
 			LoadBackground(array3[2]);
@@ -43698,7 +_,7 @@
 									Lighting.GetCornerColors(num24, num25, out var vertices);
 									vertices.BottomLeftColor = new Microsoft.Xna.Framework.Color(vertices.BottomLeftColor.ToVector3() * vector2);
 									vertices.BottomRightColor = new Microsoft.Xna.Framework.Color(vertices.BottomRightColor.ToVector3() * vector2);
-									tileBatch.Draw(TextureAssets.Background[array[1]].Value, new Vector2(bgStartX + num6 * num19 + 16 * num21 + num18, bgStartY + backgroundHeight[array2[1]] * num20 + 16 * num22) + vector, new Microsoft.Xna.Framework.Rectangle(16 * num21 + num18 + 16, 16 * num22, 16, 16), vertices, Vector2.Zero, 1f, SpriteEffects.None);
+									tileBatch.Draw(TextureAssets.Background[array[1]].Value, new Vector2(bgStartX + num6 * num19 + 16 * num21 + num18, bgStartY + backgroundHeight[array[1]] * num20 + 16 * num22) + vector, new Microsoft.Xna.Framework.Rectangle(16 * num21 + num18 + 16, 16 * num22, 16, 16), vertices, Vector2.Zero, 1f, SpriteEffects.None);
 								}
 								else if ((color4.R > num4 || (double)(int)color4.G > (double)num4 * 1.1 || (double)(int)color4.B > (double)num4 * 1.2) && !tile[num24, num25].active() && WallLightAt(num24, num25) && ugBackTransition == 0f) {
 									Lighting.GetColor9Slice(num24, num25, ref slices);
@@ -45726,6 +_,7 @@
 			num25 *= num5;
 			num = 0f - num24 + (float)(screenWidth / 2);
 			num2 = 0f - num25 + (float)(screenHeight / 2);
+			// Patch note: 'num', 'num2', are used below.
 			num += num7 * num5;
 			num2 += num8 * num5;
 			float num26 = maxTilesX / 840;
@@ -45781,8 +_,30 @@
 			spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp, DepthStencilState.None, RasterizerState.CullCounterClockwise);
 			flag = true;
 			DrawMapFullscreenBackground(screenPosition, screenWidth, screenHeight);
+
+			//TML: Map texture drawing replaced by an adaptive drawing below, as mod worlds sometimes aren't regular sizes.
+			/*
 			Microsoft.Xna.Framework.Rectangle destinationRectangle = new Microsoft.Xna.Framework.Rectangle((int)num27, (int)num28, (int)num29, (int)num30);
 			spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, Microsoft.Xna.Framework.Color.White);
+			*/
+			{
+				int x = (int)(num + mapFullscreenScale * 10);
+				int y = (int)(num2 + mapFullscreenScale * 10);
+				int width = (int)((maxTilesX - 40) * mapFullscreenScale);
+				int height = (int)((maxTilesY - 40) * mapFullscreenScale);
+				var destinationRectangle = new Rectangle(x, y, width, height);
+				spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(40, 4, 848, 240), Color.White);
+
+				int edgeWidth = (int)(40 * mapFullscreenScale * 5);
+				int edgeHeight = (int)(4 * mapFullscreenScale * 5);
+
+				destinationRectangle = new Rectangle(x - edgeWidth, y - edgeHeight, edgeWidth, height + 2 * edgeHeight);
+				spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(0, 0, 40, 248), Color.White);
+
+				destinationRectangle = new Rectangle(x + width, y - edgeHeight, edgeWidth, height + 2 * edgeHeight);
+				spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(888, 0, 40, 248), Color.White);
+			}
+
 			if (mouseLeft && mouseLeftRelease) {
 				double totalSeconds = gameTime.TotalGameTime.TotalSeconds;
 				if (totalSeconds - _lastPingMouseDownTime < 0.5 && Vector2.Distance(MouseScreen, _lastPingMousePosition) < 2f)
@@ -45894,7 +_,11 @@
 		float num40 = (float)textureMaxHeight * num5;
 		float num41 = num;
 		float num42 = 0f;
+
+		/*
 		for (int k = 0; k <= 4; k++) {
+		*/
+		for (int k = 0; k <= mapTargetX - 1; k++) {
 			if (!((float)((k + 1) * textureMaxWidth) > num7) || !((float)(k * textureMaxWidth) < num7 + num9))
 				continue;
 
@@ -46281,6 +_,7 @@
 					}
 				}
 				else if (type >= num97 && type < num97 + num98) {
+					// Patch note: 'num89' and 'num90' are used below.
 					Tile tile5 = Main.tile[num89, num90];
 					if (tile5 != null) {
 						int num107 = num90;
@@ -46293,7 +_,11 @@
 					}
 				}
 				else {
+					/*
 					text = Lang.GetMapObjectName(type);
+					*/
+					text = Lang._mapLegendCache.FromTile(Map[num89, num90], num89, num90);
+					// Patch note: 'text' is also used in a patch below.
 				}
 			}
 
@@ -46458,6 +_,9 @@
 			}
 
 			spriteBatch.Draw(TextureAssets.MapIcon[num135].Value, new Vector2(num133, num134), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.MapIcon[num135].Width(), TextureAssets.MapIcon[num135].Height()), new Microsoft.Xna.Framework.Color(num136, num136, num136, num136), 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
+			SystemLoader.PostDrawFullscreenMap(ref text);
+
 			DrawCursor(DrawThickCursor());
 		}
 
@@ -46491,6 +_,11 @@
 
 	private static void DrawMapFullscreenBackground(Vector2 screenPosition, int screenWidth, int screenHeight)
 	{
+		if (ModContent.RequestIfExists<Texture2D>(LocalPlayer.CurrentSceneEffect.mapBackground, out var modTexture, AssetRequestMode.ImmediateLoad)) {
+			spriteBatch.Draw(modTexture.Value, new Microsoft.Xna.Framework.Rectangle(0, 0, screenWidth, screenHeight), Microsoft.Xna.Framework.Color.White);
+			return;
+		}
+
 		Asset<Texture2D> asset = TextureAssets.MapBGs[0];
 		int num = -1;
 		Microsoft.Xna.Framework.Color color = Microsoft.Xna.Framework.Color.White;
@@ -47244,6 +_,12 @@
 			case 4:
 				return 13;
 			default:
+				LoaderManager.Get<WaterStylesLoader>().ChooseStyle(out var waterStyle, out var priority);
+
+				if (priority >= SceneEffectPriority.BiomeLow) {
+					return waterStyle;
+				}
+
 				if (remixWorld) {
 					if ((double)(screenPosition.Y / 16f) > rockLayer)
 						return 7;
@@ -47271,6 +_,10 @@
 		if (liquidStyle != 1)
 			return liquidStyle != 11;
 
+		// Currently all modded liquid styles come from WaterStylesLoader
+		if (liquidStyle >= maxLiquidTypes)			
+			return true;
+
 		return false;
 	}
 
@@ -47281,12 +_,15 @@
 			waterStyle = CalculateWaterStyle();
 			for (int i = 0; i < 15; i++) {
 				if (IsLiquidStyleWater(waterStyle)) {
+					// Extra patch context.
 					if (waterStyle != i)
 						liquidAlpha[i] = Math.Max(liquidAlpha[i] - 0.2f, 0f);
 					else
 						liquidAlpha[i] = Math.Min(liquidAlpha[i] + 0.2f, 1f);
 				}
 			}
+
+			LoaderManager.Get<WaterStylesLoader>().UpdateLiquidAlphas();
 		}
 
 		if (!drawToScreen && !isBackground) {
@@ -47304,7 +_,7 @@
 		}
 
 		bool flag = false;
-		for (int j = 0; j < 15; j++) {
+		for (int j = 0; j < LoaderManager.Get<WaterStylesLoader>().TotalCount; j++) {
 			if (IsLiquidStyleWater(j) && liquidAlpha[j] > 0f && j != waterStyle) {
 				DrawLiquid(isBackground, j, isBackground ? 1f : liquidAlpha[j], drawSinglePassLiquids: false);
 				flag = true;
@@ -47314,7 +_,7 @@
 		DrawLiquid(isBackground, waterStyle, flag ? liquidAlpha[waterStyle] : 1f);
 	}
 
-	protected void DrawLiquid(bool bg = false, int waterStyle = 0, float Alpha = 1f, bool drawSinglePassLiquids = true)
+	protected internal void DrawLiquid(bool bg = false, int waterStyle = 0, float Alpha = 1f, bool drawSinglePassLiquids = true)
 	{
 		if (!Lighting.NotRetro) {
 			oldDrawWater(bg, waterStyle, Alpha);
@@ -48974,12 +_,12 @@
 		if (!WorldGen.drunkWorldGen && flag && (double)(screenPosition.Y / 16f) <= worldSurface + 10.0) {
 			if (BackgroundEnabled) {
 				if (cloudBGActive > 0f) {
-					cloudBGAlpha += 0.0005f * (float)dayRate;
+					cloudBGAlpha += 0.0005f * (float)desiredWorldEventsUpdateRate;
 					if (cloudBGAlpha > 1f)
 						cloudBGAlpha = 1f;
 				}
 				else {
-					cloudBGAlpha -= 0.0005f * (float)dayRate;
+					cloudBGAlpha -= 0.0005f * (float)desiredWorldEventsUpdateRate;
 					if (cloudBGAlpha < 0f)
 						cloudBGAlpha = 0f;
 				}
@@ -48994,7 +_,7 @@
 					bgScale = 1.65f;
 					bgParallax = 0.09000000357627869;
 					if (base.IsActive && !gamePaused)
-						cloudBGX[0] += windSpeedCurrent * (float)bgParallax * 9f * (float)dayRate;
+						cloudBGX[0] += windSpeedCurrent * (float)bgParallax * 9f * (float)desiredWorldEventsUpdateRate;
 
 					if (cloudBGX[0] > (float)backgroundWidth[cloudBG[0]] * bgScale)
 						cloudBGX[0] -= (float)backgroundWidth[cloudBG[0]] * bgScale;
@@ -49024,7 +_,7 @@
 					bgScale = 1.85f;
 					bgParallax = 0.12;
 					if (base.IsActive && !gamePaused)
-						cloudBGX[1] += windSpeedCurrent * (float)bgParallax * 9f * (float)dayRate;
+						cloudBGX[1] += windSpeedCurrent * (float)bgParallax * 9f * (float)desiredWorldEventsUpdateRate;
 
 					if (cloudBGX[1] > (float)backgroundWidth[cloudBG[1]] * bgScale)
 						cloudBGX[1] -= (float)backgroundWidth[cloudBG[1]] * bgScale;
@@ -49231,10 +_,15 @@
 						DrawSurfaceBG_Mushroom(num4, num5, num6, bgTexIndexes7);
 						DrawSurfaceBG_DrawChangeOverlay(11);
 					}
+
+					if (num21 >= BG_STYLES_COUNT) {
+						LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawCloseBackground(num21);
+					}
 				}
 			}
 		}
 
+		// Extra patch context.
 		if (flag2)
 			num6 -= num11;
 
@@ -49393,11 +_,14 @@
 				DrawSurfaceBG_DrawBackMountainsLayer(24);
 		}
 
+		// Extra patch context.
 		if (bgAlphaFarBackLayer[6] > 0f && WorldGen.hallowBG == 3) {
 			ColorOfSurfaceBackgroundsModified = colorOfSurfaceBackgroundsBase * bgAlphaFarBackLayer[6];
 			DrawSurfaceBG_DrawBackMountainsLayer(246);
 		}
 
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawFarTexture();
+
 		SkyManager.Instance.DrawToDepth(spriteBatch, 5f);
 	}
 
@@ -49464,11 +_,14 @@
 				DrawSurfaceBG_DrawBackMountainsLayer(treeMntBGSet3[1]);
 		}
 
+		// Extra patch context.
 		if (bgAlphaFarBackLayer[12] > 0f) {
 			ColorOfSurfaceBackgroundsModified = colorOfSurfaceBackgroundsBase * bgAlphaFarBackLayer[12];
 			if (treeMntBGSet4[1] > -1)
 				DrawSurfaceBG_DrawBackMountainsLayer(treeMntBGSet4[1]);
 		}
+
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawMiddleTexture();
 	}
 
 	private void UpdateOceanWaterLineForAmbience()
@@ -50677,7 +_,7 @@
 
 			bool flag3 = false;
 			bool flag4 = false;
-			if (tile[x, y].type == 10) {
+			if (TileLoader.IsClosedDoor(tile[x, y])) {
 				flag3 = false;
 			}
 			else if (tileSolid[tile[x, y].type] && !tileSolidTop[tile[x, y].type]) {
@@ -50755,6 +_,17 @@
 
 	protected override void Draw(GameTime gameTime)
 	{
+		try {
+			Draw_Inner(gameTime);
+		}
+		catch (Exception e) {
+			Logging.Terraria.Error(e);
+			throw;
+		}
+	}
+
+	private void Draw_Inner(GameTime gameTime)
+	{
 		if (!_isDrawingOrUpdating && IsGraphicsDeviceAvailable) {
 			_isDrawingOrUpdating = true;
 			EnsureRenderTargetContent();
@@ -50763,6 +_,9 @@
 				Main.OnPostDraw(gameTime);
 
 			Assets.TransferCompletedAssets();
+
+			ModContent.TransferCompletedAssets();
+
 			_isDrawingOrUpdating = false;
 		}
 	}
@@ -50898,19 +_,22 @@
 				renderCount = 99;
 			}
 			else {
+				//TML: RenderTiles() is quite slow. ~30ms at peak; doesn't change with lighting modes
 				if (renderCount == 3) {
 					RenderTiles();
 					sceneTilePos.X = screenPosition.X - (float)offScreenRange;
 					sceneTilePos.Y = screenPosition.Y - (float)offScreenRange;
 				}
 
-				if (renderCount == 3) {
+				//TML: Remapped from 3 to 2 to flatten per frame load for color lighting ( ~5ms peak).
+				if (renderCount == (Lighting.LegacyEngine.Mode == 0 ? 2 : 3)) {
 					RenderTiles2();
 					sceneTile2Pos.X = screenPosition.X - (float)offScreenRange;
 					sceneTile2Pos.Y = screenPosition.Y - (float)offScreenRange;
 				}
 
-				if (renderCount == 3) {
+				//TML: Remapped from 3 to 0 to flatten per frame load for color lighting ( ~15ms peak).
+				if (renderCount == (Lighting.LegacyEngine.Mode == 0 ? 0 : 3)) {
 					RenderWalls();
 					sceneWallPos.X = screenPosition.X - (float)offScreenRange;
 					sceneWallPos.Y = screenPosition.Y - (float)offScreenRange;
@@ -51005,9 +_,12 @@
 		if (gameMenu || netMode == 2)
 			bgTopY = -200;
 
+		/*
 		int num3 = dayRate;
 		if (num3 < 1)
 			num3 = 1;
+		*/
+		double num3 = desiredWorldEventsUpdateRate;
 
 		float num4 = 0.0005f * (float)num3;
 		if (gameMenu)
@@ -51075,13 +_,21 @@
 		UpdateAtmosphereTransparencyToSkyColor();
 		base.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Black);
 		base.Draw(gameTime);
+
+		/*
 		float val = (float)screenWidth / MinimumZoomComparerX;
 		float val2 = (float)screenHeight / MinimumZoomComparerY;
+		*/
+		float val = screenWidth / (ModLoader.ModLoader.removeForcedMinimumZoom ? 8192f : MinimumZoomComparerX);
+		float val2 = screenHeight / (ModLoader.ModLoader.removeForcedMinimumZoom ? 8192f : MinimumZoomComparerY);
 		ForcedMinimumZoom = Math.Max(Math.Max(1f, val), val2);
 		GameViewMatrix.Effects = ((!gameMenu && player[myPlayer].gravDir != 1f) ? SpriteEffects.FlipVertically : SpriteEffects.None);
 		BackgroundViewMatrix.Effects = GameViewMatrix.Effects;
 		BackgroundViewMatrix.Zoom = new Vector2(ForcedMinimumZoom);
 		GameViewMatrix.Zoom = new Vector2(ForcedMinimumZoom * MathHelper.Clamp(GameZoomTarget, 1f, 2f));
+
+		SystemLoader.ModifyTransformMatrix(ref GameViewMatrix);
+
 		if (gameMenu || player[myPlayer].gravDir == 1f)
 			Rasterizer = RasterizerState.CullCounterClockwise;
 		else
@@ -51170,7 +_,7 @@
 		spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.LinearClamp, DepthStencilState.None, Rasterizer, null, GameViewMatrix.TransformationMatrix);
 		DrawBackgroundBlackFill();
 		spriteBatch.End();
-		Overlays.Scene.Draw(spriteBatch, RenderLayers.Landscape);
+		Overlays.Scene.Draw(spriteBatch, RenderLayers.Landscape, beginSpriteBatch: true); //TML: Set 'beginSpriteBatch' to true.
 		spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.LinearClamp, DepthStencilState.None, Rasterizer, null, UIScaleMatrix);
 		if (gameMenu || netMode == 2) {
 			spriteBatch.End();
@@ -51282,6 +_,9 @@
 
 		TimeLogger.DetailedDrawReset();
 		spriteBatch.End();
+
+		SystemLoader.PostDrawTiles();
+
 		TimeLogger.DetailedDrawTime(35);
 		HasInteractibleObjectThatIsNotATile = false;
 		SortDrawCacheWorms();
@@ -51363,7 +_,7 @@
 		ScreenObstruction.Draw(spriteBatch);
 		TimeLogger.DetailedDrawReset();
 		spriteBatch.End();
-		Overlays.Scene.Draw(spriteBatch, RenderLayers.All);
+		Overlays.Scene.Draw(spriteBatch, RenderLayers.All, beginSpriteBatch: true); //TML: Set 'beginSpriteBatch' to true.
 		if (flag2)
 			Terraria.Graphics.Effects.Filters.Scene.EndCapture(null, screenTarget, screenTargetSwap, Microsoft.Xna.Framework.Color.Black);
 
@@ -51488,6 +_,21 @@
 		else
 			mouseRightRelease = true;
 
+		if (mouseMiddle)
+			mouseMiddleRelease = false;
+		else
+			mouseMiddleRelease = true;
+
+		if (mouseXButton1)
+			mouseXButton1Release = false;
+		else
+			mouseXButton1Release = true;
+
+		if (mouseXButton2)
+			mouseXButton2Release = false;
+		else
+			mouseXButton2Release = true;
+
 		if (!PlayerInput.Triggers.Current.MouseRight && !PlayerInput.Triggers.Current.MouseLeft && !preventStackSplitReset)
 			stackSplit = 0;
 
@@ -51628,8 +_,12 @@
 		}
 
 		Vector2 value = screenPosition;
+		screenPosition.X = Main.player[myPlayer].position.X + (float)Main.player[myPlayer].width * 0.5f - screenWidth / 2 * vector2.X + cameraX;
+		screenPosition.Y = Main.player[myPlayer].position.Y + (float)Main.player[myPlayer].height - (float)num - screenHeight / 2 * vector2.Y + Main.player[myPlayer].gfxOffY;
+		/* Fix #603. We allow odd screen resolutions, which potentially adds 0.5f here, which in turn draws the screen 1 pixel ahead due to how the game draws at whole pixel coordinates (pixel snapping).
 		screenPosition.X = Main.player[myPlayer].position.X + (float)Main.player[myPlayer].width * 0.5f - (float)screenWidth * 0.5f * vector2.X + cameraX;
 		screenPosition.Y = Main.player[myPlayer].position.Y + (float)Main.player[myPlayer].height - (float)num - (float)screenHeight * 0.5f * vector2.Y + Main.player[myPlayer].gfxOffY;
+		*/
 		Vector2 vector3 = Vector2.Zero;
 		float num2 = 0f;
 		float num3 = 0f;
@@ -51684,6 +_,8 @@
 						else if (player.scope)
 							num5 = 0.5f;
 
+						PlayerLoader.ModifyZoom(LocalPlayer, ref num5);
+
 						Vector2 vector5 = (MouseScreen - new Vector2(screenWidth, screenHeight) / 2f) / (new Vector2(screenWidth, screenHeight) / 2f);
 						num4 = 48f;
 						if (vector5 != Vector2.Zero && num5 != -1f) {
@@ -51709,8 +_,15 @@
 					if (num7 < 0)
 						num7 = 0;
 
+					float zoom = 1 / 1.25f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+
+					/*
 					vector3.X = (float)(num6 - screenWidth / 2) / 1.25f;
 					vector3.Y = (float)(num7 - screenHeight / 2) / 1.25f;
+					*/
+					vector3.X = (num6 - screenWidth / 2) * zoom;
+					vector3.Y = (num7 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].inventory[Main.player[myPlayer].selectedItem].type == 1254 && mouseRight) {
@@ -51728,8 +_,15 @@
 					if (num9 < 0)
 						num9 = 0;
 
+					float zoom = 1 / 1.5f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+
+					/*
 					vector3.X = (float)(num8 - screenWidth / 2) / 1.5f;
 					vector3.Y = (float)(num9 - screenHeight / 2) / 1.5f;
+					*/
+					vector3.X = (num8 - screenWidth / 2) * zoom;
+					vector3.Y = (num9 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].inventory[Main.player[myPlayer].selectedItem].type == 1299 && Main.player[myPlayer].selectedItem != 58) {
@@ -51747,8 +_,15 @@
 					if (num11 < 0)
 						num11 = 0;
 
+					float zoom = 1 / 1.5f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+
+					/*
 					vector3.X = (float)(num10 - screenWidth / 2) / 1.5f;
 					vector3.Y = (float)(num11 - screenHeight / 2) / 1.5f;
+					*/
+					vector3.X = (num10 - screenWidth / 2) * zoom;
+					vector3.Y = (num11 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].scope && mouseRight) {
@@ -51766,9 +_,29 @@
 					if (num13 < 0)
 						num13 = 0;
 
+					float zoom = 1 / 2f;
+					PlayerLoader.ModifyZoom(player[myPlayer], ref zoom);
+
+					/*
 					vector3.X = (float)(num12 - screenWidth / 2) / 2f;
 					vector3.Y = (float)(num13 - screenHeight / 2) / 2f;
+					*/
+					vector3.X = (num12 - screenWidth / 2) * zoom;
+					vector3.Y = (num13 - screenHeight / 2) * zoom;
+
 					flag = true;
+				}
+				else { // Added by TML
+					float zoom = -1f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+
+					if (zoom != -1f) {
+						int mouseXClamped = Utils.Clamp(mouseX, 0, screenWidth);
+						int mouseYClamped = Utils.Clamp(mouseY, 0, screenHeight);
+						vector3.X = (mouseXClamped - screenWidth / 2) * zoom;
+						vector3.Y = (mouseYClamped - screenHeight / 2) * zoom;
+						flag = true;
+					}
 				}
 			}
 		}
@@ -51850,6 +_,8 @@
 		}
 
 		instance.CameraModifiers.ApplyTo(ref screenPosition);
+		PlayerLoader.ModifyScreenPosition(LocalPlayer);
+		SystemLoader.ModifyScreenPosition();
 		screenPosition.X = (int)screenPosition.X;
 		screenPosition.Y = (int)screenPosition.Y;
 		ClampScreenPositionToWorld();
@@ -51883,6 +_,13 @@
 			num = Utils.Clamp(num, 0, 8);
 
 		Texture2D value2 = TextureAssets.Moon[num].Value;
+
+		if (gameMenu) {
+			ModMenu menu = MenuLoader.CurrentMenu;
+			value = menu.SunTexture?.Value ?? value;
+			value2 = menu.MoonTexture?.Value ?? value2;
+		}
+
 		int num2 = sceneArea.bgTopY;
 		int num3 = (int)(time / 54000.0 * (double)(sceneArea.totalWidth + (float)(value.Width * 2))) - value.Width;
 		int num4 = 0;
@@ -51988,6 +_,8 @@
 				spriteBatch.Draw(TextureAssets.PumpkinMoon.Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.PumpkinMoon.Width() * moonPhase, TextureAssets.PumpkinMoon.Width(), TextureAssets.PumpkinMoon.Width()), moonColor, num9, new Vector2(TextureAssets.PumpkinMoon.Width() / 2, TextureAssets.PumpkinMoon.Width() / 2), num8, SpriteEffects.None, 0f);
 			else if (snowMoon)
 				spriteBatch.Draw(TextureAssets.SnowMoon.Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.SnowMoon.Width() * moonPhase, TextureAssets.SnowMoon.Width(), TextureAssets.SnowMoon.Width()), moonColor, num9, new Vector2(TextureAssets.SnowMoon.Width() / 2, TextureAssets.SnowMoon.Width() / 2), num8, SpriteEffects.None, 0f);
+			else if (value2 != TextureAssets.Moon[num].Value) // Added by TML to draw custom moon texture
+				spriteBatch.Draw(value2, position2, new Rectangle(0, 0, value2.Width, value2.Width), moonColor, num9, new Vector2(value2.Width / 2), num8, SpriteEffects.None, 0f);
 			else
 				spriteBatch.Draw(TextureAssets.Moon[num].Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.Moon[num].Width() * moonPhase, TextureAssets.Moon[num].Width(), TextureAssets.Moon[num].Width()), moonColor, num9, new Vector2(TextureAssets.Moon[num].Width() / 2, TextureAssets.Moon[num].Width() / 2), num8, SpriteEffects.None, 0f);
 		}
@@ -52129,7 +_,7 @@
 		Vector2 origin = value3.Size() / 2f;
 		if (theStar.falling) {
 			theStar.fadeIn = 0f;
-			int num8 = theStar.fallTime;
+			double num8 = theStar.fallTime;
 			float num9 = 30f;
 			if ((float)num8 > num9)
 				num8 = (int)num9;
@@ -52167,6 +_,9 @@
 		tileColor.G = (byte)((colorOfTheSkies.R + colorOfTheSkies.G + colorOfTheSkies.B + colorOfTheSkies.G * 7) / 10);
 		tileColor.B = (byte)((colorOfTheSkies.R + colorOfTheSkies.G + colorOfTheSkies.B + colorOfTheSkies.B * 7) / 10);
 		tileColor = SkyManager.Instance.ProcessTileColor(tileColor);
+
+		//TODO: Add in white and white2 as sunColor and moonColor
+		SystemLoader.ModifySunLightColor(ref tileColor, ref ColorOfTheSkies);
 	}
 
 	private static void UpdateAtmosphereTransparencyToSkyColor()
@@ -52937,6 +_,10 @@
 			preferredBGStyleForPlayer = bgStyle;
 			if (WorldGen.drunkWorldGen)
 				bgStyle = 9;
+
+			var menuBackgroundStyle = MenuLoader.CurrentMenu.MenuBackgroundStyle;
+			if (menuBackgroundStyle != null)
+				bgStyle = menuBackgroundStyle.Slot;
 		}
 
 		if (instantBGTransitionCounter > 0) {
@@ -52947,6 +_,9 @@
 
 		UpdateBGVisibility_BackLayer(null, null);
 		UpdateBGVisibility_FrontLayer(null, null);
+
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().ModifyFarFades(bgStyle, bgAlphaFrontLayer, backgroundLayerTransitionSpeed);
+
 		try {
 			DrawSurfaceBG();
 			if (BackgroundEnabled)
@@ -53034,6 +_,10 @@
 				DrawBG_ModifyBGFarBackLayerAlpha(value, null, transitionAmountOverride);
 				break;
 			default:
+				if (value >= BG_STYLES_COUNT) {
+					DrawBG_ModifyBGFarBackLayerAlpha(value, null, transitionAmountOverride);
+					break;
+				}
 				DrawBG_ModifyBGFarBackLayerAlpha(0, null, transitionAmountOverride);
 				break;
 		}
@@ -53043,6 +_,13 @@
 	{
 		int num = bgStyle;
 		int num2 = (int)((screenPosition.X + (float)(screenWidth / 2)) / 16f);
+
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().ChooseStyle(out var modBG, out var priority);
+
+		if (priority >= SceneEffectPriority.BiomeHigh) {
+			num = modBG;
+		}
+		else // ^ Added by TML
 		if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			num = (player[myPlayer].ZoneHallow ? 6 : (player[myPlayer].ZoneCorrupt ? ((SceneMetrics.BloodTileCount <= SceneMetrics.EvilTileCount) ? 1 : 8) : (player[myPlayer].ZoneCrimson ? 8 : ((SceneMetrics.HoneyBlockCount <= 400) ? 4 : 3))));
 		}
@@ -53061,12 +_,18 @@
 		else if (player[myPlayer].ZoneCrimson) {
 			num = 8;
 		}
+		else if (priority >= SceneEffectPriority.BiomeMedium) { // Added by TML
+			num = modBG;
+		}
 		else if (player[myPlayer].ZoneJungle) {
 			num = 3;
 		}
 		else if (player[myPlayer].ZoneSnow) {
 			num = 7;
 		}
+		else if (priority >= SceneEffectPriority.BiomeLow) { // Added by TML
+			num = modBG;
+		}
 		else {
 			num = 0;
 			if (num2 >= treeX[0]) {
@@ -53076,6 +_,13 @@
 					num = 11;
 				else if (WorldGen.treeBG1 != WorldGen.treeBG4)
 					num = 12;
+				// Extra patch context
+			}
+		}
+
+		if (GlobalBackgroundStyleLoader.loaded) {
+			foreach (var hook in GlobalBackgroundStyleLoader.HookChooseSurfaceBackgroundStyle) {
+				hook(ref num);
 			}
 		}
 
@@ -53138,6 +_,15 @@
 
 	private static void UpdateInvasion()
 	{
+		SystemLoader.PreUpdateInvasions();
+
+		UpdateInvasion_Inner();
+
+		SystemLoader.PostUpdateInvasions();
+	}
+
+	private static void UpdateInvasion_Inner()
+	{
 		if (invasionType <= 0)
 			return;
 
@@ -53170,9 +_,14 @@
 		if (invasionX == (double)spawnTileX)
 			return;
 
+		/*
 		float num = dayRate;
 		if (num < 1f)
 			num = 1f;
+		*/
+		double num = desiredWorldEventsUpdateRate;
+		if (num < 0)
+			num = 0;
 
 		if (invasionX > (double)spawnTileX) {
 			invasionX -= num;
@@ -53221,7 +_,10 @@
 
 		int num = 0;
 		for (int i = 0; i < 255; i++) {
+			/*
 			if (player[i].active && player[i].statLifeMax >= 200)
+			*/
+			if (player[i].active && player[i].ConsumedLifeCrystals >= 5)
 				num++;
 		}
 
@@ -53238,7 +_,10 @@
 
 		int num = 0;
 		for (int i = 0; i < 255; i++) {
+			/*
 			if (player[i].active && player[i].statLifeMax >= 200)
+			*/
+			if (player[i].active && player[i].ConsumedLifeCrystals >= 5)
 				num++;
 		}
 
@@ -53374,7 +_,7 @@
 					Netplay.Clients[k].TimeOutTimer += 3;
 
 				if (!stopTimeOuts && Netplay.Clients[k].TimeOutTimer > 7200) {
-					Netplay.Clients[k].PendingTermination = true;
+					Netplay.Clients[k].SetPendingTermination("Timeout");
 					Netplay.Clients[k].PendingTerminationApproved = true;
 				}
 			}
@@ -53384,6 +_,19 @@
 		}
 	}
 
+	// Overload added by TML.
+	/// <inheritdoc cref="NewText(string, byte, byte, byte)"/>
+	public static void NewText(object o, Color? color = null)
+	{
+		var c = color ?? Color.White;
+		NewText(o.ToString(), c.R, c.G, c.B);
+	}
+
+	/// <summary>
+	/// Spawns chat text on the local client. Does nothing on the server. <br/>
+	/// For floating text, such as damage, see <see cref="CombatText"/> <br/>
+	/// <include file = 'CommonDocs.xml' path='Common/VariousTextOptionsSummary' />
+	/// </summary>
 	public static void NewText(string newText, byte R = byte.MaxValue, byte G = byte.MaxValue, byte B = byte.MaxValue)
 	{
 		chatMonitor.NewText(newText, R, G, B);
@@ -53396,6 +_,10 @@
 		SoundEngine.PlaySound(12);
 	}
 
+	/// <summary>
+	/// Stops rain. Should be called on the server (netMode != client) - vanilla syncs it using <see cref="SyncRain"/>.
+	/// <br>You can also call this on the client to update visuals immediately, assuming it was called serverside as well (Journey Mode rain slider does this).</br>
+	/// </summary>
 	public static void StopRain()
 	{
 		rainTime = 0;
@@ -53403,6 +_,10 @@
 		maxRaining = 0f;
 	}
 
+	/// <summary>
+	/// Starts rain for a random amount of time. Should be called on the server (netMode != client) - vanilla syncs it using <see cref="SyncRain"/>.
+	/// <br>You can also call this on the client to update visuals immediately, assuming it was/will be called serverside as well (Journey Mode rain slider does this).</br>
+	/// </summary>
 	public static void StartRain()
 	{
 		int num = 86400;
@@ -53520,7 +_,7 @@
 		}
 
 		if (ladyBugRainBoost > 0)
-			ladyBugRainBoost -= dayRate;
+			ladyBugRainBoost -= desiredWorldEventsUpdateRate;
 
 		if (pumpkinMoon) {
 			bloodMoon = false;
@@ -53532,12 +_,12 @@
 
 		if ((netMode != 1 && !gameMenu) || netMode == 2) {
 			if (slimeRainTime > 0.0) {
-				slimeRainTime -= dayRate;
+				slimeRainTime -= desiredWorldEventsUpdateRate;
 				if (slimeRainTime <= 0.0)
 					StopSlimeRain();
 			}
 			else if (slimeRainTime < 0.0) {
-				slimeRainTime += dayRate;
+				slimeRainTime += desiredWorldEventsUpdateRate;
 				if (slimeRainTime > 0.0)
 					slimeRainTime = 0.0;
 			}
@@ -53548,42 +_,45 @@
 						StopRain();
 					}
 					else {
-						rainTime -= dayRate;
+						rainTime -= desiredWorldEventsUpdateRate;
-						if (dayRate > 0) {
+						if (desiredWorldEventsUpdateRate > 0) {
-							int num = 86400 / dayRate / 24;
+							double num = 86400 / desiredWorldEventsUpdateRate / 24;
 							if (rainTime <= 0)
 								StopRain();
-							else if (rand.Next(num * 2) == 0)
+							else if (rand.NextDouble() <= 1 / (num * 2))
 								ChangeRain();
 						}
 					}
 				}
 			}
 			else if (!slimeRain && !LanternNight.LanternsUp && !LanternNight.NextNightIsLanternNight) {
+				/*
 				int num2 = 86400;
 				num2 /= ((dayRate == 0) ? 1 : dayRate);
+				*/
+				double num2 = 86400 / desiredWorldEventsUpdateRate;
-				if (!CreativePowerManager.Instance.GetPower<CreativePowers.FreezeRainPower>().Enabled && dayRate != 0) {
+				if (!CreativePowerManager.Instance.GetPower<CreativePowers.FreezeRainPower>().Enabled && desiredWorldEventsUpdateRate != 0) {
-					if (rand.Next((int)((double)num2 * 5.75)) == 0)
+					if (rand.NextDouble() <= 1 / (num2 * 5.75))
 						StartRain();
-					else if (cloudBGActive >= 1f && rand.Next((int)((double)num2 * 4.25)) == 0)
+					else if (cloudBGActive >= 1f && rand.NextDouble() <= 1 / (num2 * 4.25))
 						StartRain();
-					else if (ladyBugRainBoost > 0 && rand.Next(num2) == 0)
+					else if (ladyBugRainBoost > 0 && rand.NextDouble() <= 1 / num2)
 						StartRain();
 				}
 
-				if (!raining && !NPC.BusyWithAnyInvasionOfSorts() && dayTime && time < 27000.0 && dayRate > 0) {
+				if (!raining && !NPC.BusyWithAnyInvasionOfSorts() && dayTime && time < 27000.0 && desiredWorldEventsUpdateRate > 0) {
-					int num3 = (int)(450000.00000000006 / (double)dayRate);
+					double num3 = 450000.00000000006 / desiredWorldEventsUpdateRate;
 					if (!NPC.downedSlimeKing)
 						num3 /= 2;
 
 					if (hardMode)
-						num3 = (int)((double)num3 * 1.5);
+						num3 = num3 * 1.5;
 
 					bool flag = AnyPlayerReadyToFightKingSlime();
 					if (!flag)
 						num3 *= 5;
 
-					if (num3 > 0 && (flag || expertMode) && rand.Next(num3) == 0)
+					if (num3 > 0 && (flag || expertMode) && rand.NextDouble() <= 1 / num3)
 						StartSlimeRain();
 				}
 			}
@@ -53644,13 +_,17 @@
 					WorldGen.UnspawnTravelNPC();
 			}
 			else if (!IsFastForwardingTime() && dayTime && time < 27000.0) {
+				/*
 				int num6 = dayRate;
 				if (num6 < 1)
 					num6 = 1;
 
+				// Extra patch context.
 				int num7 = (int)(27000.0 / (double)num6);
 				num7 *= 4;
 				if (rand.Next(num7) == 0) {
+				*/
+				if (rand.NextDouble() < dayRate / (27000.0 * 4)) {
 					int num8 = 0;
 					for (int i = 0; i < 200; i++) {
 						if (npc[i].active && npc[i].townNPC && npc[i].type != 37 && npc[i].type != 453)
@@ -53747,7 +_,10 @@
 	public static bool AnyPlayerReadyToFightKingSlime()
 	{
 		for (int i = 0; i < 255; i++) {
+			/*
 			if (player[i].active && player[i].statLifeMax > 140 && player[i].statDefense > 8)
+			*/
+			if (player[i].active && player[i].ConsumedLifeCrystals > 2 && player[i].statDefense > 8)
 				return true;
 		}
 
@@ -53815,7 +_,10 @@
 			if (!NPC.downedBoss1 && netMode != 1) {
 				bool flag = false;
 				for (int i = 0; i < 255; i++) {
+					/*
 					if (player[i].active && player[i].statLifeMax >= 200 && player[i].statDefense > 10) {
+					*/
+					if (player[i].active && player[i].ConsumedLifeCrystals >= 5 && player[i].statDefense > 10) {
 						flag = true;
 						break;
 					}
@@ -53898,7 +_,10 @@
 
 			if (!WorldGen.spawnEye && moonPhase != 4 && rand.Next(maxValue) == 0 && netMode != 1) {
 				for (int m = 0; m < 255; m++) {
+					/*
 					if (player[m].active && player[m].statLifeMax > 120) {
+					*/
+					if (player[m].active && player[m].ConsumedLifeCrystals > 1) {
 						bloodMoon = true;
 						break;
 					}
@@ -54060,6 +_,13 @@
 
 	public static BestiaryUnlockProgressReport GetBestiaryProgressReport()
 	{
+		List<BestiaryEntry> vanillaEntries = BestiaryDB.GetBestiaryEntriesByMod(null);
+		return new BestiaryUnlockProgressReport {
+			EntriesTotal = vanillaEntries.Count,
+			CompletionAmountTotal = vanillaEntries.Count(e => e.UIInfoProvider.GetEntryUICollectionInfo().UnlockState > BestiaryEntryUnlockState.NotKnownAtAll_0)
+		};
+
+		/*
 		float num = 0f;
 		int num2 = 0;
 		List<BestiaryEntry> entries = BestiaryDB.Entries;
@@ -54073,11 +_,12 @@
 		result.EntriesTotal = num2;
 		result.CompletionAmountTotal = num;
 		return result;
+		*/
 	}
 
 	private static void UpdateTime_SpawnTownNPCs()
 	{
-		int worldUpdateRate = WorldGen.GetWorldUpdateRate();
+		double worldUpdateRate = WorldGen.GetWorldUpdateRate();
 		if (netMode == 1 || worldUpdateRate <= 0)
 			return;
 
@@ -54092,7 +_,7 @@
 				num++;
 		}
 
-		for (int j = 0; j < NPCID.Count; j++) {
+		for (int j = 0; j < townNPCCanSpawn.Length; j++) {
 			townNPCCanSpawn[j] = false;
 		}
 
@@ -54255,6 +_,7 @@
 				if (npc[k].type == 663)
 					num39++;
 
+				// Patch note: 'num40' (the amount of NPCs) is used below.
 				num40++;
 			}
 		}
@@ -54517,20 +_,38 @@
 
 			WorldGen.prioritizedTownNPCType = num42;
 		}
+
+		NPCLoader.CanTownNPCSpawn(num40);
 	}
 
+	public static int DefaultDamageVariationPercent = 15;
+	/// <summary>
+	/// Multiplies the input damage by a random value between <c>0.85f</c> and <c>1.15f</c>.
+	/// </summary>
+	/// <param name="dmg">The damage to vary.</param>
+	/// <param name="luck">
+	/// How lucky the damager is, in the range [-1f, 1f].
+	/// <br/> If <c><paramref name="luck"/> &gt; 0f</c>, there is a <c><paramref name="luck"/></c>% chance that damage variation is rerolled, with the higher value being used.
+	/// <br/> If <c><paramref name="luck"/> &lt; 0f</c>, there is a <c>-<paramref name="luck"/></c>% chance that damage variation is rerolled, with the lower value being used.
+	/// </param>
+	/// <returns>The varied damage value, rounded to the nearest integer.</returns>
 	public static int DamageVar(float dmg, float luck = 0f)
 	{
+		return DamageVar(dmg, DefaultDamageVariationPercent, luck);
+	}
+	
+	public static int DamageVar(float dmg, int percent, float luck = 0f)
+	{
-		float num = dmg * (1f + (float)rand.Next(-15, 16) * 0.01f);
+		float num = dmg * (1f + (float)rand.Next(-percent, percent+1) * 0.01f);
 		if (luck > 0f) {
 			if (rand.NextFloat() < luck) {
-				float num2 = dmg * (1f + (float)rand.Next(-15, 16) * 0.01f);
+				float num2 = dmg * (1f + (float)rand.Next(-percent, percent + 1) * 0.01f);
 				if (num2 > num)
 					num = num2;
 			}
 		}
 		else if (luck < 0f && rand.NextFloat() < 0f - luck) {
-			float num3 = dmg * (1f + (float)rand.Next(-15, 16) * 0.01f);
+			float num3 = dmg * (1f + (float)rand.Next(-percent, percent + 1) * 0.01f);
 			if (num3 < num)
 				num = num3;
 		}
@@ -54538,7 +_,8 @@
 		return (int)Math.Round(num);
 	}
 
+	/*
-	public static double CalculateDamageNPCsTake(int Damage, int Defense)
+	public static double CalculateDamageNPCsTake(double Damage, int Defense)
 	{
 		double num = (double)Damage - (double)Defense * 0.5;
 		if (num < 1.0)
@@ -54569,6 +_,7 @@
 
 		return num;
 	}
+	*/
 
 	public void OnTileChangeEvent(int x, int y, int count, TileChangeType eventType)
 	{
@@ -54625,7 +_,11 @@
 
 	public static void SetFullScreen(bool fullscreen)
 	{
+		// TML: Make the fullscreen reset to windowed display borders when downsizing
+		/*
 		SetDisplayMode(PendingResolutionWidth, PendingResolutionHeight, fullscreen);
+		*/
+		SetDisplayMode(PendingResolutionWidth, BorderedHeight(PendingResolutionHeight, fullscreen), fullscreen);
 	}
 
 	public static void SetResolution(int width, int height)
@@ -54690,7 +_,11 @@
 				width = (int)(num2 * (float)height);
 			}
 
+			// TODO, does this patch belong in TerrariaNetCore? Why do we remove this?
+			/*
 			PlayerInput.RawMouseScale = new Vector2((float)width / (float)instance.Window.ClientBounds.Width, (float)height / (float)instance.Window.ClientBounds.Height);
+			*/
+
 			if (!graphics.IsFullScreen) {
 				num3 = Math.Max(graphics.PreferredBackBufferWidth, graphics.GraphicsDevice.Viewport.Width);
 				num4 = Math.Max(graphics.PreferredBackBufferHeight, graphics.GraphicsDevice.Viewport.Height);
@@ -54749,6 +_,7 @@
 			graphics.ToggleFullScreen();
 		}
 
+		// Note: Runs if Graphics Device needs a reset to match backBuffer to Viewport, or if target resolution is diff than current
 		if (width != num3 || height != num4 || flag2) {
 			mapTime = 0;
 			if (gamePaused)
@@ -54758,7 +_,14 @@
 			screenHeight = height;
 			graphics.PreferredBackBufferWidth = screenWidth;
 			graphics.PreferredBackBufferHeight = screenHeight;
+
+			// Only apply changes if width or height changed
+			if (width == num3 && height == num4)
+				goto SkipApplyChanges;
+
 			graphics.ApplyChanges();
+			SkipApplyChanges:
+
 			PlayerInput.CacheOriginalScreenDimensions();
 			FixUIScale();
 			if (Main.OnResolutionChanged != null)
