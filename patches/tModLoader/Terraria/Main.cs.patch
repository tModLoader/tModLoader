--- src/TerrariaNetCore/Terraria/Main.cs
+++ src/tModLoader/Terraria/Main.cs
@@ -3,7 +_,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Drawing;
+//using System.Drawing; // Causes Microsoft.Xna.Framework.Color import conflict
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -18,6 +_,7 @@
 using Microsoft.Xna.Framework.Content;
 using Microsoft.Xna.Framework.Graphics;
 using Microsoft.Xna.Framework.Input;
+using Newtonsoft.Json.Linq;
 using ReLogic.Content;
 using ReLogic.Content.Sources;
 using ReLogic.Graphics;
@@ -63,9 +_,16 @@
 using Terraria.IO;
 using Terraria.Localization;
 using Terraria.Map;
+using Terraria.ModLoader;
+using Terraria.ModLoader.Core;
+using Terraria.ModLoader.Default;
+using Terraria.ModLoader.Engine;
+using Terraria.ModLoader.IO;
+using Terraria.ModLoader.UI;
 using Terraria.Net;
 using Terraria.ObjectData;
 using Terraria.Social;
+using Terraria.Social.Steam;
 using Terraria.UI;
 using Terraria.UI.Chat;
 using Terraria.UI.Gamepad;
@@ -85,9 +_,9 @@
 #endif
 
 #if SERVER
-public class Main : Terraria.Server.Game
+public partial class Main : Terraria.Server.Game
 #else
-public class Main : Game
+public partial class Main : Game
 #endif
 {
 	public delegate void OnPlayerSelected(PlayerFileData player);
@@ -140,19 +_,31 @@
 		private string _originalText;
 		private int _lastScreenWidth;
 		private int _lastScreenHeight;
+		private Color originalColor;
 
-		public string[] TextLines { get; private set; }
+		public List<List<TextSnippet>> TextLines { get; private set; }
 
 		public int AmountOfLines { get; private set; }
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		/*
 		public void PrepareCache(string text)
 		{
 			if (false | (screenWidth != _lastScreenWidth) | (screenHeight != _lastScreenHeight) | (_originalText != text)) {
+		*/
+		public void PrepareCache(string text, Color baseColor)
+		{
+			if ((0 | ((screenWidth != _lastScreenWidth) ? 1 : 0) | ((screenHeight != _lastScreenHeight) ? 1 : 0) | ((_originalText != text) ? 1 : 0) | ((originalColor != baseColor) ? 1 : 0)) != 0) {
 				_lastScreenWidth = screenWidth;
 				_lastScreenHeight = screenHeight;
 				_originalText = text;
+				/*
 				TextLines = Utils.WordwrapString(text, FontAssets.MouseText.Value, 460, 10, out var lineAmount);
 				AmountOfLines = lineAmount;
+				*/
+				originalColor = baseColor;
+				TextLines = Utils.WordwrapStringSmart(text, baseColor, FontAssets.MouseText.Value, 460, 10);
+				AmountOfLines = TextLines.Count;
 			}
 		}
 	}
@@ -254,7 +_,7 @@
 	public static bool zenithWorld = false;
 	public static Vector2 destroyerHB = new Vector2(0f, 0f);
 	public static FavoritesFile LocalFavoriteData = new FavoritesFile(SavePath + "/favorites.json", isCloud: false);
-	public static FavoritesFile CloudFavoritesData = new FavoritesFile("favorites.json", isCloud: true);
+	public static FavoritesFile CloudFavoritesData = new FavoritesFile("ModLoader/favorites.json", true);
 	public static FileMetadata WorldFileMetadata;
 	public static FileMetadata MapFileMetadata;
 	public static PingMapLayer Pings = new PingMapLayer();
@@ -507,12 +_,12 @@
 	public static bool showSplash = true;
 	public static bool ignoreErrors = true;
 	public static string defaultIP = "";
-	public static int dayRate = 1;
+	public static double dayRate = 1;
-	public static int desiredWorldTilesUpdateRate = 1;
+	public static double desiredWorldTilesUpdateRate = 1;
 	public static int maxScreenW = 1920;
 	public static int maxScreenH = 1200;
 	public static int minScreenW = 800;
-	public static int minScreenH = 600;
+	public static int minScreenH = 720; // Used to be '600'
 	public static float iS = 1f;
 	public static bool render;
 	public static int qaStyle;
@@ -522,12 +_,40 @@
 	public static bool[] projHostile = new bool[1022];
 	public static bool[] projHook = new bool[1022];
 	public static bool[] pvpBuff = new bool[355];
+	/// <summary>
+	/// Allows status effects for which this is set to true to persist after the afflicted player's death.<br/>
+	/// Defaults to false; all vanilla flask effects have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] persistentBuff = new bool[355];
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being from vanity pets, preventing them from overlapping with other vanity pet status effects.<br/>
+	/// Defaults to false; all vanilla vanity pets have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] vanityPet = new bool[355];
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being tied to a light pet, preventing them from overlapping with other light pet status effects.<br/>
+	/// Defaults to false; all vanilla light pets have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] lightPet = new bool[355];
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being from flasks, preventing them from overlapping with other flask status effects.<br/>
+	/// Defaults to false; all vanilla flask effects have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] meleeBuff = new bool[355];
+	/// <summary>
+	/// Categorizes status effects for which this is set to true as being debuffs instead of buffs.<br/>
+	/// This has multiple effects on gameplay:<br/>
+	/// - the Nurse can remove the status effect when healing the afflicted player (to prevent this, refer to <see cref="BuffID.Sets.NurseCannotRemoveDebuff"/>)<br/>
+	/// - the status effect cannot be cleared from overflowing the status effect cap (buffs will be cleared instead)<br/>
+	/// - the status effect cannot be cleared by right-clicking it (which can be done for all other status effect types)<br/>
+	/// Defaults to false; all vanilla debuffs have their entries here set to true.<br/>
+	/// </summary>
 	public static bool[] debuff = new bool[355];
 	public static bool[] buffNoSave = new bool[355];
+	/// <summary>
+	/// Prevents status effects which have their entries set to true from displaying the amount of time they have left.<br/>
+	/// Defaults to false; most, if not all, status effects which have their entries set to true here are related to mounts, pets, and summons.<br/>
+	/// </summary>
 	public static bool[] buffNoTimeDisplay = new bool[355];
 	public static bool[] buffDoubleApply = new bool[355];
 	public static int maxMP = 10;
@@ -539,7 +_,7 @@
 	public static int instantBGTransitionCounter = 2;
 	public static int bgDelay;
 	public static int bgStyle;
-	private const int BG_STYLES_COUNT = 14;
+	internal const int BG_STYLES_COUNT = 14;
 	public static float[] bgAlphaFrontLayer = new float[14];
 	public static float[] bgAlphaFarBackLayer = new float[14];
 	public static int[] bgFrame = new int[14];
@@ -553,13 +_,13 @@
 	public static int wofDrawAreaBottom;
 	public static int wofDrawFrameIndex;
 	public static int offScreenRange = 200;
-	private RenderTarget2D backWaterTarget;
+	public RenderTarget2D backWaterTarget;
 	public static RenderTarget2D waterTarget;
-	private RenderTarget2D tileTarget;
+	public RenderTarget2D tileTarget;
-	private RenderTarget2D blackTarget;
+	public RenderTarget2D blackTarget;
-	private RenderTarget2D tile2Target;
+	public RenderTarget2D tile2Target;
-	private RenderTarget2D wallTarget;
+	public RenderTarget2D wallTarget;
-	private RenderTarget2D backgroundTarget;
+	public RenderTarget2D backgroundTarget;
 	public static RenderTarget2D screenTarget;
 	public static RenderTarget2D screenTargetSwap;
 	public static int maxMapUpdates = 250000;
@@ -580,8 +_,8 @@
 	public static bool clearMap;
 	public static int mapTargetX = 5;
 	public static int mapTargetY = 2;
-	private RenderTarget2D[,] mapTarget = new RenderTarget2D[mapTargetX, mapTargetY];
+	public RenderTarget2D[,] mapTarget = new RenderTarget2D[mapTargetX, mapTargetY];
-	private RenderTarget2D mapSectionTexture;
+	public RenderTarget2D mapSectionTexture;
 	public static bool[,] initMap = new bool[mapTargetX, mapTargetY];
 	public static bool[,] mapWasContentLost = new bool[mapTargetX, mapTargetY];
 	public const int numInfoIcons = 13;
@@ -612,12 +_,12 @@
 	private int lastTileX;
 	private int firstTileY;
 	private int lastTileY;
-	private double bgParallax;
+	internal double bgParallax;
-	private int bgStartX;
+	internal int bgStartX;
-	private int bgLoops;
+	internal int bgLoops;
 	private int bgStartY;
 	private int bgLoopsY;
-	private int bgTopY;
+	internal int bgTopY;
 	public static int renderCount = 99;
 	private const int MF_BYPOSITION = 1024;
 	public static GraphicsDeviceManager graphics;
@@ -707,7 +_,7 @@
 	public const int maxItems = 400;
 	public const int maxProjectiles = 1000;
 	public const int maxNPCs = 200;
-	private static UICharacterSelect _characterSelectMenu = new UICharacterSelect();
+	internal static UICharacterSelect _characterSelectMenu = new UICharacterSelect();
 	private static UIWorldSelect _worldSelectMenu = new UIWorldSelect();
 	public static UIManageControls ManageControlsMenu = new UIManageControls();
 	public static UIAchievementsMenu AchievementsMenu = new UIAchievementsMenu();
@@ -763,7 +_,15 @@
 	public static int LogoA = 255;
 	public static int LogoB;
 	public static bool LogoT;
-	public static string statusText = "";
+	private static string _statusText = "";
+	public static string statusText {
+		get => _statusText;
+		set {
+			Logging.LogStatusChange(_statusText, value);
+
+			_statusText = value;
+		}
+	}
 	public static string worldName = "";
 	public static int worldID;
 	public static int background;
@@ -788,7 +_,7 @@
 	public static float cloudAlpha;
 	public static float maxRaining;
 	public static float oldMaxRaining;
-	public static int rainTime;
+	public static double rainTime;
 	public static bool raining;
 	public static bool eclipse;
 	public static float eclipseLight;
@@ -829,7 +_,11 @@
 	public static float invAlpha = 1f;
 	public static float invDir = 1f;
 	[ThreadStatic]
-	public static UnifiedRandom rand;
+	public static UnifiedRandom _rand;
+	public static UnifiedRandom rand {
+		get => _rand ??= new UnifiedRandom();
+		set => _rand = value;
+	}
 	public static bool allChestStackHover;
 	public static bool inventorySortMouseOver;
 	public static float GraveyardVisualIntensity;
@@ -963,6 +_,11 @@
 	public static int[] grasshopperCageFrameCounter = new int[cageFrames];
 	public static bool[] tileSand = new bool[693];
 	public static bool[] tileFlame = new bool[693];
+	/// <summary>
+	/// Used to denote an NPC as being catchable by bug nets and similar.<br/>
+	/// Contrary to its name, this array isn't actually used for catching logic at all.<br/>
+	/// It is instead used to determine if an NPC can be released back into the world after being caught.<br/>
+	/// </summary>
 	public static bool[] npcCatchable = new bool[688];
 	public static int[] tileFrame = new int[693];
 	public static int[] tileFrameCounter = new int[693];
@@ -973,7 +_,7 @@
 	public static HairstyleUnlocksHelper Hairstyles = new HairstyleUnlocksHelper();
 	public static bool tilesLoaded = false;
 	public static WorldMap Map;
-	public static Tile[,] tile = new Tile[maxTilesX, maxTilesY];
+	public static Tilemap tile = new Tilemap((ushort)maxTilesX, (ushort)maxTilesY);
 	public static Dust[] dust = new Dust[6001];
 	public static Star[] star = new Star[400];
 	public static Item[] item = new Item[401];
@@ -1160,9 +_,9 @@
 	public static List<WorldFileData> WorldList = new List<WorldFileData>();
 	public static WorldFileData ActiveWorldFileData = new WorldFileData();
 	public static string WorldPath = Path.Combine(SavePath, "Worlds");
-	public static string CloudWorldPath = "worlds";
+	public static string CloudWorldPath = (BuildInfo.IsStable ? Program.ReleaseFolder : BuildInfo.IsPreview ? Program.PreviewFolder : Program.DevFolder) + "/worlds";
 	public static string PlayerPath = Path.Combine(SavePath, "Players");
-	public static string CloudPlayerPath = "players";
+	public static string CloudPlayerPath = (BuildInfo.IsStable ? Program.ReleaseFolder : BuildInfo.IsPreview ? Program.PreviewFolder : Program.DevFolder) + "/players";
 	public static Preferences Configuration = new Preferences(SavePath + Path.DirectorySeparatorChar + "config.json");
 	public static Preferences InputProfiles = new Preferences(SavePath + Path.DirectorySeparatorChar + "input profiles.json");
 	public static KeyboardState inputText;
@@ -1989,7 +_,7 @@
 	public static bool _shouldUseWindyDayMusic = false;
 	public static bool _shouldUseStormMusic = false;
 	private int lastMusicPlayed = -1;
-	private bool playOldTile;
+	public bool playOldTile;
 	private static float _minWind = 0.34f;
 	private static float _maxWind = 0.4f;
 	private static float _minRain = 0.4f;
@@ -2004,8 +_,11 @@
 	public static float ambientLavaY = -1f;
 	public static float ambientLavaStrength;
 	public static int ambientCounter;
+	//TML: No longer of use due to changes in Main.Ambience().
+	/*
 	private static bool _isWaterfallMusicPlaying = false;
 	private static bool _isLavafallMusicPlaying = false;
+	*/
 	public static IChatMonitor chatMonitor = new RemadeChatMonitor();
 	public static int ProjectileUpdateLoopIndex = -1;
 	public static GameTipsDisplay gameTips;
@@ -2026,17 +_,17 @@
 	private int selectedMenu2 = -1;
 	public static int selectedPlayer = 0;
 	public static int selectedWorld;
-	public static int menuMode;
+	public static int menuMode = Interface.loadModsID;
 	public static int menuSkip;
 	private static bool _needsLanguageSelect = true;
-	private static Item tooltipPrefixComparisonItem = new Item();
+	public static Item tooltipPrefixComparisonItem = new Item();
 	private MouseTextCache _mouseTextCache;
 	public int textBlinkerCount;
 	public int textBlinkerState;
 	public static string newWorldName = "";
 	private static Vector3 shimmerShine = new Vector3(1f, 0.5f, 1f);
-	private static int[] specX = new int[1000];
+	public static int[] specX = new int[1000];
-	private static int[] specY = new int[1000];
+	public static int[] specY = new int[1000];
 	public TilePaintSystemV2 TilePaintSystem;
 	public TileDrawing TilesRenderer;
 	public WallDrawing WallsRenderer;
@@ -2055,7 +_,7 @@
 	private bool _imeToggle;
 	private static int _lastHoveredLoadoutIndex = -1;
 	private List<int> _npcTypesThatAlreadyDrewAHead = new List<int>();
-	private int[] _npcIndexWhoHoldsHeadIndex = new int[81];
+	internal int[] _npcIndexWhoHoldsHeadIndex = new int[81];
 	private static List<string> _requiredObjecsForCraftingText = new List<string>();
 	private static bool _preventCraftingBecauseClickWasUsedToChangeFocusedRecipe;
 	private static int _currentRecipeBeingCrafted = -1;
@@ -2065,7 +_,7 @@
 	public static Microsoft.Xna.Framework.Color inventoryBack = new Microsoft.Xna.Framework.Color(220, 220, 220, 220);
 	public static bool mouseText;
 	private static int mH;
-	private static int rare;
+	public static int rare;
 	public static int hairStart;
 	private static int oldHairStyle;
 	private static Microsoft.Xna.Framework.Color oldHairColor;
@@ -2077,7 +_,7 @@
 	public static Player dresserInterfaceDummy;
 	private bool _needToSetupDrawInterfaceLayers = true;
 	private List<GameInterfaceLayer> _gameInterfaceLayers;
-	private static GameTime _drawInterfaceGameTime;
+	public static GameTime _drawInterfaceGameTime;
 	private byte instrumentMouseFixHack;
 	private static bool _settingsButtonIsPushedToSide;
 	private static bool _MouseOversCanClear;
@@ -2135,13 +_,13 @@
 	};
 	private static float backgroundLayerTransitionSpeed = 0.05f;
 	public static float atmo;
-	private static float bgScale = 1f;
+	internal static float bgScale = 1f;
-	private static int bgWidthScaled = (int)(1024f * bgScale);
+	internal static int bgWidthScaled = (int)(1024f * bgScale);
 	public static Microsoft.Xna.Framework.Color ColorOfTheSkies;
-	private static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsBase = Microsoft.Xna.Framework.Color.White;
+	internal static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsBase = Microsoft.Xna.Framework.Color.White;
-	private static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsModified = Microsoft.Xna.Framework.Color.White;
+	internal static Microsoft.Xna.Framework.Color ColorOfSurfaceBackgroundsModified = Microsoft.Xna.Framework.Color.White;
-	private float screenOff;
+	internal float screenOff;
-	private float scAdj;
+	internal float scAdj;
 	private float cTop;
 	private bool _isDrawingOrUpdating;
 	public static List<INeedRenderTargetContent> ContentThatNeedsRenderTargets = new List<INeedRenderTargetContent>();
@@ -2151,7 +_,7 @@
 	public static int starsHit = 0;
 	private static string _oldNetplayStatusText;
 	private static TextSnippet[] _netplayStatusTextSnippets;
-	public static int ladyBugRainBoost = 0;
+	public static double ladyBugRainBoost = 0;
 	private static bool _canShowMeteorFall;
 	private static bool _isResizingAndRemakingTargets = false;
 
@@ -2287,8 +_,16 @@
 	[Old("Transform is deprecated. Please use GameViewMatrix & GUIViewMatrix")]
 	public static Matrix Transform => GameViewMatrix.TransformationMatrix;
 
+	/// <summary>
+	/// Fetches the position of the mouse cursor on the screen.<br/>
+	/// Useful for making things visually happen near the cursor.<br/>
+	/// </summary>
 	public static Vector2 MouseScreen => new Vector2(mouseX, mouseY);
 
+	/// <summary>
+	/// Fetches the position of the mouse cursor in the world.<br/>
+	/// Useful for making things functionally happen near the cursor, such as projectile or NPC spawns.<br/>
+	/// </summary>
 	public static Vector2 MouseWorld {
 		get {
 			Vector2 result = MouseScreen + screenPosition;
@@ -2338,7 +_,7 @@
 
 	public static CreativeUnlocksTracker LocalPlayerCreativeTracker => player[myPlayer].creativeTracker;
 
-	public static int npcShop { get; private set; }
+	public static int npcShop { get; internal set; }
 
 	public static string playerPathName => ActivePlayerFileData.Path;
 
@@ -2845,6 +_,7 @@
 		}
 
 		result.X = num;
+		ItemLoader.HoldoutOffset(gravdir, itemtype, ref result);
 		return result;
 	}
 
@@ -2862,6 +_,12 @@
 		}
 	}
 
+	/// <summary>
+	/// Registers an animation for an item type to draw inside UI (not world or held item on player).
+	/// To enable its animation in the world, use ItemID.Sets.AnimatesAsSoul in conjunction with this
+	/// </summary>
+	/// <param name="index">Item type</param>
+	/// <param name="animation">Draw animation</param>
 	public static void RegisterItemAnimation(int index, DrawAnimation animation)
 	{
 		if (!itemAnimationsRegistered.Contains(index))
@@ -2910,6 +_,7 @@
 		}
 	}
 
+	/* Disabled, tML only supports HiDef
 	public static void SetGraphicsProfile(GraphicsProfile profile, bool forceSet)
 	{
 		if (_currentGraphicsProfile != profile || forceSet) {
@@ -2963,6 +_,7 @@
 				field.SetValue(field2.GetValue(null), 8192);
 		}
 	}
+	*/
 
 	public static void AnglerQuestSwap()
 	{
@@ -2977,6 +_,7 @@
 			flag2 = false;
 			anglerQuest = rand.Next(anglerQuestItemNetIDs.Length);
 			int num = anglerQuestItemNetIDs[anglerQuest];
+			//patch file: num, flag2
 			if (num == 2454 && (!hardMode || WorldGen.crimson))
 				flag2 = true;
 
@@ -3018,6 +_,8 @@
 
 			if ((num == 2476 || num == 2453 || num == 2473) && !flag)
 				flag2 = true;
+
+			ItemLoader.IsAnglerQuestAvailable(num, ref flag2);
 		}
 
 		NetMessage.SendAnglerQuest(-1);
@@ -3174,7 +_,8 @@
 	{
 		Utils.TryCreatingDirectory(SavePath);
 		try {
+			if (File.Exists(SavePath + Path.DirectorySeparatorChar + "servers.dat"))
-			File.SetAttributes(SavePath + Path.DirectorySeparatorChar + "servers.dat", FileAttributes.Normal);
+				File.SetAttributes(SavePath + Path.DirectorySeparatorChar + "servers.dat", FileAttributes.Normal);
 		}
 		catch {
 		}
@@ -3195,6 +_,8 @@
 
 	public static bool SaveSettings()
 	{
+		var resourcePacksArrayBackup = Configuration.Get<JArray>("ResourcePacks", null);
+
 		Configuration.Clear();
 		Configuration.Put("ResetDefaultUIScale", false);
 		Configuration.Put("SmartCursorToggle", cSmartCursorModeIsToggleAndNotHold);
@@ -3261,6 +_,7 @@
 		Configuration.Put("UseHeatDistortion", UseHeatDistortion);
 		Configuration.Put("WaveQuality", WaveQuality);
 		Configuration.Put("Support4K", Support4K);
+		Configuration.Put("Support8K", Support8K);
 		Configuration.Put("MouseColor", new Dictionary<string, byte> {
 			{ "R", mouseColor.R },
 			{ "G", mouseColor.G },
@@ -3278,8 +_,17 @@
 		Configuration.Put("Zoom", GameZoomTarget);
 		Configuration.Put("UIScale", _uiScaleWanted);
 		Configuration.Put("MapScale", MapScale);
+
+		//TML: A fix for resource packs randomly getting reset from AssetSourceController not yet being ready.
+		var resourcePacksArray = AssetSourceController?.ActiveResourcePackList.ToJson() ?? resourcePacksArrayBackup;
+
+		if (resourcePacksArray != null)
+			Configuration.Put("ResourcePacks", resourcePacksArray);
+
+		/*
 		if (AssetSourceController != null)
 			Configuration.Put("ResourcePacks", AssetSourceController.ActiveResourcePackList.ToJson());
+		*/
 
 		Configuration.Put("FlashIconForEvents", Enum.GetName(typeof(GameNotificationType), _flashNotificationType));
 		Configuration.Put("Display", _windowMover.ScreenDeviceName);
@@ -3289,6 +_,7 @@
 		Configuration.Put("HoverControlMode", Player.Settings.HoverControl);
 		Configuration.Put("WaterfallDrawLimit", instance.waterfallManager.maxWaterfallCount);
 		Configuration.Put("DisableIntenseVisualEffects", DisableIntenseVisualEffects);
+		ModLoader.ModLoader.SaveConfiguration();
 		if (Configuration.Save())
 			return PlayerInput.Save();
 
@@ -3330,6 +_,9 @@
 
 		IsInTheMiddleOfLoadingSettings = true;
 		Configuration.Load();
+
+		ChromaInitializer.ConfigInit(); // Added by TML, see description in the class.
+
 		int currentValue = 0;
 		Configuration.Get("LastLaunchedVersion", ref currentValue);
 		bool flag = false;
@@ -3373,8 +_,11 @@
 				screenBorderlessPendingResizes = 1;
 
 			SetDisplayMode(currentValue2, currentValue3, fullscreen: false);
+		}
+		else {
-			TryPickingDefaultUIScale(currentValue3);
+			FullscreenStartup();
 		}
+		TryPickingDefaultUIScale(graphics.GraphicsDevice.Adapter.CurrentDisplayMode.Height);
 
 		Configuration.Get("SmartCursorToggle", ref cSmartCursorModeIsToggleAndNotHold);
 		Configuration.Get("MapEnabled", ref mapEnabled);
@@ -3667,6 +_,7 @@
 			};
 		}
 
+		ModLoader.ModLoader.LoadConfiguration();
 		PlayerInput.Load();
 		if (currentValue < 165) {
 			try {
@@ -3679,8 +_,16 @@
 		mouseColorSlider.SetHSL(mouseColor);
 		mouseBorderColorSlider.SetHSL(MouseBorderColor);
 		mouseBorderColorSlider.Alpha = (float)(int)MouseBorderColor.A / 255f;
-		if (currentValue != 276)
+
+		DateTime now = DateTime.UtcNow;
+		// If you are a modder, and the current date is during the preview freeze, and the last notification wasn't this major.minor, then show the notification.
+		if (BuildInfo.IsStable && ModCompile.DeveloperMode && now.Day >= 21 && ModLoader.ModLoader.LastPreviewFreezeNotificationSeen != new System.Version(BuildInfo.tMLVersion.Major, BuildInfo.tMLVersion.Minor)) {
+			ModLoader.ModLoader.PreviewFreezeNotification = true;
+		}
+		if (currentValue != Main.curRelease || ModLoader.ModLoader.LastLaunchedTModLoaderVersion != BuildInfo.tMLVersion || (BuildInfo.Purpose == BuildInfo.BuildPurpose.Dev && ModLoader.ModLoader.LastLaunchedTModLoaderAlphaSha != BuildInfo.CommitSHA)) {
+			ModLoader.ModLoader.MigrateSettings();
 			SaveSettings();
+		}
 
 		IsInTheMiddleOfLoadingSettings = false;
 	}
@@ -3809,9 +_,11 @@
 			FileUtilities.Delete(PlayerList[i].Path, PlayerList[i].IsCloudSave);
 			FileUtilities.Delete(PlayerList[i].Path + ".bak", PlayerList[i].IsCloudSave);
 		}
+		//patch context
 		catch {
 		}
 
+		PlayerIO.ErasePlayer(PlayerList[i].Path, PlayerList[i].IsCloudSave);
 		try {
 			string text = PlayerList[i].Path.Substring(0, PlayerList[i].Path.Length - 4);
 			if (text.Substring(text.Length - 1) != "." && text.Substring(text.Length - 1) != "\\" && Directory.Exists(text))
@@ -3837,6 +_,7 @@
 				SocialAPI.Cloud.Delete(WorldList[i].Path);
 			}
 
+			WorldIO.EraseWorld(WorldList[i].Path, WorldList[i].IsCloudSave);
 			LoadWorlds();
 		}
 		catch {
@@ -3948,8 +_,10 @@
 						new FileInfo(text2);
 						autoGenFileLocation = text2;
 						ActiveWorldFileData = WorldFile.GetAllMetadata(text2, cloudSave: false);
+						ActiveWorldFileData ??= new();
 					}
 					catch {
+						ActiveWorldFileData = new();
 					}
 				}
 
@@ -4038,6 +_,12 @@
 				if (text.Length >= 10 && text.Substring(0, 10).ToLower() == "worldname=")
 					worldName = text.Substring(10);
 
+				if (text.Length >= 8 && text.Substring(0, 8).ToLower() == "modpath=")
+					ModOrganizer.modPath = text.Substring(8);
+
+				if (text.Length >= 8 && text.Substring(0, 8).ToLower() == "modpack=")
+					ModOrganizer.commandLineModPack = text.Substring(8);
+
 				if (text.Length >= 5 && text.Substring(0, 5).ToLower() == "seed=")
 					AutogenSeedName = text.Substring(5);
 
@@ -4101,7 +_,7 @@
 
 	public void SetWorld(string world, bool cloud)
 	{
-		ActiveWorldFileData = WorldFile.GetAllMetadata(world, cloud);
+		ActiveWorldFileData = WorldFile.GetAllMetadata(world, cloud) ?? new();
 	}
 
 	public void SetWorldName(string world)
@@ -4125,12 +_,37 @@
 		autoPass = true;
 	}
 
-	public void AutoJoin(string IP)
+	public void AutoJoin(string IP, string player = null)
 	{
 		defaultIP = IP;
 		getIP = IP;
 		Netplay.SetRemoteIP(defaultIP);
-		autoJoin = true;
+
+		ModLoader.ModLoader.OnSuccessfulLoad += () => {
+			IO.PlayerFileData fileData = null;
+			if (player is not null) {
+				if (System.IO.File.Exists(player)) {
+					fileData = Player.GetFileData(player, false);
+				}
+				else {
+					Main.LoadPlayers();
+					fileData = Main.PlayerList.FirstOrDefault(p => p.Name == player);
+				}
+			}
+
+			if (fileData is not null) {
+				fileData.SetAsActive();
+				Main.menuMode = 10;
+				Netplay.StartTcpClient();
+				return;
+			}
+
+			Main.OpenPlayerSelect(fileData => {
+				fileData.SetAsActive();
+				Main.menuMode = 10;
+				Netplay.StartTcpClient();
+			});
+		};
 	}
 
 	public void AutoHost()
@@ -4163,7 +_,7 @@
 	{
 		NeverSleep();
 		rand = new UnifiedRandom();
-		if (autoShutdown) {
+		if (autoShutdown && !showServerConsole) {
 			string lpWindowName = (Console.Title = "terraria" + rand.Next(int.MaxValue));
 			if (Platform.IsWindows) {
 				IntPtr intPtr = FindWindow(null, lpWindowName);
@@ -4172,17 +_,31 @@
 			}
 		}
 		else {
-			Console.Title = "Terraria Server " + versionNumber2;
+			Console.Title = "Terraria Server " + versionNumber2 + " - " + ModLoader.ModLoader.versionedName;
 		}
 
 		dedServ = true;
 		showSplash = false;
 		Initialize();
+
+		bool reloadMods;
+
+		do {
+			ModLoader.ModLoader.Reload();
+			DedServ_PostModLoad(out reloadMods);
+		}
+		while (reloadMods);
+	}
+	//The split and the boolean shenanigans are here to allow mods to hook into this method with MonoMod correctly. At any load-time.
+	private void DedServ_PostModLoad(out bool reloadMods)
+	{
+		reloadMods = false;
+
 		while (worldPathName == null || worldPathName == "") {
 			bool flag = true;
 			while (flag) {
 				LoadWorlds();
-				Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+				Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 				Console.WriteLine("");
 				for (int i = 0; i < WorldList.Count; i++) {
 					Console.WriteLine(i + 1 + "\t\t" + WorldList[i].Name);
@@ -4195,6 +_,8 @@
 				textValue2 = textValue2 + new string('\t', num - textValue2.Length / 8) + Language.GetTextValue("CLI.DeleteWorld_Description");
 				Console.WriteLine(textValue);
 				Console.WriteLine(textValue2);
+				Console.WriteLine("m\t\tMods Menu");
+				Console.WriteLine("b\t\tMod Browser");
 				Console.WriteLine("");
 				Console.Write(Language.GetTextValue("CLI.ChooseWorld"));
 				string text2 = ReadLineInput();
@@ -4212,7 +_,7 @@
 						int length = Language.GetTextValue("CLI.DeleteWorld_Command").Length;
 						int num2 = Convert.ToInt32(text2.Substring(length + 1)) - 1;
 						if (num2 < WorldList.Count) {
-							Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+							Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 							Console.WriteLine("");
 							Console.WriteLine(Language.GetTextValue("CLI.DeleteConfirmation", WorldList[num2].Name));
 							Console.Write("({0}/{1}): ", Language.GetTextValue("CLI.ShortYes"), Language.GetTextValue("CLI.ShortNo"));
@@ -4235,7 +_,7 @@
 				if (text2 == "n" || text2 == "N") {
 					bool flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("UI.WorldSizeSmall"));
 						Console.WriteLine("2\t" + Language.GetTextValue("UI.WorldSizeMedium"));
@@ -4274,7 +_,7 @@
 
 					flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("UI.Normal"));
 						Console.WriteLine("2\t" + Language.GetTextValue("UI.Expert"));
@@ -4315,7 +_,7 @@
 
 					flag2 = true;
 					while (flag2) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.WriteLine("1\t" + Language.GetTextValue("CLI.Random"));
 						Console.WriteLine("2\t" + Language.GetTextValue("CLI.Corrupt"));
@@ -4350,7 +_,7 @@
 					}
 
 					flag2 = true;
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					while (flag2) {
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.EnterWorldName"));
@@ -4382,7 +_,7 @@
 
 					string text3 = "";
 					flag2 = true;
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					while (flag2) {
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.EnterSeed"));
@@ -4446,6 +_,19 @@
 
 					continue;
 				}
+				else if (text2 == "m" || text2 == "M") {
+					Interface.ServerModMenu(out reloadMods);
+
+					if (reloadMods) {
+						return;
+					}
+
+					continue;
+				}
+				else if (text2 == "b" || text2 == "b") {
+					Interface.ServerModBrowserMenu();
+					continue;
+				}
 
 				try {
 					int num3 = Convert.ToInt32(text2);
@@ -4455,7 +_,7 @@
 
 					bool flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.SetInitialMaxPlayers"));
 						string text4 = ReadLineInput();
@@ -4483,7 +_,7 @@
 
 					flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.SetInitialPort"));
 						string text5 = ReadLineInput();
@@ -4509,7 +_,7 @@
 
 					flag3 = true;
 					while (flag3) {
-						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+						Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 						Console.WriteLine("");
 						Console.Write(Language.GetTextValue("CLI.AutomaticPortForward", Language.GetTextValue("CLI.ShortYes"), Language.GetTextValue("CLI.ShortNo")));
 						string text6 = ReadLineInput();
@@ -4533,7 +_,7 @@
 						}
 					}
 
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber2) + " - " + ModLoader.ModLoader.versionedName);
 					Console.WriteLine("");
 					Console.Write(Language.GetTextValue("CLI.EnterServerPassword"));
 					Netplay.ServerPassword = ReadLineInput();
@@ -4556,6 +_,7 @@
 		catch {
 		}
 
+		myPlayer = 255;
 		Task task2 = WorldGen.serverLoadWorld();
 		Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber));
 		Console.WriteLine("");
@@ -4578,6 +_,10 @@
 		catch {
 		}
 
+		//run one tick to JIT all the game content now rather than when a player connects
+		Logging.ServerConsoleLine("Running one update...");
+		Logging.tML.Info($"Server starting with AllowVanillaClients set to {ModNet.AllowVanillaClients}");
+		Update(new GameTime());
 		if (WorldGen.loadFailed || !WorldGen.loadSuccess) {
 			WriteFancyWorldLoadErrorToConsole();
 			if (!autoShutdown)
@@ -4589,28 +_,23 @@
 
 		Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber));
 		Console.WriteLine("");
-		Console.WriteLine(Language.GetTextValue("CLI.ListeningOnPort", Netplay.ListenPort));
+		Logging.ServerConsoleLine(Language.GetTextValue("CLI.ListeningOnPort", Netplay.ListenPort));
 		Console.WriteLine(Language.GetTextValue("CLI.HelpHint"));
 		Console.WriteLine("");
 		Console.Title = "Terraria Server: " + worldName;
 		Stopwatch stopwatch = new Stopwatch();
-		if (!autoShutdown)
+		if (!autoShutdown || showServerConsole)
 			startDedInput();
 
 		stopwatch.Start();
-		double num6 = 16.666666666666668;
-		double num7 = 0.0;
-		int num8 = 0;
-		new Stopwatch().Start();
 		Netplay.StartServer();
+		AddSignalTraps();
 		gameMenu = false;
+		double delta = 1000 / 60D;
+		double target = delta;
 		while (!Netplay.Disconnect) {
-			double totalMilliseconds = stopwatch.Elapsed.TotalMilliseconds;
-			if (totalMilliseconds + num7 >= num6) {
-				num8++;
-				num7 += totalMilliseconds - num6;
-				stopwatch.Reset();
-				stopwatch.Start();
+			ServerHangWatchdog.Checkin();
+			{
 				if (oldStatusText != statusText) {
 					oldStatusText = statusText;
 					Console.WriteLine(statusText);
@@ -4624,6 +_,7 @@
 				if (Main.OnTickForThirdPartySoftwareOnly != null)
 					Main.OnTickForThirdPartySoftwareOnly();
 
+				/*
 				double num9 = stopwatch.Elapsed.TotalMilliseconds + num7;
 				if (num9 < num6) {
 					int num10 = (int)(num6 - num9) - 1;
@@ -4638,6 +_,16 @@
 			}
 
 			Thread.Sleep(0);
+			*/
+
+				double now = stopwatch.ElapsedMilliseconds;
+				double remaining = target - now;
+				target += delta; //new target
+				if (target < now) //can't catch up, reset target
+					target = now + delta;
+
+				Thread.Sleep(Math.Max((int)remaining, 0));
+			}
 		}
 
 		if (Netplay.SaveOnServerExit) {
@@ -4645,6 +_,7 @@
 			WorldFile.SaveWorld();
 		}
 
+		SystemLoader.OnWorldUnload();
 		YouCanSleepNow();
 	}
 
@@ -4665,8 +_,20 @@
 	public static void startDedInputCallBack()
 	{
 		while (!Netplay.Disconnect) {
+			string text = Console.ReadLine();// ReadLineInput();
+			if (text == null) { // Fix for #2644 where Docker would steal lines from the active console.
+				Logging.tML.Warn("Console input not connected, ignoring...");
+				break;
+			}
+
+			ExecuteCommand(text, new ConsoleCommandCaller());
+		}
+	}
+
+	public static void ExecuteCommand(string text, CommandCaller commandCaller)
+	{
+		do { // use a do {...} while (false); loop so we don't have to change all the continue; statements to return; when moving the loop body into a separate function
 			Console.Write(": ");
-			string text = ReadLineInput();
 			string text2 = text;
 			text = text.ToLower();
 			try {
@@ -4706,12 +_,21 @@
 							num = text3.Length;
 					}
 
+					var modHelpList = CommandLoader.GetHelp(CommandType.Console);
+					foreach (var entry in modHelpList)
+						if (entry.Item1.Length > num)
+							num = entry.Item1.Length;
+
 					int num2 = (num + 1) / 8;
 					for (int j = 0; j < list.Count; j++) {
 						string text4 = (Language.Exists("CLI." + list[j] + "_Example") ? Language.GetTextValue("CLI." + list[j] + "_Example") : Language.GetTextValue("CLI." + list[j] + "_Command"));
 						Console.WriteLine(text4 + new string('\t', num2 - text4.Length / 8) + Language.GetTextValue("CLI." + list[j] + "_Description"));
 					}
+
+					foreach (var entry in modHelpList)
+						Console.WriteLine(entry.Item1 + new string('\t', num2 - entry.Item1.Length / 8) + entry.Item2);
 				}
+				else if (CommandLoader.HandleCommand(text, commandCaller)) { }
 				else if (text == Language.GetTextValue("CLI.Settle_Command")) {
 					if (!Liquid.panicMode)
 						Liquid.StartPanic();
@@ -4796,11 +_,12 @@
 					Console.WriteLine(Language.GetTextValue("CLI.Port", Netplay.ListenPort));
 				}
 				else if (text == Language.GetTextValue("CLI.Version_Command")) {
-					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber));
+					Console.WriteLine(Language.GetTextValue("CLI.Server", versionNumber) + " - " + ModLoader.ModLoader.versionedName);
 				}
 				else if (text == Language.GetTextValue("CLI.Clear_Command")) {
 					try {
 						Console.Clear();
+						Logging.ResetPastExceptions(); // "CLI.Clear_Command" above.
 					}
 					catch {
 					}
@@ -4923,6 +_,7 @@
 				Console.WriteLine(Language.GetTextValue("CLI.InvalidCommand"));
 			}
 		}
+		while (false);
 	}
 
 	private static string ReadLineInput()
@@ -4976,7 +_,8 @@
 		if (IsFastForwardingTime()) {
 			dayRate = 60;
 			desiredWorldTilesUpdateRate = 1;
-			return;
+			desiredWorldEventsUpdateRate = 60;
+			goto endVanillaMethod;
 		}
 
 		bool enabled = CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled;
@@ -4991,10 +_,17 @@
 
 		dayRate = num;
 		desiredWorldTilesUpdateRate = num;
+		desiredWorldEventsUpdateRate = num;
 		if (gameMenu) {
 			dayRate = 1;
 			desiredWorldTilesUpdateRate = 1;
+			desiredWorldEventsUpdateRate = 1;
 		}
+
+		endVanillaMethod:
+		SystemLoader.ModifyTimeRate(ref dayRate, ref desiredWorldTilesUpdateRate, ref desiredWorldEventsUpdateRate);
+		if (dayRate > 86400)
+			dayRate = 86400;
 	}
 
 	public Main() : base(headlessMode: dedServ)
@@ -5006,7 +_,9 @@
 			Map = new WorldMap(maxTilesX, maxTilesY);
 			Configuration.Load();
 			graphics = new GraphicsDeviceManager(((object)this) as Game);
-			base.Content.RootDirectory = "Content";
+			//base.Content.RootDirectory = "Content";
+			graphics.GraphicsProfile = GraphicsProfile.HiDef; // use HiDef by default for tML.
+			FNALogging.GraphicsInit(graphics);
 		}
 	}
 
@@ -5032,6 +_,7 @@
 		if (!dedServ) {
 			_cachedTitle = Lang.GetRandomGameTitle();
 			Platform.Get<IWindowService>().SetUnicodeTitle(base.Window, _cachedTitle);
+			Platform.Get<IWindowService>().SetIcon(base.Window);
 		}
 	}
 
@@ -5078,6 +_,8 @@
 
 	protected override void Initialize()
 	{
+		InitTMLContentManager();
+
 		musicFade[50] = 1f;
 		if (dedServ)
 			netMode = 2;
@@ -5125,11 +_,15 @@
 		SceneMetrics = new SceneMetrics();
 		if (dedServ) {
 			Initialize_AlmostEverything();
+			// Allow keeping tml configs on/for server
+			Configuration.Load();
+			ModLoader.ModLoader.LoadConfiguration();
 			return;
 		}
 
 		TimeLogger.Initialize();
-		LoadContent_TryEnteringHiDef();
+		// LoadContent_TryEnteringHiDef();
+		// HiDef graphics profile set in Main ctor
 		ClientInitialize();
 		base.Initialize();
 	}
@@ -9036,13 +_,20 @@
 	{
 	}
 
-	private void OnceFailedLoadingAnAsset(string assetPath, Exception e)
+	internal static void OnceFailedLoadingAnAsset(string assetPath, Exception e)
 	{
+		Logging.Terraria.Error($"Failed to load asset: \"{assetPath}\"", e);
 		FancyErrorPrinter.ShowFailedToLoadAssetError(e, assetPath);
 	}
 
 	protected override void LoadContent()
 	{
+		//Added by TML.
+		Asset<Texture2D>.DefaultValue = new Texture2D(base.GraphicsDevice, 1, 1) {
+			Name = "Asynchronously-loaded Asset Dummy Texture (do not dispose or modify!)"
+		};
+		Asset<Texture2D>.DefaultValue.SetData(new Color[] { Color.Transparent }); // AMD graphics cards on Linux/Mac don't initialize textures to transparent by default (#1918)
+
 		SoundEngine.Initialize();
 		if (base.Services.Get<IAssetRepository>() == null)
 			AssetInitializer.CreateAssetServices(base.Services);
@@ -9066,7 +_,7 @@
 			audioSystem = new DisabledAudioSystem();
 
 		AssetSourceController = new AssetSourceController(Assets, new IContentSource[1] {
-			new XnaContentSource(base.Content.RootDirectory)
+			new XnaDirectContentSource(base.Content.RootDirectory)
 		});
 
 		VanillaContentValidator.Instance = new VanillaContentValidator("Terraria.IO.Data.ResourcePacksDefaultInfo.tsv");
@@ -9078,8 +_,11 @@
 		AssetInitializer.LoadSplashAssets(asyncLoadForSounds: true);
 		ChromaInitializer.Load();
 		_gameContentLoadProcess = LoadContent_Deferred();
+
+		ModLoader.ModLoader.PrepareAssets();
 	}
 
+	/*
 	private void LoadContent_TryEnteringHiDef()
 	{
 		Configuration.Load();
@@ -9094,6 +_,7 @@
 		else if (Program.IsFna)
 			SetGraphicsProfile(GraphicsProfile.HiDef, forceSet: true);
 	}
+	*/
 
 	protected IEnumerator LoadContent_Deferred()
 	{
@@ -9586,6 +_,9 @@
 
 				if (SceneMetrics.ActiveMusicBox == 87)
 					newMusic = 91;
+
+				if (SceneMetrics.ActiveMusicBox >= maxMusic)
+					newMusic = SceneMetrics.ActiveMusicBox;
 			}
 
 			if (gameMenu || musicVolume == 0f) {
@@ -9611,12 +_,12 @@
 					curMusic = 0;
 				}
 
-				if (NPC.MoonLordCountdown == 1 && curMusic >= 1 && curMusic < 92)
+				if (NPC.MoonLordCountdown == 1 && curMusic >= 1 && curMusic < musicFade.Length)
 					musicFade[curMusic] = 0f;
 			}
 
 			bool isMainTrackAudible = musicFade[curMusic] > 0.25f;
-			for (int i = 1; i < 92; i++) {
+			for (int i = 1; i < musicFade.Length; i++) {
 				float num2 = musicFade[i] * musicVolume * num;
 				if (i >= 62 && i <= 88) {
 					num2 *= 0.9f;
@@ -9856,7 +_,7 @@
 						break;
 				}
 
-				if (NPCID.Sets.BelongsToInvasionOldOnesArmy[npc[i].type])
+				if (npc[i].type < NPCID.Sets.BelongsToInvasionOldOnesArmy.Length && NPCID.Sets.BelongsToInvasionOldOnesArmy[npc[i].type])
 					num2 = 12;
 
 				if (remixWorld && getGoodWorld && (npc[i].type == 127 || npc[i].type == 134 || npc[i].type == 125 || npc[i].type == 126))
@@ -9865,11 +_,16 @@
 				if (num2 == 0 && npc[i].boss)
 					num2 = 1;
 
-				if (num2 == 0)
+				if (num2 == 0 && (npc[i].ModNPC == null || npc[i].ModNPC.Music < 0))
 					continue;
 
 				Microsoft.Xna.Framework.Rectangle value = new Microsoft.Xna.Framework.Rectangle((int)(npc[i].position.X + (float)(npc[i].width / 2)) - num, (int)(npc[i].position.Y + (float)(npc[i].height / 2)) - num, num * 2, num * 2);
 				if (rectangle.Intersects(value)) {
+					//TODO: Implement modMusic and modPriority
+					//if (npc[i].modNPC != null && npc[i].modNPC.music >= 0 && (modMusic < 0 || npc[i].modNPC.SceneEffectPriority > modPriority)) {
+					//modMusic = npc[i].modNPC.music;
+					//modPriority = npc[i].modNPC.SceneEffectPriority;
+					//}
 					switch (num2) {
 						case 1:
 							flag = true;
@@ -10184,7 +_,10 @@
 		if (lastMusicPlayed == 50)
 			musicNoCrossFade[51] = true;
 
-		if (!showSplash) {
+		int modMusic = -1;
+		ModLoader.SceneEffectPriority modPriority = ModLoader.SceneEffectPriority.None;
+
+		if (!gameMenu) { // showSplash -> gameMenu. Fix crash iterating active NPCs while unloading mods
 			Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)screenPosition.X, (int)screenPosition.Y, screenWidth, screenHeight);
 			int num2 = 5000;
 			for (int j = 0; j < 200; j++) {
@@ -10305,6 +_,11 @@
 
 				Microsoft.Xna.Framework.Rectangle value = new Microsoft.Xna.Framework.Rectangle((int)(npc[j].position.X + (float)(npc[j].width / 2)) - num2, (int)(npc[j].position.Y + (float)(npc[j].height / 2)) - num2, num2 * 2, num2 * 2);
 				if (rectangle.Intersects(value)) {
+					//TODO: Should this be wrapped inside the new SceneEffect stuff? Not at this time, left for legacy.
+					if (npc[j].ModNPC != null && npc[j].ModNPC.Music >= 0 && (modMusic < 0 || npc[j].ModNPC.SceneEffectPriority > modPriority)) {
+						modMusic = npc[j].ModNPC.Music;
+						modPriority = npc[j].ModNPC.SceneEffectPriority;
+					}
 					switch (num3) {
 						case 1:
 							flag = true;
@@ -10362,6 +_,8 @@
 					break;
 				}
 			}
+
+			LoaderManager.Get<SceneEffectLoader>().UpdateMusic(ref modMusic, ref modPriority);
 		}
 
 		_ = (screenPosition.X + (float)(screenWidth / 2)) / 16f;
@@ -10387,13 +_,11 @@
 				else if (WorldGen.tenthAnniversaryWorldGen) {
 					newMusic = 11;
 				}
-				else if (playOldTile) {
-					newMusic = 6;
-				}
-				else if (!_isAsyncLoadComplete) {
-					newMusic = 50;
-				}
-				else if (!audioSystem.IsTrackPlaying(50)) {
+				else {
+					newMusic = MenuLoader.CurrentMenu.Music;
+				}
+
+				if (_isAsyncLoadComplete && newMusic == 50 && !audioSystem.IsTrackPlaying(50)) {
 					newMusic = 51;
 					if (musicNoCrossFade[51])
 						musicFade[51] = 1f;
@@ -10412,12 +_,18 @@
 		if (CreditsRollEvent.IsEventOngoing) {
 			newMusic = 89;
 		}
+		else if (modPriority >= SceneEffectPriority.BossHigh) { //Should this be before credits or nah?
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].happyFunTorchTime) {
 			newMusic = 13;
 		}
 		else if (flag8) {
 			newMusic = 38;
 		}
+		else if (modPriority >= SceneEffectPriority.BossMedium) {
+			newMusic = modMusic;
+		}
 		else if (flag17) {
 			newMusic = 81;
 		}
@@ -10430,6 +_,9 @@
 		else if (flag7) {
 			newMusic = 24;
 		}
+		else if (modPriority >= SceneEffectPriority.BossLow) {
+			newMusic = modMusic;
+		}
 		else if (flag15) {
 			newMusic = 57;
 		}
@@ -10451,6 +_,9 @@
 		else if (flag6) {
 			newMusic = 25;
 		}
+		else if (modPriority >= SceneEffectPriority.Event) {
+			newMusic = modMusic;
+		}
 		else if (flag14) {
 			newMusic = 56;
 		}
@@ -10466,6 +_,9 @@
 		else if (flag13) {
 			newMusic = 41;
 		}
+		else if (modPriority >= SceneEffectPriority.Environment) {
+			newMusic = modMusic;
+		}
 		else if (eclipse && !remixWorld && (double)player[myPlayer].position.Y < worldSurface * 16.0 + (double)(screenHeight / 2)) {
 			newMusic = 27;
 		}
@@ -10499,6 +_,9 @@
 		else if (num5 < 1f) {
 			newMusic = (dayTime ? 42 : 15);
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeHigh) {
+			newMusic = modMusic;
+		}
 		else if (tile[(int)(player[myPlayer].Center.X / 16f), (int)(player[myPlayer].Center.Y / 16f)].wall == 87) {
 			newMusic = 26;
 		}
@@ -10528,6 +_,9 @@
 			else
 				newMusic = 16;
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeMedium) {
+			newMusic = modMusic;
+		}
 		else if (player[myPlayer].ZoneMeteor) {
 			newMusic = 2;
 		}
@@ -10638,6 +_,9 @@
 			else
 				newMusic = 52;
 		}
+		else if (modPriority >= SceneEffectPriority.BiomeLow) {
+			newMusic = modMusic;
+		}
 		else if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			if (bloodMoon) {
 				newMusic = 2;
@@ -10851,12 +_,12 @@
 		float num3 = Math.Max(1f, 1f + 4f * cloudAlpha);
 		if (cloudBGActive > 0f) {
 			if (cloudBGActive > 1f)
-				cloudBGActive -= (float)dayRate / num3;
+				cloudBGActive -= (float)desiredWorldEventsUpdateRate / num3;
 
 			if (cloudBGActive < 1f)
 				cloudBGActive = 1f;
 
-			if (cloudBGActive == 1f && rand.Next((int)((float)(num2 * 2 / Math.Max(dayRate, 1)) * num3)) == 0) {
+			if (cloudBGActive == 1f && rand.NextDouble() <= desiredWorldEventsUpdateRate / (num2 * 2 * num3)) {
 				cloudBGActive = -rand.Next(num2 * 4, num * 4);
 				if (netMode == 2)
 					NetMessage.SendData(7);
@@ -10866,15 +_,15 @@
 		}
 
 		if (cloudBGActive < 0f) {
-			cloudBGActive += (float)dayRate * num3;
+			cloudBGActive += (float)desiredWorldEventsUpdateRate * num3;
 			if (raining)
-				cloudBGActive += (float)(2 * dayRate) * num3;
+				cloudBGActive += (float)(2 * desiredWorldEventsUpdateRate) * num3;
 		}
 
 		if (cloudBGActive > 0f)
 			cloudBGActive = 0f;
 
-		if (cloudBGActive == 0f && rand.Next((int)((float)(num2 * 12 / ((dayRate == 0) ? 1 : dayRate)) / num3)) == 0) {
+		if (cloudBGActive == 0f && rand.NextDouble() <= num3 * desiredWorldEventsUpdateRate / (num2 * 12)) {
 			cloudBGActive = rand.Next(num2 * 3, num * 2);
 			if (netMode == 2)
 				NetMessage.SendData(7);
@@ -11084,6 +_,9 @@
 		}
 	}
 
+	// Added by TML, used below.
+	private static SlotId waterfallSoundSlot, lavafallSoundSlot;
+
 	public static void Ambience()
 	{
 		ambientCounter++;
@@ -11092,6 +_,35 @@
 
 		ambientCounter = 0;
 		Microsoft.Xna.Framework.Point point = LocalPlayer.Center.ToPoint();
+
+		// Added by TML. Improves handling of waterfall and lavafall sounds for the new unified audio system.
+		static void HandleAmbientSound(in SoundStyle soundStyle, ref SlotId slot, float volume, Vector2 position) {
+			SoundEngine.TryGetActiveSound(slot, out var activeSound);
+
+			if (volume > 0f) {
+				if (activeSound == null) {
+					slot = SoundEngine.PlaySound(soundStyle, position);
+
+					if (!SoundEngine.TryGetActiveSound(slot, out activeSound)) {
+						return;
+					}
+				}
+
+				activeSound.Volume = volume;
+				activeSound.Position = position;
+			}
+			else if (activeSound != null) {
+				activeSound.Stop();
+
+				slot = SlotId.Invalid;
+			}
+		}
+
+		float usedWaterVolume = MathHelper.Clamp((ambientWaterfallStrength / 50f) * (1f - Main.shimmerAlpha), 0f, 1f);
+
+		HandleAmbientSound(in SoundID.Waterfall, ref waterfallSoundSlot, usedWaterVolume, new Vector2(ambientWaterfallX, ambientWaterfallY));
+
+		/*
 		if (ambientWaterfallStrength > 0f) {
 			SoundEngine.PlaySound(34, (int)ambientWaterfallX, (int)ambientWaterfallY, (int)ambientWaterfallStrength);
 			_isWaterfallMusicPlaying = true;
@@ -11102,6 +_,7 @@
 
 			_isWaterfallMusicPlaying = false;
 		}
+		*/
 
 		float num = Math.Abs(ambientLavaX - (screenPosition.X + (float)(screenWidth / 2))) + Math.Abs(ambientLavaY - (screenPosition.Y + (float)(screenHeight / 2)));
 		float num2 = Math.Abs(ambientLavafallX - (screenPosition.X + (float)(screenWidth / 2))) + Math.Abs(ambientLavafallY - (screenPosition.Y + (float)(screenHeight / 2)));
@@ -11113,6 +_,15 @@
 		}
 
 		float num5 = ambientLavafallStrength + ambientLavaStrength;
+		// Vanilla uses the above local for adjusting lava sounds' volume, but only uses lavafall strength when checking if the sound should be playing at all.
+		// This has been confirmed as intentional.
+		float usedLavaVolume = ambientLavaStrength > 0f
+			? MathHelper.Clamp(num5 / 50f, 0f, 1f)
+			: 0f;
+
+		HandleAmbientSound(in SoundID.Lavafall, ref lavafallSoundSlot, usedLavaVolume, new Vector2(num3, num4));
+
+		/*
 		if (ambientLavafallStrength > 0f) {
 			SoundEngine.PlaySound(35, (int)num3, (int)num4, (int)num5);
 			_isLavafallMusicPlaying = true;
@@ -11123,6 +_,7 @@
 			SoundEngine.PlaySound(35, point.X, point.Y, 0);
 
 		_isLavafallMusicPlaying = false;
+		*/
 	}
 
 	public static void AnimateTiles_CritterCages()
@@ -13333,11 +_,16 @@
 
 	public static void DoUpdate_AnimateItemIcons()
 	{
+		//Lock the collection to avoid race conditions during mod loading & unloading.
+		Monitor.Enter(itemAnimationsRegistered);
+
 		for (int i = 0; i < itemAnimationsRegistered.Count; i++) {
 			int num = itemAnimationsRegistered[i];
 			if (itemAnimations[num] != null)
 				itemAnimations[num].Update();
 		}
+
+		Monitor.Exit(itemAnimationsRegistered);
 	}
 
 	public static void QueueMainThreadAction(Action action)
@@ -13364,7 +_,14 @@
 
 		if (!_isDrawingOrUpdating) {
 			_isDrawingOrUpdating = true;
+
+			try {
-			DoUpdate(ref gameTime);
+				DoUpdate(ref gameTime);
+			}
+			catch (Exception e) {
+				Logging.Terraria.Error(e);
+			}
+
 			CinematicManager.Instance.Update(gameTime);
 			if (netMode == 2) {
 				for (int i = 0; i < 256; i++) {
@@ -13677,6 +_,9 @@
 
 				mouseLeftRelease = false;
 				mouseRightRelease = false;
+				mouseMiddleRelease = false;
+				mouseXButton1Release = false;
+				mouseXButton2Release = false;
 				if (gameMenu)
 					UpdateMenu();
 
@@ -13738,6 +_,8 @@
 
 		if (CanPauseGame()) {
 			DoUpdate_WhilePaused();
+			PlayerLoader.UpdateAutopause(player[myPlayer]);
+
 			gamePaused = true;
 			return;
 		}
@@ -13759,10 +_,16 @@
 		if (netMode != 1)
 			updateCloudLayer();
 
+		if (desiredWorldEventsUpdateRate <= 0)
+			goto skipWeatherUpdates;
+
+		timePass += desiredWorldEventsUpdateRate;
-		for (int i = 0; i < dayRate; i++) {
+		for (int i = 1; i <= (int)timePass; i++) {
 			UpdateWeather(gameTime, i);
 		}
+		timePass %= 1.0;
 
+		skipWeatherUpdates:
 		UnpausedUpdateSeed = Utils.RandomNextSeed(UnpausedUpdateSeed);
 		Ambience();
 		if (netMode != 2) {
@@ -13777,6 +_,7 @@
 			Sandstorm.EmitDust();
 		}
 
+		SystemLoader.PreUpdateEntities();
 		if (netMode != 2) {
 			if ((double)screenPosition.Y < worldSurface * 16.0 + 16.0) {
 				Star.UpdateStars();
@@ -13838,7 +_,7 @@
 		bool flag = false;
 		if (netMode == 0) {
 			flag |= ingameOptionsWindow;
-			flag |= InGameUI.IsVisible && (InGameUI.CurrentState == ManageControlsMenu || InGameUI.CurrentState == AchievementsMenu);
+			flag |= InGameUI.IsVisible && (InGameUI.CurrentState == ManageControlsMenu || InGameUI.CurrentState == AchievementsMenu || InGameUI.CurrentState == Interface.modConfigList || InGameUI.CurrentState == Interface.modConfig);
 			if (autoPause) {
 				flag |= playerInventory;
 				flag |= LocalPlayer.sign >= 0;
@@ -13879,6 +_,10 @@
 		if (playerInventory) {
 			Main.player[myPlayer].RefreshInfoAccs();
 			Recipe.GetThroughDelayedFindRecipes();
+
+			if (PlayerInput.MouseInModdedUI.Count != 0)
+				goto noScrollOnLocked;
+
 			int num = PlayerInput.ScrollWheelDelta / 120;
 			bool flag = true;
 			if (recBigList) {
@@ -13919,6 +_,9 @@
 					focusRecipe = 0;
 			}
 
+		noScrollOnLocked:
+			PlayerInput.MouseInModdedUI.Clear();
+
 			Main.player[myPlayer].dropItemCheck();
 		}
 
@@ -13963,7 +_,13 @@
 			InGameUI.Update(gameTime);
 
 		CreativeMenu.Update(gameTime);
+		SystemLoader.UpdateUI(gameTime);
+		PlayerInput.ScrollWheelDeltaForUI = 0; //TODO: Should this be before PlayerInput.ResetInputsOnActiveStateChange()?
+
+		BossBarLoader.HandleStyle(); //Has to be outside of the !gameMenu check because it deals with switching and saving the boss style in menus, including the main menu
+
+		if (!gameMenu) //Don't update IBigProgressBars in the main menu to avoid IOOB during unload when modded NPCs were alive --direwolf420
-		BigBossProgressBar.Update();
+			BigBossProgressBar.Update();
 	}
 
 	private void DoDebugFunctions()
@@ -14049,6 +_,9 @@
 		if ((byte)Main.player[myPlayer].zone5 != (byte)player.zone5)
 			flag = true;
 
+		if (!BiomeLoader.CustomBiomesMatch(Main.player[myPlayer], player))
+			flag = true;
+
 		if (flag)
 			NetMessage.SendData(36, -1, -1, null, myPlayer);
 
@@ -14077,7 +_,7 @@
 		}
 
 		bool flag2 = false;
-		for (int j = 0; j < 44; j++) {
+		for (int j = 0; j < Player.MaxBuffs; j++) {
 			if (Main.player[myPlayer].buffType[j] != player.buffType[j]) {
 				flag2 = true;
 				break;
@@ -14109,6 +_,8 @@
 		if (syncedAnyInventoryContents)
 			NetMessage.SendData(138);
 
+		PlayerLoader.SendClientChanges(Main.player[myPlayer], clientPlayer);
+
 		clientPlayer = Main.player[myPlayer].clientClone();
 	}
 
@@ -14128,6 +_,9 @@
 	{
 		UpdateParticleSystems();
 		tileSolid[379] = false;
+
+		SystemLoader.PreUpdatePlayers();
+
 		int num = 0;
 		int num2 = 0;
 		sittingManager.ClearPlayerAnchors();
@@ -14161,7 +_,12 @@
 			}
 		}
 
+		SystemLoader.PostUpdatePlayers();
+
 		_gameUpdateCount++;
+
+		SystemLoader.PreUpdateNPCs();
+
 		NPC.RevengeManager.Update();
 		if (netMode != 1) {
 			if (remixWorld)
@@ -14236,9 +_,15 @@
 			else {
 				npc[l].UpdateNPC(l);
 			}
+
+			IEntitySource.ClearFallbacks();
 		}
 
 		CurrentFrameFlags.AnyActiveBossNPC = anyActiveBossNPC;
+
+		SystemLoader.PostUpdateNPCs();
+		SystemLoader.PreUpdateGores();
+
 		for (int m = 0; m < 600; m++) {
 			if (ignoreErrors) {
 				try {
@@ -14253,6 +_,9 @@
 			}
 		}
 
+		SystemLoader.PostUpdateGores();
+		SystemLoader.PreUpdateProjectiles();
+
 		LockOnHelper.SetUP();
 		CurrentFrameFlags.HadAnActiveInteractibleProjectile = false;
 		PreUpdateAllProjectiles();
@@ -14274,6 +_,10 @@
 		ProjectileUpdateLoopIndex = -1;
 		PostUpdateAllProjectiles();
 		LockOnHelper.SetDOWN();
+
+		SystemLoader.PostUpdateProjectiles();
+		SystemLoader.PreUpdateItems();
+
 		Item.numberOfNewItems = 0;
 		for (int num4 = 0; num4 < 400; num4++) {
 			if (ignoreErrors) {
@@ -14289,6 +_,9 @@
 			}
 		}
 
+		SystemLoader.PostUpdateItems();
+		SystemLoader.PreUpdateDusts();
+
 		if (ignoreErrors) {
 			try {
 				Dust.UpdateDust();
@@ -14304,11 +_,15 @@
 			Dust.UpdateDust();
 		}
 
+		SystemLoader.PostUpdateDusts();
+
 		if (netMode != 2) {
 			CombatText.UpdateCombatText();
 			PopupText.UpdateItemText();
 		}
 
+		SystemLoader.PreUpdateTime();
+
 		if (ignoreErrors) {
 			try {
 				UpdateTime();
@@ -14321,6 +_,8 @@
 			UpdateTime();
 		}
 
+		SystemLoader.PostUpdateTime();
+
 		tileSolid[379] = true;
 		if (gameMenu && netMode != 2)
 			return;
@@ -14361,6 +_,7 @@
 				UpdateClient();
 		}
 
+		SystemLoader.PostUpdateEverything();
 		chatMonitor.Update();
 		upTimer = (float)sw.Elapsed.TotalMilliseconds;
 		if (upTimerMaxDelay > 0f)
@@ -14554,7 +_,8 @@
 		if (!inputTextEnter || !chatRelease)
 			return;
 
-		if (chatText != "") {
+		var handled = chatText.Length > 0 && chatText[0] == '/' && CommandLoader.HandleCommand(chatText, new ChatCommandCaller());
+		if (chatText != "" && !handled) {
 			ChatMessage message = ChatManager.Commands.CreateOutgoingMessage(chatText);
 			if (netMode == 1)
 				ChatHelper.SendChatMessageFromClient(message);
@@ -14571,6 +_,7 @@
 	private void DoUpdate_HandleInput()
 	{
 		PlayerInput.UpdateInput();
+		SystemLoader.PostUpdateInput();
 		UpdateViewZoomKeys();
 		PlayerInput.SetZoom_Unscaled();
 		UILinkPointNavigator.Update();
@@ -14639,7 +_,18 @@
 		if (keyState.IsKeyDown(Microsoft.Xna.Framework.Input.Keys.F8) && !drawingPlayerChat && !editSign && !editChest) {
 			if (netRelease) {
 				SoundEngine.PlaySound(12);
+				// TML: Logic changed to cycle modes
-				shouldDrawNetDiagnosticsUI = !shouldDrawNetDiagnosticsUI;
+				//shouldDrawNetDiagnosticsUI = !shouldDrawNetDiagnosticsUI;
+				if (!shouldDrawNetDiagnosticsUI && !ModNet.ShouldDrawModNetDiagnosticsUI)
+					shouldDrawNetDiagnosticsUI = true; // From off to on (vanilla)
+				else {
+					if (shouldDrawNetDiagnosticsUI && !ModNet.ShouldDrawModNetDiagnosticsUI) {
+						shouldDrawNetDiagnosticsUI = false; // From on (vanilla) to off (vanilla)
+						ModNet.ShouldDrawModNetDiagnosticsUI = true; // +on (modded)
+					}
+					else if (ModNet.ShouldDrawModNetDiagnosticsUI)
+						ModNet.ShouldDrawModNetDiagnosticsUI = false; // From on (modded) to off (all)
+				}
 			}
 
 			netRelease = false;
@@ -15260,6 +_,7 @@
 		if (tileFrameCounter[493] < 0)
 			tileFrameCounter[493] += 120;
 
+		TileLoader.AnimateTiles();
 		AnimateTiles_CritterCages();
 	}
 
@@ -15360,6 +_,8 @@
 		if (++wallFrameCounter[243] >= num2 * 8)
 			wallFrameCounter[243] = 0;
 
+		WallLoader.AnimateWalls();
+
 		wallFrameCounter[144]++;
 		int num3 = 5;
 		int num4 = 10;
@@ -15960,15 +_,15 @@
 			X += 34;
 
 		new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
+		Vector2 vector = FontAssets.MouseText.Value.MeasureString(cursorText);
 		if (HoverItem.type > 0) {
 			MouseText_DrawItemTooltip(info, num, diff, X, Y);
 			return;
 		}
 
 		if (info.buffTooltip != null && info.buffTooltip != "")
-			MouseText_DrawBuffTooltip(info.buffTooltip, ref X, ref Y);
+			MouseText_DrawBuffTooltip(info.buffTooltip, ref X, ref Y, (int)vector.Y);
 
-		Vector2 vector = FontAssets.MouseText.Value.MeasureString(cursorText);
 		if (hackedScreenHeight != -1 && hackedScreenWidth != -1) {
 			if ((float)X + vector.X + 4f > (float)hackedScreenWidth)
 				X = (int)((float)hackedScreenWidth - vector.X - 4f);
@@ -15986,9 +_,6 @@
 
 		float num2 = (float)(int)mouseTextColor / 255f;
 		Microsoft.Xna.Framework.Color baseColor = new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
-		if (num == -13)
-			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(masterColor * 200f * num2), 0, mouseTextColor);
-
 		if (num == -11)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(175f * num2), (byte)(0f * num2), mouseTextColor);
 
@@ -16028,12 +_,18 @@
 		if (num == 10)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(40f * num2), (byte)(100f * num2), mouseTextColor);
 
-		if (num >= 11)
+		if (num == 11)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)(180f * num2), (byte)(40f * num2), (byte)(255f * num2), mouseTextColor);
 
+		if (num > 11)
+			baseColor = RarityLoader.GetRarity(num).RarityColor * num2;
+
-		if (HoverItem.expert || num == -12)
+		if (HoverItem.expert || num == ItemRarityID.Expert)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)((float)DiscoR * num2), (byte)((float)DiscoG * num2), (byte)((float)DiscoB * num2), mouseTextColor);
 
+		if (HoverItem.master || num == ItemRarityID.Master)
+			baseColor = new Microsoft.Xna.Framework.Color((byte)(255f * num2), (byte)(masterColor * 200f * num2), 0, mouseTextColor);
+
 		if (diff == 1)
 			baseColor = new Microsoft.Xna.Framework.Color((byte)((float)(int)mcColor.R * num2), (byte)((float)(int)mcColor.G * num2), (byte)((float)(int)mcColor.B * num2), mouseTextColor);
 
@@ -16074,8 +_,9 @@
 			array2[i] = false;
 			array3[i] = false;
 		}
+		string[] tooltipNames = new string[num2];
 
-		MouseText_DrawItemTooltip_GetLinesInfo(hoverItem, ref yoyoLogo, ref researchLine, knockBack, ref numLines, array, array2, array3);
+		MouseText_DrawItemTooltip_GetLinesInfo(hoverItem, ref yoyoLogo, ref researchLine, knockBack, ref numLines, array, array2, array3, tooltipNames);
 		float num3 = (float)(int)mouseTextColor / 255f;
 		float num4 = num3;
 		int a = mouseTextColor;
@@ -16083,6 +_,7 @@
 			LocalPlayer.GetItemExpectedPrice(hoverItem, out var calcForSelling, out var calcForBuying);
 			long num5 = ((hoverItem.isAShopItem || hoverItem.buyOnce) ? calcForBuying : calcForSelling);
 			if (hoverItem.shopSpecialCurrency != -1) {
+				tooltipNames[numLines] = "SpecialPrice";
 				CustomCurrencyManager.GetPriceText(hoverItem.shopSpecialCurrency, array, ref numLines, num5);
 				color = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(255f * num4), (byte)(255f * num4), a);
 			}
@@ -16143,6 +_,7 @@
 				else
 					array[numLines] = Lang.tip[50].Value + " " + text;
 
+				tooltipNames[numLines] = "Price";
 				numLines++;
 				if (num6 > 0)
 					color = new Microsoft.Xna.Framework.Color((byte)(220f * num4), (byte)(220f * num4), (byte)(198f * num4), a);
@@ -16155,12 +_,15 @@
 			}
 			else if (hoverItem.type != 3817) {
 				array[numLines] = Lang.tip[51].Value;
+				tooltipNames[numLines] = "Price";
 				numLines++;
 				color = new Microsoft.Xna.Framework.Color((byte)(120f * num4), (byte)(120f * num4), (byte)(120f * num4), a);
 			}
 		}
 
 		Vector2 zero = Vector2.Zero;
+		List<TooltipLine> lines = ItemLoader.ModifyTooltips(HoverItem, ref numLines, tooltipNames, ref array, ref array2, ref array3, ref yoyoLogo, out Color?[] overrideColor);
+		List<DrawableTooltipLine> drawableLines = lines.Select((TooltipLine x, int i) => new DrawableTooltipLine(x, i, 0, 0, Color.White)).ToList();
 		int num12 = 0;
 		for (int j = 0; j < numLines; j++) {
 			Vector2 stringSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, array[j], Vector2.One);
@@ -16199,14 +_,20 @@
 			Utils.DrawInvBG(spriteBatch, new Microsoft.Xna.Framework.Rectangle(X - num17, Y - num18, (int)zero.X + num17 * 2, (int)zero.Y + num18 + num18 / 2), new Microsoft.Xna.Framework.Color(23, 25, 81, 255) * 0.925f);
 		}
 
+		bool globalCanDraw = ItemLoader.PreDrawTooltip(HoverItem, lines.AsReadOnly(), ref X, ref Y);
 		for (int k = 0; k < numLines; k++) {
-			if (k == yoyoLogo) {
-				float num19 = 1f;
-				int num20 = (int)((float)(int)mouseTextColor * num19);
-				Microsoft.Xna.Framework.Color color2 = Microsoft.Xna.Framework.Color.Black;
+			drawableLines[k].OriginalX = X;
+			drawableLines[k].OriginalY = Y + num16;
+			if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "OneDropLogo") {
+				int num20 = (int)((float)(int)mouseTextColor * 1f);
+				Color color2 = Color.Black;
+				drawableLines[k].Color = new Color(num20, num20, num20, num20);
+				if (!ItemLoader.PreDrawTooltipLine(HoverItem, drawableLines[k], ref num12) || !globalCanDraw)
+					goto PostDraw;
+
 				for (int l = 0; l < 5; l++) {
-					int num21 = X;
-					int num22 = Y + num16;
+					int num21 = drawableLines[k].X;
+					int num22 = drawableLines[k].Y;
 					if (l == 4)
 						color2 = new Microsoft.Xna.Framework.Color(num20, num20, num20, num20);
 
@@ -16224,17 +_,14 @@
 							num22++;
 							break;
 					}
-
-					spriteBatch.Draw(TextureAssets.OneDropLogo.Value, new Vector2(num21, num22), null, color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+					Color drawColor2 = drawableLines[k].OverrideColor ?? drawableLines[k].Color;
+					spriteBatch.Draw(TextureAssets.OneDropLogo.Value, new Vector2(num21, num22), null, (l != 4) ? color2 : drawColor2, drawableLines[k].Rotation, drawableLines[k].Origin, (drawableLines[k].BaseScale.X + drawableLines[k].BaseScale.Y) / 2f, SpriteEffects.None, 0f);
 				}
 			}
 			else {
 				Microsoft.Xna.Framework.Color black = Microsoft.Xna.Framework.Color.Black;
 				black = new Microsoft.Xna.Framework.Color(num4, num4, num4, num4);
-				if (k == 0) {
-					if (rare == -13)
-						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(masterColor * 200f * num4), 0, a);
-
+				if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "ItemName") {
 					if (rare == -11)
 						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(175f * num4), (byte)(0f * num4), a);
 
@@ -16271,9 +_,12 @@
 					if (rare == 10)
 						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(40f * num4), (byte)(100f * num4), a);
 
-					if (rare >= 11)
+					if (rare == 11)
 						black = new Microsoft.Xna.Framework.Color((byte)(180f * num4), (byte)(40f * num4), (byte)(255f * num4), a);
 
+					if (rare > 11)
+						black = RarityLoader.GetRarity(rare).RarityColor * num4;
+
 					if (diff == 1)
 						black = new Microsoft.Xna.Framework.Color((byte)((float)(int)mcColor.R * num4), (byte)((float)(int)mcColor.G * num4), (byte)((float)(int)mcColor.B * num4), a);
 
@@ -16282,47 +_,80 @@
 
 					if (hoverItem.expert || rare == -12)
 						black = new Microsoft.Xna.Framework.Color((byte)((float)DiscoR * num4), (byte)((float)DiscoG * num4), (byte)((float)DiscoB * num4), a);
+
+					if (hoverItem.master || rare == -13)
+						black = new Microsoft.Xna.Framework.Color((byte)(255f * num4), (byte)(masterColor * 200f * num4), 0, a);
 				}
 				else if (array2[k]) {
 					black = ((!array3[k]) ? new Microsoft.Xna.Framework.Color((byte)(120f * num4), (byte)(190f * num4), (byte)(120f * num4), a) : new Microsoft.Xna.Framework.Color((byte)(190f * num4), (byte)(120f * num4), (byte)(120f * num4), a));
 				}
-				else if (k == numLines - 1) {
+				else if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "Price") {
 					black = color;
 				}
 
-				if (k == researchLine)
+				if (drawableLines[k].Mod == "Terraria" && drawableLines[k].Name == "JourneyResearch")
 					black = Colors.JourneyMode;
 
-				ChatManager.DrawColorCodedStringWithShadow(spriteBatch, FontAssets.MouseText.Value, array[k], new Vector2(X, Y + num16), black, 0f, Vector2.Zero, Vector2.One);
+				drawableLines[k].Color = black;
+				Color realLineColor = black;
+
+				if (overrideColor[k].HasValue) {
+					realLineColor = overrideColor[k].Value * num4;
+					drawableLines[k].OverrideColor = realLineColor;
+				}
+
+				if (!ItemLoader.PreDrawTooltipLine(HoverItem, drawableLines[k], ref num12) || !globalCanDraw)
+					goto PostDraw;
+
+				ChatManager.DrawColorCodedStringWithShadow(spriteBatch, drawableLines[k].Font, drawableLines[k].Text, new Vector2(drawableLines[k].X, drawableLines[k].Y), realLineColor, drawableLines[k].Rotation, drawableLines[k].Origin, drawableLines[k].BaseScale, drawableLines[k].MaxWidth, drawableLines[k].Spread);
 			}
 
+			PostDraw:
+			ItemLoader.PostDrawTooltipLine(HoverItem, drawableLines[k]);
+
-			num16 += (int)(FontAssets.MouseText.Value.MeasureString(array[k]).Y + (float)num12);
+			num16 += (int)(FontAssets.MouseText.Value.MeasureString(drawableLines[k].Text).Y + (float)num12);
 		}
+
+		ItemLoader.PostDrawTooltip(HoverItem, drawableLines.AsReadOnly());
 	}
 
-	public static void MouseText_DrawItemTooltip_GetLinesInfo(Item item, ref int yoyoLogo, ref int researchLine, float oldKB, ref int numLines, string[] toolTipLine, bool[] preFixLine, bool[] badPreFixLine)
+	public static void MouseText_DrawItemTooltip_GetLinesInfo(Item item, ref int yoyoLogo, ref int researchLine, float oldKB, ref int numLines, string[] toolTipLine, bool[] preFixLine, bool[] badPreFixLine, string[] toolTipNames)
 	{
 		toolTipLine[0] = item.HoverName;
+		toolTipNames[0] = "ItemName";
 		if (item.favorited) {
 			toolTipLine[numLines++] = Lang.tip[56].Value;
+			toolTipNames[numLines - 1] = "Favorite";
 			toolTipLine[numLines++] = Lang.tip[57].Value;
+			toolTipNames[numLines - 1] = "FavoriteDesc";
 			if (LocalPlayer.chest != -1) {
 				ChestUI.GetContainerUsageInfo(out var _, out var chestinv);
-				if (ChestUI.IsBlockedFromTransferIntoChest(item, chestinv))
+				if (ChestUI.IsBlockedFromTransferIntoChest(item, chestinv)) {
 					toolTipLine[numLines++] = Language.GetTextValue("UI.ItemCannotBePlacedInsideItself");
+					toolTipNames[numLines - 1] = "NoTransfer";
+				}
 			}
 		}
 
 		if (item.social) {
 			toolTipLine[numLines] = Lang.tip[0].Value;
+			toolTipNames[numLines] = "Social";
 			numLines++;
 			toolTipLine[numLines] = Lang.tip[1].Value;
+			toolTipNames[numLines] = "SocialDesc";
 			numLines++;
 		}
 		else {
-			if (item.damage > 0 && (!item.notAmmo || item.useStyle != 0) && (item.type < 71 || item.type > 74 || player[myPlayer].HasItem(905))) {
-				float num = 5E-06f;
-				int damage = item.damage;
+			if (item.damage > 0 && (!item.notAmmo || item.useStyle != 0) && (item.type < 71 || item.type > 74 || player[myPlayer].HasItem(905)) && item.DamageType.ShowStatTooltipLine(player[myPlayer], "Damage")) {
+				LocalizedText tip;
+				if (item.DamageType != null) {
+					tip = new LocalizedText("", " " + item.DamageType.DisplayName);
+				}
+				else {
+					tip = Lang.tip[55]; // No damage class
+				}
+				int damage = player[myPlayer].GetWeaponDamage(item, true);
+				/*
 				damage = (int)((float)damage * ItemID.Sets.ToolTipDamageMultiplier[item.type]);
 				if (item.melee) {
 					toolTipLine[numLines] = string.Concat((int)(LocalPlayer.meleeDamage * (float)damage + num));
@@ -16360,8 +_,12 @@
 					toolTipLine[numLines] = string.Concat(damage);
 					toolTipLine[numLines] += Lang.tip[55].Value;
 				}
+				*/
+				toolTipLine[numLines] = damage + tip.Value;
+				toolTipNames[numLines] = "Damage";
 
 				numLines++;
+				/*
 				if (item.melee) {
 					int num3 = player[myPlayer].meleeCrit - player[myPlayer].inventory[player[myPlayer].selectedItem].crit + item.crit;
 					toolTipLine[numLines] = num3 + Lang.tip[5].Value;
@@ -16377,8 +_,15 @@
 					toolTipLine[numLines] = num5 + Lang.tip[5].Value;
 					numLines++;
 				}
+				*/
+				if (item.DamageType.UseStandardCritCalcs && item.DamageType.ShowStatTooltipLine(player[myPlayer], "CritChance")) {
+					int crit = player[myPlayer].GetWeaponCrit(item);
+					toolTipLine[numLines] = crit + Lang.tip[5].Value;
+					toolTipNames[numLines] = "CritChance";
+					numLines++;
+				}
 
-				if (item.useStyle != 0 && !item.summon) {
+				if (item.useStyle != 0 && item.DamageType.ShowStatTooltipLine(player[myPlayer], "Speed")) {
 					if (item.useAnimation <= 8)
 						toolTipLine[numLines] = Lang.tip[6].Value;
 					else if (item.useAnimation <= 20)
@@ -16396,10 +_,41 @@
 					else
 						toolTipLine[numLines] = Lang.tip[13].Value;
 
+					toolTipNames[numLines] = "Speed";
 					numLines++;
+
+					/*
+					tML:
+					these lines add a degree of transparency which vanilla doesn't provide by tellin' the player what
+					does and doesn't get affected by attack speed bonuses, as well as if the item in question has any
+					special scalin' rules. they're tML-specific, and can be messed with at the will of the modder
+
+					as for why they're differently named: prep for when that tooltip rework comes out
+					-thomas
+					*/
+					if (item.DamageType == DamageClass.MeleeNoSpeed || ItemID.Sets.BonusAttackSpeedMultiplier[item.type] == 0f) {
+						if (ModLoader.ModLoader.attackSpeedScalingTooltipVisibility == 0) {
+							toolTipLine[numLines] = Language.GetTextValue("tModLoader.NoAttackSpeedScaling");
+							toolTipNames[numLines] = "NoSpeedScaling";
+							numLines++;
+						}
+					}
+					else if (ItemID.Sets.BonusAttackSpeedMultiplier[item.type] != 1f) {
+						if (ModLoader.ModLoader.attackSpeedScalingTooltipVisibility <= 1) {
+							int attackSpeedScaling = (int)(ItemID.Sets.BonusAttackSpeedMultiplier[item.type] * 100);
+							toolTipLine[numLines] = Language.GetTextValue("tModLoader.SpecialAttackSpeedScaling", attackSpeedScaling);
+							toolTipNames[numLines] = "SpecialSpeedScaling";
+							numLines++;
+						}
+					}
 				}
+
+				if (!item.DamageType.ShowStatTooltipLine(player[myPlayer], "Knockback"))
+					goto noKnockbackLine;
 
 				float num6 = item.knockBack;
+				num6 = player[myPlayer].GetWeaponKnockback(item, num6);
+				/*
 				if (item.summon)
 					num6 += player[myPlayer].minionKB;
 
@@ -16409,6 +_,9 @@
 				if (player[myPlayer].inventory[player[myPlayer].selectedItem].type == 3106 && item.type == 3106)
 					num6 += num6 * (1f - player[myPlayer].stealth);
 
+				ItemLoader.GetWeaponKnockback(item, player[myPlayer], ref num6);
+				PlayerLoader.GetWeaponKnockback(player[myPlayer], item, ref num6);
+				*/
 				if (num6 == 0f)
 					toolTipLine[numLines] = Lang.tip[14].Value;
 				else if ((double)num6 <= 1.5)
@@ -16428,18 +_,23 @@
 				else
 					toolTipLine[numLines] = Lang.tip[22].Value;
 
+				toolTipNames[numLines] = "Knockback";
 				numLines++;
 			}
 
+			noKnockbackLine:
 			if (item.fishingPole > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.PrecentFishingPower", item.fishingPole);
+				toolTipNames[numLines] = "FishingPower";
 				numLines++;
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.BaitRequired");
+				toolTipNames[numLines] = "NeedsBait";
 				numLines++;
 			}
 
 			if (item.bait > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("GameUI.BaitPower", item.bait);
+				toolTipNames[numLines] = "BaitPower";
 				numLines++;
 			}
 
@@ -16449,41 +_,49 @@
 				else
 					toolTipLine[numLines] = Lang.tip[23].Value;
 
+				toolTipNames[numLines] = "Equipable";
 				numLines++;
 			}
 
 			if (item.tileWand > 0) {
 				toolTipLine[numLines] = Lang.tip[52].Value + Lang.GetItemNameValue(item.tileWand);
+				toolTipNames[numLines] = "WandConsumes";
 				numLines++;
 			}
 
 			if (item.questItem) {
 				toolTipLine[numLines] = Lang.inter[65].Value;
+				toolTipNames[numLines] = "Quest";
 				numLines++;
 			}
 
 			if (item.vanity) {
 				toolTipLine[numLines] = Lang.tip[24].Value;
+				toolTipNames[numLines] = "Vanity";
 				numLines++;
 			}
 
 			if (item.defense > 0) {
 				toolTipLine[numLines] = item.defense + Lang.tip[25].Value;
+				toolTipNames[numLines] = "Defense";
 				numLines++;
 			}
 
 			if (item.pick > 0) {
 				toolTipLine[numLines] = item.pick + Lang.tip[26].Value;
+				toolTipNames[numLines] = "PickPower";
 				numLines++;
 			}
 
 			if (item.axe > 0) {
 				toolTipLine[numLines] = item.axe * 5 + Lang.tip[27].Value;
+				toolTipNames[numLines] = "AxePower";
 				numLines++;
 			}
 
 			if (item.hammer > 0) {
 				toolTipLine[numLines] = item.hammer + Lang.tip[28].Value;
+				toolTipNames[numLines] = "HammerPower";
 				numLines++;
 			}
 
@@ -16494,6 +_,7 @@
 				else
 					toolTipLine[numLines] = tileBoost + Lang.tip[54].Value;
 
+				toolTipNames[numLines] = "TileBoost";
 				numLines++;
 			}
 
@@ -16507,36 +_,43 @@
 					toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.RestoresLife", item.healLife);
 				}
 
+				toolTipNames[numLines] = "HealLife";
 				numLines++;
 			}
 
 			if (item.healMana > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.RestoresMana", item.healMana);
+				toolTipNames[numLines] = "HealMana";
 				numLines++;
 			}
 
 			if (item.mana > 0 && (item.type != 127 || !player[myPlayer].spaceGun)) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.UsesMana", (int)((float)item.mana * player[myPlayer].manaCost));
+				toolTipNames[numLines] = "UseMana";
 				numLines++;
 			}
 
 			if (item.createWall > 0 || item.createTile > -1) {
 				if (item.type != 213 && item.type != 5295 && item.tileWand < 1) {
 					toolTipLine[numLines] = Lang.tip[33].Value;
+					toolTipNames[numLines] = "Placeable";
 					numLines++;
 				}
 			}
 			else if (item.ammo > 0 && !item.notAmmo) {
 				toolTipLine[numLines] = Lang.tip[34].Value;
+				toolTipNames[numLines] = "Ammo";
 				numLines++;
 			}
 			else if (item.consumable) {
 				toolTipLine[numLines] = Lang.tip[35].Value;
+				toolTipNames[numLines] = "Consumable";
 				numLines++;
 			}
 
 			if (item.material) {
 				toolTipLine[numLines] = Lang.tip[36].Value;
+				toolTipNames[numLines] = "Material";
 				numLines++;
 			}
 
@@ -16544,10 +_,12 @@
 				for (int i = 0; i < item.ToolTip.Lines; i++) {
 					if (i == 0 && ItemID.Sets.UsesCursedByPlanteraTooltip[item.type] && !NPC.downedPlantBoss) {
 						toolTipLine[numLines] = Lang.tip[59].Value;
+						toolTipNames[numLines] = "Tooltip" + i.ToString();
 						numLines++;
 					}
 					else {
 						toolTipLine[numLines] = item.ToolTip.GetLine(i);
+						toolTipNames[numLines] = "Tooltip" + i.ToString();
 						numLines++;
 					}
 				}
@@ -16575,16 +_,19 @@
 
 			if ((item.type == 3818 || item.type == 3819 || item.type == 3820 || item.type == 3824 || item.type == 3825 || item.type == 3826 || item.type == 3829 || item.type == 3830 || item.type == 3831 || item.type == 3832 || item.type == 3833 || item.type == 3834) && !player[myPlayer].downedDD2EventAnyDifficulty) {
 				toolTipLine[numLines] = Lang.misc[104].Value;
+				toolTipNames[numLines] = "EtherianManaWarning";
 				numLines++;
 			}
 
 			if (item.buffType > 0 && BuffID.Sets.IsWellFed[item.buffType] && expertMode) {
 				toolTipLine[numLines] = Lang.misc[40].Value;
+				toolTipNames[numLines] = "WellFedExpert";
 				numLines++;
 			}
 
 			if (item.buffTime > 0) {
 				string text = ((item.buffTime / 60 < 60) ? Language.GetTextValue("CommonItemTooltip.SecondDuration", Math.Round((double)item.buffTime / 60.0)) : Language.GetTextValue("CommonItemTooltip.MinuteDuration", Math.Round((double)(item.buffTime / 60) / 60.0)));
+				toolTipNames[numLines] = "BuffTime";
 				toolTipLine[numLines] = text;
 				numLines++;
 			}
@@ -16592,6 +_,7 @@
 			if (item.type == 3262 || item.type == 3282 || item.type == 3283 || item.type == 3284 || item.type == 3285 || item.type == 3286 || item.type == 3316 || item.type == 3315 || item.type == 3317 || item.type == 3291 || item.type == 3389) {
 				toolTipLine[numLines] = " ";
 				yoyoLogo = numLines;
+				toolTipNames[numLines] = "OneDropLogo";
 				numLines++;
 			}
 
@@ -16615,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixDamage";
 					numLines++;
 				}
 
@@ -16632,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixSpeed";
 					numLines++;
 				}
 
@@ -16646,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixCritChance";
 					numLines++;
 				}
 
@@ -16662,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixUseMana";
 					numLines++;
 				}
 
@@ -16678,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixSize";
 					numLines++;
 				}
 
@@ -16694,6 +_,7 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixShootSpeed";
 					numLines++;
 				}
 
@@ -16710,137 +_,160 @@
 						badPreFixLine[numLines] = true;
 
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixKnockback";
 					numLines++;
 				}
 
 				if (item.prefix == 62) {
 					toolTipLine[numLines] = "+1" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 63) {
 					toolTipLine[numLines] = "+2" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 64) {
 					toolTipLine[numLines] = "+3" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 65) {
 					toolTipLine[numLines] = "+4" + Lang.tip[25].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDefense";
 					numLines++;
 				}
 
 				if (item.prefix == 66) {
 					toolTipLine[numLines] = "+20 " + Lang.tip[31].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMaxMana";
 					numLines++;
 				}
 
 				if (item.prefix == 67) {
 					toolTipLine[numLines] = "+2" + Lang.tip[5].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccCritChance";
 					numLines++;
 				}
 
 				if (item.prefix == 68) {
 					toolTipLine[numLines] = "+4" + Lang.tip[5].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccCritChance";
 					numLines++;
 				}
 
 				if (item.prefix == 69) {
 					toolTipLine[numLines] = "+1" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 70) {
 					toolTipLine[numLines] = "+2" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 71) {
 					toolTipLine[numLines] = "+3" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 72) {
 					toolTipLine[numLines] = "+4" + Lang.tip[39].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccDamage";
 					numLines++;
 				}
 
 				if (item.prefix == 73) {
 					toolTipLine[numLines] = "+1" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 74) {
 					toolTipLine[numLines] = "+2" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 75) {
 					toolTipLine[numLines] = "+3" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 76) {
 					toolTipLine[numLines] = "+4" + Lang.tip[46].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMoveSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 77) {
 					toolTipLine[numLines] = "+1" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 78) {
 					toolTipLine[numLines] = "+2" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 79) {
 					toolTipLine[numLines] = "+3" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 
 				if (item.prefix == 80) {
 					toolTipLine[numLines] = "+4" + Lang.tip[47].Value;
 					preFixLine[numLines] = true;
+					toolTipNames[numLines] = "PrefixAccMeleeSpeed";
 					numLines++;
 				}
 			}
 
 			if (item.wornArmor && player[myPlayer].setBonus != "") {
 				toolTipLine[numLines] = Lang.tip[48].Value + " " + player[myPlayer].setBonus;
+				toolTipNames[numLines] = "SetBonus";
 				numLines++;
 			}
 		}
 
 		if (item.expert) {
 			toolTipLine[numLines] = Language.GetTextValue("GameUI.Expert");
+			toolTipNames[numLines] = "Expert";
 			numLines++;
 		}
 
-		if (item.rare == -13) {
+		if (item.master) {
 			toolTipLine[numLines] = Language.GetTextValue("GameUI.Master");
+			toolTipNames[numLines] = "Master";
 			numLines++;
 		}
 
@@ -16849,8 +_,27 @@
 			if (amountNeeded - sacrificeCount > 0) {
 				toolTipLine[numLines] = Language.GetTextValue("CommonItemTooltip.CreativeSacrificeNeeded", amountNeeded - sacrificeCount);
 				researchLine = numLines;
+				toolTipNames[numLines] = "JourneyResearch";
 				numLines++;
 			}
+		}
+
+		if (item.StatsModifiedBy.Count > 0)
+		{
+			if (keyState.PressingShift()) {
+				toolTipLine[numLines] = Language.GetTextValue("tModLoader.ModifiedByMods");
+				for (int i = 0; i < item.StatsModifiedBy.Count; i++) {
+					Mod mod = item.StatsModifiedBy[i];
+					if (i > 0)
+						toolTipLine[numLines] += ", ";
+					toolTipLine[numLines] += mod.DisplayName;
+				}
+			}
+			else {
+				toolTipLine[numLines] = Language.GetTextValue("tModLoader.ModifiedByModsHoldSHIFT");
+			}
+			toolTipNames[numLines] = "ModifiedByMods";
+			numLines++;
 		}
 
 		string bestiaryNotes = item.BestiaryNotes;
@@ -16858,11 +_,12 @@
 			string[] array = bestiaryNotes.Split('\n');
 			foreach (string text2 in array) {
 				toolTipLine[numLines++] = text2;
+				toolTipNames[numLines - 1] = "BestiaryNotes";
 			}
 		}
 	}
 
-	private void MouseText_DrawBuffTooltip(string buffString, ref int X, ref int Y)
+	private void MouseText_DrawBuffTooltip(string buffString, ref int X, ref int Y, int buffNameHeight)
 	{
 		Microsoft.Xna.Framework.Point p = new Microsoft.Xna.Framework.Point(X, Y);
 		int num = 220;
@@ -16878,7 +_,7 @@
 
 		if (bannerMouseOver) {
 			int num6 = 0;
-			for (int i = 0; i < 290; i++) {
+			for (int i = 0; i < NPCLoader.NPCCount; i++) {
 				if (Item.BannerToNPC(i) != 0 && player[myPlayer].HasNPCBannerBuff(i)) {
 					num6++;
 					string nPCNameValue = Lang.GetNPCNameValue(Item.BannerToNPC(i));
@@ -16903,6 +_,7 @@
 			}
 		}
 
+		BuffLoader.CustomBuffTipSize(buffString, list);
 		Vector2 zero = Vector2.Zero;
 		foreach (Vector2 item in list) {
 			if (zero.X < item.X)
@@ -16920,7 +_,7 @@
 
 		for (int k = 0; k < 5; k++) {
 			int num11 = X;
-			int num12 = Y + (int)FontAssets.MouseText.Value.MeasureString(buffString).Y;
+			int num12 = Y + buffNameHeight;
 			Microsoft.Xna.Framework.Color color = Microsoft.Xna.Framework.Color.Black;
 			switch (k) {
 				case 0:
@@ -16947,7 +_,7 @@
 			return;
 
 		int num13 = 0;
-		for (int l = 0; l < 290; l++) {
+		for (int l = 0; l < NPCLoader.NPCCount; l++) {
 			if (Item.BannerToNPC(l) == 0 || !player[myPlayer].HasNPCBannerBuff(l))
 				continue;
 
@@ -16989,9 +_,12 @@
 				spriteBatch.DrawString(FontAssets.MouseText.Value, text, new Vector2(num14, num15), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 			}
 
+			// TODO: BuffLoader.DrawCustomBuffTip here? This is new to fix too many banner buffs I think.
 			if (flag)
 				break;
 		}
+
+		BuffLoader.DrawCustomBuffTip(buffString, spriteBatch, X, Y + (int)FontAssets.MouseText.Value.MeasureString(buffString).Y);
 	}
 
 	protected void DrawFPS()
@@ -17027,10 +_,10 @@
 			float num2 = 1f;
 			Vector2 baseScale = new Vector2(num2);
 			if (gameMenu)
-				num = 55f;
+				num = 90f;
 
 			if (menuMode == 0)
-				num += 32f;
+				num += 55f;
 
 			Vector2 stringSize = ChatManager.GetStringSize(FontAssets.MouseText.Value, text, new Vector2(1f));
 			float t = num2;
@@ -17248,10 +_,15 @@
 		}
 	}
 
-	public static bool IsTileSpelunkable(Tile t) => IsTileSpelunkable(t.type, t.frameX, t.frameY);
+	//TML: Added x/y to IsTileSpelunkable methods for hook compatibility, made internal. Public variant in partial TML class
+	internal static bool IsTileSpelunkable(int tileX, int tileY, Tile t) => IsTileSpelunkable(tileX, tileY, t.type, t.frameX, t.frameY);
 
-	public static bool IsTileSpelunkable(ushort typeCache, short tileFrameX, short tileFrameY)
+	internal static bool IsTileSpelunkable(int tileX, int tileY, ushort typeCache, short tileFrameX, short tileFrameY)
 	{
+		bool? modded = TileLoader.IsTileSpelunkable(tileX, tileY, typeCache);
+		if (modded.HasValue)
+			return modded.Value;
+
 		if (tileSpelunker[typeCache])
 			return true;
 
@@ -17296,7 +_,7 @@
 				continue;
 
 			bool flag = false;
-			if (((gore[i].type >= 706 && gore[i].type <= 717) || gore[i].type == 943 || gore[i].type == 1147 || (gore[i].type >= 1160 && gore[i].type <= 1162)) && (gore[i].frame < 7 || gore[i].frame > 9))
+			if (GoreID.Sets.DrawBehind[gore[i].type] && (gore[i].type >= GoreID.Count || gore[i].frame is < 7 or > 9))
 				flag = true;
 
 			if (flag) {
@@ -17304,11 +_,11 @@
 				if (gore[i].Frame.ColumnCount > 1 || gore[i].Frame.RowCount > 1) {
 					Microsoft.Xna.Framework.Rectangle sourceRectangle = gore[i].Frame.GetSourceRectangle(TextureAssets.Gore[gore[i].type].Value);
 					Microsoft.Xna.Framework.Color alpha = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)sourceRectangle.Width * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)sourceRectangle.Height * 0.5) / 16.0)));
-					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f), sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
+					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X + gore[i].drawOffset.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y + gore[i].drawOffset.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f), sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
 				}
 				else {
 					Microsoft.Xna.Framework.Color alpha2 = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)TextureAssets.Gore[gore[i].type].Width() * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)TextureAssets.Gore[gore[i].type].Height() * 0.5) / 16.0)));
-					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
+					spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X + gore[i].drawOffset.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y + gore[i].drawOffset.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
 				}
 			}
 		}
@@ -17321,7 +_,7 @@
 			if (!gore[i].active || gore[i].type <= 0)
 				continue;
 
-			if (((gore[i].type >= 706 && gore[i].type <= 717) || gore[i].type == 943 || gore[i].type == 1147 || (gore[i].type >= 1160 && gore[i].type <= 1162)) && (gore[i].frame < 7 || gore[i].frame > 9)) {
+			if (GoreID.Sets.DrawBehind[gore[i].type] && (gore[i].type >= GoreID.Count || gore[i].frame is < 7 or > 9)) {
 				drawBackGore = true;
 				continue;
 			}
@@ -17334,11 +_,11 @@
 					vector.Y += 4f;
 
 				Microsoft.Xna.Framework.Color alpha = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)sourceRectangle.Width * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)sourceRectangle.Height * 0.5) / 16.0)));
-				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f) + vector, sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
+				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X + gore[i].drawOffset.X - screenPosition.X + (float)(sourceRectangle.Width / 2), gore[i].position.Y + gore[i].drawOffset.Y - screenPosition.Y + (float)(sourceRectangle.Height / 2) - 2f) + vector, sourceRectangle, alpha, gore[i].rotation, new Vector2(sourceRectangle.Width / 2, sourceRectangle.Height / 2), gore[i].scale, SpriteEffects.None, 0f);
 			}
 			else {
 				Microsoft.Xna.Framework.Color alpha2 = gore[i].GetAlpha(Lighting.GetColor((int)((double)gore[i].position.X + (double)TextureAssets.Gore[gore[i].type].Width() * 0.5) / 16, (int)(((double)gore[i].position.Y + (double)TextureAssets.Gore[gore[i].type].Height() * 0.5) / 16.0)));
-				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
+				spriteBatch.Draw(TextureAssets.Gore[gore[i].type].Value, new Vector2(gore[i].position.X + gore[i].drawOffset.X - screenPosition.X + (float)(TextureAssets.Gore[gore[i].type].Width() / 2), gore[i].position.Y + gore[i].drawOffset.Y - screenPosition.Y + (float)(TextureAssets.Gore[gore[i].type].Height() / 2)), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Gore[gore[i].type].Width(), TextureAssets.Gore[gore[i].type].Height()), alpha2, gore[i].rotation, new Vector2(TextureAssets.Gore[gore[i].type].Width() / 2, TextureAssets.Gore[gore[i].type].Height() / 2), gore[i].scale, SpriteEffects.None, 0f);
 			}
 		}
 
@@ -17427,6 +_,8 @@
 		float num = 0f;
 		if (theNPC.type == 125)
 			num = 30f;
+		else if (theNPC.ModNPC != null)
+			num = theNPC.ModNPC.DrawOffsetY;
 		else if (theNPC.type == 54)
 			num = 2f;
 		else if (theNPC.type == 205)
@@ -17643,7 +_,7 @@
 		Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)screenPosition.X - 800, (int)screenPosition.Y - 800, screenWidth + 1600, screenHeight + 1600);
 		for (int num = 199; num >= 0; num--) {
 			try {
-				if (npc[num].active && npc[num].type > 0 && npc[num].type < 688 && !npc[num].hide) {
+				if (npc[num].active && npc[num].type > 0 && !npc[num].hide) {
 					npc[num].position += npc[num].netOffset;
 					if (npc[num].behindTiles == behindTiles) {
 						if (npc[num].type == 125 || npc[num].type == 126) {
@@ -17760,13 +_,13 @@
 		}
 	}
 
-	protected void DrawNPCCheckAlt(NPC n)
+	public void DrawNPCCheckAlt(NPC n)
 	{
-		if (TownNPCProfiles.Instance.GetProfile(n.type, out var profile))
+		if (TownNPCProfiles.Instance.GetProfile(n, out var profile))
 			TextureAssets.Npc[n.type] = profile.GetTextureNPCShouldUse(n);
 	}
 
-	protected void DrawNPC(int iNPCIndex, bool behindTiles)
+	public void DrawNPC(int iNPCIndex, bool behindTiles)
 	{
 		NPC rCurrentNPC = npc[iNPCIndex];
 		Vector2 screenPos = screenPosition;
@@ -18157,6 +_,18 @@
 			}
 		}
 
+		NPCLoader.DrawEffects(rCurrentNPC, ref npcColor); //TODO: Effects were previously done before drawing, here, but 1.4 moved them to updates in UpdateNPC_BuffApplyVFX(). Should this hook be moved and renamed? --Mirsario
+
+		if (NPCLoader.PreDraw(rCurrentNPC, spriteBatch, screenPos, npcColor)) {
+			DrawNPCDirect_Inner(spriteBatch, rCurrentNPC, behindTiles, screenPos, ref npcColor);
+		}
+
+		NPCLoader.PostDraw(rCurrentNPC, spriteBatch, screenPos, npcColor);
+	}
+
+	private void DrawNPCDirect_Inner(SpriteBatch mySpriteBatch, NPC rCurrentNPC, bool behindTiles, Vector2 screenPos, ref Color npcColor)
+	{
+		int type = rCurrentNPC.type;
 		npcColor = rCurrentNPC.GetNPCColorTintedByBuffs(npcColor);
 		if (type == 50) {
 			Vector2 zero = Vector2.Zero;
@@ -21960,6 +_,7 @@
 				}
 			}
 
+			NPCLoader.DrawTownAttackGun(n, ref num10, ref itemtype, ref num11);
 			Vector2 vector4 = DrawPlayerItemPos(1f, itemtype);
 			GetItemDrawFrame(itemtype, out var itemTexture, out var value2);
 			int num12 = (int)vector4.X - num11;
@@ -21967,6 +_,7 @@
 			if (n.spriteDirection == -1)
 				origin2 = new Vector2(value2.Width + num12, value2.Height / 2);
 
+			//patch context
 			spriteBatch.Draw(itemTexture, new Vector2((int)(vector3.X - screenPosition.X), (int)(vector3.Y - screenPosition.Y)), value2, npcColor, rotation, origin2, n.scale * num10, npcSpriteEffect ^ SpriteEffects.FlipHorizontally, 0f);
 			if (n.type == 22 && n.frame.Y / (TextureAssets.Npc[n.type].Height() / npcFrameCount[n.type]) >= 21) {
 				Texture2D value3 = TextureAssets.Extra[52].Value;
@@ -22029,6 +_,7 @@
 			}
 
 			GetItemDrawFrame(num15, out var itemTexture2, out var rectangle3);
+			NPCLoader.DrawTownAttackSwing(n, ref itemTexture2, ref num13, ref num14, ref zero);
 			Tuple<Vector2, float> swingStats = n.GetSwingStats(NPCID.Sets.AttackTime[n.type] * 2, (int)n.ai[1], n.spriteDirection, num13, num13);
 			Vector2 vector6 = swingStats.Item1 + (swingStats.Item1 - n.Center) * num14 + zero;
 			Vector2 origin4 = rectangle3.Size() * new Vector2((n.spriteDirection != 1) ? 1 : 0, 1f);
@@ -22504,6 +_,11 @@
 	public void DrawProjDirect(Projectile proj)
 	{
 		PrepareDrawnProjectileDrawing(proj);
+		DrawProj_Inner(proj);
+	}
+
+	private void DrawProj_DrawVoidLens(Projectile proj, ref bool earlyReturn)
+	{
 		if (proj.type == 734) {
 			VoidLensHelper voidLensHelper = new VoidLensHelper(proj);
 			_voidLensData.Clear();
@@ -22518,6 +_,11 @@
 			}
 		}
 
+		earlyReturn = false;
+	}
+
+	private void DrawProj_Inner(Projectile proj)
+	{
 		float polePosX = 0f;
 		float polePosY = 0f;
 		LoadProjectile(proj.type);
@@ -22525,6 +_,15 @@
 		if (Main.player[proj.owner].mount.Active && Main.player[proj.owner].mount.Type == 52)
 			mountedCenter += new Vector2(Main.player[proj.owner].direction * 14, -10f);
 
+		if (ProjectileLoader.PreDrawExtras(proj)) {
+			DrawProj_DrawYoyoString(proj, mountedCenter);
+			DrawProj_DrawExtras(proj, mountedCenter, ref polePosX, ref polePosY);
+		}
+		DrawProj_Inner_DoDrawProj(proj, mountedCenter, polePosX, polePosY);
+	}
+
+	private void DrawProj_DrawYoyoString(Projectile proj, Vector2 mountedCenter)
+	{
 		if (proj.aiStyle == 99) {
 			Vector2 vector = mountedCenter;
 			vector.Y += Main.player[proj.owner].gfxOffY;
@@ -22630,7 +_,12 @@
 				EntitySpriteDraw(color: new Microsoft.Xna.Framework.Color((byte)((float)(int)white.R * num11), (byte)((float)(int)white.G * num11), (byte)((float)(int)white.B * num11), (byte)((float)(int)white.A * num11)), texture: TextureAssets.FishingLine.Value, position: new Vector2(vector.X - screenPosition.X + (float)TextureAssets.FishingLine.Width() * 0.5f, vector.Y - screenPosition.Y + (float)TextureAssets.FishingLine.Height() * 0.5f) - new Vector2(6f, 0f), sourceRectangle: new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.FishingLine.Width(), (int)num6), rotation: num3, origin: new Vector2((float)TextureAssets.FishingLine.Width() * 0.5f, 0f), scale: 1f, effects: SpriteEffects.None);
 			}
 		}
-		else {
+	}
+
+	private void DrawProj_DrawSpecialProjs(Projectile proj, ref bool earlyReturn)
+	{
+		/*else*/
+		{
 			if (proj.aiStyle == 160) {
 				DrawKite(proj);
 				return;
@@ -22843,6 +_,11 @@
 			return;
 		}
 
+		earlyReturn = false;
+	}
+
+	private void DrawProj_DrawExtras(Projectile proj, Vector2 mountedCenter, ref float polePosX, ref float polePosY)
+	{
 		if (proj.bobber && Main.player[proj.owner].inventory[Main.player[proj.owner].selectedItem].holdStyle != 0) {
 			DrawProj_FishingLine(proj, ref polePosX, ref polePosY, mountedCenter);
 		}
@@ -23914,6 +_,10 @@
 			DrawProj_FlailChains(proj, mountedCenter);
 		}
 
+	}
+
+	private void DrawProj_Inner_DoDrawProj(Projectile proj, Vector2 mountedCenter, float polePosX, float polePosY)
+	{
 		Microsoft.Xna.Framework.Color projectileColor = Lighting.GetColor((int)((double)proj.position.X + (double)proj.width * 0.5) / 16, (int)(((double)proj.position.Y + (double)proj.height * 0.5) / 16.0));
 		if (proj.hide && !ProjectileID.Sets.DontAttachHideToAlpha[proj.type])
 			projectileColor = Lighting.GetColor((int)mountedCenter.X / 16, (int)(mountedCenter.Y / 16f));
@@ -23921,6 +_,23 @@
 		if (proj.type == 14)
 			projectileColor = Microsoft.Xna.Framework.Color.White;
 
+		if (ProjectileLoader.PreDraw(proj, ref projectileColor)) {
+			bool earlyReturn = true;
+			DrawProj_DrawVoidLens(proj, ref earlyReturn);
+			if (earlyReturn)
+				goto PostDraw;
+			earlyReturn = true;
+			DrawProj_DrawSpecialProjs(proj, ref earlyReturn);
+			if (earlyReturn)
+				goto PostDraw;
+			DrawProj_DrawNormalProjs(proj, polePosX, polePosY, mountedCenter, ref projectileColor);
+		}
+		PostDraw:
+		ProjectileLoader.PostDraw(proj, projectileColor);
+	}
+
+	private void DrawProj_DrawNormalProjs(Projectile proj, float polePosX, float polePosY, Vector2 mountedCenter, ref Color projectileColor)
+	{
 		int num136 = 0;
 		int num137 = 0;
 		if (proj.type == 175)
@@ -24312,6 +_,7 @@
 			num137 = 3;
 		}
 
+		//patch details
 		if (proj.type == 397) {
 			num138 -= 1f;
 			num136 = -2;
@@ -24321,6 +_,7 @@
 		if (proj.type == 398)
 			num136 = 8;
 
+		ProjectileLoader.DrawOffset(proj, ref num137, ref num136, ref num138);
 		SpriteEffects dir = SpriteEffects.None;
 		if (proj.spriteDirection == -1)
 			dir = SpriteEffects.FlipHorizontally;
@@ -27632,6 +_,11 @@
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY) + vector108 + vector109, new Microsoft.Xna.Framework.Rectangle(0, num408 * 2, TextureAssets.Projectile[proj.type].Width(), num408 - 1), alpha12, proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 				}
 
+				var modProjectile = proj.ModProjectile;
+
+				if (modProjectile != null && ModContent.RequestIfExists<Texture2D>(modProjectile.GlowTexture, out var glowTexture, AssetRequestMode.ImmediateLoad)) // todo: preload this!
+					EntitySpriteDraw(glowTexture.Value, new Vector2(proj.position.X - screenPosition.X + num138 + num137, proj.position.Y - screenPosition.Y + proj.height / 2 + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, y27, TextureAssets.Projectile[proj.type].Width(), num408 - 1), new Microsoft.Xna.Framework.Color(250, 250, 250, proj.alpha), proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
+
 				if (proj.type == 335)
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, y27, TextureAssets.Projectile[proj.type].Width(), num408 - 1), new Microsoft.Xna.Framework.Color(100, 100, 100, 0), proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
 
@@ -27825,7 +_,7 @@
 			}
 
 			if (proj.bobber) {
-				if (proj.ai[1] > 0f && proj.ai[1] < 5456f && proj.ai[0] == 1f) {
+				if (proj.ai[1] > 0f && proj.ai[0] == 1f) {
 					int num436 = (int)proj.ai[1];
 					Vector2 center5 = proj.Center;
 					float rotation31 = proj.rotation;
@@ -27886,6 +_,10 @@
 				if (proj.type >= 511 && proj.type <= 513)
 					EntitySpriteDraw(TextureAssets.Projectile[proj.type].Value, new Vector2(proj.position.X - screenPosition.X + num138 + (float)num137, proj.position.Y - screenPosition.Y + (float)(proj.height / 2) + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Projectile[proj.type].Width(), TextureAssets.Projectile[proj.type].Height()), proj.GetAlpha(projectileColor) * 0.25f, proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale * (1f + proj.Opacity * 1.75f), dir);
 
+				ModProjectile modProjectile = proj.ModProjectile;
+				if (modProjectile != null && ModContent.RequestIfExists<Texture2D>(modProjectile.GlowTexture, out var glowTexture)) // todo: preload this!
+					EntitySpriteDraw(glowTexture.Value, new Vector2(proj.position.X - screenPosition.X + num138 + num137, proj.position.Y - screenPosition.Y + proj.height / 2 + proj.gfxOffY), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Projectile[proj.type].Width(), TextureAssets.Projectile[proj.type].Height()), new Microsoft.Xna.Framework.Color(250, 250, 250, proj.alpha), proj.rotation, new Vector2(num138, proj.height / 2 + num136), proj.scale, dir);
+
 				if (proj.type == 312) {
 					ulong seed3 = TileFrameSeed;
 					for (int num439 = 0; num439 < 4; num439++) {
@@ -28385,6 +_,7 @@
 		if (type == 4442)
 			stringColor = new Microsoft.Xna.Framework.Color(100, 100, 200, 100);
 
+		ProjectileLoader.ModifyFishingLine(proj, ref polePosX, ref polePosY, ref stringColor);
 		stringColor = TryApplyingPlayerStringColor(Main.player[proj.owner].stringColor, stringColor);
 		float gravDir = Main.player[proj.owner].gravDir;
 		switch (type) {
@@ -30241,10 +_,13 @@
 			}
 			else if (npc[i].type == 516 || npc[i].type == 519) {
 				DrawCacheNPCProjectiles.Add(i);
+				//Extra patch context.
 			}
 			else if (npc[i].type == 548) {
 				DrawCacheNPCsBehindNonSolidTiles.Add(i);
 			}
+
+			NPCLoader.DrawBehind(Main.npc[i], i);
 		}
 	}
 
@@ -30279,7 +_,7 @@
 				DrawCacheProjsBehindNPCs.Add(i);
 
 			if (projectile[i].type != 636 && projectile[i].type != 598 && projectile[i].type != 971)
-				continue;
+				goto PostProjDrawCache;
 
 			bool flag = true;
 			if (projectile[i].ai[0] == 1f) {
@@ -30296,6 +_,9 @@
 
 			if (flag)
 				DrawCacheProjsBehindProjectiles.Add(i);
+
+			PostProjDrawCache:
+			ProjectileLoader.DrawBehind(projectile[i], i, DrawCacheProjsBehindNPCsAndTiles, DrawCacheProjsBehindNPCs, DrawCacheProjsBehindProjectiles, DrawCacheProjsOverPlayers, DrawCacheProjsOverWiresUI);
 		}
 	}
 
@@ -30674,6 +_,7 @@
 		Vector2 vector = frame.Size() / 2f;
 		Vector2 vector2 = new Vector2((float)(item.width / 2) - vector.X, item.height - frame.Height);
 		Vector2 vector3 = item.position - screenPosition + vector + vector2;
+		// patch context (num)
 		float num = item.velocity.X * 0.2f;
 		if (item.shimmered)
 			num = 0f;
@@ -30695,6 +_,9 @@
 		}
 
 		ItemSlot.GetItemLight(ref currentColor, ref scale, item);
+		if (!ItemLoader.PreDrawInWorld(item, spriteBatch, color, currentColor, ref num, ref scale, whoami)) {
+			goto PostDraw;
+		}
 		int num2 = item.glowMask;
 		if (!gamePaused && base.IsActive && (item.IsACoin || item.type == 58 || item.type == 109) && color.R > 60 && (float)rand.Next(500) - (Math.Abs(item.velocity.X) + Math.Abs(item.velocity.Y)) * 10f < (float)((int)color.R / 50)) {
 			int type = 43;
@@ -30816,6 +_,8 @@
 			Microsoft.Xna.Framework.Rectangle rectangle = value.Frame();
 			spriteBatch.Draw(value, vector3 + vector4 + frame.Size().RotatedBy(num) * 0.45f * item.scale, rectangle, currentColor, num, rectangle.Size() / 2f, 1f, SpriteEffects.None, 0f);
 		}
+		PostDraw:
+		ItemLoader.PostDrawInWorld(item, spriteBatch, color, currentColor, num, scale, whoami);
 	}
 
 	public void DrawItems()
@@ -30839,7 +_,18 @@
 				if (shimmerAlpha > 0f)
 					color *= 1f - shimmerAlpha;
 
+				if (rain.waterStyle >= maxLiquidTypes) {
+					value2 = LoaderManager.Get<WaterStylesLoader>().Get(rain.waterStyle).GetRainTexture().Value;
+					if (value2 == null) {
+						goto justUpdateRain;
+					}
+				}
+				else {
+					value2 = TextureAssets.Rain.Value;
+				}
+
 				spriteBatch.Draw(value2, rain.position - screenPosition, value, color, rain.rotation, zero, rain.scale, SpriteEffects.None, 0f);
+				justUpdateRain:
 				if (flag)
 					rain.Update();
 			}
@@ -30968,6 +_,13 @@
 				if (dust.type == 213)
 					scale = 1f;
 
+				ModDust modDust = DustLoader.GetDust(dust.type);
+
+				if (modDust != null) {
+					modDust.Draw(dust, newColor, scale);
+					continue;
+				}
+
 				spriteBatch.Draw(TextureAssets.Dust.Value, dust.position - screenPosition, dust.frame, newColor, dust.GetVisualRotation(), new Vector2(4f, 4f), scale, SpriteEffects.None, 0f);
 				if (dust.color.PackedValue != 0) {
 					Microsoft.Xna.Framework.Color color6 = dust.GetColor(newColor);
@@ -30991,11 +_,11 @@
 	private static void HelpText()
 	{
 		bool flag = false;
-		if (player[myPlayer].statLifeMax > 100)
+		if (player[myPlayer].ConsumedLifeCrystals > 0)
 			flag = true;
 
 		bool flag2 = false;
-		if (player[myPlayer].statManaMax > 20)
+		if (player[myPlayer].ConsumedManaCrystals > 0)
 			flag2 = true;
 
 		bool flag3 = true;
@@ -31417,7 +_,7 @@
 				return;
 			}
 
-			if (helpText == 202 && !hardMode && player[myPlayer].statLifeMax >= 140) {
+			if (helpText == 202 && !hardMode && player[myPlayer].ConsumedLifeCrystals >= 2) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1120");
 				return;
 			}
@@ -31427,12 +_,12 @@
 				return;
 			}
 
-			if (helpText == 204 && !NPC.downedGoblins && player[myPlayer].statLifeMax >= 200 && WorldGen.shadowOrbSmashed) {
+			if (helpText == 204 && !NPC.downedGoblins && player[myPlayer].ConsumedLifeCrystals >= 5 && WorldGen.shadowOrbSmashed) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1122");
 				return;
 			}
 
-			if (helpText == 205 && hardMode && !NPC.downedPirates && player[myPlayer].statLifeMax >= 200) {
+			if (helpText == 205 && hardMode && !NPC.downedPirates && player[myPlayer].ConsumedLifeCrystals >= 5) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1123");
 				return;
 			}
@@ -31511,7 +_,7 @@
 				return;
 			}
 
-			if (helpText == 1050 && !NPC.downedBoss1 && player[myPlayer].statLifeMax < 200) {
+			if (helpText == 1050 && !NPC.downedBoss1 && player[myPlayer].ConsumedLifeCrystals < 5) {
 				npcChatText = Lang.dialog(211);
 				return;
 			}
@@ -31521,22 +_,22 @@
 				return;
 			}
 
-			if (helpText == 1052 && !NPC.downedBoss1 && player[myPlayer].statLifeMax >= 200 && player[myPlayer].statDefense > 10) {
+			if (helpText == 1052 && !NPC.downedBoss1 && player[myPlayer].ConsumedLifeCrystals >= 5 && player[myPlayer].statDefense > 10) {
 				npcChatText = Lang.dialog(WorldGen.crimson ? 404 : 213);
 				return;
 			}
 
-			if (helpText == 1053 && NPC.downedBoss1 && !NPC.downedBoss2 && player[myPlayer].statLifeMax < 300) {
+			if (helpText == 1053 && NPC.downedBoss1 && !NPC.downedBoss2 && player[myPlayer].ConsumedLifeCrystals < 10) {
 				npcChatText = Lang.dialog(214);
 				return;
 			}
 
-			if (helpText == 1054 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			if (helpText == 1054 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Lang.dialog(215);
 				return;
 			}
 
-			if (helpText == 1055 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			if (helpText == 1055 && NPC.downedBoss1 && !NPC.downedBoss2 && !WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Lang.dialog(216);
 				return;
 			}
@@ -31546,22 +_,22 @@
 				return;
 			}
 
-			if (helpText == 1057 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax < 400) {
+			if (helpText == 1057 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals < Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(218);
 				return;
 			}
 
-			if (helpText == 1058 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			if (helpText == 1058 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(219);
 				return;
 			}
 
-			if (helpText == 1059 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			if (helpText == 1059 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(220);
 				return;
 			}
 
-			if (helpText == 1060 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].statLifeMax >= 400) {
+			if (helpText == 1060 && NPC.downedBoss1 && NPC.downedBoss2 && NPC.downedBoss3 && !hardMode && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax) {
 				npcChatText = Lang.dialog(221);
 				return;
 			}
@@ -31576,12 +_,12 @@
 				return;
 			}
 
-			if (helpText == 1140 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			if (helpText == 1140 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1140");
 				return;
 			}
 
-			if (helpText == 1141 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].statLifeMax >= 300) {
+			if (helpText == 1141 && NPC.downedBoss1 && !NPC.downedBoss2 && WorldGen.crimson && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1141");
 				return;
 			}
@@ -31591,7 +_,7 @@
 				return;
 			}
 
-			if (helpText == 1143 && NPC.downedBoss2 && !NPC.downedQueenBee && player[myPlayer].statLifeMax >= 300) {
+			if (helpText == 1143 && NPC.downedBoss2 && !NPC.downedQueenBee && player[myPlayer].ConsumedLifeCrystals >= 10) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1143");
 				return;
 			}
@@ -31621,7 +_,7 @@
 				return;
 			}
 
-			if (helpText == 1149 && hardMode && NPC.downedMechBossAny && player[myPlayer].statLifeMax < 500) {
+			if (helpText == 1149 && hardMode && NPC.downedMechBossAny && player[myPlayer].ConsumedLifeCrystals == Player.LifeCrystalMax && player[myPlayer].ConsumedLifeFruit < Player.LifeFruitMax) {
 				npcChatText = Language.GetTextValue("GuideHelpTextSpecific.Help_1149");
 				return;
 			}
@@ -31706,8 +_,8 @@
 		if (num2 && !NPC.PreventJojaColaDialog)
 			textValue = Language.GetTextValue("StardewTalk.PlayerHasColaAndIsHoldingIt");
 
-		_textDisplayCache.PrepareCache(textValue);
-		string[] textLines = _textDisplayCache.TextLines;
+		_textDisplayCache.PrepareCache(textValue, textColor);
+		List<List<TextSnippet>> textLines = _textDisplayCache.TextLines;
 		int amountOfLines = _textDisplayCache.AmountOfLines;
 		bool flag2 = false;
 		if (editSign) {
@@ -31721,23 +_,41 @@
 				textBlinkerCount = 0;
 			}
 
-			if (textBlinkerState == 1)
+			if (textBlinkerState == 1) {
 				flag2 = true;
+
+				textLines[amountOfLines - 1].Add(new TextSnippet("|", Microsoft.Xna.Framework.Color.White, 1f));
+			}
 
 			instance.DrawWindowsIMEPanel(new Vector2(screenWidth / 2, 90f), 0.5f);
 		}
 
-		amountOfLines++;
+		//amountOfLines++;
 		spriteBatch.Draw(TextureAssets.ChatBack.Value, new Vector2(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.ChatBack.Width(), (amountOfLines + 1) * 30), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 		spriteBatch.Draw(TextureAssets.ChatBack.Value, new Vector2(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100 + (amountOfLines + 1) * 30), new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.ChatBack.Height() - 30, TextureAssets.ChatBack.Width(), 30), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		TextSnippet hoveredSnippet = null;
 		for (int i = 0; i < amountOfLines; i++) {
-			string text = textLines[i];
+			List<TextSnippet> text = textLines[i];
+			/*
 			if (text != null) {
 				if (i == amountOfLines - 1 && flag2)
 					text += "|";
 
 				Utils.DrawBorderStringFourWay(spriteBatch, FontAssets.MouseText.Value, text, 170 + (screenWidth - 800) / 2, 120 + i * 30, textColor, Microsoft.Xna.Framework.Color.Black, Vector2.Zero);
 			}
+			*/
+			ChatManager.DrawColorCodedStringWithShadow(spriteBatch, FontAssets.MouseText.Value, text.ToArray(), new Vector2(170 + (screenWidth - 800) / 2, 120 + i * 30), 0f, textColor, Color.Black, Vector2.Zero, Vector2.One, out int hoveredSnippetNum);
+
+			if (hoveredSnippetNum > -1)
+				hoveredSnippet = text[hoveredSnippetNum];
+		}
+
+		if (hoveredSnippet is not null) {
+			hoveredSnippet.OnHover();
+
+			if (Main.mouseLeft && Main.mouseLeftRelease)
+				hoveredSnippet.OnClick();
 		}
 
 		Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(screenWidth / 2 - TextureAssets.ChatBack.Width() / 2, 100, TextureAssets.ChatBack.Width(), (amountOfLines + 2) * 30);
@@ -31781,12 +_,16 @@
 		string focusText = "";
 		string focusText2 = "";
 		int num5 = player[myPlayer].statLifeMax2 - player[myPlayer].statLife;
-		for (int j = 0; j < 44; j++) {
+		for (int j = 0; j < Player.MaxBuffs; j++) {
 			int num6 = player[myPlayer].buffType[j];
-			if (debuff[num6] && player[myPlayer].buffTime[j] > 60 && (num6 < 0 || num6 >= 355 || !BuffID.Sets.NurseCannotRemoveDebuff[num6]))
+			if (debuff[num6] && player[myPlayer].buffTime[j] > 60 && (num6 < 0 || !BuffID.Sets.NurseCannotRemoveDebuff[num6]))
 				num5 += 100;
 		}
 
+		int health = LocalPlayer.statLifeMax2 - LocalPlayer.statLife;
+		bool removeDebuffs = true;
+		string reason = "";
+		bool canHeal = true;
 		if (NPC.downedGolemBoss)
 			num5 *= 200;
 		else if (NPC.downedPlantBoss)
@@ -31957,6 +_,10 @@
 			if (num16 > 0 && num16 < 1)
 				num16 = 1;
 
+			reason = Language.GetTextValue("tModLoader.DefaultNurseCantHealChat");
+			canHeal = PlayerLoader.ModifyNurseHeal(player[myPlayer], npc[player[myPlayer].talkNPC], ref health, ref removeDebuffs, ref reason);
+			PlayerLoader.ModifyNursePrice(player[myPlayer], npc[player[myPlayer].talkNPC], health, removeDebuffs, ref num16);
+
 			if (num16 < 0)
 				num16 = 0;
 
@@ -32007,8 +_,11 @@
 			else {
 				text5 = text5.Substring(0, text5.Length - 1);
 				focusText = Lang.inter[54].Value + " (" + text5 + ")";
+				//Patch context.
 			}
 		}
+
+		NPCLoader.SetChatButtons(ref focusText, ref focusText2);
 
 		if (!flag) {
 			DrawNPCChatButtons(num, textColor, amountOfLines, focusText, focusText2);
@@ -32043,11 +_,19 @@
 					SubmitSignText();
 				else
 					IngameFancyUI.OpenVirtualKeyboard(1);
+				return;
 			}
 			else if (NPCID.Sets.IsTownPet[npc[player[myPlayer].talkNPC].type]) {
 				player[myPlayer].PetAnimal(player[myPlayer].talkNPC);
+				return;
 			}
+
+			if (!NPCLoader.PreChatButtonClicked(true))
+				return;
+
+			NPCLoader.OnChatButtonClicked(true);
+
-			else if (npc[player[myPlayer].talkNPC].type == 369) {
+			if (npc[player[myPlayer].talkNPC].type == 369) {
 				npcChatCornerItem = 0;
 				SoundEngine.PlaySound(12);
 				bool flag3 = false;
@@ -32219,10 +_,15 @@
 
 				SoundEngine.PlaySound(12);
 				if (num5 > 0) {
+					if (!canHeal) {
+						npcChatText = reason;
+						return;
+					}
+
 					if (player[myPlayer].BuyItem(num5)) {
 						AchievementsHelper.HandleNurseService(num5);
 						SoundEngine.PlaySound(SoundID.Item4);
-						player[myPlayer].HealEffect(player[myPlayer].statLifeMax2 - player[myPlayer].statLife);
+						player[myPlayer].HealEffect(health, true);
 						if ((double)player[myPlayer].statLife < (double)player[myPlayer].statLifeMax2 * 0.25)
 							npcChatText = Lang.dialog(227);
 						else if ((double)player[myPlayer].statLife < (double)player[myPlayer].statLifeMax2 * 0.5)
@@ -32232,14 +_,21 @@
 						else
 							npcChatText = Lang.dialog(230);
 
-						player[myPlayer].statLife = player[myPlayer].statLifeMax2;
-						for (int l = 0; l < 44; l++) {
+						player[myPlayer].statLife += health;
+
+						if (!removeDebuffs) // no indent for better patching
+							goto SkipDebuffRemoval;
+
+						for (int l = 0; l < Player.MaxBuffs; l++) {
 							int num25 = player[myPlayer].buffType[l];
-							if (debuff[num25] && player[myPlayer].buffTime[l] > 0 && (num25 < 0 || num25 >= 355 || !BuffID.Sets.NurseCannotRemoveDebuff[num25])) {
+							if (debuff[num25] && player[myPlayer].buffTime[l] > 0 && (num25 < 0 || !BuffID.Sets.NurseCannotRemoveDebuff[num25])) {
 								player[myPlayer].DelBuff(l);
 								l = -1;
 							}
 						}
+
+						SkipDebuffRemoval:
+						PlayerLoader.PostNurseHeal(LocalPlayer, npc[LocalPlayer.talkNPC], health, removeDebuffs, num5);
 					}
 					else {
 						int num26 = rand.Next(3);
@@ -32281,6 +_,10 @@
 			if (!npcChatFocus3 || player[myPlayer].talkNPC < 0)
 				return;
 
+			if (!NPCLoader.PreChatButtonClicked(false))
+				return;
+
+			NPCLoader.OnChatButtonClicked(false);
 			if (npc[player[myPlayer].talkNPC].type == 20) {
 				SoundEngine.PlaySound(12);
 				npcChatText = Lang.GetDryadWorldStatusDialog(out var worldIsEntirelyPure);
@@ -32411,8 +_,12 @@
 			npcChatFocus2 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus2) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus2) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		if (text.Length > 0) {
 			UILinkPointNavigator.SetPosition(2500, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsLeft = true;
@@ -32442,8 +_,12 @@
 			npcChatFocus1 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus1) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus1) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		if (text.Length > 0) {
 			UILinkPointNavigator.SetPosition(2501, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsMiddle = true;
@@ -32479,8 +_,12 @@
 				npcChatFocus3 = false;
 			}
 
+			// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+			ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus3) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+			/*
 			ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus3) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 			ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+			*/
 			UILinkPointNavigator.SetPosition(2502, vector2 + stringSize * 0.5f);
 			UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsRight = true;
 		}
@@ -32519,8 +_,12 @@
 			npcChatFocus4 = false;
 		}
 
+		// Fix all instances of drawing text to use TextSnippets instead of strings (#FixNPCChat)
+		ChatManager.DrawColorCodedStringWithShadow(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, (!npcChatFocus4) ? Microsoft.Xna.Framework.Color.Black : brown, 0f, stringSize * 0.5f, vector3 * vector4);
+		/*
 		ChatManager.DrawColorCodedStringShadow(baseColor: (!npcChatFocus4) ? Microsoft.Xna.Framework.Color.Black : brown, spriteBatch: spriteBatch, font: value, text: text, position: vector2 + stringSize * vector4 * 0.5f, rotation: 0f, origin: stringSize * 0.5f, baseScale: vector3 * vector4);
 		ChatManager.DrawColorCodedString(spriteBatch, value, text, vector2 + stringSize * vector4 * 0.5f, baseColor, 0f, stringSize * 0.5f, vector3 * vector4);
+		*/
 		UILinkPointNavigator.SetPosition(2503, vector2 + stringSize * 0.5f);
 		UILinkPointNavigator.Shortcuts.NPCCHAT_ButtonsRight2 = true;
 	}
@@ -33082,7 +_,7 @@
 				num29++;
 
 			int num31 = 46;
-			for (int n = 0; n < 44; n++) {
+			for (int n = 0; n < Player.MaxBuffs; n++) {
 				if (player[myPlayer].buffType[n] != 0) {
 					int num32 = num28 / num29;
 					int num33 = num28 % num29;
@@ -33105,17 +_,19 @@
 					if (num34 == 147)
 						bannerMouseOver = true;
 
+					int rare = 0;
 					if (meleeBuff[num34])
-						MouseTextHackZoom(buffName, -10, 0, buffTooltip);
-					else
-						MouseTextHackZoom(buffName, buffTooltip);
+						rare = -10;
+
+					BuffLoader.ModifyBuffTip(num34, ref buffTooltip, ref rare);
+					MouseTextHackZoom(buffName, rare, 0);
 				}
 			}
 		}
 		else if (EquipPage == 1) {
 			DrawNPCHousesInUI();
 		}
-		else {
+		else if (EquipPage == 0) {// allow mods to add custom equip pages
 			int num35 = 4;
 			if (mouseX > screenWidth - 64 - 28 && mouseX < (int)((float)(screenWidth - 64 - 28) + 56f * inventoryScale) && mouseY > num20 && mouseY < (int)((float)num20 + 448f * inventoryScale) && !PlayerInput.IgnoreMouseInterface)
 				player[myPlayer].mouseInterface = true;
@@ -33133,7 +_,7 @@
 			Microsoft.Xna.Framework.Color color2 = new Microsoft.Xna.Framework.Color(80, 80, 80, 80);
 			DrawLoadoutButtons(num20, flag5, flag6);
 			int num39 = -1;
-			for (int num40 = 0; num40 < 10; num40++) {
+			for (int num40 = 0; num40 < 3; num40++) {
 				if ((num40 == 8 && !flag5) || (num40 == 9 && !flag6))
 					continue;
 
@@ -33154,6 +_,7 @@
 					context2 = 10;
 				}
 
+				/*
 				if (num39 == num38 && !_achievementAdvisor.CanDrawAboveCoins) {
 					_achievementAdvisor.DrawOneAchievement(spriteBatch, new Vector2(num41 - 10 - 47 - 47 - 14 - 14, num42 + 8), large: false);
 					UILinkPointNavigator.SetPosition(1570, new Vector2(num41 - 10 - 47 - 47 - 14 - 14, num42 + 8) + new Vector2(20f) * inventoryScale);
@@ -33161,6 +_,7 @@
 
 				if (num39 == num37)
 					DrawDefenseCounter(num41, num42);
+				*/
 
 				Texture2D value3 = TextureAssets.InventoryTickOn.Value;
 				if (player[myPlayer].hideVisibleAccessory[num40])
@@ -33207,7 +_,7 @@
 				player[myPlayer].mouseInterface = true;
 
 			num39 = -1;
-			for (int num46 = 10; num46 < 20; num46++) {
+			for (int num46 = 10; num46 < 13; num46++) {
 				if ((num46 == 18 && !flag5) || (num46 == 19 && !flag6))
 					continue;
 
@@ -33248,7 +_,7 @@
 				player[myPlayer].mouseInterface = true;
 
 			num39 = -1;
-			for (int num50 = 0; num50 < 10; num50++) {
+			for (int num50 = 0; num50 < 3; num50++) {
 				if ((num50 == 8 && !flag5) || (num50 == 9 && !flag6))
 					continue;
 
@@ -33283,9 +_,22 @@
 			}
 
 			inventoryBack = color;
+
+			var defPos = AccessorySlotLoader.DefenseIconPosition;
+			DrawDefenseCounter((int)defPos.X, (int)defPos.Y);
+
+			if (!_achievementAdvisor.CanDrawAboveCoins) {
+				var achievePos = new Vector2(defPos.X - 10 - 47 - 47 - 14 - 14, defPos.Y - 56 * inventoryScale * 0.5f);
+				_achievementAdvisor.DrawOneAchievement(spriteBatch, achievePos , large: false);
+				UILinkPointNavigator.SetPosition(1570, achievePos + new Vector2(20f) * inventoryScale);
+			}
+
+			inventoryBack = color;
 			inventoryScale = num36;
 		}
 
+		LoaderManager.Get<AccessorySlotLoader>().DrawAccSlots(num20);
+
 		int num54 = (screenHeight - 600) / 2;
 		int num55 = (int)((float)screenHeight / 600f * 250f);
 		if (screenHeight < 700) {
@@ -33329,11 +_,18 @@
 				string text = Lang.inter[46].Value + ": ";
 				if (reforgeItem.type > 0) {
 					int num58 = reforgeItem.value;
-					if (player[myPlayer].discountAvailable)
+					num58 *= reforgeItem.stack; // TML: #StackablePrefixWeapons: scale with current stack size
+					bool canApplyDiscount = true;
+					if (!ItemLoader.ReforgePrice(reforgeItem, ref num58, ref canApplyDiscount))
+						goto skipVanillaPricing;
+
+					if (canApplyDiscount && LocalPlayer.discountAvailable)
 						num58 = (int)((double)num58 * 0.8);
 
 					num58 = (int)((double)num58 * player[myPlayer].currentShoppingSettings.PriceAdjustment);
 					num58 /= 3;
+
+					skipVanillaPricing:
 					string text2 = "";
 					int num59 = 0;
 					int num60 = 0;
@@ -33391,11 +_,13 @@
 
 						mouseReforge = true;
 						player[myPlayer].mouseInterface = true;
-						if (mouseLeftRelease && mouseLeft && player[myPlayer].BuyItem(num58)) {
+						if (mouseLeftRelease && mouseLeft && player[myPlayer].CanBuyItem(num58) && ItemLoader.PreReforge(reforgeItem)) {
+							player[myPlayer].BuyItem(num58);
 							reforgeItem.ResetPrefix();
 							reforgeItem.Prefix(-2);
 							reforgeItem.position.X = player[myPlayer].position.X + (float)(player[myPlayer].width / 2) - (float)(reforgeItem.width / 2);
 							reforgeItem.position.Y = player[myPlayer].position.Y + (float)(player[myPlayer].height / 2) - (float)(reforgeItem.height / 2);
+							ItemLoader.PostReforge(reforgeItem);
 							PopupText.NewText(PopupTextContext.ItemReforge, reforgeItem, reforgeItem.stack, noStack: true);
 							SoundEngine.PlaySound(SoundID.Item37);
 						}
@@ -33450,6 +_,7 @@
 
 		CreativeMenu.Draw(spriteBatch);
 		bool flag10 = CreativeMenu.Enabled && !CreativeMenu.Blocked;
+		flag10 |= hidePlayerCraftingMenu;
 		if (!InReforgeMenu && !LocalPlayer.tileEntityAnchor.InUse && !flag10) {
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = -1;
@@ -33532,7 +_,7 @@
 			if (numAvailableRecipes > 0) {
 				UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
 				UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = -1;
-				for (int num72 = 0; num72 < Recipe.maxRequirements; num72++) {
+				for (int num72 = 0; num72 < recipe[availableRecipe[focusRecipe]].requiredItem.Count; num72++) {
 					if (recipe[availableRecipe[focusRecipe]].requiredItem[num72].type == 0) {
 						UILinkPointNavigator.Shortcuts.CRAFT_CurrentIngredientsCount = num72 + 1;
 						break;
@@ -33577,7 +_,8 @@
 					UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeSmall = 1 + num72;
 					Microsoft.Xna.Framework.Color color5 = inventoryBack;
 					inventoryBack = new Microsoft.Xna.Framework.Color((byte)num75, (byte)num75, (byte)num75, (byte)num75);
-					ItemSlot.Draw(spriteBatch, ref recipe[availableRecipe[focusRecipe]].requiredItem[num72], 22, new Vector2(num73, num74));
+					Item tempItem = recipe[availableRecipe[focusRecipe]].requiredItem[num72];
+					ItemSlot.Draw(spriteBatch, ref tempItem, 22, new Vector2(num73, num74));
 					inventoryBack = color5;
 				}
 			}
@@ -33610,6 +_,7 @@
 				}
 			}
 		}
+		hidePlayerCraftingMenu = false;
 
 		if (recBigList && !flag10) {
 			UILinkPointNavigator.Shortcuts.CRAFT_CurrentRecipeBig = -1;
@@ -33949,9 +_,9 @@
 		}
 
 		for (int j = 0; j < 200; j++) {
-			if (npc[j].active && !_npcTypesThatAlreadyDrewAHead.Contains(npc[j].type)) {
+			if (npc[j].active && !_npcTypesThatAlreadyDrewAHead.Contains(npc[j].type) && npc[j].ModNPC?.TownNPCStayingHomeless is not true) {
 				int headIndexSafe = TownNPCProfiles.GetHeadIndexSafe(npc[j]);
-				if (headIndexSafe > 0 && headIndexSafe <= 81 && !NPCHeadID.Sets.CannotBeDrawnInHousingUI[headIndexSafe] && _npcIndexWhoHoldsHeadIndex[headIndexSafe] == -1) {
+				if (headIndexSafe > 0 && !NPCHeadID.Sets.CannotBeDrawnInHousingUI[headIndexSafe] && _npcIndexWhoHoldsHeadIndex[headIndexSafe] == -1) {
 					_npcIndexWhoHoldsHeadIndex[headIndexSafe] = j;
 					_npcTypesThatAlreadyDrewAHead.Add(npc[j].type);
 				}
@@ -34057,7 +_,7 @@
 		else {
 			text = Lang.inter[21].Value + " " + guideItem.Name;
 			Recipe recipe = Main.recipe[availableRecipe[focusRecipe]];
-			for (int i = 0; i < Recipe.maxRequirements; i++) {
+			for (int i = 0; i < recipe.requiredTile.Count; i++) {
 				int num = recipe.requiredTile[i];
 				if (num == -1)
 					break;
@@ -34082,6 +_,8 @@
 			if (recipe.needGraveyardBiome)
 				_requiredObjecsForCraftingText.Add(Lang.inter[124].Value);
 
+			_requiredObjecsForCraftingText.AddRange(recipe.Conditions.Select(x => x.Description));
+
 			if (_requiredObjecsForCraftingText.Count == 0) {
 				string value = Lang.inter[23].Value;
 				_requiredObjecsForCraftingText.Add(value);
@@ -34119,7 +_,7 @@
 			spriteBatch.DrawString(FontAssets.MouseText.Value, Lang.inter[22].Value, new Vector2(inventoryX, inventoryY + 118), craftingTipColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 			int num3 = focusRecipe;
 			int num4 = 0;
-			for (int i = 0; i < Recipe.maxRequirements; i++) {
+			for (int i = 0; i < recipe[availableRecipe[num3]].requiredTile.Count; i++) {
 				int num5 = (i + 1) * 26;
 				if (recipe[availableRecipe[num3]].requiredTile[i] == -1) {
 					if (i == 0 && !recipe[availableRecipe[num3]].needWater && !recipe[availableRecipe[num3]].needHoney && !recipe[availableRecipe[num3]].needLava && !recipe[availableRecipe[num3]].needSnowBiome && !recipe[availableRecipe[num3]].needGraveyardBiome)
@@ -34224,6 +_,9 @@
 		if (mouseItem.IsAir)
 			return true;
 
+		if (mouseItem.maxStack > 1 && mouseItem.AllowReforgeForStackableItem && mouseItem.prefix > 0) // TML: #StackablePrefixWeapons: Gameplay impact: Prevent crafted prefix application by blocking crafting if mouse item is prefixed
+			return false;
+
 		if (mouseItem.IsTheSameAs(currentRecipe.createItem) && mouseItem.stack + currentRecipe.createItem.stack <= mouseItem.maxStack)
 			return true;
 
@@ -34253,6 +_,11 @@
 			inventoryScale = 0.755f;
 			num += 5;
 		}
+		else if ((player[myPlayer].chest == -1 || npcShop == -1) && trashSlotOffset != Point16.Zero) {
+			num += trashSlotOffset.X;
+			num2 += trashSlotOffset.Y;
+			inventoryScale = 0.755f;
+		}
 
 		new Microsoft.Xna.Framework.Color(150, 150, 150, 150);
 		if (mouseX >= num && (float)mouseX <= (float)num + (float)TextureAssets.InventoryBack.Width() * inventoryScale && mouseY >= num2 && (float)mouseY <= (float)num2 + (float)TextureAssets.InventoryBack.Height() * inventoryScale && !PlayerInput.IgnoreMouseInterface) {
@@ -34487,17 +_,33 @@
 
 	public static void CraftItem(Recipe r)
 	{
+		/* TML: #OnStackHook
 		int stack = mouseItem.stack;
 		mouseItem = r.createItem.Clone();
 		mouseItem.stack += stack;
 		mouseItem.OnCreated(new RecipeItemCreationContext(r));
 		if (stack <= 0)
 			mouseItem.Prefix(-1);
+		*/
+
+		if (mouseItem.stack > 0 && !ItemLoader.CanStack(mouseItem, r.createItem))
+			return;
+
+		Item crafted = r.createItem.Clone();
+		crafted.Prefix(-1);
+		r.Create();
+		RecipeLoader.OnCraft(crafted, r, mouseItem);
+		if (mouseItem.stack > 0) {
+			ItemLoader.StackItems(mouseItem, crafted, out _);
+		}
+		else {
+			mouseItem = crafted;
+		}
 
 		mouseItem.position.X = player[myPlayer].position.X + (float)(player[myPlayer].width / 2) - (float)(mouseItem.width / 2);
 		mouseItem.position.Y = player[myPlayer].position.Y + (float)(player[myPlayer].height / 2) - (float)(mouseItem.height / 2);
 		PopupText.NewText(PopupTextContext.ItemCraft, mouseItem, r.createItem.stack);
-		r.Create();
+
 		if (mouseItem.type > 0 || r.createItem.type > 0)
 			SoundEngine.PlaySound(7);
 	}
@@ -34680,6 +_,8 @@
 					rare = item[i].rare;
 					if (item[i].expert)
 						rare = -12;
+					if (item[i].master)
+						rare = -13;
 
 					MouseTextHackZoom(text, rare, 0);
 					mouseText = true;
@@ -34769,6 +_,10 @@
 		Player player = Main.player[myPlayer];
 		for (int i = 0; i < 200; i++) {
 			NPC nPC = npc[i];
+
+			if (!nPC.ShowNameOnHover)
+				continue;
+
 			if (!(nPC.active & (nPC.shimmerTransparency == 0f || nPC.CanApplyHunterPotionEffects())))
 				continue;
 
@@ -34779,6 +_,7 @@
 			if (nPC.type >= 87 && nPC.type <= 92)
 				value = new Microsoft.Xna.Framework.Rectangle((int)((double)nPC.position.X + (double)nPC.width * 0.5 - 32.0), (int)((double)nPC.position.Y + (double)nPC.height * 0.5 - 32.0), 64, 64);
 
+			NPCLoader.ModifyHoverBoundingBox(nPC, ref value);
 			bool flag = mouseRectangle.Intersects(value);
 			bool flag2 = flag || (SmartInteractShowingGenuine && SmartInteractNPC == i);
 			if (flag2 && ((nPC.type != 85 && nPC.type != 341 && nPC.type != 629 && nPC.aiStyle != 87) || nPC.ai[0] != 0f) && nPC.type != 488) {
@@ -34803,7 +_,11 @@
 				}
 				else {
 					bool flag3 = SmartInteractShowingGenuine && SmartInteractNPC == i;
+					bool vanillaCanChat = false;
 					if (nPC.townNPC || nPC.type == 105 || nPC.type == 106 || nPC.type == 123 || nPC.type == 354 || nPC.type == 376 || nPC.type == 579 || nPC.type == 453 || nPC.type == 589) {
+						vanillaCanChat = true;
+					}
+					if (NPCLoader.CanChat(nPC) ?? vanillaCanChat) {
 						Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle((int)(player.position.X + (float)(player.width / 2) - (float)(Player.tileRangeX * 16)), (int)(player.position.Y + (float)(player.height / 2) - (float)(Player.tileRangeY * 16)), Player.tileRangeX * 16 * 2, Player.tileRangeY * 16 * 2);
 						Microsoft.Xna.Framework.Rectangle value2 = new Microsoft.Xna.Framework.Rectangle((int)nPC.position.X, (int)nPC.position.Y, nPC.width, nPC.height);
 						if (rectangle.Intersects(value2))
@@ -34981,10 +_,17 @@
 			if (num5 == 147)
 				bannerMouseOver = true;
 
+			int rare = 0;
 			if (meleeBuff[num5])
+			/*
 				MouseTextHackZoom(buffName, -10, 0, buffTooltip);
 			else
 				MouseTextHackZoom(buffName, buffTooltip);
+			*/
+				rare = -10;
+			
+			BuffLoader.ModifyBuffTip(num5, ref buffTooltip, ref rare);
+			MouseTextHackZoom(buffName, rare, 0, buffTooltip);
 		}
 	}
 
@@ -35014,6 +_,14 @@
 		return text;
 	}
 
+	/// <summary>
+	/// Checks if the buff at index <paramref name="buffSlotOnPlayer"/> is allowed to draw a "remaining time" text, and sets <paramref name="buffTimeValue"/> to it.
+	/// <para>Check <paramref name="buffTimeValue"/> > 2 afterwards if you want to mirror text draw logic.</para>
+	/// </summary>
+	/// <param name="buffSlotOnPlayer">The index for buffType and buffTime</param>
+	/// <param name="buffTimeValue">The "remaining time" in ticks</param>
+	/// <returns><see langword="true"/> if <paramref name="buffTimeValue"/> is set, otherwise <see langword="false"/></returns>
+	// TO-DO: add a hook for drawing time left probably?
 	public static bool TryGetBuffTime(int buffSlotOnPlayer, out int buffTimeValue)
 	{
 		int num = player[myPlayer].buffType[buffSlotOnPlayer];
@@ -35026,6 +_,16 @@
 		return false;
 	}
 
+	/// <summary>
+	/// Draws the buff icon corresponding to the buff in Main.LocalPlayer.buffType[<paramref name="buffSlotOnPlayer"/>].
+	/// <para>Calls TML hooks related to drawing and clicking.</para>
+	/// <para>Has two exclusive contexts: Below the accessory slots (Main.EquipPage == 2), and regular under-the-inventory.</para>
+	/// </summary>
+	/// <param name="drawBuffText">The return from a previous DrawBuffIcon call, -1 if first drawn buff</param>
+	/// <param name="buffSlotOnPlayer">The index for buffType and buffTime</param>
+	/// <param name="x">Top-left draw position on the x-axis</param>
+	/// <param name="y">Top-left draw position on the y-axis</param>
+	/// <returns>The index of the currently mouseovered buff icon, equal to <paramref name="buffSlotOnPlayer"/> if it's currently mouseovered, -1 otherwise</returns>
 	public static int DrawBuffIcon(int drawBuffText, int buffSlotOnPlayer, int x, int y)
 	{
 		int num = player[myPlayer].buffType[buffSlotOnPlayer];
@@ -35033,13 +_,41 @@
 			return drawBuffText;
 
 		Microsoft.Xna.Framework.Color color = new Microsoft.Xna.Framework.Color(buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer], buffAlpha[buffSlotOnPlayer]);
+
+		/*
 		spriteBatch.Draw(TextureAssets.Buff[num].Value, new Vector2(x, y), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Buff[num].Width(), TextureAssets.Buff[num].Height()), color, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+		*/
+
+		// Drawing made customizable through tML hooks
+		Asset<Texture2D> buffAsset = TextureAssets.Buff[num];
+		Texture2D texture = buffAsset.Value;
+		Vector2 drawPosition = new Vector2(x, y);
+		int width = buffAsset.Width();
+		int height = buffAsset.Height();
+		Vector2 textPosition = new Vector2(x, y + height);
+		Rectangle sourceRectangle = new Rectangle(0, 0, width, height);
+		Rectangle mouseRectangle = new Rectangle(x, y, width, height);
+		Color drawColor = color;
+
+		BuffDrawParams drawParams = new BuffDrawParams(texture, drawPosition, textPosition, sourceRectangle, mouseRectangle, drawColor);
+
+		bool skipped = !BuffLoader.PreDraw(spriteBatch, num, buffSlotOnPlayer, ref drawParams);
+
+		(texture, drawPosition, textPosition, sourceRectangle, mouseRectangle, drawColor) = drawParams;
+
+		if (!skipped)
+			spriteBatch.Draw(texture, drawPosition, sourceRectangle, drawColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+
+		BuffLoader.PostDraw(spriteBatch, num, buffSlotOnPlayer, drawParams);
+
 		if (TryGetBuffTime(buffSlotOnPlayer, out var buffTimeValue) && buffTimeValue > 2) {
 			string text = Lang.LocalizedDuration(new TimeSpan(0, 0, buffTimeValue / 60), abbreviated: true, showAllAvailableUnits: false);
-			spriteBatch.DrawString(FontAssets.ItemStack.Value, text, new Vector2(x, y + TextureAssets.Buff[num].Height()), color, 0f, default(Vector2), 0.8f, SpriteEffects.None, 0f);
+			//spriteBatch.DrawString(FontAssets.ItemStack.Value, text, new Vector2(x, y + TextureAssets.Buff[num].Height()), color, 0f, default(Vector2), 0.8f, SpriteEffects.None, 0f);
+			spriteBatch.DrawString(FontAssets.ItemStack.Value, text, textPosition, color, 0f, default(Vector2), 0.8f, SpriteEffects.None, 0f);
 		}
 
-		if (mouseX < x + TextureAssets.Buff[num].Width() && mouseY < y + TextureAssets.Buff[num].Height() && mouseX > x && mouseY > y) {
+		//if (mouseX < x + TextureAssets.Buff[num].Width() && mouseY < y + TextureAssets.Buff[num].Height() && mouseX > x && mouseY > y) {
+		if (mouseRectangle.Contains(new Point(mouseX, mouseY))) {
 			drawBuffText = buffSlotOnPlayer;
 			buffAlpha[buffSlotOnPlayer] += 0.1f;
 			bool flag = mouseRight && mouseRightRelease;
@@ -35053,6 +_,9 @@
 			}
 
 			if (flag)
+				flag &= BuffLoader.RightClick(num, buffSlotOnPlayer);
+
+			if (flag)
 				TryRemovingBuff(buffSlotOnPlayer, num);
 		}
 		else {
@@ -35070,6 +_,11 @@
 		return drawBuffText;
 	}
 
+	/// <summary>
+	/// Calls Player.DelBuff with index i after checking Main.debuff of buff type b. Will toggle Player.hideMisc for pet and light pet.
+	/// </summary>
+	/// <param name="i">The index for buffType and buffTime</param>
+	/// <param name="b">The buff type</param>
 	public static void TryRemovingBuff(int i, int b)
 	{
 		bool flag = false;
@@ -36345,7 +_,9 @@
 			SetupDrawInterfaceLayers();
 
 		PlayerInput.SetZoom_UI();
+		List<GameInterfaceLayer> interfaceLayers = new List<GameInterfaceLayer>(_gameInterfaceLayers);
+		SystemLoader.ModifyInterfaceLayers(interfaceLayers);
-		using (List<GameInterfaceLayer>.Enumerator enumerator = _gameInterfaceLayers.GetEnumerator()) {
+		using (List<GameInterfaceLayer>.Enumerator enumerator = interfaceLayers.GetEnumerator()) {
 			while (enumerator.MoveNext() && enumerator.Current.Draw()) {
 			}
 		}
@@ -36710,6 +_,8 @@
 
 	private void DrawInterface_33_MouseText()
 	{
+		// TODO - UI Sorting and selective disable support -  move this to new one between 32 and 33
+		SystemLoader.PostDrawInterface(spriteBatch);
 		if (mouseItem.stack <= 0)
 			mouseItem.type = 0;
 
@@ -36793,7 +_,8 @@
 				num4 += num5;
 			}
 
+			//TML: Remove the Setting button being moved when player has too many slots. The ModAccessorySlot rework fixed this in a better fashion.
-			if (amountOfExtraAccessorySlotsToShow >= 1 && (screenHeight < num3 || (screenHeight < num4 && mapStyle == 1))) {
+			if (false && amountOfExtraAccessorySlotsToShow >= 1 && (screenHeight < num3 || (screenHeight < num4 && mapStyle == 1))) {
 				num -= 140;
 				num2 -= PlayerInput.SettingsForUI.PushEquipmentAreaUp.ToInt() * 30;
 				_settingsButtonIsPushedToSide = true;
@@ -37134,7 +_,9 @@
 
 	private static void DrawInterface_17_DiagnoseNet()
 	{
-		if (shouldDrawNetDiagnosticsUI)
+		if (ModNet.ShouldDrawModNetDiagnosticsUI)
+			ModNet.ModNetDiagnosticsUI.Draw(spriteBatch);
+		else if (shouldDrawNetDiagnosticsUI)
 			ActiveNetDiagnosticsUI.Draw(spriteBatch);
 	}
 
@@ -37258,6 +_,11 @@
 					if (HealthBarDrawSettings == 2)
 						num3 -= 34f;
 
+					if (!NPCLoader.DrawHealthBar(npc[num2], ref scale)) {
+						npc[num2].position -= npc[num2].netOffset;
+						continue;
+					}
+
 					if ((!expertMode || type != 266) && ((type != 439 && type != 440) || npc[num2].ai[0] != 5f)) {
 						if (type >= 134 && type <= 136) {
 							scale = 1.5f;
@@ -37996,6 +_,7 @@
 		if (!CanShowInfoAccs)
 			return;
 
+#pragma warning disable CS0219
 		bool flag = false;
 		bool flag2 = false;
 		bool flag3 = false;
@@ -38008,6 +_,7 @@
 		bool flag10 = false;
 		bool flag11 = false;
 		bool flag12 = false;
+#pragma warning restore CS0219
 		int num = -1;
 		int num2 = -10;
 		int num3 = 0;
@@ -38020,12 +_,20 @@
 		}
 
 		Microsoft.Xna.Framework.Color color = new Microsoft.Xna.Framework.Color(100, 100, 100, mouseTextColor);
+		InfoDisplayPageHandler(startX, ref text, out int startingDisplay, out int endingDisplay);
-		for (int i = 0; i < 12; i++) {
+		for (int i = startingDisplay; i < endingDisplay; i++) {
 			string text2 = "";
 			string text3 = "";
 			Microsoft.Xna.Framework.Color infoTextColor = new Microsoft.Xna.Framework.Color(mouseTextColor, mouseTextColor, mouseTextColor, mouseTextColor);
 			Microsoft.Xna.Framework.Color infoTextShadowColor = Microsoft.Xna.Framework.Color.Black;
+
+			InfoDisplay info = InfoDisplayLoader.InfoDisplays[i];
+
+			if (!InfoDisplayLoader.Active(info) || (player[myPlayer].hideInfo[info.Type] && !playerInventory))
+				continue;
+
-			if (player[myPlayer].accWatch > 0 && !flag && (!player[myPlayer].hideInfo[0] || playerInventory)) {
+			//if (player[myPlayer].accWatch > 0 && !flag && (!player[myPlayer].hideInfo[0] || playerInventory)) {
+			if (info == InfoDisplay.Watches) {
 				num = 0;
 				text3 = Lang.inter[95].Value;
 				string textValue = Language.GetTextValue("GameUI.TimeAtMorning");
@@ -38063,7 +_,8 @@
 				text2 = num7 + ":" + text4 + " " + textValue;
 				flag = true;
 			}
-			else if (player[myPlayer].accWeatherRadio && !flag5 && (!player[myPlayer].hideInfo[1] || playerInventory)) {
+			//else if (player[myPlayer].accWeatherRadio && !flag5 && (!player[myPlayer].hideInfo[1] || playerInventory)) {
+			else if (info == InfoDisplay.WeatherRadio) {
 				num = 1;
 				text3 = Lang.inter[96].Value;
 				string text5 = "";
@@ -38084,7 +_,8 @@
 
 				flag5 = true;
 			}
-			else if (player[myPlayer].accCalendar && !flag8 && (!player[myPlayer].hideInfo[7] || playerInventory)) {
+			//else if (player[myPlayer].accCalendar && !flag8 && (!player[myPlayer].hideInfo[7] || playerInventory)) {
+			else if (info == InfoDisplay.Sextant) {
 				num = ((bloodMoon && !dayTime) ? 8 : ((!eclipse || !dayTime) ? 7 : 8));
 				text3 = Lang.inter[102].Value;
 				if (moonPhase == 0)
@@ -38106,7 +_,8 @@
 
 				flag8 = true;
 			}
-			else if (player[myPlayer].accFishFinder && !flag4 && (!player[myPlayer].hideInfo[2] || playerInventory)) {
+			//else if (player[myPlayer].accFishFinder && !flag4 && (!player[myPlayer].hideInfo[2] || playerInventory)) {
+			else if (info == InfoDisplay.FishFinder) {
 				bool flag13 = false;
 				num = 2;
 				text3 = Lang.inter[97].Value;
@@ -38127,7 +_,8 @@
 
 				flag4 = true;
 			}
-			else if (player[myPlayer].accOreFinder && !flag10 && (!player[myPlayer].hideInfo[10] || playerInventory)) {
+			//else if (player[myPlayer].accOreFinder && !flag10 && (!player[myPlayer].hideInfo[10] || playerInventory)) {
+			else if (info == InfoDisplay.MetalDetector) {
 				num = 10;
 				text3 = Lang.inter[104].Value;
 				if (SceneMetrics.bestOre <= 0) {
@@ -38153,7 +_,8 @@
 
 				flag10 = true;
 			}
-			else if (player[myPlayer].accCritterGuide && !flag11 && (!player[myPlayer].hideInfo[11] || playerInventory)) {
+			//else if (player[myPlayer].accCritterGuide && !flag11 && (!player[myPlayer].hideInfo[11] || playerInventory)) {
+			else if (info == InfoDisplay.LifeformAnalyzer) {
 				flag11 = true;
 				num = 11;
 				text3 = Lang.inter[105].Value;
@@ -38185,7 +_,8 @@
 					infoTextColor = color;
 				}
 			}
-			else if (player[myPlayer].accThirdEye && !flag6 && (!player[myPlayer].hideInfo[5] || playerInventory)) {
+			//else if (player[myPlayer].accThirdEye && !flag6 && (!player[myPlayer].hideInfo[5] || playerInventory)) {
+			else if (info == InfoDisplay.Radar) {
 				flag6 = true;
 				num = 5;
 				text3 = Lang.inter[100].Value;
@@ -38210,7 +_,8 @@
 					infoTextColor = color;
 				}
 			}
-			else if (player[myPlayer].accJarOfSouls && !flag7 && (!player[myPlayer].hideInfo[6] || playerInventory)) {
+			//else if (player[myPlayer].accJarOfSouls && !flag7 && (!player[myPlayer].hideInfo[6] || playerInventory)) {
+			else if (info == InfoDisplay.TallyCounter) {
 				flag7 = true;
 				num = 6;
 				text3 = Lang.inter[101].Value;
@@ -38223,7 +_,8 @@
 					text2 = Lang.GetNPCNameValue(Item.BannerToNPC(lastCreatureHit)) + ": " + NPC.killCount[lastCreatureHit];
 				}
 			}
-			else if (player[myPlayer].accDreamCatcher && !flag12 && (!player[myPlayer].hideInfo[12] || playerInventory)) {
+			//else if (player[myPlayer].accDreamCatcher && !flag12 && (!player[myPlayer].hideInfo[12] || playerInventory)) {
+			else if (info == InfoDisplay.DPSMeter) {
 				num = 12;
 				text3 = Lang.inter[106].Value;
 				player[myPlayer].checkDPSTime();
@@ -38237,7 +_,8 @@
 					text2 = Language.GetTextValue("GameUI.DPS", player[myPlayer].getDPS());
 				}
 			}
-			else if (player[myPlayer].accStopwatch && !flag9 && (!player[myPlayer].hideInfo[9] || playerInventory)) {
+			//else if (player[myPlayer].accStopwatch && !flag9 && (!player[myPlayer].hideInfo[9] || playerInventory)) {
+			else if (info == InfoDisplay.Stopwatch) {
 				num = 9;
 				text3 = Lang.inter[103].Value;
 				Vector2 vector = player[myPlayer].velocity + player[myPlayer].instantMovementAccumulatedThisFrame;
@@ -38275,15 +_,17 @@
 				text2 = Language.GetTextValue("GameUI.Speed", Math.Round(num20));
 				flag9 = true;
 			}
-			else if (player[myPlayer].accCompass > 0 && !flag3 && (!player[myPlayer].hideInfo[3] || playerInventory)) {
+			//else if (player[myPlayer].accCompass > 0 && !flag3 && (!player[myPlayer].hideInfo[3] || playerInventory)) {
+			else if (info == InfoDisplay.Compass) {
 				num = 3;
 				text3 = Lang.inter[98].Value;
 				int num21 = (int)((player[myPlayer].position.X + (float)(player[myPlayer].width / 2)) * 2f / 16f - (float)maxTilesX);
 				text2 = ((num21 > 0) ? Language.GetTextValue("GameUI.CompassEast", num21) : ((num21 >= 0) ? Language.GetTextValue("GameUI.CompassCenter") : Language.GetTextValue("GameUI.CompassWest", -num21)));
 				flag3 = true;
 			}
-			else if (player[myPlayer].accDepthMeter > 0 && !flag2 && (!player[myPlayer].hideInfo[4] || playerInventory)) {
+			//else if (player[myPlayer].accDepthMeter > 0 && !flag2 && (!player[myPlayer].hideInfo[4] || playerInventory)) {
+			else if (info == InfoDisplay.DepthMeter) {
-				num = 4;
+			num = 4;
 				text3 = Lang.inter[99].Value;
 				int num22 = (int)((double)((player[myPlayer].position.Y + (float)player[myPlayer].height) * 2f / 16f) - worldSurface * 2.0);
 				string text6 = "";
@@ -38298,27 +_,33 @@
 				text2 = text7 + " " + text6;
 				flag2 = true;
 			}
+			else {
+				num = info.Type;
+				text2 = info.DisplayValue();
+				text3 = info.DisplayName;
+			}
+
+			InfoDisplayLoader.ModifyDisplayValue(info, ref text2);
+			InfoDisplayLoader.ModifyDisplayName(info, ref text3);
 
 			if (!(text2 != ""))
 				continue;
 
 			GetInfoAccIconPosition(num3, startX, out var X, out var Y);
 			if (num >= 0) {
-				num3++;
 				int num26 = 22;
 				if (screenHeight < 650)
 					num26 = 20;
 
-				Vector2 vector2 = new Vector2(X, Y + 74 + num26 * i + 52);
+				Vector2 vector2 = new Vector2(X, Y + 74 + num26 * num3 + 52);
-				int num27 = num;
+				int num27 = info.Type;
-				if (num27 == 8)
-					num27 = 7;
 
+				Texture2D icon = ModContent.Request<Texture2D>(info.Texture).Value;
 				Microsoft.Xna.Framework.Color color2 = Microsoft.Xna.Framework.Color.White;
 				bool flag14 = false;
 				if (playerInventory) {
 					vector2 = new Vector2(X, Y);
-					if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)TextureAssets.InfoIcon[num].Width() && (float)mouseY <= vector2.Y + (float)TextureAssets.InfoIcon[num].Height() && !PlayerInput.IgnoreMouseInterface) {
+					if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)icon.Width && (float)mouseY <= vector2.Y + (float)icon.Height && !PlayerInput.IgnoreMouseInterface) {
 						flag14 = true;
 						player[myPlayer].mouseInterface = true;
 						if (mouseLeft && mouseLeftRelease) {
@@ -38336,14 +_,18 @@
 					if (player[myPlayer].hideInfo[num27])
 						color2 = new Microsoft.Xna.Framework.Color(80, 80, 80, 70);
 				}
-				else if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)TextureAssets.InfoIcon[num].Width() && (float)mouseY <= vector2.Y + (float)TextureAssets.InfoIcon[num].Height() && !mouseText) {
+				else if ((float)mouseX >= vector2.X && (float)mouseY >= vector2.Y && (float)mouseX <= vector2.X + (float)icon.Width && (float)mouseY <= vector2.Y + (float)icon.Height && !mouseText) {
-					num2 = i;
+					//num2 = i;
+					num2 = num3;
+					if (i >= 7)
+						num2 += 1;
 					text = text3;
 					mouseText = true;
 				}
 
-				UILinkPointNavigator.SetPosition(1558 + num3 - 1, vector2 + TextureAssets.InfoIcon[num].Value.Size() * 0.75f);
-				spriteBatch.Draw(TextureAssets.InfoIcon[num].Value, vector2, new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.InfoIcon[num].Width(), TextureAssets.InfoIcon[num].Height()), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+				if(num3 < 14) // This is a quick fix until someone works on controller support
+					UILinkPointNavigator.SetPosition(1558 + num3 - 1, vector2 + icon.Size() * 0.75f);
+				spriteBatch.Draw(icon, vector2, new Microsoft.Xna.Framework.Rectangle(0, 0, icon.Width, icon.Height), color2, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 				if (flag14)
 					spriteBatch.Draw(TextureAssets.InfoIcon[13].Value, vector2 - Vector2.One * 2f, null, OurFavoriteColor, 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
 
@@ -38351,8 +_,9 @@
 			}
 
 			UILinkPointNavigator.Shortcuts.INFOACCCOUNT = num3;
+
 			if (playerInventory)
-				continue;
+				goto endThisIcon;
 
 			Vector2 scale = new Vector2(1f);
 			Vector2 vector3 = FontAssets.MouseText.Value.MeasureString(text2);
@@ -38388,8 +_,11 @@
 				if (screenHeight < 650)
 					num30 = 20;
 
-				spriteBatch.DrawString(FontAssets.MouseText.Value, text2, new Vector2(X + num28, Y + 74 + num30 * i + num29 + 48), color3, 0f, default(Vector2), scale, SpriteEffects.None, 0f);
+				spriteBatch.DrawString(FontAssets.MouseText.Value, text2, new Vector2(X + num28, Y + 74 + num30 * num3 + num29 + 48), color3, 0f, default(Vector2), scale, SpriteEffects.None, 0f);
 			}
+
+			endThisIcon:
+			num3++; // moved here due to calculation changes
 		}
 
 		if (!string.IsNullOrEmpty(text)) {
@@ -38423,8 +_,8 @@
 				Y += 261;
 		}
 		else if (ShouldDrawInfoIconsHorizontally) {
-			X = screenWidth - 280 + 20 * drawnCount - 10;
-			Y = 94;
+			X = screenWidth - 280 + 20 * (drawnCount % 12) - 10;
+			Y = 94 + (20 * (drawnCount / 12));
 			if (mapStyle == 1 && mapEnabled)
 				Y += 261;
 		}
@@ -39041,6 +_,10 @@
 	private static void TryDisposingEverything()
 	{
 		ChromaInitializer.DisableAllDeviceGroups();
+
+		SteamedWraps.OnGameExitCleanup(); // Added by TML.
+		TerrariaSteamClient.Shutdown();
+
 		CaptureManager.Instance.Dispose();
 		audioSystem.Dispose();
 	}
@@ -39360,8 +_,9 @@
 		screenLastPosition = screenPosition;
 		screenPosition.Y = (float)(worldSurface * 16.0 - (double)screenHeight);
 		MenuXMovement = 4f;
-		if (alreadyGrabbingSunOrMoon) {
+		if (alreadyGrabbingSunOrMoon && !playOldTile) {
 			playOldTile = true;
+			MenuLoader.ActivateOldVanillaMenu();
 			if (starGame)
 				playOldTile = false;
 		}
@@ -39449,13 +_,14 @@
 				logoScaleSpeed -= 1f;
 		}
 
+		MenuLoader.UpdateAndDrawModMenu(spriteBatch, gameTime, color, logoRotation, logoScale);
 		Microsoft.Xna.Framework.Color color2 = new Microsoft.Xna.Framework.Color((byte)((float)(int)color.R * ((float)LogoA / 255f)), (byte)((float)(int)color.G * ((float)LogoA / 255f)), (byte)((float)(int)color.B * ((float)LogoA / 255f)), (byte)((float)(int)color.A * ((float)LogoA / 255f)));
 		Microsoft.Xna.Framework.Color color3 = new Microsoft.Xna.Framework.Color((byte)((float)(int)color.R * ((float)LogoB / 255f)), (byte)((float)(int)color.G * ((float)LogoB / 255f)), (byte)((float)(int)color.B * ((float)LogoB / 255f)), (byte)((float)(int)color.A * ((float)LogoB / 255f)));
-		if (playOldTile) {
+		if (MenuLoader.MenuOldVanilla.IsSelected) {
 			spriteBatch.Draw(TextureAssets.Logo3.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color2, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 			spriteBatch.Draw(TextureAssets.Logo4.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color3, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 		}
-		else {
+		else if (MenuLoader.MenuJourneysEnd.IsSelected) {
 			spriteBatch.Draw(TextureAssets.Logo.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color2, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 			spriteBatch.Draw(TextureAssets.Logo2.Value, new Vector2(screenWidth / 2, 100f), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.Logo.Width(), TextureAssets.Logo.Height()), color3, logoRotation, new Vector2(TextureAssets.Logo.Width() / 2, TextureAssets.Logo.Height() / 2), logoScale, SpriteEffects.None, 0f);
 		}
@@ -39514,8 +_,21 @@
 		if (menuMode == -1)
 			menuMode = 0;
 
-		if (Program.LoadedEverything)
+		if (Program.LoadedEverything) {
 			GamepadMainMenuHandler.CanRun = true;
+		} else {
+			array9[0] = string.Format("{0}  {1}", Language.GetTextValue("UI.LoadingCode"), Program.LoadedPercentage.ToString("P0"));
+			if (!ModLoader.ModLoader.skipLoad) {
+				array9[1] = "Click to skip loading mods";
+				array7[1] = 0.5f;
+				num5 = 2;
+				if(selectedMenu == 1) {
+					ModLoader.ModLoader.skipLoad = true;
+				}
+			}
+
+			goto SkipMenuEnumeration; //Put the label somewhere after the following if-else chain.
+		}
 
 		if (menuMode == 1212) {
 			array9[0] = Lang.menu[102].Value;
@@ -39552,7 +_,7 @@
 			if (selectedMenu >= 1) {
 				changeTheTitle = true;
 				LanguageManager.Instance.SetLanguage(selectedMenu);
-				menuMode = 0;
+				menuMode = Interface.loadModsID;
 				SoundEngine.PlaySound(10);
 				SaveSettings();
 			}
@@ -39692,7 +_,7 @@
 				OnSubmitServerPasswordFromRequest();
 			}
 		}
-		else if ((netMode == 1 && menuMode != 888) || menuMode == 14) {
+		else if (netMode == 1 && menuMode < 10000 && menuMode != 888 || menuMode == 14) {
 			num5 = 2;
 			array9[0] = statusText;
 			array[0] = true;
@@ -39802,7 +_,10 @@
 			array4[3] = 30;
 			array4[4] = 70;
 			array4[5] = 70;
+			array4[6] = 70;
-			num5 = 6;
+			num5 = 7;
+			array9[6] = Language.GetTextValue(showServerConsole ? "tModLoader.MPShowServerConsoleYes" : "tModLoader.MPShowServerConsoleNo");
+			array7[6] = 0.5f;
 			array9[0] = Lang.menu[135].Value;
 			array9[4] = Lang.menu[144].Value;
 			array9[5] = Lang.menu[5].Value;
@@ -39863,6 +_,10 @@
 					menuMode = 6;
 					SoundEngine.PlaySound(11);
 					break;
+				case 6:
+					showServerConsole = !showServerConsole;
+					SoundEngine.PlaySound(12, -1, -1, 1, 1f, 0f);
+					break;
 			}
 		}
 		else if (menuMode == 15) {
@@ -39883,16 +_,23 @@
 		else if (menuMode == 200) {
 			num5 = 3;
 			array9[0] = Lang.menu[9].Value;
+			if (WorldIO.customDataFail != null)
+				array9[0] = WorldIO.customDataFail.modName + ": " + array9[0];
+
 			array[0] = true;
 			num2 -= 30;
 			array4[1] = 70;
 			array4[2] = 50;
 			array9[1] = Lang.menu[10].Value;
 			array9[2] = Lang.menu[6].Value;
+			if (WorldIO.customDataFail != null)
+				array9[2] = Language.GetTextValue("tModLoader.OpenLogs");
+
 			if (selectedMenu == 1) {
 				if (FileUtilities.Exists(worldPathName + ".bak", ActiveWorldFileData.IsCloudSave)) {
 					FileUtilities.Move(worldPathName, worldPathName + ".bad", ActiveWorldFileData.IsCloudSave);
 					FileUtilities.Move(worldPathName + ".bak", worldPathName, ActiveWorldFileData.IsCloudSave);
+					WorldIO.LoadBackup(worldPathName, ActiveWorldFileData.IsCloudSave);
 					SoundEngine.PlaySound(10);
 					WorldGen.playWorld();
 					menuMode = 10;
@@ -39907,13 +_,23 @@
 			if (selectedMenu == 2 || flag5) {
 				flag5 = false;
 				SoundEngine.PlaySound(11);
+				if (WorldIO.customDataFail == null)
-				menuMode = 0;
+					menuMode = 0;
+				else {
+					Logging.tML.Error(Language.GetTextValue("tModLoader.WorldIODataException"), WorldIO.customDataFail.InnerException);
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenFolder(Logging.LogDir);
+				}
+
 				netMode = 0;
 			}
 		}
 		else if (menuMode == 201) {
 			num5 = 3;
 			array9[0] = Lang.menu[9].Value;
+			if (WorldIO.customDataFail != null)
+				array9[0] = WorldIO.customDataFail.modName + ": " + array9[0];
+
 			array[0] = true;
 			array[1] = true;
 			num2 -= 30;
@@ -39921,9 +_,21 @@
 			array4[2] = 50;
 			array9[1] = Lang.menu[11].Value;
 			array9[2] = Lang.menu[5].Value;
+			if (WorldIO.customDataFail != null)
+				array9[2] = Language.GetTextValue("tModLoader.OpenLogs");
+
 			if (selectedMenu == 2 || flag5) {
 				flag5 = false;
 				SoundEngine.PlaySound(11);
+				if (WorldIO.customDataFail == null) {
+					menuMode = 0;
+				}
+				else {
+					Logging.tML.Error(Language.GetTextValue("tModLoader.WorldIODataException"), WorldIO.customDataFail.InnerException);
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenFolder(Logging.LogDir);
+				}
+
 				menuMode = 0;
 				netMode = 0;
 			}
@@ -39981,7 +_,9 @@
 			}
 
 			num11++;
-			if (SocialAPI.Workshop != null) {
+
+			// The workshop hub itself will no longer be exclusive to Steam versions.
+			if (true) { //if (SocialAPI.Workshop != null) {
 				array9[num11] = Language.GetText("UI.Workshop").Value;
 				if (selectedMenu == num11) {
 					SoundEngine.PlaySound(10);
@@ -40000,6 +_,7 @@
 			}
 
 			num11++;
+			Interface.AddMenuButtons(this, selectedMenu, array9, array7, ref num2, ref num4, ref num11, ref num5);
 			array9[num11] = Lang.menu[14].Value;
 			if (selectedMenu == num11) {
 				SoundEngine.PlaySound(10);
@@ -40628,6 +_,7 @@
 				num2 = 210;
 				num4 = 37;
 				num5 = 8;
+				num5++; // Room for tModLoader settings option.
 				array4[num5 - 1] = 8;
 				for (int num19 = 0; num19 < num5; num19++) {
 					array7[num19] = 0.75f;
@@ -40683,6 +_,13 @@
 				}
 
 				num20++;
+				array9[num20] = Language.GetTextValue("tModLoader.tModLoaderSettings");
+				if (selectedMenu == num20) {
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					menuMode = Interface.tModLoaderSettingsID;
+				}
+
+				num20++;
 				array9[num20] = Lang.menu[5].Value;
 				if (selectedMenu == num20 || flag5) {
 					flag5 = false;
@@ -40761,6 +_,7 @@
 				num2 = 210;
 				num4 = 32;
 				num5 = 10;
+				num5++; // Room for tModLoader BossBarStyle option.
 				array4[num5 - 1] = 18;
 				for (int num23 = 0; num23 < num5; num23++) {
 					array7[num23] = 0.7f;
@@ -40824,8 +_,11 @@
 					MinimapFrameManagerInstance.CycleSelection();
 
 				num24++;
+				/*
 				string activeSetKeyName = ResourceSetsManager.ActiveSetKeyName;
 				string textValue2 = Language.GetTextValue("UI.HealthManaStyle_" + activeSetKeyName);
+				*/
+				string textValue2 = ResourceSetsManager.ActiveSet.DisplayedName;
 				array9[num24] = Language.GetTextValue("UI.SelectHealthStyle", textValue2);
 				if (selectedMenu == num24)
 					ResourceSetsManager.CycleResourceSet();
@@ -40836,6 +_,11 @@
 					BigProgressBarSystem.ToggleShowText();
 
 				num24++;
+				array9[num24] = BossBarLoader.InsertMenu(out Action onClick);
+				if (selectedMenu == num24)
+					onClick();
+
+				num24++;
 				array9[num24] = Lang.menu[5].Value;
 				if (selectedMenu == num24 || flag5) {
 					flag5 = false;
@@ -41003,19 +_,21 @@
 				num4 = 55;
 				int num30 = 0;
 				array9[num30] = Lang.menu[73].Value + ": " + PendingResolutionWidth + "x" + PendingResolutionHeight;
-				if (selectedMenu == num30) {
+				if (selectedMenu == num30 || selectedMenu2 == num30) {
 					SoundEngine.PlaySound(12);
 					int num31 = 0;
 					for (int num32 = 0; num32 < numDisplayModes; num32++) {
+						// TML: Match the changeto follow so that resolution options provided on this settings menu still can be cycled correctly
-						if (displayWidth[num32] == PendingResolutionWidth && displayHeight[num32] == PendingResolutionHeight) {
+						if (displayWidth[num32] == PendingResolutionWidth && BorderedHeight(displayHeight[num32], graphics.IsFullScreen) == PendingResolutionHeight) {
 							num31 = num32;
 							break;
 						}
 					}
 
-					num31 = (num31 + 1) % numDisplayModes;
+					num31 = Utils.Repeat(num31 + ((selectedMenu == num30) ? 1 : -1), Main.numDisplayModes);
 					PendingResolutionWidth = displayWidth[num31];
-					PendingResolutionHeight = displayHeight[num31];
+					// TML: Limit the resolution when going from fullscreen to windowed to be less than the full monitor size so that the key window edges are accessible
+					PendingResolutionHeight = BorderedHeight(displayHeight[num31], graphics.IsFullScreen);
 				}
 
 				num30++;
@@ -41781,7 +_,12 @@
 					}
 				}
 			}
+			else {
+				Interface.ModLoaderMenus(this, selectedMenu, array9, array7, array4, ref num2, ref num4, ref num5, ref flag5);
+			}
 		}
+
+		SkipMenuEnumeration:
 
 		if (menuMode == 888) {
 			if (!_blockFancyUIWhileLoading)
@@ -42491,6 +_,7 @@
 		if (!WorldGen.drunkWorldGen && menuMode == 0) {
 			DrawSocialMediaButtons(color, num110);
 			num110 += 32f;
+			DrawtModLoaderSocialMediaButtons(color, num110);
 		}
 
 		if (!WorldGen.drunkWorldGen) {
@@ -42528,6 +_,21 @@
 		else
 			mouseRightRelease = true;
 
+		if (mouseMiddle)
+			mouseMiddleRelease = false;
+		else
+			mouseMiddleRelease = true;
+
+		if (mouseXButton1)
+			mouseXButton1Release = false;
+		else
+			mouseXButton1Release = true;
+
+		if (mouseXButton2)
+			mouseXButton2Release = false;
+		else
+			mouseXButton2Release = true;
+
 		if (menuMode == num)
 			GamepadMainMenuHandler.LastDrew = num;
 	}
@@ -42570,28 +_,41 @@
 
 	private void OnSubmitServerPassword()
 	{
-		string text = "-autoshutdown -password \"" + ConvertToSafeArgument(Netplay.ServerPassword) + "\" -lang " + Language.ActiveCulture.LegacyId;
+		string text = "tModLoader.dll -server " + "-autoshutdown -password \"" + ConvertToSafeArgument(Netplay.ServerPassword) + "\" -lang " + Language.ActiveCulture.LegacyId;
 		if (Platform.IsLinux)
 			text = ((IntPtr.Size != 8) ? (text + " -x86") : (text + " -x64"));
 
 		text = ((!ActiveWorldFileData.IsCloudSave) ? (text + SanitizePathArgument("world", worldPathName)) : (text + SanitizePathArgument("cloudworld", worldPathName)));
 		text = text + " -worldrollbackstokeep " + WorldRollingBackupsCountToKeep;
+		text += $@" -modpath ""{ModOrganizer.modPath}""";
+		if (showServerConsole)
+		text += " -showserverconsole";
+
 		tServer = new Process();
+		/*
 		if (Platform.IsLinux)
 			tServer.StartInfo.FileName = "TerrariaServer";
 		else if (Platform.IsOSX)
 			tServer.StartInfo.FileName = "../MacOS/TerrariaServer";
 		else
 			tServer.StartInfo.FileName = "TerrariaServer.exe";
+		*/
 
+		tServer.StartInfo.FileName = Process.GetCurrentProcess().MainModule.FileName;
 		tServer.StartInfo.Arguments = text;
 		if (libPath != "") {
 			ProcessStartInfo startInfo = tServer.StartInfo;
 			startInfo.Arguments = startInfo.Arguments + " -loadlib " + libPath;
 		}
 
+		/*
 		tServer.StartInfo.UseShellExecute = false;
 		tServer.StartInfo.CreateNoWindow = true;
+		*/
+		tServer.StartInfo.UseShellExecute = true;
+		if (!showServerConsole)
+			tServer.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
+
 		if (SocialAPI.Network != null)
 			SocialAPI.Network.LaunchLocalServer(tServer, MenuServerMode);
 		else
@@ -42655,7 +_,19 @@
 
 	private static void DrawVersionNumber(Microsoft.Xna.Framework.Color menuColor, float upBump)
 	{
-		string text = versionNumber;
+		string supportMessage = Language.GetTextValue("tModLoader.PatreonSupport");
+		string patreonShortURL = @"patreon.com/tModLoader";
+		bool showPatreon = SocialAPI.Mode != SocialMode.Steam;
+
+		// Show number of mods - 1 such as to show number of enabled mods that are not tModLoader itself
+		string modsMessage = Language.GetTextValue("tModLoader.MenuModsEnabled", Math.Max(0, ModLoader.ModLoader.Mods.Length - 1));
+		/* //TODO: FUTURE
+		if (ModLoader.Core.GOGModUpdateChecker.ModUpdatesAvailable > 0) {
+			modsMessage += " " + Language.GetTextValue("tModLoader.MenuModUpdatesAvailable", ModLoader.Core.GOGModUpdateChecker.ModUpdatesAvailable);
+		}
+		*/
+		string text = ModLoader.ModLoader.versionedName + (showPatreon ? Environment.NewLine + supportMessage : "") + (Main.menuMode == 0 ? Environment.NewLine : "") + Environment.NewLine + "Terraria " + versionNumber;
+
 		Vector2 origin = FontAssets.MouseText.Value.MeasureString(text);
 		origin.X *= 0.5f;
 		origin.Y *= 0.5f;
@@ -42684,7 +_,59 @@
 				num2 = 2;
 
 			spriteBatch.DrawString(FontAssets.MouseText.Value, text, new Vector2(origin.X + (float)num + 10f, (float)screenHeight - origin.Y + (float)num2 - 2f - upBump), color, 0f, origin, 1f, SpriteEffects.None, 0f);
+
+			// Developer mode button.
+			if (menuMode == 0 /*&& !ModCompile.DeveloperMode*/) {
+				string DeveloperModeText = Language.GetTextValue("tModLoader.13InfoButton");
+
+				// measure and draw text from bottom right
+				var textSize = FontAssets.MouseText.Value.MeasureString(DeveloperModeText);
+				var pos = new Vector2(screenWidth - 10f + num, screenHeight - 2f + num2);
+				var d_color = color;
+
+				float scale = 1.2f;
+
+				// final draw
+				if (i == 4) {
+					var rect = new Rectangle((int)(pos.X - textSize.X * scale), (int)(pos.Y - textSize.Y * scale), (int)(textSize.X * scale), (int)(textSize.Y * scale));
+					bool mouseover = rect.Contains(mouseX, mouseY);
+					d_color = mouseover ? highVersionColor : d_color;
+
+					if (mouseover && mouseLeftRelease && mouseLeft) {
+						SoundEngine.PlaySound(SoundID.MenuOpen);
+						Utils.OpenToURL("https://github.com/tModLoader/tModLoader/wiki/tModLoader-guide-for-players");
+					}
+				}
+
+				spriteBatch.DrawString(FontAssets.MouseText.Value, DeveloperModeText, pos, d_color, 0f, textSize, 1.2f, SpriteEffects.None, 0f);
+			}
+
+			// TML Patreon.
+			if (showPatreon) {
+				var font = FontAssets.MouseText.Value;
+				var patreonOrigin = font.MeasureString(supportMessage);
+				Vector2 urlSize = font.MeasureString(patreonShortURL);
+
+				spriteBatch.DrawString(font, patreonShortURL, new Vector2(patreonOrigin.X + num + 10f, screenHeight - patreonOrigin.Y + num2 - 2f - (int)upBump), color, 0f, Vector2.Zero, 1f, SpriteEffects.None, 0f);
+
+				if (i == 4 && mouseLeftRelease && mouseLeft && new Microsoft.Xna.Framework.Rectangle((int)patreonOrigin.X + 10, screenHeight - (int)urlSize.Y - 2 - (int)upBump, (int)urlSize.X, (int)patreonOrigin.Y).Contains(new Microsoft.Xna.Framework.Point(mouseX, mouseY)) && hasFocus) {
+					SoundEngine.PlaySound(SoundID.MenuOpen);
+					Utils.OpenToURL("https://www.patreon.com/tModLoader");
+				}
+			}
+
+			// ModPack
+			if (ModOrganizer.ModPackActive != null) {
+				var font = FontAssets.MouseText.Value;
+				string modpackText = Language.GetTextValue("tModLoader.CurrentModPack", Path.GetFileNameWithoutExtension(ModOrganizer.ModPackActive));
+				var packOrigin = font.MeasureString(modpackText);
+
+				spriteBatch.DrawString(font, modpackText, new Vector2(packOrigin.X + num + 10f, screenHeight - packOrigin.Y + num2 - 2f - (int)upBump), color, 0f, Vector2.Zero, 1f, SpriteEffects.None, 0f);
+
+			}
 		}
+
+		// End of DrawVersionNumber
 	}
 
 	private static void ClearVisualPostProcessEffects()
@@ -42782,6 +_,10 @@
 		CreditsRollEvent.Reset();
 		maxRaining = 0f;
 		raining = false;
+
+		//Added by tML.
+		Graphics.Effects.Filters.Scene.DeactivateAll();
+		SkyManager.Instance.DeactivateAll();
 	}
 
 	private static void PostDrawMenu(Microsoft.Xna.Framework.Point screenSizeCache, Microsoft.Xna.Framework.Point screenSizeCacheAfterScaling)
@@ -43282,9 +_,16 @@
 		float value = (float)((double)(screenPosition.Y - (float)(screenHeight / 2) + 200f) - rockLayer * 16.0) / 300f;
 		value = MathHelper.Clamp(value, 0f, 1f);
 		int num8 = (int)((screenPosition.X + (float)(screenWidth / 2)) / 16f);
+
+		LoaderManager.Get<UndergroundBackgroundStylesLoader>().ChooseStyle(out var modBG, out var priority);
 		int num9 = 3;
 		num9 = ((num8 <= caveBackX[0]) ? caveBackStyle[0] : ((num8 <= caveBackX[1]) ? caveBackStyle[1] : ((num8 > caveBackX[2]) ? caveBackStyle[3] : caveBackStyle[2])));
 		num9 += 3;
+
+		if (priority == SceneEffectPriority.BiomeLow) {
+			num9 = modBG;
+		}
+
 		if (SceneMetrics.SnowTileCount > SceneMetrics.SnowTileThreshold && (screenPosition.Y + (float)screenHeight + 1200f) / 16f < (float)(maxTilesY - 250))
 			num9 = 1;
 
@@ -43298,6 +_,10 @@
 			}
 		}
 
+		if (priority == SceneEffectPriority.BiomeMedium) {
+			num9 = modBG;
+		}
+
 		if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenHeight / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			num9 = (player[myPlayer].ZoneCorrupt ? 19 : (player[myPlayer].ZoneCrimson ? 21 : ((!player[myPlayer].ZoneHallow) ? 18 : 20)));
 		}
@@ -43324,6 +_,16 @@
 		if (player[myPlayer].ZoneGlowshroom)
 			num9 = 2;
 
+		if (priority >= SceneEffectPriority.BiomeHigh) {
+			num9 = modBG;
+		}
+
+		if (GlobalBackgroundStyleLoader.loaded) {
+			foreach (var hook in GlobalBackgroundStyleLoader.HookChooseUndergroundBackgroundStyle) {
+				hook(ref num9);
+			}
+		}
+
 		if (num9 != undergroundBackground) {
 			oldUndergroundBackground = undergroundBackground;
 			undergroundBackground = num9;
@@ -43532,6 +_,7 @@
 				array3[5] = 127;
 
 			array3[6] = 185 + hellBackStyle;
+			LoaderManager.Get<UndergroundBackgroundStylesLoader>().FillTextureArray(num9, array3);
 			LoadBackground(array3[0]);
 			LoadBackground(array3[1]);
 			LoadBackground(array3[2]);
@@ -45768,8 +_,22 @@
 			spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp, DepthStencilState.None, RasterizerState.CullCounterClockwise);
 			flag = true;
 			DrawMapFullscreenBackground(screenPosition, screenWidth, screenHeight);
+			/* Map texture drawing replaced by an adaptive drawing below, as mod worlds sometimes aren't regular sizes.
 			Microsoft.Xna.Framework.Rectangle destinationRectangle = new Microsoft.Xna.Framework.Rectangle((int)num27, (int)num28, (int)num29, (int)num30);
 			spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, Microsoft.Xna.Framework.Color.White);
+			*/
+			int x = (int)(num + mapFullscreenScale * 10);
+			int y = (int)(num2 + mapFullscreenScale * 10);
+			int width = (int)((maxTilesX - 40) * mapFullscreenScale);
+			int height = (int)((maxTilesY - 40) * mapFullscreenScale);
+			var destinationRectangle = new Rectangle(x, y, width, height);
+			spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(40, 4, 848, 240), Color.White);
+			int edgeWidth = (int)(40 * mapFullscreenScale * 5);
+			int edgeHeight = (int)(4 * mapFullscreenScale * 5);
+			destinationRectangle = new Rectangle(x - edgeWidth, y - edgeHeight, edgeWidth, height + 2 * edgeHeight);
+			spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(0, 0, 40, 248), Color.White);
+			destinationRectangle = new Rectangle(x + width, y - edgeHeight, edgeWidth, height + 2 * edgeHeight);
+			spriteBatch.Draw(TextureAssets.Map.Value, destinationRectangle, new Rectangle(888, 0, 40, 248), Color.White);
 			if (mouseLeft && mouseLeftRelease) {
 				double totalSeconds = gameTime.TotalGameTime.TotalSeconds;
 				if (totalSeconds - _lastPingMouseDownTime < 0.5 && Vector2.Distance(MouseScreen, _lastPingMousePosition) < 2f)
@@ -45881,7 +_,7 @@
 		float num40 = (float)textureMaxHeight * num5;
 		float num41 = num;
 		float num42 = 0f;
-		for (int k = 0; k <= 4; k++) {
+		for (int k = 0; k <= mapTargetX - 1; k++) {
 			if (!((float)((k + 1) * textureMaxWidth) > num7) || !((float)(k * textureMaxWidth) < num7 + num9))
 				continue;
 
@@ -46268,6 +_,7 @@
 					}
 				}
 				else if (type >= num97 && type < num97 + num98) {
+					//patch file: num89, num90
 					Tile tile5 = Main.tile[num89, num90];
 					if (tile5 != null) {
 						int num107 = num90;
@@ -46281,6 +_,7 @@
 				}
 				else {
 					text = Lang.GetMapObjectName(type);
+					text = Lang._mapLegendCache.FromTile(Map[num89, num90], num89, num90);
 				}
 			}
 
@@ -46445,6 +_,7 @@
 			}
 
 			spriteBatch.Draw(TextureAssets.MapIcon[num135].Value, new Vector2(num133, num134), new Microsoft.Xna.Framework.Rectangle(0, 0, TextureAssets.MapIcon[num135].Width(), TextureAssets.MapIcon[num135].Height()), new Microsoft.Xna.Framework.Color(num136, num136, num136, num136), 0f, default(Vector2), 1f, SpriteEffects.None, 0f);
+			SystemLoader.PostDrawFullscreenMap(ref text);
 			DrawCursor(DrawThickCursor());
 		}
 
@@ -46478,6 +_,10 @@
 
 	private static void DrawMapFullscreenBackground(Vector2 screenPosition, int screenWidth, int screenHeight)
 	{
+		if (ModContent.RequestIfExists<Texture2D>(LocalPlayer.CurrentSceneEffect.mapBackground, out var modTexture, AssetRequestMode.ImmediateLoad)) {
+			spriteBatch.Draw(modTexture.Value, new Microsoft.Xna.Framework.Rectangle(0, 0, screenWidth, screenHeight), Microsoft.Xna.Framework.Color.White);
+			return;
+		}
 		Asset<Texture2D> asset = TextureAssets.MapBGs[0];
 		int num = -1;
 		Microsoft.Xna.Framework.Color color = Microsoft.Xna.Framework.Color.White;
@@ -47213,6 +_,11 @@
 			case 4:
 				return 13;
 			default:
+				LoaderManager.Get<WaterStylesLoader>().ChooseStyle(out var waterStyle, out var priority);
+				if (priority >= SceneEffectPriority.BiomeLow) {
+					return waterStyle;
+				}
+
 				if (remixWorld) {
 					if ((double)(screenPosition.Y / 16f) > rockLayer)
 						return 7;
@@ -47240,6 +_,9 @@
 		if (liquidStyle != 1)
 			return liquidStyle != 11;
 
+		if (liquidStyle >= Main.maxLiquidTypes)
+			return true; // currently all modded liquid styles come from WaterStylesLoader
+
 		return false;
 	}
 
@@ -47256,6 +_,7 @@
 						liquidAlpha[i] = Math.Min(liquidAlpha[i] + 0.2f, 1f);
 				}
 			}
+			LoaderManager.Get<WaterStylesLoader>().UpdateLiquidAlphas();
 		}
 
 		if (!drawToScreen && !isBackground) {
@@ -47273,7 +_,7 @@
 		}
 
 		bool flag = false;
-		for (int j = 0; j < 15; j++) {
+		for (int j = 0; j < LoaderManager.Get<WaterStylesLoader>().TotalCount; j++) {
 			if (IsLiquidStyleWater(j) && liquidAlpha[j] > 0f && j != waterStyle) {
 				DrawLiquid(isBackground, j, isBackground ? 1f : liquidAlpha[j], drawSinglePassLiquids: false);
 				flag = true;
@@ -47283,7 +_,7 @@
 		DrawLiquid(isBackground, waterStyle, flag ? liquidAlpha[waterStyle] : 1f);
 	}
 
-	protected void DrawLiquid(bool bg = false, int waterStyle = 0, float Alpha = 1f, bool drawSinglePassLiquids = true)
+	protected internal void DrawLiquid(bool bg = false, int waterStyle = 0, float Alpha = 1f, bool drawSinglePassLiquids = true)
 	{
 		if (!Lighting.NotRetro) {
 			oldDrawWater(bg, waterStyle, Alpha);
@@ -48943,12 +_,12 @@
 		if (!WorldGen.drunkWorldGen && flag && (double)(screenPosition.Y / 16f) <= worldSurface + 10.0) {
 			if (BackgroundEnabled) {
 				if (cloudBGActive > 0f) {
-					cloudBGAlpha += 0.0005f * (float)dayRate;
+					cloudBGAlpha += 0.0005f * (float)desiredWorldEventsUpdateRate;
 					if (cloudBGAlpha > 1f)
 						cloudBGAlpha = 1f;
 				}
 				else {
-					cloudBGAlpha -= 0.0005f * (float)dayRate;
+					cloudBGAlpha -= 0.0005f * (float)desiredWorldEventsUpdateRate;
 					if (cloudBGAlpha < 0f)
 						cloudBGAlpha = 0f;
 				}
@@ -48963,7 +_,7 @@
 					bgScale = 1.65f;
 					bgParallax = 0.09000000357627869;
 					if (base.IsActive && !gamePaused)
-						cloudBGX[0] += windSpeedCurrent * (float)bgParallax * 9f * (float)dayRate;
+						cloudBGX[0] += windSpeedCurrent * (float)bgParallax * 9f * (float)desiredWorldEventsUpdateRate;
 
 					if (cloudBGX[0] > (float)backgroundWidth[cloudBG[0]] * bgScale)
 						cloudBGX[0] -= (float)backgroundWidth[cloudBG[0]] * bgScale;
@@ -48993,7 +_,7 @@
 					bgScale = 1.85f;
 					bgParallax = 0.12;
 					if (base.IsActive && !gamePaused)
-						cloudBGX[1] += windSpeedCurrent * (float)bgParallax * 9f * (float)dayRate;
+						cloudBGX[1] += windSpeedCurrent * (float)bgParallax * 9f * (float)desiredWorldEventsUpdateRate;
 
 					if (cloudBGX[1] > (float)backgroundWidth[cloudBG[1]] * bgScale)
 						cloudBGX[1] -= (float)backgroundWidth[cloudBG[1]] * bgScale;
@@ -49200,6 +_,10 @@
 						DrawSurfaceBG_Mushroom(num4, num5, num6, bgTexIndexes7);
 						DrawSurfaceBG_DrawChangeOverlay(11);
 					}
+
+					if (num21 >= BG_STYLES_COUNT) {
+						LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawCloseBackground(num21);
+					}
 				}
 			}
 		}
@@ -49367,6 +_,7 @@
 			DrawSurfaceBG_DrawBackMountainsLayer(246);
 		}
 
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawFarTexture();
 		SkyManager.Instance.DrawToDepth(spriteBatch, 5f);
 	}
 
@@ -49438,6 +_,8 @@
 			if (treeMntBGSet4[1] > -1)
 				DrawSurfaceBG_DrawBackMountainsLayer(treeMntBGSet4[1]);
 		}
+
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().DrawMiddleTexture();
 	}
 
 	private void UpdateOceanWaterLineForAmbience()
@@ -50646,7 +_,7 @@
 
 			bool flag3 = false;
 			bool flag4 = false;
-			if (tile[x, y].type == 10) {
+			if (TileLoader.IsClosedDoor(tile[x, y])) {
 				flag3 = false;
 			}
 			else if (tileSolid[tile[x, y].type] && !tileSolidTop[tile[x, y].type]) {
@@ -50724,6 +_,7 @@
 
 	protected override void Draw(GameTime gameTime)
 	{
+		try {
 		if (!_isDrawingOrUpdating && IsGraphicsDeviceAvailable) {
 			_isDrawingOrUpdating = true;
 			EnsureRenderTargetContent();
@@ -50732,7 +_,13 @@
 				Main.OnPostDraw(gameTime);
 
 			Assets.TransferCompletedAssets();
+			ModContent.TransferCompletedAssets();
 			_isDrawingOrUpdating = false;
+		}
+		}
+		catch (Exception e) {
+			Logging.Terraria.Error(e);
+			throw;
 		}
 	}
 
@@ -50867,19 +_,22 @@
 				renderCount = 99;
 			}
 			else {
+				//TML: RenderTiles() is quite slow. ~30ms at peak; doesn't change with lighting modes
 				if (renderCount == 3) {
 					RenderTiles();
 					sceneTilePos.X = screenPosition.X - (float)offScreenRange;
 					sceneTilePos.Y = screenPosition.Y - (float)offScreenRange;
 				}
 
-				if (renderCount == 3) {
+				//TML: Remapped from 3 to 2 to flatten per frame load for colour lighting ( ~5ms peak).
+				if (renderCount == (Lighting.LegacyEngine.Mode == 0 ? 2 : 3)) {
 					RenderTiles2();
 					sceneTile2Pos.X = screenPosition.X - (float)offScreenRange;
 					sceneTile2Pos.Y = screenPosition.Y - (float)offScreenRange;
 				}
 
-				if (renderCount == 3) {
+				//TML: Remapped from 3 to 0 to flatten per frame load for colour lighting ( ~15ms peak).
+				if (renderCount == (Lighting.LegacyEngine.Mode == 0 ? 0 : 3)) {
 					RenderWalls();
 					sceneWallPos.X = screenPosition.X - (float)offScreenRange;
 					sceneWallPos.Y = screenPosition.Y - (float)offScreenRange;
@@ -50974,10 +_,13 @@
 		if (gameMenu || netMode == 2)
 			bgTopY = -200;
 
+		/*
 		int num3 = dayRate;
 		if (num3 < 1)
 			num3 = 1;
+		*/
 
+		double num3 = desiredWorldEventsUpdateRate;
 		float num4 = 0.0005f * (float)num3;
 		if (gameMenu)
 			num4 *= 20f;
@@ -51044,13 +_,16 @@
 		UpdateAtmosphereTransparencyToSkyColor();
 		base.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Black);
 		base.Draw(gameTime);
-		float val = (float)screenWidth / MinimumZoomComparerX;
-		float val2 = (float)screenHeight / MinimumZoomComparerY;
+		float val = screenWidth / (ModLoader.ModLoader.removeForcedMinimumZoom ? 8192f : MinimumZoomComparerX);
+		float val2 = screenHeight / (ModLoader.ModLoader.removeForcedMinimumZoom ? 8192f : MinimumZoomComparerY);
 		ForcedMinimumZoom = Math.Max(Math.Max(1f, val), val2);
 		GameViewMatrix.Effects = ((!gameMenu && player[myPlayer].gravDir != 1f) ? SpriteEffects.FlipVertically : SpriteEffects.None);
 		BackgroundViewMatrix.Effects = GameViewMatrix.Effects;
 		BackgroundViewMatrix.Zoom = new Vector2(ForcedMinimumZoom);
 		GameViewMatrix.Zoom = new Vector2(ForcedMinimumZoom * MathHelper.Clamp(GameZoomTarget, 1f, 2f));
+
+		SystemLoader.ModifyTransformMatrix(ref GameViewMatrix);
+
 		if (gameMenu || player[myPlayer].gravDir == 1f)
 			Rasterizer = RasterizerState.CullCounterClockwise;
 		else
@@ -51139,7 +_,7 @@
 		spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.LinearClamp, DepthStencilState.None, Rasterizer, null, GameViewMatrix.TransformationMatrix);
 		DrawBackgroundBlackFill();
 		spriteBatch.End();
-		Overlays.Scene.Draw(spriteBatch, RenderLayers.Landscape);
+		Overlays.Scene.Draw(spriteBatch, RenderLayers.Landscape, true);
 		spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.LinearClamp, DepthStencilState.None, Rasterizer, null, UIScaleMatrix);
 		if (gameMenu || netMode == 2) {
 			spriteBatch.End();
@@ -51251,6 +_,7 @@
 
 		TimeLogger.DetailedDrawReset();
 		spriteBatch.End();
+		SystemLoader.PostDrawTiles();
 		TimeLogger.DetailedDrawTime(35);
 		HasInteractibleObjectThatIsNotATile = false;
 		SortDrawCacheWorms();
@@ -51332,7 +_,7 @@
 		ScreenObstruction.Draw(spriteBatch);
 		TimeLogger.DetailedDrawReset();
 		spriteBatch.End();
-		Overlays.Scene.Draw(spriteBatch, RenderLayers.All);
+		Overlays.Scene.Draw(spriteBatch, RenderLayers.All, true);
 		if (flag2)
 			Terraria.Graphics.Effects.Filters.Scene.EndCapture(null, screenTarget, screenTargetSwap, Microsoft.Xna.Framework.Color.Black);
 
@@ -51457,6 +_,21 @@
 		else
 			mouseRightRelease = true;
 
+		if (mouseMiddle)
+			mouseMiddleRelease = false;
+		else
+			mouseMiddleRelease = true;
+
+		if (mouseXButton1)
+			mouseXButton1Release = false;
+		else
+			mouseXButton1Release = true;
+
+		if (mouseXButton2)
+			mouseXButton2Release = false;
+		else
+			mouseXButton2Release = true;
+
 		if (!PlayerInput.Triggers.Current.MouseRight && !PlayerInput.Triggers.Current.MouseLeft && !preventStackSplitReset)
 			stackSplit = 0;
 
@@ -51653,6 +_,7 @@
 						else if (player.scope)
 							num5 = 0.5f;
 
+						PlayerLoader.ModifyZoom(LocalPlayer, ref num5);
 						Vector2 vector5 = (MouseScreen - new Vector2(screenWidth, screenHeight) / 2f) / (new Vector2(screenWidth, screenHeight) / 2f);
 						num4 = 48f;
 						if (vector5 != Vector2.Zero && num5 != -1f) {
@@ -51678,8 +_,10 @@
 					if (num7 < 0)
 						num7 = 0;
 
-					vector3.X = (float)(num6 - screenWidth / 2) / 1.25f;
-					vector3.Y = (float)(num7 - screenHeight / 2) / 1.25f;
+					float zoom = 0.8f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+					vector3.X = (num6 - screenWidth / 2) * zoom;
+					vector3.Y = (num7 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].inventory[Main.player[myPlayer].selectedItem].type == 1254 && mouseRight) {
@@ -51697,8 +_,10 @@
 					if (num9 < 0)
 						num9 = 0;
 
-					vector3.X = (float)(num8 - screenWidth / 2) / 1.5f;
-					vector3.Y = (float)(num9 - screenHeight / 2) / 1.5f;
+					float zoom = 3f/2f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+					vector3.X = (num8 - screenWidth / 2) * zoom;
+					vector3.Y = (num9 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].inventory[Main.player[myPlayer].selectedItem].type == 1299 && Main.player[myPlayer].selectedItem != 58) {
@@ -51716,8 +_,10 @@
 					if (num11 < 0)
 						num11 = 0;
 
-					vector3.X = (float)(num10 - screenWidth / 2) / 1.5f;
-					vector3.Y = (float)(num11 - screenHeight / 2) / 1.5f;
+					float zoom = 3f/2f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+					vector3.X = (num10 - screenWidth / 2) * zoom;
+					vector3.Y = (num11 - screenHeight / 2) * zoom;
 					flag = true;
 				}
 				else if (Main.player[myPlayer].scope && mouseRight) {
@@ -51735,8 +_,32 @@
 					if (num13 < 0)
 						num13 = 0;
 
+					float zoom = 0.5f;
+					PlayerLoader.ModifyZoom(player[myPlayer], ref zoom);
-					vector3.X = (float)(num12 - screenWidth / 2) / 2f;
+					vector3.X = (num12 - screenWidth / 2) * zoom;
-					vector3.Y = (float)(num13 - screenHeight / 2) / 2f;
+					vector3.Y = (num13 - screenHeight / 2) * zoom;
+				}
+				else {
+					int mouseXClamped = mouseX;
+					int mouseYClamped = mouseY;
+					if (mouseXClamped > screenWidth)
+						mouseXClamped = screenWidth;
+
+					if (mouseXClamped < 0)
+						mouseXClamped = 0;
+
+					if (mouseYClamped > screenHeight)
+						mouseYClamped = screenHeight;
+
+					if (mouseYClamped < 0)
+						mouseYClamped = 0;
+
+					float zoom = -1f;
+					PlayerLoader.ModifyZoom(LocalPlayer, ref zoom);
+					if (zoom != -1f) {
+						vector3.X = (mouseXClamped - screenWidth / 2) * zoom;
+						vector3.Y = (mouseYClamped - screenHeight / 2) * zoom;
+					}
 					flag = true;
 				}
 			}
@@ -51957,6 +_,8 @@
 				spriteBatch.Draw(TextureAssets.PumpkinMoon.Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.PumpkinMoon.Width() * moonPhase, TextureAssets.PumpkinMoon.Width(), TextureAssets.PumpkinMoon.Width()), moonColor, num9, new Vector2(TextureAssets.PumpkinMoon.Width() / 2, TextureAssets.PumpkinMoon.Width() / 2), num8, SpriteEffects.None, 0f);
 			else if (snowMoon)
 				spriteBatch.Draw(TextureAssets.SnowMoon.Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.SnowMoon.Width() * moonPhase, TextureAssets.SnowMoon.Width(), TextureAssets.SnowMoon.Width()), moonColor, num9, new Vector2(TextureAssets.SnowMoon.Width() / 2, TextureAssets.SnowMoon.Width() / 2), num8, SpriteEffects.None, 0f);
+			else if (value2 != TextureAssets.Moon[num].Value) // custom menu.MoonTexture drawn here.
+				spriteBatch.Draw(value2, position2, new Rectangle(0, 0, value2.Width, value2.Width), moonColor, num9, new Vector2(value2.Width / 2), num8, SpriteEffects.None, 0f);
 			else
 				spriteBatch.Draw(TextureAssets.Moon[num].Value, position2, new Microsoft.Xna.Framework.Rectangle(0, TextureAssets.Moon[num].Width() * moonPhase, TextureAssets.Moon[num].Width(), TextureAssets.Moon[num].Width()), moonColor, num9, new Vector2(TextureAssets.Moon[num].Width() / 2, TextureAssets.Moon[num].Width() / 2), num8, SpriteEffects.None, 0f);
 		}
@@ -52098,7 +_,7 @@
 		Vector2 origin = value3.Size() / 2f;
 		if (theStar.falling) {
 			theStar.fadeIn = 0f;
-			int num8 = theStar.fallTime;
+			double num8 = theStar.fallTime;
 			float num9 = 30f;
 			if ((float)num8 > num9)
 				num8 = (int)num9;
@@ -52136,6 +_,8 @@
 		tileColor.G = (byte)((colorOfTheSkies.R + colorOfTheSkies.G + colorOfTheSkies.B + colorOfTheSkies.G * 7) / 10);
 		tileColor.B = (byte)((colorOfTheSkies.R + colorOfTheSkies.G + colorOfTheSkies.B + colorOfTheSkies.B * 7) / 10);
 		tileColor = SkyManager.Instance.ProcessTileColor(tileColor);
+		// TODO: Add in white and white2 as sunColor and moonColor
+		SystemLoader.ModifySunLightColor(ref tileColor, ref ColorOfTheSkies);
 	}
 
 	private static void UpdateAtmosphereTransparencyToSkyColor()
@@ -52906,6 +_,10 @@
 			preferredBGStyleForPlayer = bgStyle;
 			if (WorldGen.drunkWorldGen)
 				bgStyle = 9;
+
+			var menuBackgroundStyle = MenuLoader.CurrentMenu.MenuBackgroundStyle;
+			if (menuBackgroundStyle != null)
+				bgStyle = menuBackgroundStyle.Slot;
 		}
 
 		if (instantBGTransitionCounter > 0) {
@@ -52916,6 +_,8 @@
 
 		UpdateBGVisibility_BackLayer(null, null);
 		UpdateBGVisibility_FrontLayer(null, null);
+
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().ModifyFarFades(bgStyle, bgAlphaFrontLayer, backgroundLayerTransitionSpeed);
 		try {
 			DrawSurfaceBG();
 			if (BackgroundEnabled)
@@ -53003,6 +_,10 @@
 				DrawBG_ModifyBGFarBackLayerAlpha(value, null, transitionAmountOverride);
 				break;
 			default:
+				if (value >= BG_STYLES_COUNT) {
+					DrawBG_ModifyBGFarBackLayerAlpha(value, null, transitionAmountOverride);
+					break;
+				}
 				DrawBG_ModifyBGFarBackLayerAlpha(0, null, transitionAmountOverride);
 				break;
 		}
@@ -53012,7 +_,12 @@
 	{
 		int num = bgStyle;
 		int num2 = (int)((screenPosition.X + (float)(screenWidth / 2)) / 16f);
+		LoaderManager.Get<SurfaceBackgroundStylesLoader>().ChooseStyle(out var modBG, out var priority);
+
+		if (priority >= SceneEffectPriority.BiomeHigh) {
+			num = modBG;
+		}
-		if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
+		else if (WorldGen.oceanDepths((int)(screenPosition.X + (float)(screenWidth / 2)) / 16, (int)(screenPosition.Y + (float)(screenHeight / 2)) / 16)) {
 			num = (player[myPlayer].ZoneHallow ? 6 : (player[myPlayer].ZoneCorrupt ? ((SceneMetrics.BloodTileCount <= SceneMetrics.EvilTileCount) ? 1 : 8) : (player[myPlayer].ZoneCrimson ? 8 : ((SceneMetrics.HoneyBlockCount <= 400) ? 4 : 3))));
 		}
 		else if (player[myPlayer].ZoneGlowshroom) {
@@ -53030,12 +_,18 @@
 		else if (player[myPlayer].ZoneCrimson) {
 			num = 8;
 		}
+		else if (priority >= SceneEffectPriority.BiomeMedium) {
+			num = modBG;
+		}
 		else if (player[myPlayer].ZoneJungle) {
 			num = 3;
 		}
 		else if (player[myPlayer].ZoneSnow) {
 			num = 7;
 		}
+		else if (priority >= SceneEffectPriority.BiomeLow) {
+			num = modBG;
+		}
 		else {
 			num = 0;
 			if (num2 >= treeX[0]) {
@@ -53045,6 +_,12 @@
 					num = 11;
 				else if (WorldGen.treeBG1 != WorldGen.treeBG4)
 					num = 12;
+			} // Patch context
+		}
+
+		if (GlobalBackgroundStyleLoader.loaded) {
+			foreach (var hook in GlobalBackgroundStyleLoader.HookChooseSurfaceBackgroundStyle) {
+				hook(ref num);
 			}
 		}
 
@@ -53107,6 +_,15 @@
 
 	private static void UpdateInvasion()
 	{
+		SystemLoader.PreUpdateInvasions();
+
+		UpdateInvasion_Inner();
+
+		SystemLoader.PostUpdateInvasions();
+	}
+
+	private static void UpdateInvasion_Inner()
+	{
 		if (invasionType <= 0)
 			return;
 
@@ -53139,9 +_,14 @@
 		if (invasionX == (double)spawnTileX)
 			return;
 
+		/*
 		float num = dayRate;
 		if (num < 1f)
 			num = 1f;
+		*/
+		double num = desiredWorldEventsUpdateRate;
+		if (num < 0)
+			num = 0;
 
 		if (invasionX > (double)spawnTileX) {
 			invasionX -= num;
@@ -53190,7 +_,7 @@
 
 		int num = 0;
 		for (int i = 0; i < 255; i++) {
-			if (player[i].active && player[i].statLifeMax >= 200)
+			if (player[i].active && player[i].ConsumedLifeCrystals >= 5)
 				num++;
 		}
 
@@ -53207,7 +_,7 @@
 
 		int num = 0;
 		for (int i = 0; i < 255; i++) {
-			if (player[i].active && player[i].statLifeMax >= 200)
+			if (player[i].active && player[i].ConsumedLifeCrystals >= 5)
 				num++;
 		}
 
@@ -53343,7 +_,7 @@
 					Netplay.Clients[k].TimeOutTimer += 3;
 
 				if (!stopTimeOuts && Netplay.Clients[k].TimeOutTimer > 7200) {
-					Netplay.Clients[k].PendingTermination = true;
+					Netplay.Clients[k].SetPendingTermination("Timeout");
 					Netplay.Clients[k].PendingTerminationApproved = true;
 				}
 			}
@@ -53353,6 +_,12 @@
 		}
 	}
 
+	public static void NewText(object o, Color? color = null)
+	{
+		if (color == null) color = Color.White;
+		NewText(o.ToString(), color.Value.R, color.Value.G, color.Value.B);
+	}
+
 	public static void NewText(string newText, byte R = byte.MaxValue, byte G = byte.MaxValue, byte B = byte.MaxValue)
 	{
 		chatMonitor.NewText(newText, R, G, B);
@@ -53365,6 +_,10 @@
 		SoundEngine.PlaySound(12);
 	}
 
+	/// <summary>
+	/// Stops rain. Should be called on the server (netMode != client) - vanilla syncs it using <see cref="SyncRain"/>.
+	/// <br>You can also call this on the client to update visuals immediately, assuming it was called serverside aswell (Journey Mode rain slider does this).</br>
+	/// </summary>
 	public static void StopRain()
 	{
 		rainTime = 0;
@@ -53372,6 +_,10 @@
 		maxRaining = 0f;
 	}
 
+	/// <summary>
+	/// Starts rain for a random amount of time. Should be called on the server (netMode != client) - vanilla syncs it using <see cref="SyncRain"/>.
+	/// <br>You can also call this on the client to update visuals immediately, assuming it was/will be called serverside aswell (Journey Mode rain slider does this).</br>
+	/// </summary>
 	public static void StartRain()
 	{
 		int num = 86400;
@@ -53489,7 +_,7 @@
 		}
 
 		if (ladyBugRainBoost > 0)
-			ladyBugRainBoost -= dayRate;
+			ladyBugRainBoost -= desiredWorldEventsUpdateRate;
 
 		if (pumpkinMoon) {
 			bloodMoon = false;
@@ -53501,12 +_,12 @@
 
 		if ((netMode != 1 && !gameMenu) || netMode == 2) {
 			if (slimeRainTime > 0.0) {
-				slimeRainTime -= dayRate;
+				slimeRainTime -= desiredWorldEventsUpdateRate;
 				if (slimeRainTime <= 0.0)
 					StopSlimeRain();
 			}
 			else if (slimeRainTime < 0.0) {
-				slimeRainTime += dayRate;
+				slimeRainTime += desiredWorldEventsUpdateRate;
 				if (slimeRainTime > 0.0)
 					slimeRainTime = 0.0;
 			}
@@ -53517,31 +_,30 @@
 						StopRain();
 					}
 					else {
-						rainTime -= dayRate;
+						rainTime -= desiredWorldEventsUpdateRate;
-						if (dayRate > 0) {
+						if (desiredWorldEventsUpdateRate > 0) {
-							int num = 86400 / dayRate / 24;
+							double num = 86400 / desiredWorldEventsUpdateRate / 24;
 							if (rainTime <= 0)
 								StopRain();
-							else if (rand.Next(num * 2) == 0)
+							else if (rand.NextDouble() <= 1 / (num * 2))
 								ChangeRain();
 						}
 					}
 				}
 			}
 			else if (!slimeRain && !LanternNight.LanternsUp && !LanternNight.NextNightIsLanternNight) {
-				int num2 = 86400;
-				num2 /= ((dayRate == 0) ? 1 : dayRate);
-				if (!CreativePowerManager.Instance.GetPower<CreativePowers.FreezeRainPower>().Enabled && dayRate != 0) {
+				if (!CreativePowerManager.Instance.GetPower<CreativePowers.FreezeRainPower>().Enabled && desiredWorldEventsUpdateRate != 0) {
+					double num2 = 86400 / desiredWorldEventsUpdateRate;
 					if (rand.Next((int)((double)num2 * 5.75)) == 0)
 						StartRain();
 					else if (cloudBGActive >= 1f && rand.Next((int)((double)num2 * 4.25)) == 0)
 						StartRain();
-					else if (ladyBugRainBoost > 0 && rand.Next(num2) == 0)
+					else if (ladyBugRainBoost > 0 && rand.Next((int)num2) == 0)
 						StartRain();
 				}
 
-				if (!raining && !NPC.BusyWithAnyInvasionOfSorts() && dayTime && time < 27000.0 && dayRate > 0) {
+				if (!raining && !NPC.BusyWithAnyInvasionOfSorts() && dayTime && time < 27000.0 && desiredWorldEventsUpdateRate > 0) {
-					int num3 = (int)(450000.00000000006 / (double)dayRate);
+					int num3 = (int)(450000.00000000006 / desiredWorldEventsUpdateRate);
 					if (!NPC.downedSlimeKing)
 						num3 /= 2;
 
@@ -53550,7 +_,7 @@
 
 					bool flag = false;
 					for (int i = 0; i < 255; i++) {
-						if (Main.player[i].active && Main.player[i].statLifeMax > 140 && Main.player[i].statDefense > 8)
+						if (Main.player[i].active && Main.player[i].ConsumedLifeCrystals > 2 && Main.player[i].statDefense > 8)
 							flag = true;
 					}
 
@@ -53618,6 +_,7 @@
 					WorldGen.UnspawnTravelNPC();
 			}
 			else if (!IsFastForwardingTime() && dayTime && time < 27000.0) {
+				/*
 				int num6 = dayRate;
 				if (num6 < 1)
 					num6 = 1;
@@ -53625,6 +_,9 @@
 				int num7 = (int)(27000.0 / (double)num6);
 				num7 *= 4;
 				if (rand.Next(num7) == 0) {
+				*/
+
+				if (rand.NextDouble() < dayRate / (27000.0 * 4)) {
 					int num8 = 0;
 					for (int j = 0; j < 200; j++) {
 						if (npc[j].active && npc[j].townNPC && npc[j].type != 37 && npc[j].type != 453)
@@ -53779,7 +_,7 @@
 			if (!NPC.downedBoss1 && netMode != 1) {
 				bool flag = false;
 				for (int i = 0; i < 255; i++) {
-					if (player[i].active && player[i].statLifeMax >= 200 && player[i].statDefense > 10) {
+					if (player[i].active && player[i].ConsumedLifeCrystals >= 5 && player[i].statDefense > 10) {
 						flag = true;
 						break;
 					}
@@ -53862,7 +_,7 @@
 
 			if (!WorldGen.spawnEye && moonPhase != 4 && rand.Next(maxValue) == 0 && netMode != 1) {
 				for (int m = 0; m < 255; m++) {
-					if (player[m].active && player[m].statLifeMax > 120) {
+					if (player[m].active && player[m].ConsumedLifeCrystals > 1) {
 						bloodMoon = true;
 						break;
 					}
@@ -54024,6 +_,11 @@
 
 	public static BestiaryUnlockProgressReport GetBestiaryProgressReport()
 	{
+		List<BestiaryEntry> terEntries = BestiaryDB.GetBestiaryEntriesByMod(null);
+		return new BestiaryUnlockProgressReport() {
+			EntriesTotal = terEntries.Count,
+			CompletionAmountTotal = terEntries.Count(e => e.UIInfoProvider.GetEntryUICollectionInfo().UnlockState > BestiaryEntryUnlockState.NotKnownAtAll_0)
+		};
 		float num = 0f;
 		int num2 = 0;
 		List<BestiaryEntry> entries = BestiaryDB.Entries;
@@ -54041,7 +_,7 @@
 
 	private static void UpdateTime_SpawnTownNPCs()
 	{
-		int worldUpdateRate = WorldGen.GetWorldUpdateRate();
+		double worldUpdateRate = WorldGen.GetWorldUpdateRate();
 		if (netMode == 1 || worldUpdateRate <= 0)
 			return;
 
@@ -54056,7 +_,7 @@
 				num++;
 		}
 
-		for (int j = 0; j < 688; j++) {
+		for (int j = 0; j < townNPCCanSpawn.Length; j++) {
 			townNPCCanSpawn[j] = false;
 		}
 
@@ -54219,6 +_,7 @@
 				if (npc[k].type == 663)
 					num39++;
 
+				//Patch context: this is the amount of NPCs.
 				num40++;
 			}
 		}
@@ -54481,6 +_,8 @@
 
 			WorldGen.prioritizedTownNPCType = num42;
 		}
+
+		NPCLoader.CanTownNPCSpawn(num40);
 	}
 
 	public static int DamageVar(float dmg, float luck = 0f)
@@ -54589,7 +_,8 @@
 
 	public static void SetFullScreen(bool fullscreen)
 	{
-		SetDisplayMode(PendingResolutionWidth, PendingResolutionHeight, fullscreen);
+		// TML: Make the fullscreen reset to windowed display borders when downsizing
+		SetDisplayMode(PendingResolutionWidth, BorderedHeight(PendingResolutionHeight, fullscreen), fullscreen);
 	}
 
 	public static void SetResolution(int width, int height)
@@ -54654,7 +_,11 @@
 				width = (int)(num2 * (float)height);
 			}
 
+#if !NETCORE
+			if (!Platform.IsWindows)
-			PlayerInput.RawMouseScale = new Vector2((float)width / (float)instance.Window.ClientBounds.Width, (float)height / (float)instance.Window.ClientBounds.Height);
+				PlayerInput.RawMouseScale = new Vector2((float)width / (float)instance.Window.ClientBounds.Width, (float)height / (float)instance.Window.ClientBounds.Height);
+#endif
+
 			if (!graphics.IsFullScreen) {
 				num3 = Math.Max(graphics.PreferredBackBufferWidth, graphics.GraphicsDevice.Viewport.Width);
 				num4 = Math.Max(graphics.PreferredBackBufferHeight, graphics.GraphicsDevice.Viewport.Height);
@@ -54710,6 +_,7 @@
 			graphics.ToggleFullScreen();
 		}
 
+		// Runs if Graphics Device needs a reset to match backBuffer to Viewport, or if target resolution is diff than current
 		if (width != num3 || height != num4 || flag2) {
 			mapTime = 0;
 			if (gamePaused)
@@ -54719,7 +_,9 @@
 			screenHeight = height;
 			graphics.PreferredBackBufferWidth = screenWidth;
 			graphics.PreferredBackBufferHeight = screenHeight;
+			if (width != num3 || height != num4)
-			graphics.ApplyChanges();
+				graphics.ApplyChanges();
+
 			PlayerInput.CacheOriginalScreenDimensions();
 			FixUIScale();
 			if (Main.OnResolutionChanged != null)
