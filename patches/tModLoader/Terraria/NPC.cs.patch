--- src/TerrariaNetCore/Terraria/NPC.cs
+++ src/tModLoader/Terraria/NPC.cs
@@ -23,10 +_,11 @@
 using Terraria.Localization;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
 
 namespace Terraria
 {
-	public class NPC : Entity
+	public partial class NPC : Entity
 	{
 		private const int NPC_TARGETS_START = 300;
 		public bool IsABestiaryIconDummy;
@@ -65,8 +_,17 @@
 		public int altTexture;
 		public int townNpcVariationIndex;
 		public Vector2 netOffset = Vector2.Zero;
-		public short catchItem;
+		/// <summary>
+		/// The numerical ID of the item that this NPC becomes when caught.<br></br>
+		/// Mainly used for critters that can be caught with bug nets, such as butterflies and worms.<br></br>
+		/// Bug nets and other catching tools will only work on NPCs with this field set to something greater than 0.
+		/// </summary>
+		public int catchItem; // tML: changed to int for convenience and consistency purposes
 		public short releaseOwner = 255;
+		/// <summary>
+		/// How rare the NPC is for the Lifeform Analyzer. For example: 4 is for Tim and Mimics, 1 is for bound town NPCs.
+		/// <br/> Defaults to 0.
+		/// </summary>
 		public int rarity;
 		public static bool taxCollector = false;
 		public bool[] playerInteraction = new bool[256];
@@ -99,6 +_,12 @@
 		public static int deerclopsBoss = -1;
 		public int netSkip;
 		public bool netAlways;
+		/// <summary>
+		/// Stores the index (the <see cref="Entity.whoAmI"/>) of a single NPC. This NPC will then share a health pool with that NPC.<br/>
+		/// Used for the Destroyer's various segments and the Wall of Flesh's eyes and mouth.<br/>
+		/// This is useful for worm enemies. All the segments will point to the same npc, usually the "head" of the npc, and the head and all other non-multi-part npcs will have the default value of -1 still.
+		/// <br/> Defaults to -1.
+		/// </summary>
 		public int realLife = -1;
 		private string _givenName = "";
 		public static int sWidth = 1920;
@@ -111,9 +_,14 @@
 		private static int activeRangeY = (int)((double)sHeight * 2.1);
 		private static int townRangeX = sWidth;
 		private static int townRangeY = sHeight;
+		/// <summary>
+		/// Represents how much this npc counts towards the npc spawn limit. Small critters like worms or flys have values around .1f and .25. Enemies that are more difficult than normal have values higher than 1f, and bosses and mini bosses have values around 6.
+		/// <br/> Proper npcSlots values help balance the game and prevents the player from randomly being overwhelmed by powerful enemies. The <see href="https://terraria.wiki.gg/wiki/NPC_spawning#Spawn_rates">Spawn rates section on the NPC spawning wiki page</see> lists vanilla npcSlots values. Use this as a guide to find a suitable value.
+		/// <br/> Defaults to 1f.
+		/// </summary>
 		public float npcSlots = 1f;
 		private static bool noSpawnCycle = false;
-		private static int activeTime = 750;
+		public static int activeTime = 750;
 		private static int defaultSpawnRate = 600;
 		private static int defaultMaxSpawns = 5;
 		public float shimmerTransparency;
@@ -121,7 +_,10 @@
 		public const int maxBuffs = 20;
 		public int[] buffType = new int[20];
 		public int[] buffTime = new int[20];
+		/// <summary>
+		/// Make the NPC immune to buffs/debuffs. Example: <c>NPC.buffImmune[BuffID.OnFire] = true;</c>
+		/// </summary>
-		public bool[] buffImmune = new bool[355];
+		public bool[] buffImmune = new bool[BuffLoader.BuffCount];
 		public bool canDisplayBuffs = true;
 		public bool midas;
 		public bool ichor;
@@ -182,35 +_,121 @@
 		public static bool unlockedArmsDealerSpawn = false;
 		public static bool unlockedNurseSpawn = false;
 		public static bool unlockedPrincessSpawn = false;
+		/// <summary>
+		/// Denotes whether or not Advanced Combat Techniques has been used in the current world.
+		/// </summary>
 		public static bool combatBookWasUsed = false;
 		public static bool combatBookVolumeTwoWasUsed = false;
 		public static bool peddlersSatchelWasUsed = false;
+		/// <summary>
+		/// Denotes whether or not the Eye of Cthulhu has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Eater of Worlds OR the Brain of Cthulhu have been defeated at least once in the current world.<br/>
+		/// This does NOT track the two of them separately; you will need to establish your own fields in a <see cref="ModSystem"/> for that.<br/>
+		/// </summary>
 		public static bool downedBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss3 = false;
+		/// <summary>
+		/// Denotes whether or not at least one Queen Bee has been defeated in the current world.
+		/// </summary>
 		public static bool downedQueenBee = false;
+		/// <summary>
+		/// Denotes whether or not King Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedSlimeKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Goblin Army has been defeated in the current world.
+		/// </summary>
 		public static bool downedGoblins = false;
+		/// <summary>
+		/// Denotes whether or not the Frost Legion has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFrost = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pirate Invasion has been defeated in the current world.
+		/// </summary>
 		public static bool downedPirates = false;
+		/// <summary>
+		/// Denotes whether or not at least one Clown has been killed in the current world.<br/>
+		/// Only used to make the Clothier sell the Clown set once at least one has been killed.
+		/// </summary>
 		public static bool downedClown = false;
+		/// <summary>
+		/// Denotes whether or not Plantera has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedPlantBoss = false;
+		/// <summary>
+		/// Denotes whether or not Golem has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedGolemBoss = false;
+		/// <summary>
+		/// Denotes whether or not at least one Martian Madness event has been cleared in the current world.
+		/// </summary>
 		public static bool downedMartians = false;
+		/// <summary>
+		/// Denotes whether or not Duke Fishron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFishron = false;
+		/// <summary>
+		/// Denotes whether or not at least one Mourning Wood has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pumpking has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Ice Queen has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasIceQueen = false;
+		/// <summary>
+		/// Denotes whether or not at least one Everscream has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Santa-NK1 has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasSantank = false;
+		/// <summary>
+		/// Denotes whether or not the Lunatic Cultist has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedAncientCultist = false;
+		/// <summary>
+		/// Denotes whether or not the Moon Lord has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMoonlord = false;
+		/// <summary>
+		/// Denotes whether or not the Solar Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerSolar = false;
+		/// <summary>
+		/// Denotes whether or not the Vortex Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerVortex = false;
+		/// <summary>
+		/// Denotes whether or not the Nebula Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerNebula = false;
+		/// <summary>
+		/// Denotes whether or not the Stardust Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerStardust = false;
+		/// <summary>
+		/// Denotes whether or not the Empress of Light has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedEmpressOfLight = false;
+		/// <summary>
+		/// Denotes whether or not Queen Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedQueenSlime = false;
+		/// <summary>
+		/// Denotes whether or not the Deerclops has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedDeerclops = false;
 		public static int ShieldStrengthTowerSolar = 0;
 		public static int ShieldStrengthTowerVortex = 0;
@@ -223,9 +_,21 @@
 		public static bool TowerActiveNebula = false;
 		public static bool TowerActiveStardust = false;
 		public static bool LunarApocalypseIsUp = false;
+		/// <summary>
+		/// Denotes whether or not ANY Mechanical Boss has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBossAny = false;
+		/// <summary>
+		/// Denotes whether or not the Destroyer has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Twins have been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron Prime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss3 = false;
 		public static bool[] npcsFoundForCheckActive = new bool[688];
 		public static int[] lazyNPCOwnedProjectileSearchArray = new int[200];
@@ -233,47 +_,130 @@
 		private static int maxSpawns = defaultMaxSpawns;
 		public int soundDelay;
 		public static CoinLossRevengeSystem RevengeManager = new CoinLossRevengeSystem();
+		/// <summary>
+		/// This determines if an NPC can be hit by a item or projectile owned by a particular player (it is an array, each slot corresponds to different players (whoAmI)). It is decremented towards 0 every update. Melee items set immune[Player.whoAmI] to Player.itemAnimation, which starts at item.useAnimation and decrements towards 0. Penetrating projectiles usually set immune to 10, while non-penetrating projectiles do not set immune. <see href="https://github.com/tModLoader/tModLoader/blob/1.4/ExampleMod/Content/Projectiles/ExamplePiercingProjectile.cs">ExamplePiercingProjectile.cs</see> explains more about options for npc and projectile immunity.
+		/// </summary>
 		public int[] immune = new int[256];
 		public int directionY = 1;
 		public int type;
 		public float[] ai = new float[maxAI];
 		public float[] localAI = new float[maxAI];
 		public int aiAction;
+		/// <summary>
+		/// 
+		/// Selects which vanilla code to use for the AI method. Vanilla NPC AI styles are enumerated in the <see cref="NPCAIStyleID"/> class. Modders can use vanilla aiStyle and optionally <see cref="ModNPC.AIType"/> to mimic AI code already in the game. This is usually only useful as a prototyping tool since it is difficult to customize existing aiStyle code. See <see cref="ModNPC.AIType"/> and <see href="https://github.com/tModLoader/tModLoader/blob/1.4/ExampleMod/Content/NPCs/PartyZombie.cs">PartyZombie</see> to see how to use vanilla ai. If you are using custom AI code, there is no need to set this field.
+		/// <br/> Customizing an existing aiStyle usually requires following the <see href="https://github.com/tModLoader/tModLoader/wiki/Advanced-Vanilla-Code-Adaption#example-projectile-or-npc-ai-code">Vanilla Code Adaption Guide</see>.
+		/// <br/> If you are using completely custom AI, set this to -1 since an aiStyle of 0 will face the player automatically, which may interfere with your logic.
+		/// <br/> Defaults to 0.
+		/// </summary>
 		public int aiStyle;
 		public bool justHit;
 		public int timeLeft;
 		public int target = -1;
+		/// <summary>
+		/// The amount of contact damage this NPC deals.<br/>
+		/// Changing this WILL NOT change the amount of damage done by projectiles.<br/>
+		/// Usually damage is scaled by some factor when NPC spawn projectiles with Projectile.NewProjectile in AI code. For example, passing in <c>(int)(NPC.damage * 0.5f)</c> as the Damage parameter.
+		/// <br/> The <see href="https://terraria.wiki.gg/wiki/List_of_NPCs">List of NPCs wiki page</see> can be useful for finding appropriate values.
+		/// </summary>
 		public int damage;
+		/// <summary>
+		/// How resistant to damage this NPC is.
+		/// <br/> The <see href="https://terraria.wiki.gg/wiki/List_of_NPCs">List of NPCs wiki page</see> can be useful for finding appropriate values.
+		/// </summary>
 		public int defense;
+		/// <summary>
+		/// Stores the value of <see cref="damage"/> at the end of SetDefaults. Useful for scaling damage in AI code conditionally.
+		/// </summary>
 		public int defDamage;
+		/// <summary>
+		/// Stores the value of <see cref="defense"/> at the end of SetDefaults. Useful for scaling defense in AI code, like how King Slime changes defense as it gets smaller.
+		/// </summary>
 		public int defDefense;
+		/// <summary>
+		/// Denotes whether or not this NPC counts as dealing cold damage for the purposes of the Warmth Potion.<br/>
+		/// Defaults to false.
+		/// </summary>
 		public bool coldDamage;
 		public bool trapImmune;
-		public LegacySoundStyle HitSound;
-		public LegacySoundStyle DeathSound;
+		/// <summary>
+		/// The sound that plays when this npc is hit. Set this to an existing <see cref="SoundID"/> entry or assign to a new <see cref="SoundStyle"/> for a custom sound.
+		/// <br/> The <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Sounds">Basic Sounds Guide</see> teaches how to find existing sounds to use, how to use custom sounds, and how to customize the playback properties of the sounds. 
+		/// <br/> For example <c>NPC.HitSound = SoundID.NPCHit1;</c> can be used for the typical NPC hit sound.
+		/// <br/> Defaults to null.
+		/// </summary>
+		public SoundStyle? HitSound;
+		/// <summary>
+		/// The sound that plays when this npc dies. Set this to an existing <see cref="SoundID"/> entry or assign to a new <see cref="SoundStyle"/> for a custom sound.
+		/// <br/> The <see href="https://github.com/tModLoader/tModLoader/wiki/Basic-Sounds">Basic Sounds Guide</see> teaches how to find existing sounds to use, how to use custom sounds, and how to customize the playback properties of the sounds. 
+		/// <br/> For example <c>NPC.DeathSound = SoundID.NPCDeath1;</c> can be used for the typical NPC kill sound.
+		/// <br/> Defaults to null.
+		/// </summary>
+		public SoundStyle? DeathSound;
+		/// <summary>
+		/// The current life of the NPC. Automatically set to the value of <see cref="lifeMax"/> at the end of SetDefaults.
+		/// </summary>
 		public int life;
+		/// <summary>
+		/// The maximum life of this NPC.
+		/// </summary>
 		public int lifeMax;
 		public Rectangle targetRect;
 		public double frameCounter;
 		public Rectangle frame;
 		public Color color;
+		/// <summary>
+		/// 0 is opaque, and 255 is transparent. Note that this is the opposite of how alpha is typically expressed in computer graphics. Can be used to fade an NPC in and out.
+		/// <br/> Use <see cref="Opacity"/> instead for a 0f to 1f scaling that uses the high value for fully opaque, as is more typical in computer graphics.
+		/// <br/> Defaults to 0.
+		/// </summary>
 		public int alpha;
+		/// <summary>
+		/// Indicates that this NPC is drawn at a specific layer in the render order. Must use in conjunction with <see cref="ModNPC.DrawBehind(int)"/>.
+		/// <br/> See <see href="https://github.com/tModLoader/tModLoader/blob/1.4/ExampleMod/Content/NPCs/ExampleDrawBehindNPC.cs">ExampleDrawBehindNPC</see> for examples of how to use this and all available layers to draw in.
+		/// </summary>
 		public bool hide;
+		/// <summary>
+		/// Makes the NPC bigger or smaller. Bigger than 1f is bigger.
+		/// <br/> Defaults to 1f.
+		/// </summary>
 		public float scale = 1f;
+		/// <summary>
+		/// How much of the knockback it receives will actually apply. 1f: full knockback; 0f: no knockback.
+		/// <br/> Defaults to 1f.
+		/// </summary>
 		public float knockBackResist = 1f;
 		public int oldDirectionY;
 		public int oldTarget;
 		public float rotation;
+		/// <summary>
+		/// If true, the npc will not be affected by gravity. Demon Eyes and other floating npc use this.
+		/// <br/> Defaults to <see langword="false"/>.
+		/// </summary>
 		public bool noGravity;
+		/// <summary>
+		/// If true, the npc does not collide with tiles, making the npc pass through tiles freely. Meteor Head and Worm npc use this.
+		/// <br/> Defaults to <see langword="false"/>.
+		/// </summary>
 		public bool noTileCollide;
 		public bool netUpdate;
 		public bool netUpdate2;
 		public bool collideX;
 		public bool collideY;
+		/// <summary>
+		/// Set to true if the NPC is a boss. Prevents off-screen despawn. Bosses also need <c>[AutoloadBossHead]</c> annotated on the ModNPC class itself to fully register as a boss.
+		/// </summary>
 		public bool boss;
 		public int spriteDirection = -1;
+		/// <summary>
+		/// Indicates that this NPC draws behind solid tiles.
+		/// <br/> See <see href="https://github.com/tModLoader/tModLoader/blob/1.4/ExampleMod/Content/NPCs/ExampleDrawBehindNPC.cs">ExampleDrawBehindNPC</see> for examples of how to use this and other options for layers to draw in.
+		/// </summary>
 		public bool behindTiles;
 		public bool lavaImmune;
+		/// <summary>
+		/// How many copper coins the NPC will drop when killed (100 copper coins = 1 silver coin etc.).
+		/// </summary>
 		public float value;
 		public int extraValue;
 		public bool dontTakeDamage;
@@ -462,8 +_,20 @@
 			}
 		}
 
-		public string TypeName => Lang.GetNPCNameValue(netID);
+		/// <summary>
+		/// The TYPE name of this NPC.<br/>
+		/// Type names are the base titles given to any NPC, and are typically shared amongst all instances of an NPC. For example, the Stylist's type name will always be "Stylist".<br/>
+		/// To modify the type name of a specific NPC, make use of the ModifyTypeName hooks in <see cref="GlobalNPC"/> and <see cref="ModLoader.ModNPC"/>, according to your needs.<br/>
+		/// </summary>
+		public string TypeName => NPCLoader.ModifyTypeName(this, Lang.GetNPCNameValue(netID));
 
+		/// <summary>
+		/// The FULL name of this NPC.<br/>
+		/// If the NPC doesn't have a given name, this will just return the type name. A Stylist without a given name will always return "Stylist" here.<br/>
+		/// If the NPC does have a given name, this will return the NPC's full name; given name first, then type name.<br/>
+		/// Full name with a given name is given in the format of "X the Y", where X is their given name and Y is their type name.<br/>
+		/// For example, a Stylist might return "Scarlett the Stylist" here; with Scarlett being her given name, and Stylist being her type name.<br/>
+		/// </summary>
 		public string FullName {
 			get {
 				if (!HasGivenName)
@@ -473,8 +_,14 @@
 			}
 		}
 
+		/// <summary>
+		/// Whether or not this NPC has a given name.<br/>
+		/// </summary>
 		public bool HasGivenName => _givenName.Length != 0;
 
+		/// <summary>
+		/// If this NPC has a given name, returns their given name; otherwise, returns their type name.<br/>
+		/// </summary>
 		public string GivenOrTypeName {
 			get {
 				if (!HasGivenName)
@@ -484,6 +_,11 @@
 			}
 		}
 
+		/// <summary>
+		/// The GIVEN name of this NPC. Can be set directly.<br/>
+		/// Given names are unique to each NPC, though two NPCs can have the same given name.<br/>
+		/// Some vanilla examples of given names are Andrew (for the Guide), Yorai (for the Princess), Whitney (for the Steampunker), or Scarlett (for the Stylist).<br/>
+		/// </summary>
 		public string GivenName {
 			get {
 				return _givenName;
@@ -532,7 +_,7 @@
 
 		public bool isLikeATownNPC {
 			get {
-				if (type == 453)
+				if (NPCID.Sets.ActsLikeTownNPC[type])
 					return true;
 
 				return townNPC;
@@ -901,7 +_,7 @@
 		public static void UpdateFoundActiveNPCs() {
 			for (int i = 0; i < 200; i++) {
 				NPC nPC = Main.npc[i];
-				if (nPC.active && nPC.type >= 0 && nPC.type < 688)
+				if (nPC.active && nPC.type >= 0)
 					npcsFoundForCheckActive[nPC.type] = true;
 			}
 
@@ -1014,8 +_,116 @@
 			return false;
 		}
 
-		public static string getNewNPCName(int npcType) => getNewNPCNameInner(npcType);
-
+		public string getNewNPCName() {
+			string NPCNameCategoryKey = null;
+			switch (type) {
+				// TODO: this looks horrible, and I know it does
+				// ideally, there'd exist a better way to do this,
+				// but as of now, I'm not sure what it would be
+				// -thomas
+				case 17:
+					NPCNameCategoryKey = "MerchantNames";
+					break;
+				case 18:
+					NPCNameCategoryKey = "NurseNames";
+					break;
+				case 19:
+					NPCNameCategoryKey = "ArmsDealerNames";
+					break;
+				case 20:
+					NPCNameCategoryKey = "DryadNames";
+					break;
+				case 22:
+					NPCNameCategoryKey = "GuideNames";
+					break;
+				case 38:
+					NPCNameCategoryKey = "DemolitionistNames";
+					break;
+				case 54:
+					NPCNameCategoryKey = "ClothierNames";
+					break;
+				case 107:
+					NPCNameCategoryKey = "GoblinTinkererNames";
+					break;
+				case 108:
+					NPCNameCategoryKey = "WizardNames";
+					break;
+				case 124:
+					NPCNameCategoryKey = "MechanicNames";
+					break;
+				case 160:
+					NPCNameCategoryKey = "TruffleNames";
+					break;
+				case 178:
+					NPCNameCategoryKey = "SteampunkerNames";
+					break;
+				case 207:
+					NPCNameCategoryKey = "DyeTraderNames";
+					break;
+				case 208:
+					NPCNameCategoryKey = "PartyGirlNames";
+					break;
+				case 209:
+					NPCNameCategoryKey = "CyborgNames";
+					break;
+				case 227:
+					NPCNameCategoryKey = "PainterNames";
+					break;
+				case 228:
+					NPCNameCategoryKey = "WitchDoctorNames";
+					break;
+				case 229:
+					NPCNameCategoryKey = "PirateNames";
+					break;
+				case 353:
+					NPCNameCategoryKey = "StylistNames";
+					break;
+				case 368:
+					NPCNameCategoryKey = "TravelingMerchantNames";
+					break;
+				case 369:
+					NPCNameCategoryKey = "AnglerNames";
+					break;
+				case 453:
+					NPCNameCategoryKey = "SkeletonMerchantNames";
+					break;
+				case 441:
+					NPCNameCategoryKey = "TaxCollectorNames";
+					break;
+				case 550:
+					NPCNameCategoryKey = "BartenderNames";
+					break;
+				case 588:
+					NPCNameCategoryKey = "GolferNames";
+					break;
+				case 633:
+					NPCNameCategoryKey = "BestiaryGirlNames";
+					break;
+				case 663:
+					NPCNameCategoryKey = "PrincessNames";
+					break;
+				case 637:
+					NPCNameCategoryKey = "CatNames_Siamese";
+					break;
+				case 638:
+					NPCNameCategoryKey = "DogNames_Labrador";
+					break;
+				case 656:
+					NPCNameCategoryKey = "BunnyNames_White";
+					break;
+			}
+
+			List<string> NPCNameList = new List<string>();
+			if (NPCNameCategoryKey != null)
+				NPCNameList = LanguageManager.Instance.GetLocalizedEntriesInCategory(NPCNameCategoryKey);
+			NPCNameList = NPCLoader.ModifyNPCNameList(this, NPCNameList);
+			if (NPCNameList != null && NPCNameList.Count > 0)
+				return NPCNameList[WorldGen.genRand.Next(NPCNameList.Count)];
+			else
+				return "";
+		}
+
+		/*
 		private static string getNewNPCNameInner(int npcType) {
 			switch (npcType) {
 				case 17:
@@ -1098,6 +_,7 @@
 					return "";
 			}
 		}
+		*/
 
 		public NetworkText GetTypeNetName() => NetworkText.FromKey(Lang.GetNPCName(netID).Key);
 
@@ -1138,7 +_,7 @@
 					continue;
 
 				if (flag) {
-					Main.npc[i].GivenName = getNewNPCName(npcType);
+					Main.npc[i].GivenName = Main.npc[i].getNewNPCName();
 					Main.npc[i].needsUniqueInfoUpdate = true;
 					continue;
 				}
@@ -1151,6 +_,7 @@
 			}
 		}
 
+		/*
 		public static string firstNPCName(int npcType) {
 			for (int i = 0; i < 200; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == npcType)
@@ -1159,6 +_,7 @@
 
 			return getNewNPCName(npcType);
 		}
+		*/
 
 		public static string GetFirstNPCNameOrNull(int npcType) {
 			for (int i = 0; i < 200; i++) {
@@ -1313,7 +_,7 @@
 				case 684:
 					return 53;
 				default:
-					return -1;
+					return NPCHeadLoader.GetNPCHeadSlot(type);
 			}
 		}
 
@@ -1350,6 +_,8 @@
 					break;
 			}
 
+			NPCLoader.BossHeadSlot(this, ref result);
+
 			return result;
 		}
 
@@ -1371,6 +_,7 @@
 					break;
 			}
 
+			NPCLoader.BossHeadRotation(this, ref result);
 			return result;
 		}
 
@@ -1380,6 +_,7 @@
 			if (num == 491 && spriteDirection == 1)
 				result = SpriteEffects.FlipHorizontally;
 
+			NPCLoader.BossHeadSpriteEffects(this, ref result);
 			return result;
 		}
 
@@ -2068,9 +_,21 @@
 			defDamage = damage;
 			defDefense = defense;
 			if (flag) {
-				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData, spawnparams.strengthMultiplierOverride);
+				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData ?? Main.GameModeInfo, spawnparams.strengthMultiplierOverride);
 				life = lifeMax;
 			}
+		}
+
+		public void CloneDefaults(int Type) {
+			int originalType = type;
+			int originalNetID = netID;
+			var originalModNPC = ModNPC;
+			var originalGlobals = globalNPCs;
+			SetDefaultsKeepPlayerInteraction(Type);
+			type = originalType;
+			netID = originalNetID;
+			ModNPC = originalModNPC;
+			globalNPCs = originalGlobals;
 		}
 
 		public void SetDefaultsKeepPlayerInteraction(int Type) {
@@ -2114,6 +_,9 @@
 				return;
 			}
 
+			ModNPC = null;
+			ShowNameOnHover = true;
+			globalNPCs = new Instanced<GlobalNPC>[0];
 			waterMovementSpeed = (lavaMovementSpeed = 0.5f);
 			honeyMovementSpeed = 0.25f;
 			netOffset *= 0f;
@@ -2165,10 +_,14 @@
 				buffType[k] = 0;
 			}
 
+			if (buffImmune.Length != BuffLoader.BuffCount)
+				Array.Resize(ref buffImmune, BuffLoader.BuffCount);
+
-			for (int l = 0; l < 355; l++) {
+			for (int l = 0; l < buffImmune.Length; l++) {
 				buffImmune[l] = false;
 			}
 
+			aiStyle = type < NPCID.Count ? 0 : -1; //Added by tML - use aiStyle -1 for modded NPCs by default so they don't always face the nearest player, and trigger net updates
 			setFrameSize = false;
 			netSkip = -2;
 			realLife = -1;
@@ -10751,13 +_,18 @@
 				catchItem = 2121;
 			}
 
+			NPCLoader.SetDefaults(this);
+
 			if (Main.dedServ)
 				frame = default(Rectangle);
+			// Extra patch context.
 			else if (TextureAssets.Npc[type] != null && TextureAssets.Npc[type].IsLoaded)
 				frame = new Rectangle(0, 0, TextureAssets.Npc[type].Width(), TextureAssets.Npc[type].Height() / Main.npcFrameCount[type]);
 			else
 				setFrameSize = true;
 
+			// Extra patch context.
+
 			if (spawnparams.sizeScaleOverride.HasValue) {
 				int num3 = (int)((float)width * scale);
 				int num4 = (int)((float)height * scale);
@@ -10804,7 +_,7 @@
 				friendly = true;
 			}
 
-			ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData, spawnparams.strengthMultiplierOverride);
+			ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData.Value, spawnparams.strengthMultiplierOverride);
 			life = lifeMax;
 		}
 
@@ -11450,6 +_,7 @@
 				}
 			}
 
+			NPCLoader.ScaleExpertStats(this, numPlayers, balance);
 			defDefense = defense;
 			defDamage = damage;
 			life = lifeMax;
@@ -11814,7 +_,8 @@
 			if (flag)
 				value2 = vector;
 
+			//TML: Added context
-			Projectile.NewProjectile(new EntitySource_DebugCommand(), value2 + value, Vector2.Zero, 995, 0, 0f, Main.myPlayer);
+			Projectile.NewProjectile(new EntitySource_DebugCommand("DryadStardewAnimation"), value2 + value, Vector2.Zero, 995, 0, 0f, Main.myPlayer);
 		}
 
 		private void AI_047_GolemFist() {
@@ -12269,6 +_,18 @@
 		}
 
 		public void AI() {
+			NPCLoader.NPCAI(this);
+		}
+
+		public void VanillaAI() {
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaAI_Inner();
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaAI_Inner() {
 			if (aiStyle == 0) {
 				if (Main.netMode != 1) {
 					for (int i = 0; i < 255; i++) {
@@ -31598,7 +_,8 @@
 				timeLeft = 86400;
 			}
 
+			//TODO: Replace this downcast.
-			timeLeft -= Main.dayRate;
+			timeLeft -= (int)Main.dayRate;
 			if (timeLeft < 0)
 				timeLeft = 0;
 
@@ -39047,13 +_,14 @@
 
 			int num2 = 7;
 			int num3 = 6;
-			int num4 = 2;
+			int num4 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			int num5 = 1;
-			int num6 = 2;
+			int num6 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			for (int i = point.X - num2; i <= point.X + num2; i += num5) {
 				for (int num7 = point.Y + num4; num7 >= point.Y - num3; num7 -= num6) {
 					Tile tile = Main.tile[i, num7];
-					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					//if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]) { // TML: #ModdedChairsForNPCs: Removed vanilla specific conditions
 						int num8 = Math.Abs(i - point.X) + Math.Abs(num7 - point.Y);
 						if (num == -1 || num8 < num) {
 							num = num8;
@@ -39074,6 +_,12 @@
 
 				b.Y += 2;
 			}
+			else if (tile2.type >= TileID.Count) { // Check necessary as in this case vanilla changes (to vanilla tiles that aren't sittable by default) by the hook should not take effect
+				TileRestingInfo info = new TileRestingInfo(this, b, Vector2.Zero, base.direction);
+				TileLoader.ModifySittingTargetInfo(b.X, b.Y, tile2.type, ref info);
+				b = info.AnchorTilePosition;
+				b.Y += 1; // Set to tile *below* chair
+			}
 
 			for (int j = 0; j < 200; j++) {
 				if (Main.npc[j].active && Main.npc[j].aiStyle == 7 && Main.npc[j].townNPC && Main.npc[j].ai[0] == 5f && (Main.npc[j].Bottom + Vector2.UnitY * -2f).ToTileCoordinates() == b)
@@ -39086,9 +_,11 @@
 
 		private void AI_007_TryForcingSitting(int homeFloorX, int homeFloorY) {
 			Tile tile = Main.tile[homeFloorX, homeFloorY - 1];
-			bool flag = type != 638 && type != 656 && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
+			//bool flag = type != 638 && type != 656 && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
+			bool flag = !NPCID.Sets.CannotSitOnFurniture[type] && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
 			if (flag)
-				flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				//flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				flag &= (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]); // TML: #ModdedChairsForNPCs
 
 			if (flag)
 				flag &= (tile.type != 15 || tile.frameY < 1080 || tile.frameY > 1098);
@@ -39106,8 +_,10 @@
 			if (flag) {
 				ai[0] = 5f;
 				ai[1] = 900 + Main.rand.Next(10800);
-				direction = ((tile.frameX != 0) ? 1 : (-1));
-				base.Bottom = new Vector2(homeFloorX * 16 + 8 + 2 * direction, homeFloorY * 16);
+				// TML: #ModdedChairsForNPCs
+				SitDown(new Point(homeFloorX, homeFloorY - 1), out int targetDirection, out var bottom);
+				direction = targetDirection;
+				base.Bottom = bottom;
 				velocity = Vector2.Zero;
 				localAI[3] = 0f;
 				netUpdate = true;
@@ -39148,6 +_,7 @@
 			if (type == 638 || type == 656 || NPCID.Sets.IsTownSlime[type])
 				num = 0;
 
+			//patch file: flag
 			bool flag = Main.raining;
 			if (!Main.dayTime)
 				flag = true;
@@ -39241,6 +_,8 @@
 					num2 += 0.15f;
 					defense += 8;
 				}
+
+				NPCLoader.BuffTownNPC(ref num2, ref defense);
 			}
 
 			if (type == 142 && Main.netMode != 1 && !Main.xMas) {
@@ -39382,7 +_,7 @@
 				return;
 			}
 
-			if (type >= 0 && type < 688 && NPCID.Sets.TownCritter[type] && target == 255) {
+			if (type >= 0 && NPCID.Sets.TownCritter[type] && target == 255) {
 				TargetClosest();
 				if (position.X < Main.player[target].position.X) {
 					base.direction = 1;
@@ -39477,7 +_,7 @@
 					base.direction = -1;
 			}
 
-			if (!WorldGen.InWorld(num5, num6) || Main.tile[num5, num6] == null)
+			if (!WorldGen.InWorld(num5, num6) || Main.netMode == 1 && !Main.sectionManager.TileLoaded(num5, num6))
 				return;
 
 			if (!homeless && Main.netMode != 1 && townNPC && (flag || (type == 37 && Main.tileDungeon[Main.tile[num5, num6].type])) && !AI_007_TownEntities_IsInAGoodRestingSpot(num5, num6, floorX, floorY)) {
@@ -39524,7 +_,14 @@
 			int num12 = -1;
 			if (!flag6 && Main.netMode != 1 && !flag3) {
 				for (int m = 0; m < 200; m++) {
+					if (!Main.npc[m].active) continue;
+					bool? modCanHit = NPCLoader.CanHitNPC(Main.npc[m], this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						continue;
+
+					bool canHitVal = modCanHit.HasValue && modCanHit.Value;
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
-					if (!Main.npc[m].active || Main.npc[m].friendly || Main.npc[m].damage <= 0 || !(Main.npc[m].Distance(base.Center) < num7) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[m].type]) || (!Main.npc[m].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[m].Center, 0, 0)))
+					if (!Main.npc[m].active || Main.npc[m].friendly || Main.npc[m].damage <= 0 || !(Main.npc[m].Distance(base.Center) < num7) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[m].type] && canHitVal) || (!Main.npc[m].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[m].Center, 0, 0)))
 						continue;
 
 					bool flag15 = Main.npc[m].CanBeChasedBy(this);
@@ -39778,7 +_,7 @@
 
 					if (closeDoor && ((position.X + (float)(width / 2)) / 16f > (float)(doorX + 2) || (position.X + (float)(width / 2)) / 16f < (float)(doorX - 2))) {
 						Tile tileSafely = Framing.GetTileSafely(doorX, doorY);
-						if (tileSafely.type == 11) {
+						if (TileLoader.CloseDoorID(tileSafely) >= 0) {
 							if (WorldGen.CloseDoor(doorX, doorY)) {
 								closeDoor = false;
 								NetMessage.SendData(19, -1, -1, null, 1, doorX, doorY, base.direction);
@@ -39947,7 +_,7 @@
 						Tile tileSafely4 = Framing.GetTileSafely(num19, num20 - 1);
 						Tile tileSafely5 = Framing.GetTileSafely(num19, num20 - 2);
 						bool flag21 = height / 16 < 3;
-						if (townNPC && tileSafely5.nactive() && (tileSafely5.type == 10 || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
+						if ((townNPC || NPCID.Sets.AllowDoorInteraction[type]) && tileSafely5.nactive() && (TileLoader.IsClosedDoor(tileSafely5) || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
 							if (Main.netMode != 1) {
 								if (WorldGen.OpenDoor(num19, num20 - 2, base.direction)) {
 									closeDoor = true;
@@ -40126,7 +_,8 @@
 				if (ai[0] == 5f) {
 					Point coords = (base.Bottom + Vector2.UnitY * -2f).ToTileCoordinates();
 					Tile tile = Main.tile[coords.X, coords.Y];
-					if (tile.type != 15 && tile.type != 497)
+					//if (tile.type != 15 && tile.type != 497)
+					if (!TileID.Sets.CanBeSatOnForNPCs[tile.type]) // TML: #ModdedChairsForNPCs 
 						ai[1] = 0f;
 					else
 						Main.sittingManager.AddNPC(whoAmI, coords);
@@ -40298,13 +_,19 @@
 					num35 = 589;
 					num37 = 7f;
 					num36 = 22;
+					//Patch context: num35 - proj type, num36 - damage, num37 - speed multiplier, num38 - attack delay, num39 - attack cooldown.
 					num38 = 1;
 					num39 = 10;
 					maxValue = 1;
 					knockBack = 2f;
+					//Patch context: num40 - gravity correction.
 					num40 = 10f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num36, ref knockBack);
+				NPCLoader.TownNPCAttackCooldown(this, ref num39, ref maxValue);
+				NPCLoader.TownNPCAttackProj(this, ref num35, ref num38);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num37, ref num40, ref num42);
 				if (Main.expertMode)
 					num36 = (int)((float)num36 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40324,6 +_,7 @@
 						vec = new Vector2(spriteDirection, -1f);
 
 					vec *= num37;
+					// Context for the patch above: num42 - random speed offset.
 					vec += Utils.RandomVector2(Main.rand, 0f - num42, num42);
 					int num43 = 1000;
 					num43 = ((type == 124) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer, 0f, whoAmI, townNpcVariationIndex) : ((type != 142) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer) : Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer, 0f, Main.rand.Next(5))));
@@ -40349,7 +_,7 @@
 				int num48 = 0;
 				int maxValue2 = 0;
 				float knockBack2 = 0f;
-				int num49 = 0;
+				float num49 = 0;
 				bool flag24 = false;
 				float num50 = 0f;
 				if ((float)NPCID.Sets.AttackTime[type] == ai[1]) {
@@ -40514,6 +_,7 @@
 
 					if (localAI[3] > (float)num47) {
 						num47 = 48;
+						//Patch context: flag24 means 'in between shots'.
 						flag24 = true;
 					}
 
@@ -40527,12 +_,14 @@
 				}
 				else if (type == 209) {
 					num44 = Utils.SelectRandom<int>(Main.rand, 134, 133, 135);
+					//Patch context: num44 - proj type, num45 - damage, num46 - speed multiplier, num47 - attack delay, num48 - attack cooldown.
 					num47 = 1;
 					switch (num44) {
 						case 135:
 							num46 = 12f;
 							num45 = 30;
 							num48 = 30;
+							//Patch context: num50 - randomOffset
 							maxValue2 = 10;
 							knockBack2 = 7f;
 							num50 = 0.2f;
@@ -40556,6 +_,12 @@
 					}
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num45, ref knockBack2);
+				NPCLoader.TownNPCAttackCooldown(this, ref num48, ref maxValue2);
+				NPCLoader.TownNPCAttackProj(this, ref num44, ref num47);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num46, ref num49, ref num50);
+				NPCLoader.TownNPCAttackShoot(this, ref flag24);
+
 				if (Main.expertMode)
 					num45 = (int)((float)num45 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40676,6 +_,7 @@
 				else if (type == 663) {
 					num54 = 950;
 					num55 = ((!Main.hardMode) ? 15 : 20);
+					//Patch context: num54 - proj type, num55 - damage, num57 - attack delay, num58 - attack cooldown.
 					num57 = 15;
 					num58 = 0;
 					maxValue3 = 0;
@@ -40691,6 +_,11 @@
 					knockBack3 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num55, ref knockBack3);
+				NPCLoader.TownNPCAttackCooldown(this, ref num58, ref maxValue3);
+				NPCLoader.TownNPCAttackProj(this, ref num54, ref num57);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num56, ref num59, ref num62);
+				NPCLoader.TownNPCAttackMagic(this, ref num61);
 				if (Main.expertMode)
 					num55 = (int)((float)num55 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40701,12 +_,14 @@
 				if (localAI[3] == (float)num57 && Main.netMode != 1) {
 					Vector2 vec4 = Vector2.Zero;
 					if (num63 != -1)
+						//Patch context: num59 is gravity correction.
 						vec4 = DirectionTo(Main.npc[num63].Center + new Vector2(0f, (0f - num59) * MathHelper.Clamp(Distance(Main.npc[num63].Center) / num60, 0f, 1f)));
 
 					if (vec4.HasNaNs() || Math.Sign(vec4.X) != spriteDirection)
 						vec4 = new Vector2(spriteDirection, 0f);
 
 					vec4 *= num56;
+					// Context for the patch above: num92 - random speed offset.
 					vec4 += Utils.RandomVector2(Main.rand, 0f - num62, num62);
 					if (type == 108) {
 						int num64 = Utils.SelectRandom<int>(Main.rand, 1, 1, 1, 1, 2, 2, 3);
@@ -40757,6 +_,7 @@
 					}
 				}
 
+				//Patch context: num61 is aura light multiplier
 				if (num61 > 0f) {
 					Vector3 vector6 = GetMagicAuraColor().ToVector3() * num61;
 					Lighting.AddLight(base.Center, vector6.X, vector6.Y, vector6.Z);
@@ -40820,11 +_,15 @@
 				else if (NPCID.Sets.IsTownPet[type]) {
 					num74 = 10;
 					num76 = (num77 = 32);
+					//Patch context: num73 - attack cooldown,  num74 - damage, num75 - knockback, num76 & num77 - width and height, maxValue4 - random extra cooldown
 					num73 = 15;
 					maxValue4 = 8;
 					num75 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num74, ref num75);
+				NPCLoader.TownNPCAttackCooldown(this, ref num73, ref maxValue4);
+				NPCLoader.TownNPCAttackSwing(this, ref num76, ref num77);
 				if (Main.expertMode)
 					num74 = (int)((float)num74 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -41107,15 +_,18 @@
 
 					if (flag30) {
 						Tile tile2 = Main.tile[b.X, b.Y];
-						flag30 = (tile2.type == 15 || tile2.type == 497);
+						//flag30 = (tile2.type == 15 || tile2.type == 497);
+						flag30 = TileID.Sets.CanBeSatOnForNPCs[tile2.type]; // TML: #ModdedChairsForNPCs
 						if (flag30 && tile2.type == 15 && tile2.frameY >= 1080 && tile2.frameY <= 1098)
 							flag30 = false;
 
 						if (flag30) {
 							ai[0] = 5f;
 							ai[1] = 900 + Main.rand.Next(10800);
-							base.direction = ((tile2.frameX != 0) ? 1 : (-1));
-							base.Bottom = new Vector2(b.X * 16 + 8 + 2 * base.direction, b.Y * 16 + 16);
+							// TML: #ModdedChairsForNPCs
+							SitDown(b, out int targetDirection, out var bottom);
+							base.direction = targetDirection;
+							base.Bottom = bottom;
 							velocity = Vector2.Zero;
 							localAI[3] = 0f;
 							netUpdate = true;
@@ -44646,7 +_,7 @@
 					Main.tile[num191 - direction, num192 + 1] = new Tile();
 
 				Main.tile[num191, num192 + 1].halfBrick();
-				if (Main.tile[num191, num192 - 1].nactive() && (Main.tile[num191, num192 - 1].type == 10 || Main.tile[num191, num192 - 1].type == 388) && flag8) {
+				if (Main.tile[num191, num192 - 1].nactive() && (TileLoader.IsClosedDoor(Main.tile[num191, num192 - 1]) || Main.tile[num191, num192 - 1].type == 388) && flag8) {
 					ai[2] += 1f;
 					ai[3] = 0f;
 					if (ai[2] >= 60f) {
@@ -44685,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num191, num192 - 1);
 							}
 							else {
-								if (Main.tile[num191, num192 - 1].type == 10) {
+								if (TileLoader.IsClosedDoor(Main.tile[num191, num192 - 1])) {
 									bool flag26 = WorldGen.OpenDoor(num191, num192 - 1, direction);
 									if (!flag26) {
 										ai[3] = num53;
@@ -45861,7 +_,7 @@
 								Tile tileSafely = Framing.GetTileSafely(i, j);
 								bool flag2 = tileSafely.active() && Main.tileSolid[tileSafely.type] && !Main.tileFrameImportant[tileSafely.type];
 								if (flag && flag2) {
-									int num38 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely);
+									int num38 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, i, j);
 									for (int k = 0; k < num38; k++) {
 										Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 										obj.velocity.Y -= 3f + (float)num37 * 1.5f;
@@ -46464,7 +_,7 @@
 			bool flag21 = false;
 			bool flag22 = false;
 			bool flag23 = false;
-			LegacySoundStyle style = null;
+			SoundStyle? style = null;
 			int num20 = 0;
 			bool flag24 = false;
 			float num21 = 1f;
@@ -47316,8 +_,13 @@
 
 			if (!flag20) {
 				if (ai[3] < (float)num19 && flag21) {
+					/*
 					if (num20 > 0 && Main.rand.Next(num20) == 0)
 						SoundEngine.PlayTrackedSound(style, base.Center);
+					*/
+
+					if (num20 > 0 && Main.rand.Next(num20) == 0 && style.HasValue)
+						SoundEngine.PlayTrackedSound(style.Value, base.Center);
 
 					bool hasValidTarget = HasValidTarget;
 					nPCTargetingMethod(this, faceTarget: true, null);
@@ -47495,7 +_,7 @@
 				Tile tileSafely4 = Framing.GetTileSafely(num64, num65 - 1);
 				Tile tileSafely5 = Framing.GetTileSafely(num64, num65 - 2);
 				Tile tileSafely6 = Framing.GetTileSafely(num64, num65 - 3);
-				if (flag8 && tileSafely4.nactive() && (tileSafely4.type == 10 || tileSafely4.type == 388)) {
+				if (flag8 && tileSafely4.nactive() && (TileLoader.IsClosedDoor(tileSafely4) || tileSafely4.type == 388)) {
 					ai[0] += 1f;
 					ai[3] = 0f;
 					if (ai[0] >= 60f) {
@@ -47525,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num64, num65 - 1);
 							}
 							else {
-								if (tileSafely4.type == 10) {
+								if (TileLoader.IsClosedDoor(tileSafely4)) {
 									bool flag38 = WorldGen.OpenDoor(num64, num65 - 1, direction);
 									if (!flag38) {
 										ai[3] = num19;
@@ -49539,6 +_,10 @@
 			if (type == 20 && townNpcVariationIndex == 1)
 				return false;
 
+			if (!NPCLoader.UsesPartyHat(this)) {
+				return false;
+			}
+
 			if (ForcePartyHatOn)
 				return true;
 
@@ -49590,6 +_,10 @@
 				num = TextureAssets.Npc[type].Height() / Main.npcFrameCount[type];
 			}
 
+			NPCLoader.FindFrame(this, num);
+		}
+
+		public void VanillaFindFrame(int num, bool isLikeATownNPC, int type) {
 			int num2 = 0;
 			if (aiAction == 0)
 				num2 = ((velocity.Y < 0f) ? 2 : ((velocity.Y > 0f) ? 3 : ((velocity.X != 0f) ? 1 : 0)));
@@ -51195,7 +_,7 @@
 				case 684: {
 						int num231 = isLikeATownNPC ? NPCID.Sets.ExtraFramesCount[type] : 0;
 						bool flag11 = NPCID.Sets.IsTownSlime[type];
-						if (false && !Main.dedServ && TownNPCProfiles.Instance.GetProfile(type, out ITownNPCProfile profile)) {
+						if (false && !Main.dedServ && TownNPCProfiles.Instance.GetProfile(this, out ITownNPCProfile profile)) {
 							Asset<Texture2D> textureNPCShouldUse = profile.GetTextureNPCShouldUse(this);
 							if (textureNPCShouldUse.IsLoaded) {
 								num = textureNPCShouldUse.Height() / Main.npcFrameCount[type];
@@ -57883,7 +_,10 @@
 					if (Main.tile[x, y].type == 467)
 						number2 = 5;
 
-					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number);
+					if (Main.tile[x, y].type >= TileID.Count)
+						number2 = 101;
+
+					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number, Main.tile[x, y].type, 0);
 					NetMessage.SendTileSquare(-1, x, y, 3);
 				}
 
@@ -58229,6 +_,9 @@
 			if (!active || DoesntDespawnToInactivity())
 				return;
 
+			if (!NPCLoader.CheckActive(this))
+				return;
+
 			if (townNPC) {
 				AddIntoPlayersTownNPCSlots();
 				return;
@@ -58309,7 +_,7 @@
 			if (timeLeft <= 0)
 				flag2 = false;
 
-			if (!flag2 && Main.netMode != 1) {
+			if (!flag2 && Main.netMode != 1 && !NPCLoader.SavesAndLoads(this)) {
 				noSpawnCycle = true;
 				active = false;
 				if (Main.netMode == 2) {
@@ -58438,6 +_,9 @@
 				}
 			}
 
+			if (!NPCLoader.CheckDead(this))
+				return;
+
 			noSpawnCycle = true;
 			if (townNPC && type != 37 && type != 453) {
 				if (Main.netMode != 2)
@@ -58483,13 +_,14 @@
 			if (townNPC && Main.netMode != 1 && homeless && WorldGen.prioritizedTownNPCType == type)
 				WorldGen.prioritizedTownNPCType = 0;
 
-			LegacySoundStyle legacySoundStyle = DeathSound;
+			var legacySoundStyle = DeathSound;
 			if (type == 229 && IsShimmerVariant)
 				legacySoundStyle = SoundID.NPCDeath6;
 
 			if (legacySoundStyle != null)
 				SoundEngine.PlaySound(legacySoundStyle, base.position);
 
+			if (NPCLoader.SpecialOnKill(this)) { } else 
 			if (type == 13 || type == 14 || type == 15) {
 				DropEoWLoot();
 			}
@@ -58992,7 +_,7 @@
 		}
 
 		public static void ResetKillCount() {
-			for (int i = 0; i < 688; i++) {
+			for (int i = 0; i < killCount.Length; i++) {
 				killCount[i] = 0;
 			}
 		}
@@ -59055,7 +_,7 @@
 		}
 
 		public void NPCLoot() {
-			if (Main.netMode == 1 || type >= 688 || (Main.getGoodWorld && !downedBoss3 && (type == 31 || type == 294 || type == 296 || type == 295 || type == 32 || type == 34 || type == 71)))
+			if (Main.netMode == 1 || (Main.getGoodWorld && !downedBoss3 && (type == 31 || type == 294 || type == 296 || type == 295 || type == 32 || type == 34 || type == 71)))
 				return;
 
 			Player closestPlayer = Main.player[Player.FindClosest(position, width, height)];
@@ -59072,9 +_,13 @@
 			if ((type == 23 && Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.NoEarlymodeLootWhenSpawnedFromStatue[type] && !Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.StatueSpawnedDropRarity[type] != -1f && (Main.rand.NextFloat() >= NPCID.Sets.StatueSpawnedDropRarity[type] || !AnyInteractions())))
 				return;
 
+			if (!NPCLoader.PreKill(this))
+				return;
+
 			bool num = downedMechBoss1 && downedMechBoss2 && downedMechBoss3;
 			DoDeathEvents_BeforeLoot(closestPlayer);
 			NPCLoot_DropItems(closestPlayer);
+			NPCLoader.OnKill(this);
 			DoDeathEvents(closestPlayer);
 			if (!num && downedMechBoss1 && downedMechBoss2 && downedMechBoss3 && Main.hardMode) {
 				if (Main.netMode == 0)
@@ -59120,7 +_,7 @@
 			WoFKilledToday = false;
 		}
 
-		private void DoDeathEvents_DropBossPotionsAndHearts() {
+		private void DoDeathEvents_DropBossPotionsAndHearts(ref string typeName) {
 			int stack = Main.rand.Next(5, 16);
 			int num = 28;
 			if (type == 113)
@@ -59148,6 +_,7 @@
 			else if (type == 398)
 				num = 3544;
 
+			NPCLoader.BossLoot(this, ref typeName, ref num);
 			Item.NewItem(GetItemSource_Loot(), (int)position.X, (int)position.Y, width, height, num, stack);
 			int num2 = Main.rand.Next(5) + 5;
 			for (int i = 0; i < num2; i++) {
@@ -59165,7 +_,7 @@
 			}
 		}
 
-		private void DoDeathEvents_CelebrateBossDeath() {
+		private void DoDeathEvents_CelebrateBossDeath(string typeName) {
 			if (type == 125 || type == 126) {
 				if (Main.netMode == 0)
 					Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Plural", Language.GetTextValue("Enemies.TheTwins")), 175, 75);
@@ -59179,7 +_,7 @@
 					ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", NetworkText.FromKey("Enemies.MoonLord")), new Color(175, 75, 255));
 			}
 			else if (Main.netMode == 0) {
-				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", TypeName), 175, 75);
+				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", typeName), 175, 75);
 			}
 			else if (Main.netMode == 2) {
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", GetTypeNetName()), new Color(175, 75, 255));
@@ -59571,8 +_,10 @@
 			}
 
 			if (boss) {
+				string typeName = TypeName;
+
-				DoDeathEvents_DropBossPotionsAndHearts();
+				DoDeathEvents_DropBossPotionsAndHearts(ref typeName);
-				DoDeathEvents_CelebrateBossDeath();
+				DoDeathEvents_CelebrateBossDeath(typeName);
 				if (Main.netMode == 2)
 					NetMessage.SendData(7);
 			}
@@ -59822,7 +_,10 @@
 			}
 		}
 
+		// this is made internal because NPC.CheckCatchNPC now fulfills every use case
+		// that callin' this method manually could have for modders, and then some
+		// -thomas
-		public static void CatchNPC(int i, int who = -1) {
+		internal static void CatchNPC(int i, int who = -1) {
 			if (!Main.npc[i].active)
 				return;
 
@@ -59842,8 +_,14 @@
 					NetMessage.SendData(106, -1, -1, null, (int)position.X, position.Y);
 				}
 				else {
+					/*
 					new Item().SetDefaults(Main.npc[i].catchItem);
 					Item.NewItem(GetSpawnSource_NPCCatch(who), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, noBroadcast: false, 0, noGrabDelay: true);
+					*/
+					int itemWhoAmI = Item.NewItem(GetSpawnSource_NPCCatch(who, Main.npc[i]), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, true, 0, true, false);
+					
+					NetMessage.SendData(MessageID.SyncItem, -1, -1, null, itemWhoAmI, 1f); // NewItem above changed to noBroadcast, number2 is 1 for noGrabDelay effect.
+					
 					Main.npc[i].active = false;
 					NetMessage.SendData(23, -1, -1, null, i);
 				}
@@ -59984,7 +_,7 @@
 			if (Main.netMode == 1) {
 				NetMessage.SendData(71, -1, -1, null, x, y, Type, Style);
 			}
-			else if (Type >= 0 && Type < 688 && (Main.npcCatchable[Type] || who == Main.myPlayer) && CanReleaseNPCs(who)) {
+			else if (Type >= 0 && (Main.npcCatchable[Type] || who == Main.myPlayer) && CanReleaseNPCs(who)) {
 				switch (Type) {
 					case 583:
 					case 584:
@@ -60245,6 +_,7 @@
 			int num10;
 			int maxValue;
 			bool flag15;
+			NPCSpawnInfo spawnInfo = new NPCSpawnInfo();
 			while (true) {
 				if (num7 >= 255)
 					return;
@@ -60265,11 +_,13 @@
 						flag11 = false;
 						flag12 = false;
 						flag13 = false;
+						//patch file: flag14
 						flag14 = (downedPlantBoss && Main.hardMode);
 						isItAHappyWindyDay = Main.IsItAHappyWindyDay;
 						if (Main.player[num7].active && Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0 && ((double)Main.player[num7].position.Y < Main.worldSurface * 16.0 + (double)sHeight || Main.remixWorld)) {
 							int num8 = 3000;
 							if ((double)Main.player[num7].position.X > Main.invasionX * 16.0 - (double)num8 && (double)Main.player[num7].position.X < Main.invasionX * 16.0 + (double)num8) {
+								//patch file: flag6
 								flag6 = true;
 							}
 							else if (Main.invasionX >= (double)(Main.maxTilesX / 2 - 5) && Main.invasionX <= (double)(Main.maxTilesX / 2 + 5)) {
@@ -60285,14 +_,17 @@
 						}
 
 						if (Main.player[num7].ZoneTowerSolar || Main.player[num7].ZoneTowerNebula || Main.player[num7].ZoneTowerVortex || Main.player[num7].ZoneTowerStardust)
+							// Patch note: flag6 - Invasion.
 							flag6 = true;
 
 						num9 = (int)(Main.player[num7].position.X + (float)(Main.player[num7].width / 2)) / 16;
 						num10 = (int)(Main.player[num7].position.Y + (float)(Main.player[num7].height / 2)) / 16;
 						if (Main.wallHouse[Main.tile[num9, num10].wall])
+							//Patch note: flag5 - playerSafe
 							flag5 = true;
 
 						if (Main.tile[num9, num10].wall == 87)
+							//Patch note: flag4 - Lihzahrd
 							flag4 = true;
 
 						flag2 = false;
@@ -60651,12 +_,14 @@
 								}
 								else {
 									if (!Main.expertMode || Main.rand.Next(30) != 0)
+										// Patch note: flag12 - playerInTown??????????????? Pretty weird
 										flag12 = true;
 
 									maxSpawns = (int)((double)(float)maxSpawns * 0.6);
 								}
 							}
 						}
+						NPCLoader.EditSpawnRate(Main.player[num7], ref spawnRate, ref maxSpawns);
 
 						flag15 = false;
 						if (Main.player[num7].active && !Main.player[num7].dead && Main.player[num7].nearbyActiveNPCs < (float)maxSpawns && Main.rand.Next(spawnRate) == 0) {
@@ -60682,6 +_,7 @@
 								safeRangeY += (int)((double)(sHeight / 16) * 0.5 / (double)num12);
 							}
 
+							NPCLoader.EditSpawnRange(Main.player[num7], ref spawnRangeX, ref spawnRangeY, ref safeRangeX, ref safeRangeY);
 							int num13 = (int)(Main.player[num7].position.X / 16f) - spawnRangeX;
 							int num14 = (int)(Main.player[num7].position.X / 16f) + spawnRangeX;
 							int num15 = (int)(Main.player[num7].position.Y / 16f) - spawnRangeY;
@@ -60715,6 +_,7 @@
 										num2 = num22;
 										flag2 = true;
 										flag3 = true;
+										// Patch note: flag3 - Sky
 									}
 									else if (!flag6 && (double)num22 < Main.worldSurface * 0.44999998807907104 && !flag12 && Main.hardMode && Main.rand.Next(10) == 0) {
 										num3 = Main.tile[num21, num22].type;
@@ -60777,6 +_,7 @@
 										}
 
 										if (num >= num17 && num <= num18)
+											// Patch note: flag15 - safeRangeX
 											flag15 = true;
 									}
 								}
@@ -60806,17 +_,23 @@
 									flag2 = false;
 
 								if (Main.tile[num, num2 - 1].honey())
+									// Patch note: flag8 - Honey
 									flag8 = true;
 								else
+									// Patch note: flag7 - Water
 									flag7 = true;
 							}
 
 							int num29 = (int)Main.player[num7].Center.X / 16;
 							int num30 = (int)(Main.player[num7].Bottom.Y + 8f) / 16;
+							spawnInfo.PlayerFloorX = num29;
+							spawnInfo.PlayerFloorY = num30;
 							if (Main.tile[num, num2].type == 367) {
+								// Patch note: flag10 - marble
 								flag10 = true;
 							}
 							else if (Main.tile[num, num2].type == 368) {
+								// Patch note: flag9 - granite
 								flag9 = true;
 							}
 							else if (Main.tile[num29, num30].type == 367) {
@@ -60912,6 +_,7 @@
 						for (int num40 = num - num39; num40 < num + num39; num40++) {
 							for (int num41 = num2 - num39; num41 < num2 + num39; num41++) {
 								if (Main.tile[num40, num41].wall == 62)
+									// Patch note: flag11 - Spider wall
 									flag11 = true;
 							}
 						}
@@ -60932,6 +_,7 @@
 						for (int num45 = num - num44; num45 < num + num44; num45++) {
 							for (int num46 = num2 - num44; num46 < num2 + num44; num46++) {
 								if (WallID.Sets.AllowsUndergroundDesertEnemiesToSpawn[Main.tile[num45, num46].wall])
+									// Patch note: flag13 - Desert cave
 									flag13 = true;
 							}
 						}
@@ -60995,9 +_,35 @@
 			}
 
 			num49 = SpawnNPC_TryFindingProperGroundTileType(num49, num, num2);
+
+			spawnInfo.SpawnTileX = num;
+			spawnInfo.SpawnTileY = num2;
+			spawnInfo.SpawnTileType = num3;
+			spawnInfo.Player = Main.player[num7];
+			spawnInfo.Sky = flag3;
+			spawnInfo.Lihzahrd = flag4;
+			spawnInfo.PlayerSafe = flag5;
+			spawnInfo.Invasion = flag6;
+			spawnInfo.Water = flag7;
+			spawnInfo.Granite = flag9;
+			spawnInfo.Marble = flag10;
+			spawnInfo.SpiderCave = flag11;
+			spawnInfo.PlayerInTown = flag12;
+			spawnInfo.DesertCave = flag13;
+			spawnInfo.PlanteraDefeated = flag14;
+			spawnInfo.SafeRangeX = flag15;
+
 			int newNPC = 200;
 			int cattailX;
 			int cattailY;
+			int? spawnChoice = NPCLoader.ChooseSpawn(spawnInfo);
+			if (!spawnChoice.HasValue)
+				return;
+
+			int spawn = spawnChoice.Value;
+			if (spawn != 0)
+				goto endVanillaSpawn;
+
 			if (Main.player[num7].ZoneTowerNebula) {
 				bool flag25 = true;
 				int num51 = 0;
@@ -62980,7 +_,7 @@
 						int num109 = Main.rand.Next(7);
 						int num110 = 12;
 						int maxValue4 = 20;
-						if (Main.player[num7].statLifeMax <= 100) {
+						if (Main.player[num7].ConsumedLifeCrystals == 0) {
 							num110 = 5;
 							num110 -= Main.CurrentFrameFlags.ActivePlayersCount / 2;
 							if (num110 < 2)
@@ -63276,6 +_,11 @@
 				}
 			}
 
+			endVanillaSpawn:
+
+			if (spawn != 0)
+				newNPC = NPCLoader.SpawnNPC(spawn, num, num2);
+
 			if (Main.npc[newNPC].type == 1 && Main.player[num7].RollLuck(180) == 0)
 				Main.npc[newNPC].SetDefaults(-4);
 
@@ -63994,6 +_,20 @@
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[num].GetTypeNetName()), new Color(175, 75, 255));
 		}
 
+		/// <summary>
+		/// Spawns an NPC into the game world with the given type. This method should not be called on multiplayer clients. The X and Y parameters dictate the centered spawn position. ai0, ai1, ai2, and ai3 will initialize the NPC.ai[] array with the supplied values. This can be used to pass in information to the NPC. The NPC AI code will have to be written to utilize those values. Target can be set to a Player.whoAmI to have the NPC targetting a specific Player immediately on spawn. Start can be used to ensure that an NPC spawns in a slot after an existing NPC. This can be used to ensure that the spawned NPC draws behind an existing NPC. This is useful for bosses that spawn minions. The return value is the index of the spawned NPC within the <see cref="Main.npc"/> array. 
+		/// </summary>
+		/// <param name="source"></param>
+		/// <param name="X"></param>
+		/// <param name="Y"></param>
+		/// <param name="Type">Either an <see cref="NPCID"/> entry or <see cref="ModContent.NPCType{T}"/>, for example <see cref="NPCID.BabySlime"/> or ModContent.NPCType&lt;MyModNPC&gt;()</param>
+		/// <param name="Start"></param>
+		/// <param name="ai0"></param>
+		/// <param name="ai1"></param>
+		/// <param name="ai2"></param>
+		/// <param name="ai3"></param>
+		/// <param name="Target"></param>
+		/// <returns></returns>
 		public static int NewNPC(IEntitySource source, int X, int Y, int Type, int Start = 0, float ai0 = 0f, float ai1 = 0f, float ai2 = 0f, float ai3 = 0f, int Target = 255) {
 			if (Main.getGoodWorld && Main.rand.Next(3) != 0) {
 				if (Type == 46)
@@ -64026,6 +_,8 @@
 						ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[availableNPCSlot].GetTypeNetName()), new Color(175, 75, 255));
 				}
 
+				NPCLoader.OnSpawn(Main.npc[availableNPCSlot], source);
+
 				return availableNPCSlot;
 			}
 
@@ -64033,7 +_,7 @@
 		}
 
 		private static int GetAvailableNPCSlot(int Type, int startIndex) {
-			bool num = Type == 222 || Type == 245;
+			bool num = Type >= 0 && NPCID.Sets.SpawnFromLastEmptySlot[Type];
 			int t = 200;
 			int num2 = 1;
 			if (num) {
@@ -64057,9 +_,9 @@
 
 		private static void GiveTownUniqueDataToNPCsThatNeedIt(int Type, int nextNPC) {
 			NPC nPC = Main.npc[nextNPC];
-			if (nPC.isLikeATownNPC) {
-				nPC.GivenName = getNewNPCName(Type);
-				if (TownNPCProfiles.Instance.GetProfile(Type, out ITownNPCProfile profile)) {
+			if (nPC.isLikeATownNPC || Type >= 0 && NPCID.Sets.SpawnsWithCustomName[Type]) {
+				nPC.GivenName = nPC.getNewNPCName();
+				if (TownNPCProfiles.Instance.GetProfile(nPC, out ITownNPCProfile profile)) {
 					nPC.townNpcVariationIndex = profile.RollVariation();
 					nPC.GivenName = profile.GetNameForVariant(nPC);
 				}
@@ -64101,7 +_,7 @@
 		}
 
 		public bool RerollVariation() {
-			if (!TownNPCProfiles.Instance.GetProfile(type, out ITownNPCProfile profile))
+			if (!TownNPCProfiles.Instance.GetProfile(this, out ITownNPCProfile profile))
 				return false;
 
 			int num = townNpcVariationIndex;
@@ -64322,12 +_,16 @@
 				return 0.0;
 
 			double num = Damage;
+			if (!NPCLoader.StrikeNPC(this, ref num, defense, ref knockBack, hitDirection, ref crit))
+				goto skipStrike;
+
 			num = Main.CalculateDamageNPCsTake((int)num, defense);
 			if (crit)
 				num *= 2.0;
 
 			if (takenDamageMultiplier > 1f)
 				num *= (double)takenDamageMultiplier;
+			skipStrike:
 
 			if ((takenDamageMultiplier > 1f || Damage != 9999) && lifeMax > 1) {
 				if (friendly) {
@@ -64604,7 +_,20 @@
 			}
 		}
 
+		public void HitEffect(int hitDirection = 0, double dmg = 10.0)
+			=> NPCLoader.HitEffect(this, hitDirection, dmg);
+
-		public void HitEffect(int hitDirection = 0, double dmg = 10.0) {
+		public void VanillaHitEffect(int hitDirection = 0, double dmg = 10.0) {
+			var usedSource = new EntitySource_HitEffect(this);
+
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaHitEffect_Inner(hitDirection, dmg);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaHitEffect_Inner(int hitDirection, double dmg) {
 			if (!active)
 				return;
 
@@ -71899,6 +_,9 @@
 			int num = -1;
 			for (int i = 0; i < 20; i++) {
 				if (buffType[i] == type) {
+					if (BuffLoader.ReApply(type, this, time, i))
+						return;
+
 					if (buffTime[i] < time)
 						buffTime[i] = time;
 
@@ -71934,7 +_,7 @@
 		}
 
 		public void RequestBuffRemoval(int buffTypeToRemove) {
-			if (buffTypeToRemove < 0 || buffTypeToRemove >= 355 || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
+			if (buffTypeToRemove < 0 || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
 				return;
 
 			int num = FindBuffIndex(buffTypeToRemove);
@@ -72115,9 +_,18 @@
 
 		public void UpdateNPC(int i) {
 			whoAmI = i;
+
 			if (!active)
 				return;
 
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			UpdateNPC_Inner(i);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void UpdateNPC_Inner(int i) {
 			if (offSetDelayTime > 0) {
 				netOffset *= 0f;
 			}
@@ -72131,7 +_,7 @@
 				if (NPCID.Sets.NoMultiplayerSmoothingByType[type]) {
 					netOffset *= 0f;
 				}
-				else if (NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
+				else if (aiStyle >= 0 && aiStyle < NPCLoader.NPCCount && NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
 					netOffset *= 0f;
 				}
 				else {
@@ -72182,6 +_,7 @@
 				bool flag = false;
 				int num4 = (int)(position.X + (float)(width / 2)) / 16;
 				int num5 = (int)(position.Y + (float)(height / 2)) / 16;
+				/*
 				try {
 					if (num4 >= 4 && num4 <= Main.maxTilesX - 4 && num5 >= 4 && num5 <= Main.maxTilesY - 4) {
 						if (Main.tile[num4, num5] == null)
@@ -72199,12 +_,14 @@
 				catch {
 					flag = true;
 				}
+				*/
 
-				if (flag)
+				if (!Main.sectionManager.TilesLoaded(num4 - 3, num5 - 3, num4 + 3, num5 + 3))
 					return;
 			}
 
 			UpdateNPC_BuffFlagsReset();
+			NPCLoader.ResetEffects(this);
 			UpdateNPC_BuffSetFlags();
 			UpdateNPC_SoulDrainDebuff();
 			UpdateNPC_BuffClearExpiredBuffs();
@@ -72440,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public IEntitySource GetItemSource_Misc(int itemSourceId) => new EntitySource_ByItemSourceId(this, itemSourceId);
 		public static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => new EntitySource_Parent(Main.player[whoReleasedIt]);
 		public static IEntitySource GetSpawnSource_NPCCatch(int whoCatchedIt) => new EntitySource_Parent(Main.player[whoCatchedIt]);
@@ -72450,6 +_,24 @@
 		public static IEntitySource GetSpawnSourceForTownSpawn() => new EntitySource_SpawnNPC();
 		public IEntitySource GetSpawnSourceForNPCFromNPCAI() => new EntitySource_Parent(this);
 		public IEntitySource GetItemSource_Loot() => new EntitySource_Loot(this);
+		*/
+
+		// Internal redirects:
+		internal static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => Main.player[whoReleasedIt].GetSource_ReleaseEntity();
+		internal static IEntitySource GetSpawnSource_NPCCatch(int whoCaughtIt, Entity caughtEntity) => Main.player[whoCaughtIt].GetSource_CatchEntity(caughtEntity);
+		internal static IEntitySource GetSpawnSourceForNaturalSpawn() => GetSource_NaturalSpawn();
+		internal static IEntitySource GetSpawnSourceForTownSpawn() => GetSource_TownSpawn();
+
+		internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetSpawnSource_NPCHurt() => new EntitySource_Parent(this);
+		internal IEntitySource GetSpawnSource_ForProjectile() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForProjectileNPC() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForNPCFromNPCAI() => GetSource_FromAI();
+		internal IEntitySource GetItemSource_Loot() => GetSource_Loot();
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   NPC.TML.Sources.cs (if exists);
 
 		private void UpdateNPC_UpdateTrails() {
 			int num = NPCID.Sets.TrailingMode[type];
@@ -73299,6 +_,7 @@
 					num = 5;
 			}
 
+			NPCLoader.UpdateLifeRegen(this, ref num);
 			if (lifeRegen <= -240 && num < 2)
 				num = 2;
 
@@ -73502,6 +_,8 @@
 					else
 						shimmering = true;
 				}
+				
+				BuffLoader.Update(buffType[i], this, ref i); // todo, move?
 			}
 		}
 
@@ -73749,10 +_,16 @@
 				if (acceptableNPCIDs[nPC.type] && nPC.active && !nPC.friendly && nPC.damage > 0) {
 					Rectangle npcRect = nPC.Hitbox;
 					GetMeleeCollisionData(hitbox, num, ref specialHitSetter, ref damageMultiplier, ref npcRect);
+					bool? modCanHit = NPCLoader.CanHitNPC(nPC, this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						goto Continue;
+
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
-					if (hitbox.Intersects(npcRect) && (type != 453 || !NPCID.Sets.Skeletons[nPC.type]) && nPC.type != 624)
+					if (hitbox.Intersects(npcRect) && ((modCanHit == true) || type != 453 || !NPCID.Sets.Skeletons[nPC.type])&& nPC.type != 624)
 						break;
 				}
 
+				Continue:
 				num++;
 			}
 
@@ -73765,14 +_,17 @@
 				num = 20;
 
 			int num2 = Main.DamageVar(thatNPC.damage);
-			int num3 = 6;
+			float num3 = 6;
 			int num4 = (!(thatNPC.Center.X > base.Center.X)) ? 1 : (-1);
-			double num5 = StrikeNPCNoInteraction(num2, num3, num4);
+			bool crit = false;
+			NPCLoader.ModifyHitNPC(thatNPC, this, ref num2, ref num3, ref crit);
+			double num5 = StrikeNPCNoInteraction(num2, num3, num4, crit, false, false);
 			if (Main.netMode != 0)
 				NetMessage.SendData(28, -1, -1, null, whoAmI, num2, num3, num4);
 
 			netUpdate = true;
 			immune[255] = num;
+			NPCLoader.OnHitNPC(thatNPC, this, (int)num5, num3, crit);
 			if (dryadWard) {
 				num2 = (int)num5 / 3;
 				num3 = 6;
@@ -74141,6 +_,10 @@
 		}
 
 		private bool Collision_DecideFallThroughPlatforms() {
+			bool? modResult = NPCLoader.CanFallThroughPlatforms(this);
+			if (modResult.HasValue)
+				return modResult.Value;
+
 			bool result = false;
 			if (type == 2 || type == -43 || type == 190 || type == 191 || type == 192 || type == 193 || type == 194 || type == 317 || type == 318 || type == 133)
 				result = true;
@@ -74507,6 +_,10 @@
 			if (IsABestiaryIconDummy)
 				newColor = Color.White;
 
+			Color? modColor = NPCLoader.GetAlpha(this, newColor);
+			if (modColor.HasValue)
+				return modColor.Value;
+
 			float num = (float)(255 - alpha) / 255f;
 			int num2 = (int)((float)(int)newColor.R * num);
 			int num3 = (int)((float)(int)newColor.G * num);
@@ -75166,7 +_,7 @@
 							break;
 					}
 				}
-				else if (Main.player[Main.myPlayer].statLifeMax < 300 || Main.player[Main.myPlayer].statDefense < 10) {
+				else if (Main.player[Main.myPlayer].ConsumedLifeCrystals < 10 || Main.player[Main.myPlayer].statDefense < 10) {
 					switch (Main.rand.Next(4)) {
 						case 0:
 							result = Lang.dialog(85);
@@ -76047,6 +_,7 @@
 				result = ((!HasSpecialEventText("Slime", out specialEventText)) ? Lang.SlimeChat(this) : specialEventText);
 			}
 
+			NPCLoader.GetChat(this, ref result);
 			return result;
 		}
 
