--- src/TerrariaNetCore/Terraria/NPC.cs
+++ src/tModLoader/Terraria/NPC.cs
@@ -23,10 +_,11 @@
 using Terraria.Localization;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
 
 namespace Terraria
 {
-	public class NPC : Entity
+	public partial class NPC : Entity
 	{
 		private const int NPC_TARGETS_START = 300;
 		public bool IsABestiaryIconDummy;
@@ -64,7 +_,12 @@
 		public int altTexture;
 		public int townNpcVariationIndex;
 		public Vector2 netOffset = Vector2.Zero;
-		public short catchItem;
+		/// <summary>
+		/// The numerical ID of the item that this NPC becomes when caught.<br></br>
+		/// Mainly used for critters that can be caught with bug nets, such as butterflies and worms.<br></br>
+		/// Bug nets and other catching tools will only work on NPCs with this field set to something greater than 0.
+		/// </summary>
+		public int catchItem; // tML: changed to int for convenience and consistency purposes
 		public short releaseOwner = 255;
 		public int rarity;
 		public static bool taxCollector = false;
@@ -98,6 +_,10 @@
 		public static int deerclopsBoss = -1;
 		public int netSkip;
 		public bool netAlways;
+		/// <summary>
+		/// Stores the index of a single NPC. This NPC will then share a health pool with that NPC.<br/>
+		/// Used for the Destroyer's various segments and the Wall of Flesh's eyes and mouth.<br/>
+		/// </summary>
 		public int realLife = -1;
 		private string _givenName = "";
 		public static int sWidth = 1920;
@@ -112,7 +_,7 @@
 		private static int townRangeY = sHeight;
 		public float npcSlots = 1f;
 		private static bool noSpawnCycle = false;
-		private static int activeTime = 750;
+		public static int activeTime = 750;
 		private static int defaultSpawnRate = 600;
 		private static int defaultMaxSpawns = 5;
 		public float shimmerTransparency;
@@ -120,7 +_,7 @@
 		public const int maxBuffs = 20;
 		public int[] buffType = new int[20];
 		public int[] buffTime = new int[20];
-		public bool[] buffImmune = new bool[355];
+		public bool[] buffImmune = new bool[BuffLoader.BuffCount];
 		public bool canDisplayBuffs = true;
 		public bool midas;
 		public bool ichor;
@@ -181,35 +_,121 @@
 		public static bool unlockedArmsDealerSpawn = false;
 		public static bool unlockedNurseSpawn = false;
 		public static bool unlockedPrincessSpawn = false;
+		/// <summary>
+		/// Denotes whether or not Advanced Combat Techniques has been used in the current world.
+		/// </summary>
 		public static bool combatBookWasUsed = false;
 		public static bool combatBookVolumeTwoWasUsed = false;
 		public static bool peddlersSatchelWasUsed = false;
+		/// <summary>
+		/// Denotes whether or not the Eye of Cthulhu has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Eater of Worlds OR the Brain of Cthulhu have been defeated at least once in the current world.<br/>
+		/// This does NOT track the two of them separately; you will need to establish your own fields in a <see cref="ModSystem"/> for that.<br/>
+		/// </summary>
 		public static bool downedBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss3 = false;
+		/// <summary>
+		/// Denotes whether or not at least one Queen Bee has been defeated in the current world.
+		/// </summary>
 		public static bool downedQueenBee = false;
+		/// <summary>
+		/// Denotes whether or not King Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedSlimeKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Goblin Army has been defeated in the current world.
+		/// </summary>
 		public static bool downedGoblins = false;
+		/// <summary>
+		/// Denotes whether or not the Frost Legion has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFrost = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pirate Invasion has been defeated in the current world.
+		/// </summary>
 		public static bool downedPirates = false;
+		/// <summary>
+		/// Denotes whether or not at least one Clown has been killed in the current world.<br/>
+		/// Only used to make the Clothier sell the Clown set once at least one has been killed.
+		/// </summary>
 		public static bool downedClown = false;
+		/// <summary>
+		/// Denotes whether or not Plantera has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedPlantBoss = false;
+		/// <summary>
+		/// Denotes whether or not Golem has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedGolemBoss = false;
+		/// <summary>
+		/// Denotes whether or not at least one Martian Madness event has been cleared in the current world.
+		/// </summary>
 		public static bool downedMartians = false;
+		/// <summary>
+		/// Denotes whether or not Duke Fishron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFishron = false;
+		/// <summary>
+		/// Denotes whether or not at least one Mourning Wood has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pumpking has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Ice Queen has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasIceQueen = false;
+		/// <summary>
+		/// Denotes whether or not at least one Everscream has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Santa-NK1 has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasSantank = false;
+		/// <summary>
+		/// Denotes whether or not the Lunatic Cultist has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedAncientCultist = false;
+		/// <summary>
+		/// Denotes whether or not the Moon Lord has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMoonlord = false;
+		/// <summary>
+		/// Denotes whether or not the Solar Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerSolar = false;
+		/// <summary>
+		/// Denotes whether or not the Vortex Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerVortex = false;
+		/// <summary>
+		/// Denotes whether or not the Nebula Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerNebula = false;
+		/// <summary>
+		/// Denotes whether or not the Stardust Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerStardust = false;
+		/// <summary>
+		/// Denotes whether or not the Empress of Light has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedEmpressOfLight = false;
+		/// <summary>
+		/// Denotes whether or not Queen Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedQueenSlime = false;
+		/// <summary>
+		/// Denotes whether or not the Deerclops has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedDeerclops = false;
 		public static int ShieldStrengthTowerSolar = 0;
 		public static int ShieldStrengthTowerVortex = 0;
@@ -222,9 +_,21 @@
 		public static bool TowerActiveNebula = false;
 		public static bool TowerActiveStardust = false;
 		public static bool LunarApocalypseIsUp = false;
+		/// <summary>
+		/// Denotes whether or not ANY Mechanical Boss has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBossAny = false;
+		/// <summary>
+		/// Denotes whether or not the Destroyer has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Twins have been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron Prime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss3 = false;
 		public static bool[] npcsFoundForCheckActive = new bool[688];
 		public static int[] lazyNPCOwnedProjectileSearchArray = new int[200];
@@ -242,14 +_,22 @@
 		public bool justHit;
 		public int timeLeft;
 		public int target = -1;
+		/// <summary>
+		/// The amount of contact damage this NPC deals.<br/>
+		/// Changing this WILL NOT change the amount of damage done by projectiles.<br/>
+		/// </summary>
 		public int damage;
 		public int defense;
 		public int defDamage;
 		public int defDefense;
+		/// <summary>
+		/// Denotes whether or not this NPC counts as dealing cold damage for the purposes of the Warmth Potion.<br/>
+		/// Defaults to false.
+		/// </summary>
 		public bool coldDamage;
 		public bool trapImmune;
-		public LegacySoundStyle HitSound;
-		public LegacySoundStyle DeathSound;
+		public SoundStyle? HitSound;
+		public SoundStyle? DeathSound;
 		public int life;
 		public int lifeMax;
 		public Rectangle targetRect;
@@ -461,8 +_,20 @@
 			}
 		}
 
-		public string TypeName => Lang.GetNPCNameValue(netID);
+		/// <summary>
+		/// The TYPE name of this NPC.<br/>
+		/// Type names are the base titles given to any NPC, and are typically shared amongst all instances of an NPC. For example, the Stylist's type name will always be "Stylist".<br/>
+		/// To modify the type name of a specific NPC, make use of the ModifyTypeName hooks in <see cref="GlobalNPC"/> and <see cref="ModLoader.ModNPC"/>, according to your needs.<br/>
+		/// </summary>
+		public string TypeName => NPCLoader.GetTypeName(this, Lang.GetNPCNameValue(netID));
 
+		/// <summary>
+		/// The FULL name of this NPC.<br/>
+		/// If the NPC doesn't have a given name, this will just return the type name. A Stylist without a given name will always return "Stylist" here.<br/>
+		/// If the NPC does have a given name, this will return the NPC's full name; given name first, then type name.<br/>
+		/// Full name with a given name is given in the format of "X the Y", where X is their given name and Y is their type name.<br/>
+		/// For example, a Stylist might return "Scarlett the Stylist" here; with Scarlett being her given name, and Stylist being her type name.<br/>
+		/// </summary>
 		public string FullName {
 			get {
 				if (!HasGivenName)
@@ -472,8 +_,14 @@
 			}
 		}
 
+		/// <summary>
+		/// Whether or not this NPC has a given name.<br/>
+		/// </summary>
 		public bool HasGivenName => _givenName.Length != 0;
 
+		/// <summary>
+		/// If this NPC has a given name, returns their given name; otherwise, returns their type name.<br/>
+		/// </summary>
 		public string GivenOrTypeName {
 			get {
 				if (!HasGivenName)
@@ -483,6 +_,11 @@
 			}
 		}
 
+		/// <summary>
+		/// The GIVEN name of this NPC. Can be set directly.<br/>
+		/// Given names are unique to each NPC, though two NPCs can have the same given name.<br/>
+		/// Some vanilla examples of given names are Andrew (for the Guide), Yorai (for the Princess), Whitney (for the Steampunker), or Scarlett (for the Stylist).<br/>
+		/// </summary>
 		public string GivenName {
 			get {
 				return _givenName;
@@ -531,7 +_,7 @@
 
 		public bool isLikeATownNPC {
 			get {
-				if (type == 453)
+				if (NPCID.Sets.ActsLikeTownNPC[type])
 					return true;
 
 				return townNPC;
@@ -900,7 +_,7 @@
 		public static void UpdateFoundActiveNPCs() {
 			for (int i = 0; i < 200; i++) {
 				NPC nPC = Main.npc[i];
-				if (nPC.active && nPC.type >= 0 && nPC.type < 688)
+				if (nPC.active && nPC.type >= 0)
 					npcsFoundForCheckActive[nPC.type] = true;
 			}
 
@@ -1013,8 +_,116 @@
 			return false;
 		}
 
-		public static string getNewNPCName(int npcType) => getNewNPCNameInner(npcType);
-
+		public string getNewNPCName() {
+			string NPCNameCategoryKey = null;
+			switch (type) {
+				// TODO: this looks horrible, and I know it does
+				// ideally, there'd exist a better way to do this,
+				// but as of now, I'm not sure what it would be
+				// -thomas
+				case 17:
+					NPCNameCategoryKey = "MerchantNames";
+					break;
+				case 18:
+					NPCNameCategoryKey = "NurseNames";
+					break;
+				case 19:
+					NPCNameCategoryKey = "ArmsDealerNames";
+					break;
+				case 20:
+					NPCNameCategoryKey = "DryadNames";
+					break;
+				case 22:
+					NPCNameCategoryKey = "GuideNames";
+					break;
+				case 38:
+					NPCNameCategoryKey = "DemolitionistNames";
+					break;
+				case 54:
+					NPCNameCategoryKey = "ClothierNames";
+					break;
+				case 107:
+					NPCNameCategoryKey = "GoblinTinkererNames";
+					break;
+				case 108:
+					NPCNameCategoryKey = "WizardNames";
+					break;
+				case 124:
+					NPCNameCategoryKey = "MechanicNames";
+					break;
+				case 160:
+					NPCNameCategoryKey = "TruffleNames";
+					break;
+				case 178:
+					NPCNameCategoryKey = "SteampunkerNames";
+					break;
+				case 207:
+					NPCNameCategoryKey = "DyeTraderNames";
+					break;
+				case 208:
+					NPCNameCategoryKey = "PartyGirlNames";
+					break;
+				case 209:
+					NPCNameCategoryKey = "CyborgNames";
+					break;
+				case 227:
+					NPCNameCategoryKey = "PainterNames";
+					break;
+				case 228:
+					NPCNameCategoryKey = "WitchDoctorNames";
+					break;
+				case 229:
+					NPCNameCategoryKey = "PirateNames";
+					break;
+				case 353:
+					NPCNameCategoryKey = "StylistNames";
+					break;
+				case 368:
+					NPCNameCategoryKey = "TravelingMerchantNames";
+					break;
+				case 369:
+					NPCNameCategoryKey = "AnglerNames";
+					break;
+				case 453:
+					NPCNameCategoryKey = "SkeletonMerchantNames";
+					break;
+				case 441:
+					NPCNameCategoryKey = "TaxCollectorNames";
+					break;
+				case 550:
+					NPCNameCategoryKey = "BartenderNames";
+					break;
+				case 588:
+					NPCNameCategoryKey = "GolferNames";
+					break;
+				case 633:
+					NPCNameCategoryKey = "BestiaryGirlNames";
+					break;
+				case 663:
+					NPCNameCategoryKey = "PrincessNames";
+					break;
+				case 637:
+					NPCNameCategoryKey = "CatNames_Siamese";
+					break;
+				case 638:
+					NPCNameCategoryKey = "DogNames_Labrador";
+					break;
+				case 656:
+					NPCNameCategoryKey = "BunnyNames_White";
+					break;
+			}
+
+			List<string> NPCNameList = new List<string>();
+			if (NPCNameCategoryKey != null)
+				NPCNameList = LanguageManager.Instance.GetLocalizedEntriesInCategory(NPCNameCategoryKey);
+			NPCNameList = NPCLoader.ModifyNPCNameList(this, NPCNameList);
+			if (NPCNameList != null && NPCNameList.Count > 0)
+				return NPCNameList[WorldGen.genRand.Next(NPCNameList.Count)];
+			else
+				return "";
+		}
+
+		/*
 		private static string getNewNPCNameInner(int npcType) {
 			switch (npcType) {
 				case 17:
@@ -1097,6 +_,7 @@
 					return "";
 			}
 		}
+		*/
 
 		public NetworkText GetTypeNetName() => NetworkText.FromKey(Lang.GetNPCName(netID).Key);
 
@@ -1137,7 +_,7 @@
 					continue;
 
 				if (flag) {
-					Main.npc[i].GivenName = getNewNPCName(npcType);
+					Main.npc[i].GivenName = Main.npc[i].getNewNPCName();
 					Main.npc[i].needsUniqueInfoUpdate = true;
 					continue;
 				}
@@ -1150,6 +_,7 @@
 			}
 		}
 
+		/*
 		public static string firstNPCName(int npcType) {
 			for (int i = 0; i < 200; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == npcType)
@@ -1158,6 +_,7 @@
 
 			return getNewNPCName(npcType);
 		}
+		*/
 
 		public static string GetFirstNPCNameOrNull(int npcType) {
 			for (int i = 0; i < 200; i++) {
@@ -1312,7 +_,7 @@
 				case 684:
 					return 53;
 				default:
-					return -1;
+					return NPCHeadLoader.GetNPCHeadSlot(type);
 			}
 		}
 
@@ -1349,6 +_,8 @@
 					break;
 			}
 
+			NPCLoader.BossHeadSlot(this, ref result);
+
 			return result;
 		}
 
@@ -1370,6 +_,7 @@
 					break;
 			}
 
+			NPCLoader.BossHeadRotation(this, ref result);
 			return result;
 		}
 
@@ -1379,6 +_,7 @@
 			if (num == 491 && spriteDirection == 1)
 				result = SpriteEffects.FlipHorizontally;
 
+			NPCLoader.BossHeadSpriteEffects(this, ref result);
 			return result;
 		}
 
@@ -2067,9 +_,21 @@
 			defDamage = damage;
 			defDefense = defense;
 			if (flag) {
-				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData, spawnparams.strengthMultiplierOverride);
+				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData ?? Main.GameModeInfo, spawnparams.strengthMultiplierOverride);
 				life = lifeMax;
 			}
+		}
+
+		public void CloneDefaults(int Type) {
+			int originalType = type;
+			int originalNetID = netID;
+			var originalModNPC = ModNPC;
+			var originalGlobals = globalNPCs;
+			SetDefaultsKeepPlayerInteraction(Type);
+			type = originalType;
+			netID = originalNetID;
+			ModNPC = originalModNPC;
+			globalNPCs = originalGlobals;
 		}
 
 		public void SetDefaultsKeepPlayerInteraction(int Type) {
@@ -2113,6 +_,9 @@
 				return;
 			}
 
+			ModNPC = null;
+			ShowNameOnHover = true;
+			globalNPCs = new Instanced<GlobalNPC>[0];
 			waterMovementSpeed = (lavaMovementSpeed = 0.5f);
 			honeyMovementSpeed = 0.25f;
 			netOffset *= 0f;
@@ -2163,10 +_,14 @@
 				buffType[k] = 0;
 			}
 
+			if (buffImmune.Length != BuffLoader.BuffCount)
+				Array.Resize(ref buffImmune, BuffLoader.BuffCount);
+
-			for (int l = 0; l < 355; l++) {
+			for (int l = 0; l < buffImmune.Length; l++) {
 				buffImmune[l] = false;
 			}
 
+			aiStyle = type < NPCID.Count ? 0 : -1; //Added by tML - use aiStyle -1 for modded NPCs by default so they don't always face the nearest player, and trigger net updates
 			setFrameSize = false;
 			netSkip = -2;
 			realLife = -1;
@@ -10749,13 +_,18 @@
 				catchItem = 2121;
 			}
 
+			NPCLoader.SetDefaults(this);
+
 			if (Main.dedServ)
 				frame = default(Rectangle);
+			// Extra patch context.
 			else if (TextureAssets.Npc[type] != null && TextureAssets.Npc[type].IsLoaded)
 				frame = new Rectangle(0, 0, TextureAssets.Npc[type].Width(), TextureAssets.Npc[type].Height() / Main.npcFrameCount[type]);
 			else
 				setFrameSize = true;
 
+			// Extra patch context.
+
 			if (spawnparams.sizeScaleOverride.HasValue) {
 				int num3 = (int)((float)width * scale);
 				int num4 = (int)((float)height * scale);
@@ -11439,6 +_,7 @@
 				}
 			}
 
+			NPCLoader.ScaleExpertStats(this, numPlayers, balance);
 			defDefense = defense;
 			defDamage = damage;
 			life = lifeMax;
@@ -12258,6 +_,18 @@
 		}
 
 		public void AI() {
+			NPCLoader.NPCAI(this);
+		}
+
+		public void VanillaAI() {
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaAI_Inner();
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaAI_Inner() {
 			if (aiStyle == 0) {
 				if (Main.netMode != 1) {
 					for (int i = 0; i < 255; i++) {
@@ -31573,7 +_,8 @@
 				timeLeft = 86400;
 			}
 
+			//TODO: Replace this downcast.
-			timeLeft -= Main.dayRate;
+			timeLeft -= (int)Main.dayRate;
 			if (timeLeft < 0)
 				timeLeft = 0;
 
@@ -39022,13 +_,14 @@
 
 			int num2 = 7;
 			int num3 = 6;
-			int num4 = 2;
+			int num4 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			int num5 = 1;
-			int num6 = 2;
+			int num6 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			for (int i = point.X - num2; i <= point.X + num2; i += num5) {
 				for (int num7 = point.Y + num4; num7 >= point.Y - num3; num7 -= num6) {
 					Tile tile = Main.tile[i, num7];
-					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					//if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]) { // TML: #ModdedChairsForNPCs: Removed vanilla specific conditions
 						int num8 = Math.Abs(i - point.X) + Math.Abs(num7 - point.Y);
 						if (num == -1 || num8 < num) {
 							num = num8;
@@ -39049,6 +_,12 @@
 
 				b.Y += 2;
 			}
+			else if (tile2.type >= TileID.Count) { // Check necessary as in this case vanilla changes (to vanilla tiles that aren't sittable by default) by the hook should not take effect
+				TileRestingInfo info = new TileRestingInfo(this, b, Vector2.Zero, base.direction);
+				TileLoader.ModifySittingTargetInfo(b.X, b.Y, tile2.type, ref info);
+				b = info.AnchorTilePosition;
+				b.Y += 1; // Set to tile *below* chair
+			}
 
 			for (int j = 0; j < 200; j++) {
 				if (Main.npc[j].active && Main.npc[j].aiStyle == 7 && Main.npc[j].townNPC && Main.npc[j].ai[0] == 5f && (Main.npc[j].Bottom + Vector2.UnitY * -2f).ToTileCoordinates() == b)
@@ -39061,9 +_,11 @@
 
 		private void AI_007_TryForcingSitting(int homeFloorX, int homeFloorY) {
 			Tile tile = Main.tile[homeFloorX, homeFloorY - 1];
-			bool flag = type != 638 && type != 656 && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
+			//bool flag = type != 638 && type != 656 && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
+			bool flag = !NPCID.Sets.CannotSitOnFurniture[type] && !NPCID.Sets.IsTownSlime[type] && ai[0] != 5f;
 			if (flag)
-				flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				//flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				flag &= (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]); // TML: #ModdedChairsForNPCs
 
 			if (flag)
 				flag &= (tile.type != 15 || tile.frameY < 1080 || tile.frameY > 1098);
@@ -39081,8 +_,10 @@
 			if (flag) {
 				ai[0] = 5f;
 				ai[1] = 900 + Main.rand.Next(10800);
-				direction = ((tile.frameX != 0) ? 1 : (-1));
-				base.Bottom = new Vector2(homeFloorX * 16 + 8 + 2 * direction, homeFloorY * 16);
+				// TML: #ModdedChairsForNPCs
+				SitDown(new Point(homeFloorX, homeFloorY - 1), out int targetDirection, out var bottom);
+				direction = targetDirection;
+				base.Bottom = bottom;
 				velocity = Vector2.Zero;
 				localAI[3] = 0f;
 				netUpdate = true;
@@ -39123,6 +_,7 @@
 			if (type == 638 || type == 656 || NPCID.Sets.IsTownSlime[type])
 				num = 0;
 
+			//patch file: flag
 			bool flag = Main.raining;
 			if (!Main.dayTime)
 				flag = true;
@@ -39216,6 +_,8 @@
 					num2 += 0.15f;
 					defense += 8;
 				}
+
+				NPCLoader.BuffTownNPC(ref num2, ref defense);
 			}
 
 			if (type == 142 && Main.netMode != 1 && !Main.xMas) {
@@ -39357,7 +_,7 @@
 				return;
 			}
 
-			if (type >= 0 && type < 688 && NPCID.Sets.TownCritter[type] && target == 255) {
+			if (type >= 0 && NPCID.Sets.TownCritter[type] && target == 255) {
 				TargetClosest();
 				if (position.X < Main.player[target].position.X) {
 					base.direction = 1;
@@ -39452,7 +_,7 @@
 					base.direction = -1;
 			}
 
-			if (!WorldGen.InWorld(num5, num6) || Main.tile[num5, num6] == null)
+			if (!WorldGen.InWorld(num5, num6) || Main.netMode == 1 && !Main.sectionManager.TileLoaded(num5, num6))
 				return;
 
 			if (!homeless && Main.netMode != 1 && townNPC && (flag || (type == 37 && Main.tileDungeon[Main.tile[num5, num6].type])) && !AI_007_TownEntities_IsInAGoodRestingSpot(num5, num6, floorX, floorY)) {
@@ -39499,7 +_,14 @@
 			int num12 = -1;
 			if (!flag6 && Main.netMode != 1 && !flag3) {
 				for (int m = 0; m < 200; m++) {
+					if (!Main.npc[m].active) continue;
+					bool? modCanHit = NPCLoader.CanHitNPC(Main.npc[m], this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						continue;
+
+					bool canHitVal = modCanHit.HasValue && modCanHit.Value;
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
-					if (!Main.npc[m].active || Main.npc[m].friendly || Main.npc[m].damage <= 0 || !(Main.npc[m].Distance(base.Center) < num7) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[m].type]) || (!Main.npc[m].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[m].Center, 0, 0)))
+					if (!Main.npc[m].active || Main.npc[m].friendly || Main.npc[m].damage <= 0 || !(Main.npc[m].Distance(base.Center) < num7) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[m].type] && canHitVal) || (!Main.npc[m].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[m].Center, 0, 0)))
 						continue;
 
 					bool flag15 = Main.npc[m].CanBeChasedBy(this);
@@ -39753,7 +_,7 @@
 
 					if (closeDoor && ((position.X + (float)(width / 2)) / 16f > (float)(doorX + 2) || (position.X + (float)(width / 2)) / 16f < (float)(doorX - 2))) {
 						Tile tileSafely = Framing.GetTileSafely(doorX, doorY);
-						if (tileSafely.type == 11) {
+						if (TileLoader.CloseDoorID(tileSafely) >= 0) {
 							if (WorldGen.CloseDoor(doorX, doorY)) {
 								closeDoor = false;
 								NetMessage.SendData(19, -1, -1, null, 1, doorX, doorY, base.direction);
@@ -39922,7 +_,7 @@
 						Tile tileSafely4 = Framing.GetTileSafely(num19, num20 - 1);
 						Tile tileSafely5 = Framing.GetTileSafely(num19, num20 - 2);
 						bool flag21 = height / 16 < 3;
-						if (townNPC && tileSafely5.nactive() && (tileSafely5.type == 10 || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
+						if ((townNPC || NPCID.Sets.AllowDoorInteraction[type]) && tileSafely5.nactive() && (TileLoader.IsClosedDoor(tileSafely5) || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
 							if (Main.netMode != 1) {
 								if (WorldGen.OpenDoor(num19, num20 - 2, base.direction)) {
 									closeDoor = true;
@@ -40101,7 +_,8 @@
 				if (ai[0] == 5f) {
 					Point coords = (base.Bottom + Vector2.UnitY * -2f).ToTileCoordinates();
 					Tile tile = Main.tile[coords.X, coords.Y];
-					if (tile.type != 15 && tile.type != 497)
+					//if (tile.type != 15 && tile.type != 497)
+					if (!TileID.Sets.CanBeSatOnForNPCs[tile.type]) // TML: #ModdedChairsForNPCs 
 						ai[1] = 0f;
 					else
 						Main.sittingManager.AddNPC(whoAmI, coords);
@@ -40273,13 +_,19 @@
 					num35 = 589;
 					num37 = 7f;
 					num36 = 22;
+					//Patch context: num35 - proj type, num36 - damage, num37 - speed multiplier, num38 - attack delay, num39 - attack cooldown.
 					num38 = 1;
 					num39 = 10;
 					maxValue = 1;
 					knockBack = 2f;
+					//Patch context: num40 - gravity correction.
 					num40 = 10f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num36, ref knockBack);
+				NPCLoader.TownNPCAttackCooldown(this, ref num39, ref maxValue);
+				NPCLoader.TownNPCAttackProj(this, ref num35, ref num38);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num37, ref num40, ref num42);
 				if (Main.expertMode)
 					num36 = (int)((float)num36 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40299,6 +_,7 @@
 						vec = new Vector2(spriteDirection, -1f);
 
 					vec *= num37;
+					// Context for the patch above: num42 - random speed offset.
 					vec += Utils.RandomVector2(Main.rand, 0f - num42, num42);
 					int num43 = 1000;
 					num43 = ((type == 124) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer, 0f, whoAmI, townNpcVariationIndex) : ((type != 142) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer) : Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num35, num36, knockBack, Main.myPlayer, 0f, Main.rand.Next(5))));
@@ -40324,7 +_,7 @@
 				int num48 = 0;
 				int maxValue2 = 0;
 				float knockBack2 = 0f;
-				int num49 = 0;
+				float num49 = 0;
 				bool flag24 = false;
 				float num50 = 0f;
 				if ((float)NPCID.Sets.AttackTime[type] == ai[1]) {
@@ -40489,6 +_,7 @@
 
 					if (localAI[3] > (float)num47) {
 						num47 = 48;
+						//Patch context: flag24 means 'in between shots'.
 						flag24 = true;
 					}
 
@@ -40502,12 +_,14 @@
 				}
 				else if (type == 209) {
 					num44 = Utils.SelectRandom<int>(Main.rand, 134, 133, 135);
+					//Patch context: num44 - proj type, num45 - damage, num46 - speed multiplier, num47 - attack delay, num48 - attack cooldown.
 					num47 = 1;
 					switch (num44) {
 						case 135:
 							num46 = 12f;
 							num45 = 30;
 							num48 = 30;
+							//Patch context: num50 - randomOffset
 							maxValue2 = 10;
 							knockBack2 = 7f;
 							num50 = 0.2f;
@@ -40531,6 +_,12 @@
 					}
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num45, ref knockBack2);
+				NPCLoader.TownNPCAttackCooldown(this, ref num48, ref maxValue2);
+				NPCLoader.TownNPCAttackProj(this, ref num44, ref num47);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num46, ref num49, ref num50);
+				NPCLoader.TownNPCAttackShoot(this, ref flag24);
+
 				if (Main.expertMode)
 					num45 = (int)((float)num45 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40651,6 +_,7 @@
 				else if (type == 663) {
 					num54 = 950;
 					num55 = ((!Main.hardMode) ? 15 : 20);
+					//Patch context: num54 - proj type, num55 - damage, num57 - attack delay, num58 - attack cooldown.
 					num57 = 15;
 					num58 = 0;
 					maxValue3 = 0;
@@ -40666,6 +_,11 @@
 					knockBack3 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num55, ref knockBack3);
+				NPCLoader.TownNPCAttackCooldown(this, ref num58, ref maxValue3);
+				NPCLoader.TownNPCAttackProj(this, ref num54, ref num57);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num56, ref num59, ref num62);
+				NPCLoader.TownNPCAttackMagic(this, ref num61);
 				if (Main.expertMode)
 					num55 = (int)((float)num55 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -40676,12 +_,14 @@
 				if (localAI[3] == (float)num57 && Main.netMode != 1) {
 					Vector2 vec4 = Vector2.Zero;
 					if (num63 != -1)
+						//Patch context: num59 is gravity correction.
 						vec4 = DirectionTo(Main.npc[num63].Center + new Vector2(0f, (0f - num59) * MathHelper.Clamp(Distance(Main.npc[num63].Center) / num60, 0f, 1f)));
 
 					if (vec4.HasNaNs() || Math.Sign(vec4.X) != spriteDirection)
 						vec4 = new Vector2(spriteDirection, 0f);
 
 					vec4 *= num56;
+					// Context for the patch above: num92 - random speed offset.
 					vec4 += Utils.RandomVector2(Main.rand, 0f - num62, num62);
 					if (type == 108) {
 						int num64 = Utils.SelectRandom<int>(Main.rand, 1, 1, 1, 1, 2, 2, 3);
@@ -40732,6 +_,7 @@
 					}
 				}
 
+				//Patch context: num61 is aura light multiplier
 				if (num61 > 0f) {
 					Vector3 vector6 = GetMagicAuraColor().ToVector3() * num61;
 					Lighting.AddLight(base.Center, vector6.X, vector6.Y, vector6.Z);
@@ -40795,11 +_,15 @@
 				else if (NPCID.Sets.IsTownPet[type]) {
 					num74 = 10;
 					num76 = (num77 = 32);
+					//Patch context: num73 - attack cooldown,  num74 - damage, num75 - knockback, num76 & num77 - width and height, maxValue4 - random extra cooldown
 					num73 = 15;
 					maxValue4 = 8;
 					num75 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num74, ref num75);
+				NPCLoader.TownNPCAttackCooldown(this, ref num73, ref maxValue4);
+				NPCLoader.TownNPCAttackSwing(this, ref num76, ref num77);
 				if (Main.expertMode)
 					num74 = (int)((float)num74 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -41082,15 +_,18 @@
 
 					if (flag30) {
 						Tile tile2 = Main.tile[b.X, b.Y];
-						flag30 = (tile2.type == 15 || tile2.type == 497);
+						//flag30 = (tile2.type == 15 || tile2.type == 497);
+						flag30 = TileID.Sets.CanBeSatOnForNPCs[tile2.type]; // TML: #ModdedChairsForNPCs
 						if (flag30 && tile2.type == 15 && tile2.frameY >= 1080 && tile2.frameY <= 1098)
 							flag30 = false;
 
 						if (flag30) {
 							ai[0] = 5f;
 							ai[1] = 900 + Main.rand.Next(10800);
-							base.direction = ((tile2.frameX != 0) ? 1 : (-1));
-							base.Bottom = new Vector2(b.X * 16 + 8 + 2 * base.direction, b.Y * 16 + 16);
+							// TML: #ModdedChairsForNPCs
+							SitDown(b, out int targetDirection, out var bottom);
+							base.direction = targetDirection;
+							base.Bottom = bottom;
 							velocity = Vector2.Zero;
 							localAI[3] = 0f;
 							netUpdate = true;
@@ -44683,7 +_,7 @@
 					Main.tile[num191 - direction, num192 + 1] = new Tile();
 
 				Main.tile[num191, num192 + 1].halfBrick();
-				if (Main.tile[num191, num192 - 1].nactive() && (Main.tile[num191, num192 - 1].type == 10 || Main.tile[num191, num192 - 1].type == 388) && flag8) {
+				if (Main.tile[num191, num192 - 1].nactive() && (TileLoader.IsClosedDoor(Main.tile[num191, num192 - 1]) || Main.tile[num191, num192 - 1].type == 388) && flag8) {
 					ai[2] += 1f;
 					ai[3] = 0f;
 					if (ai[2] >= 60f) {
@@ -44722,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num191, num192 - 1);
 							}
 							else {
-								if (Main.tile[num191, num192 - 1].type == 10) {
+								if (TileLoader.IsClosedDoor(Main.tile[num191, num192 - 1])) {
 									bool flag26 = WorldGen.OpenDoor(num191, num192 - 1, direction);
 									if (!flag26) {
 										ai[3] = num53;
@@ -45898,7 +_,7 @@
 								Tile tileSafely = Framing.GetTileSafely(i, j);
 								bool flag2 = tileSafely.active() && Main.tileSolid[tileSafely.type] && !Main.tileFrameImportant[tileSafely.type];
 								if (flag && flag2) {
-									int num38 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely);
+									int num38 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, i, j);
 									for (int k = 0; k < num38; k++) {
 										Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 										obj.velocity.Y -= 3f + (float)num37 * 1.5f;
@@ -46501,7 +_,7 @@
 			bool flag21 = false;
 			bool flag22 = false;
 			bool flag23 = false;
-			LegacySoundStyle style = null;
+			SoundStyle? style = null;
 			int num20 = 0;
 			bool flag24 = false;
 			float num21 = 1f;
@@ -47353,8 +_,13 @@
 
 			if (!flag20) {
 				if (ai[3] < (float)num19 && flag21) {
+					/*
 					if (num20 > 0 && Main.rand.Next(num20) == 0)
 						SoundEngine.PlayTrackedSound(style, base.Center);
+					*/
+
+					if (num20 > 0 && Main.rand.Next(num20) == 0 && style.HasValue)
+						SoundEngine.PlayTrackedSound(style.Value, base.Center);
 
 					bool hasValidTarget = HasValidTarget;
 					nPCTargetingMethod(this, faceTarget: true, null);
@@ -47532,7 +_,7 @@
 				Tile tileSafely4 = Framing.GetTileSafely(num64, num65 - 1);
 				Tile tileSafely5 = Framing.GetTileSafely(num64, num65 - 2);
 				Tile tileSafely6 = Framing.GetTileSafely(num64, num65 - 3);
-				if (flag8 && tileSafely4.nactive() && (tileSafely4.type == 10 || tileSafely4.type == 388)) {
+				if (flag8 && tileSafely4.nactive() && (TileLoader.IsClosedDoor(tileSafely4) || tileSafely4.type == 388)) {
 					ai[0] += 1f;
 					ai[3] = 0f;
 					if (ai[0] >= 60f) {
@@ -47562,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num64, num65 - 1);
 							}
 							else {
-								if (tileSafely4.type == 10) {
+								if (TileLoader.IsClosedDoor(tileSafely4)) {
 									bool flag38 = WorldGen.OpenDoor(num64, num65 - 1, direction);
 									if (!flag38) {
 										ai[3] = num19;
@@ -49576,6 +_,10 @@
 			if (type == 20 && townNpcVariationIndex == 1)
 				return false;
 
+			if (!NPCLoader.UsesPartyHat(this)) {
+				return false;
+			}
+
 			if (ForcePartyHatOn)
 				return true;
 
@@ -49627,6 +_,10 @@
 				num = TextureAssets.Npc[type].Height() / Main.npcFrameCount[type];
 			}
 
+			NPCLoader.FindFrame(this, num);
+		}
+
+		public void VanillaFindFrame(int num, bool isLikeATownNPC, int type) {
 			int num2 = 0;
 			if (aiAction == 0)
 				num2 = ((velocity.Y < 0f) ? 2 : ((velocity.Y > 0f) ? 3 : ((velocity.X != 0f) ? 1 : 0)));
@@ -57920,7 +_,10 @@
 					if (Main.tile[x, y].type == 467)
 						number2 = 5;
 
-					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number);
+					if (Main.tile[x, y].type >= TileID.Count)
+						number2 = 101;
+
+					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number, Main.tile[x, y].type, 0);
 					NetMessage.SendTileSquare(-1, x, y, 3);
 				}
 
@@ -58265,6 +_,9 @@
 			if (!active || DoesntDespawnToInactivity())
 				return;
 
+			if (!NPCLoader.CheckActive(this))
+				return;
+
 			if (townNPC) {
 				AddIntoPlayersTownNPCSlots();
 				return;
@@ -58338,7 +_,7 @@
 			if (timeLeft <= 0)
 				flag = false;
 
-			if (!flag && Main.netMode != 1) {
+			if (!flag && Main.netMode != 1 && !NPCLoader.SavesAndLoads(this)) {
 				noSpawnCycle = true;
 				active = false;
 				if (Main.netMode == 2) {
@@ -58467,6 +_,9 @@
 				}
 			}
 
+			if (!NPCLoader.CheckDead(this))
+				return;
+
 			noSpawnCycle = true;
 			if (townNPC && type != 37 && type != 453) {
 				if (Main.netMode != 2)
@@ -58519,6 +_,7 @@
 			if (legacySoundStyle != null)
 				SoundEngine.PlaySound(legacySoundStyle, base.position);
 
+			if (NPCLoader.SpecialOnKill(this)) { } else 
 			if (type == 13 || type == 14 || type == 15) {
 				DropEoWLoot();
 			}
@@ -59021,7 +_,7 @@
 		}
 
 		public static void ResetKillCount() {
-			for (int i = 0; i < 688; i++) {
+			for (int i = 0; i < killCount.Length; i++) {
 				killCount[i] = 0;
 			}
 		}
@@ -59084,7 +_,7 @@
 		}
 
 		public void NPCLoot() {
-			if (Main.netMode == 1 || type >= 688 || (Main.getGoodWorld && !downedBoss3 && (type == 31 || type == 294 || type == 296 || type == 295 || type == 32 || type == 34 || type == 71)))
+			if (Main.netMode == 1 || (Main.getGoodWorld && !downedBoss3 && (type == 31 || type == 294 || type == 296 || type == 295 || type == 32 || type == 34 || type == 71)))
 				return;
 
 			Player closestPlayer = Main.player[Player.FindClosest(position, width, height)];
@@ -59101,9 +_,13 @@
 			if ((type == 23 && Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.NoEarlymodeLootWhenSpawnedFromStatue[type] && !Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.StatueSpawnedDropRarity[type] != -1f && (Main.rand.NextFloat() >= NPCID.Sets.StatueSpawnedDropRarity[type] || !AnyInteractions())))
 				return;
 
+			if (!NPCLoader.PreKill(this))
+				return;
+
 			bool num = downedMechBoss1 && downedMechBoss2 && downedMechBoss3;
 			DoDeathEvents_BeforeLoot(closestPlayer);
 			NPCLoot_DropItems(closestPlayer);
+			NPCLoader.OnKill(this);
 			DoDeathEvents(closestPlayer);
 			if (!num && downedMechBoss1 && downedMechBoss2 && downedMechBoss3 && Main.hardMode) {
 				if (Main.netMode == 0)
@@ -59149,7 +_,7 @@
 			WoFKilledToday = false;
 		}
 
-		private void DoDeathEvents_DropBossPotionsAndHearts() {
+		private void DoDeathEvents_DropBossPotionsAndHearts(ref string typeName) {
 			int stack = Main.rand.Next(5, 16);
 			int num = 28;
 			if (type == 113)
@@ -59177,6 +_,7 @@
 			else if (type == 398)
 				num = 3544;
 
+			NPCLoader.BossLoot(this, ref typeName, ref num);
 			Item.NewItem(GetItemSource_Loot(), (int)position.X, (int)position.Y, width, height, num, stack);
 			int num2 = Main.rand.Next(5) + 5;
 			for (int i = 0; i < num2; i++) {
@@ -59194,7 +_,7 @@
 			}
 		}
 
-		private void DoDeathEvents_CelebrateBossDeath() {
+		private void DoDeathEvents_CelebrateBossDeath(string typeName) {
 			if (type == 125 || type == 126) {
 				if (Main.netMode == 0)
 					Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Plural", Language.GetTextValue("Enemies.TheTwins")), 175, 75);
@@ -59208,7 +_,7 @@
 					ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", NetworkText.FromKey("Enemies.MoonLord")), new Color(175, 75, 255));
 			}
 			else if (Main.netMode == 0) {
-				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", TypeName), 175, 75);
+				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", typeName), 175, 75);
 			}
 			else if (Main.netMode == 2) {
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", GetTypeNetName()), new Color(175, 75, 255));
@@ -59600,8 +_,10 @@
 			}
 
 			if (boss) {
+				string typeName = TypeName;
+
-				DoDeathEvents_DropBossPotionsAndHearts();
+				DoDeathEvents_DropBossPotionsAndHearts(ref typeName);
-				DoDeathEvents_CelebrateBossDeath();
+				DoDeathEvents_CelebrateBossDeath(typeName);
 				if (Main.netMode == 2)
 					NetMessage.SendData(7);
 			}
@@ -59851,7 +_,10 @@
 			}
 		}
 
+		// this is made internal because NPC.CheckCatchNPC now fulfills every use case
+		// that callin' this method manually could have for modders, and then some
+		// -thomas
-		public static void CatchNPC(int i, int who = -1) {
+		internal static void CatchNPC(int i, int who = -1) {
 			if (!Main.npc[i].active)
 				return;
 
@@ -59871,8 +_,14 @@
 					NetMessage.SendData(106, -1, -1, null, (int)position.X, position.Y);
 				}
 				else {
+					/*
 					new Item().SetDefaults(Main.npc[i].catchItem);
 					Item.NewItem(GetSpawnSource_NPCCatch(who), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, noBroadcast: false, 0, noGrabDelay: true);
+					*/
+					int itemWhoAmI = Item.NewItem(GetSpawnSource_NPCCatch(who, Main.npc[i]), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, true, 0, true, false);
+					
+					NetMessage.SendData(MessageID.SyncItem, -1, -1, null, itemWhoAmI, 1f); // NewItem above changed to noBroadcast, number2 is 1 for noGrabDelay effect.
+					
 					Main.npc[i].active = false;
 					NetMessage.SendData(23, -1, -1, null, i);
 				}
@@ -60013,7 +_,7 @@
 			if (Main.netMode == 1) {
 				NetMessage.SendData(71, -1, -1, null, x, y, Type, Style);
 			}
-			else if (Type >= 0 && Type < 688 && (Main.npcCatchable[Type] || who == Main.myPlayer) && CanReleaseNPCs(who)) {
+			else if (Type >= 0 && (Main.npcCatchable[Type] || who == Main.myPlayer) && CanReleaseNPCs(who)) {
 				switch (Type) {
 					case 583:
 					case 584:
@@ -60254,6 +_,7 @@
 			int num10;
 			int maxValue;
 			bool flag15;
+			NPCSpawnInfo spawnInfo = new NPCSpawnInfo();
 			while (true) {
 				if (num7 >= 255)
 					return;
@@ -60274,11 +_,13 @@
 						flag11 = false;
 						flag12 = false;
 						flag13 = false;
+						//patch file: flag14
 						flag14 = (downedPlantBoss && Main.hardMode);
 						isItAHappyWindyDay = Main.IsItAHappyWindyDay;
 						if (Main.player[num7].active && Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0 && ((double)Main.player[num7].position.Y < Main.worldSurface * 16.0 + (double)sHeight || Main.remixWorld)) {
 							int num8 = 3000;
 							if ((double)Main.player[num7].position.X > Main.invasionX * 16.0 - (double)num8 && (double)Main.player[num7].position.X < Main.invasionX * 16.0 + (double)num8) {
+								//patch file: flag6
 								flag6 = true;
 							}
 							else if (Main.invasionX >= (double)(Main.maxTilesX / 2 - 5) && Main.invasionX <= (double)(Main.maxTilesX / 2 + 5)) {
@@ -60294,14 +_,17 @@
 						}
 
 						if (Main.player[num7].ZoneTowerSolar || Main.player[num7].ZoneTowerNebula || Main.player[num7].ZoneTowerVortex || Main.player[num7].ZoneTowerStardust)
+							// Patch note: flag6 - Invasion.
 							flag6 = true;
 
 						num9 = (int)(Main.player[num7].position.X + (float)(Main.player[num7].width / 2)) / 16;
 						num10 = (int)(Main.player[num7].position.Y + (float)(Main.player[num7].height / 2)) / 16;
 						if (Main.wallHouse[Main.tile[num9, num10].wall])
+							//Patch note: flag5 - playerSafe
 							flag5 = true;
 
 						if (Main.tile[num9, num10].wall == 87)
+							//Patch note: flag4 - Lihzahrd
 							flag4 = true;
 
 						flag2 = false;
@@ -60660,12 +_,14 @@
 								}
 								else {
 									if (!Main.expertMode || Main.rand.Next(30) != 0)
+										// Patch note: flag12 - playerInTown??????????????? Pretty weird
 										flag12 = true;
 
 									maxSpawns = (int)((double)(float)maxSpawns * 0.6);
 								}
 							}
 						}
+						NPCLoader.EditSpawnRate(Main.player[num7], ref spawnRate, ref maxSpawns);
 
 						flag15 = false;
 						if (Main.player[num7].active && !Main.player[num7].dead && Main.player[num7].nearbyActiveNPCs < (float)maxSpawns && Main.rand.Next(spawnRate) == 0) {
@@ -60691,6 +_,7 @@
 								safeRangeY += (int)((double)(sHeight / 16) * 0.5 / (double)num12);
 							}
 
+							NPCLoader.EditSpawnRange(Main.player[num7], ref spawnRangeX, ref spawnRangeY, ref safeRangeX, ref safeRangeY);
 							int num13 = (int)(Main.player[num7].position.X / 16f) - spawnRangeX;
 							int num14 = (int)(Main.player[num7].position.X / 16f) + spawnRangeX;
 							int num15 = (int)(Main.player[num7].position.Y / 16f) - spawnRangeY;
@@ -60724,6 +_,7 @@
 										num2 = num22;
 										flag2 = true;
 										flag3 = true;
+										// Patch note: flag3 - Sky
 									}
 									else if (!flag6 && (double)num22 < Main.worldSurface * 0.44999998807907104 && !flag12 && Main.hardMode && Main.rand.Next(10) == 0) {
 										num3 = Main.tile[num21, num22].type;
@@ -60786,6 +_,7 @@
 										}
 
 										if (num >= num17 && num <= num18)
+											// Patch note: flag15 - safeRangeX
 											flag15 = true;
 									}
 								}
@@ -60815,17 +_,23 @@
 									flag2 = false;
 
 								if (Main.tile[num, num2 - 1].honey())
+									// Patch note: flag8 - Honey
 									flag8 = true;
 								else
+									// Patch note: flag7 - Water
 									flag7 = true;
 							}
 
 							int num29 = (int)Main.player[num7].Center.X / 16;
 							int num30 = (int)(Main.player[num7].Bottom.Y + 8f) / 16;
+							spawnInfo.PlayerFloorX = num29;
+							spawnInfo.PlayerFloorY = num30;
 							if (Main.tile[num, num2].type == 367) {
+								// Patch note: flag10 - marble
 								flag10 = true;
 							}
 							else if (Main.tile[num, num2].type == 368) {
+								// Patch note: flag9 - granite
 								flag9 = true;
 							}
 							else if (Main.tile[num29, num30].type == 367) {
@@ -60918,6 +_,7 @@
 						for (int num40 = num - num39; num40 < num + num39; num40++) {
 							for (int num41 = num2 - num39; num41 < num2 + num39; num41++) {
 								if (Main.tile[num40, num41].wall == 62)
+									// Patch note: flag11 - Spider wall
 									flag11 = true;
 							}
 						}
@@ -60938,6 +_,7 @@
 						for (int num45 = num - num44; num45 < num + num44; num45++) {
 							for (int num46 = num2 - num44; num46 < num2 + num44; num46++) {
 								if (WallID.Sets.Conversion.Sandstone[Main.tile[num45, num46].wall] || WallID.Sets.Conversion.HardenedSand[Main.tile[num45, num46].wall])
+									// Patch note: flag13 - Desert cave
 									flag13 = true;
 							}
 						}
@@ -60999,9 +_,35 @@
 			}
 
 			num49 = SpawnNPC_TryFindingProperGroundTileType(num49, num, num2);
+
+			spawnInfo.SpawnTileX = num;
+			spawnInfo.SpawnTileY = num2;
+			spawnInfo.SpawnTileType = num3;
+			spawnInfo.Player = Main.player[num7];
+			spawnInfo.Sky = flag3;
+			spawnInfo.Lihzahrd = flag4;
+			spawnInfo.PlayerSafe = flag5;
+			spawnInfo.Invasion = flag6;
+			spawnInfo.Water = flag7;
+			spawnInfo.Granite = flag9;
+			spawnInfo.Marble = flag10;
+			spawnInfo.SpiderCave = flag11;
+			spawnInfo.PlayerInTown = flag12;
+			spawnInfo.DesertCave = flag13;
+			spawnInfo.PlanteraDefeated = flag14;
+			spawnInfo.SafeRangeX = flag15;
+
 			int newNPC = 200;
 			int cattailX;
 			int cattailY;
+			int? spawnChoice = NPCLoader.ChooseSpawn(spawnInfo);
+			if (!spawnChoice.HasValue)
+				return;
+
+			int spawn = spawnChoice.Value;
+			if (spawn != 0)
+				goto endVanillaSpawn;
+
 			if (Main.player[num7].ZoneTowerNebula) {
 				bool flag24 = true;
 				int num51 = 0;
@@ -62986,7 +_,7 @@
 						int num109 = Main.rand.Next(7);
 						int num110 = 12;
 						int maxValue4 = 20;
-						if (Main.player[num7].statLifeMax <= 100) {
+						if (Main.player[num7].ConsumedLifeCrystals == 0) {
 							num110 = 5;
 							num110 -= Main.CurrentFrameFlags.ActivePlayersCount / 2;
 							if (num110 < 2)
@@ -63282,6 +_,11 @@
 				}
 			}
 
+			endVanillaSpawn:
+
+			if (spawn != 0)
+				newNPC = NPCLoader.SpawnNPC(spawn, num, num2);
+
 			if (Main.npc[newNPC].type == 1 && Main.player[num7].RollLuck(180) == 0)
 				Main.npc[newNPC].SetDefaults(-4);
 
@@ -64003,6 +_,20 @@
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[num].GetTypeNetName()), new Color(175, 75, 255));
 		}
 
+		/// <summary>
+		/// Spawns an NPC into the game world with the given type. This method should not be called on multiplayer clients. The X and Y parameters dictate the centered spawn position. ai0, ai1, ai2, and ai3 will initialize the NPC.ai[] array with the supplied values. This can be used to pass in information to the NPC. The NPC AI code will have to be written to utilize those values. Target can be set to a Player.whoAmI to have the NPC targetting a specific Player immediately on spawn. Start can be used to ensure that an NPC spawns in a slot after an existing NPC. This can be used to ensure that the spawned NPC draws behind an existing NPC. This is useful for bosses that spawn minions. The return value is the index of the spawned NPC within the <see cref="Main.npc"/> array. 
+		/// </summary>
+		/// <param name="source"></param>
+		/// <param name="X"></param>
+		/// <param name="Y"></param>
+		/// <param name="Type">Either an <see cref="NPCID"/> entry or <see cref="ModContent.NPCType{T}"/>, for example <see cref="NPCID.BabySlime"/> or ModContent.NPCType&lt;MyModNPC&gt;()</param>
+		/// <param name="Start"></param>
+		/// <param name="ai0"></param>
+		/// <param name="ai1"></param>
+		/// <param name="ai2"></param>
+		/// <param name="ai3"></param>
+		/// <param name="Target"></param>
+		/// <returns></returns>
 		public static int NewNPC(IEntitySource source, int X, int Y, int Type, int Start = 0, float ai0 = 0f, float ai1 = 0f, float ai2 = 0f, float ai3 = 0f, int Target = 255) {
 			if (Main.getGoodWorld && Main.rand.Next(3) != 0) {
 				if (Type == 46)
@@ -64013,7 +_,9 @@
 			}
 
 			int num = -1;
+
-			if (Type == 222 || Type == 245) {
+			//if (Type == 222 || Type == 245) {
+			if (Type >= 0 && NPCID.Sets.SpawnFromLastEmptySlot[Type]) {
 				for (int num2 = 199; num2 >= 0; num2--) {
 					if (!Main.npc[num2].active) {
 						num = num2;
@@ -64052,6 +_,8 @@
 						ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[num].GetTypeNetName()), new Color(175, 75, 255));
 				}
 
+				NPCLoader.OnSpawn(Main.npc[num], source);
+
 				return num;
 			}
 
@@ -64060,9 +_,9 @@
 
 		private static void GiveTownUniqueDataToNPCsThatNeedIt(int Type, int nextNPC) {
 			NPC nPC = Main.npc[nextNPC];
-			if (nPC.isLikeATownNPC) {
-				nPC.GivenName = getNewNPCName(Type);
-				if (TownNPCProfiles.Instance.GetProfile(Type, out ITownNPCProfile profile)) {
+			if (nPC.isLikeATownNPC || Type >= 0 && NPCID.Sets.SpawnsWithCustomName[Type]) {
+				nPC.GivenName = nPC.getNewNPCName();
+				if (TownNPCProfiles.Instance.GetProfile(nPC, out ITownNPCProfile profile)) {
 					nPC.townNpcVariationIndex = profile.RollVariation();
 					nPC.GivenName = profile.GetNameForVariant(nPC);
 				}
@@ -64325,12 +_,16 @@
 				return 0.0;
 
 			double num = Damage;
+			if (!NPCLoader.StrikeNPC(this, ref num, defense, ref knockBack, hitDirection, ref crit))
+				goto skipStrike;
+
 			num = Main.CalculateDamageNPCsTake((int)num, defense);
 			if (crit)
 				num *= 2.0;
 
 			if (takenDamageMultiplier > 1f)
 				num *= (double)takenDamageMultiplier;
+			skipStrike:
 
 			if ((takenDamageMultiplier > 1f || Damage != 9999) && lifeMax > 1) {
 				if (friendly) {
@@ -64607,7 +_,20 @@
 			}
 		}
 
+		public void HitEffect(int hitDirection = 0, double dmg = 10.0)
+			=> NPCLoader.HitEffect(this, hitDirection, dmg);
+
-		public void HitEffect(int hitDirection = 0, double dmg = 10.0) {
+		public void VanillaHitEffect(int hitDirection = 0, double dmg = 10.0) {
+			var usedSource = new EntitySource_HitEffect(this);
+
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaHitEffect_Inner(hitDirection, dmg);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaHitEffect_Inner(int hitDirection, double dmg) {
 			if (!active)
 				return;
 
@@ -71902,6 +_,9 @@
 			int num = -1;
 			for (int i = 0; i < 20; i++) {
 				if (buffType[i] == type) {
+					if (BuffLoader.ReApply(type, this, time, i))
+						return;
+
 					if (buffTime[i] < time)
 						buffTime[i] = time;
 
@@ -71937,7 +_,7 @@
 		}
 
 		public void RequestBuffRemoval(int buffTypeToRemove) {
-			if (buffTypeToRemove < 0 || buffTypeToRemove >= 355 || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
+			if (buffTypeToRemove < 0 || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
 				return;
 
 			int num = FindBuffIndex(buffTypeToRemove);
@@ -72118,9 +_,18 @@
 
 		public void UpdateNPC(int i) {
 			whoAmI = i;
+
 			if (!active)
 				return;
 
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			UpdateNPC_Inner(i);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void UpdateNPC_Inner(int i) {
 			if (offSetDelayTime > 0) {
 				netOffset *= 0f;
 			}
@@ -72134,7 +_,7 @@
 				if (NPCID.Sets.NoMultiplayerSmoothingByType[type]) {
 					netOffset *= 0f;
 				}
-				else if (NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
+				else if (aiStyle >= 0 && aiStyle < NPCLoader.NPCCount && NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
 					netOffset *= 0f;
 				}
 				else {
@@ -72185,6 +_,7 @@
 				bool flag = false;
 				int num4 = (int)(position.X + (float)(width / 2)) / 16;
 				int num5 = (int)(position.Y + (float)(height / 2)) / 16;
+				/*
 				try {
 					if (num4 >= 4 && num4 <= Main.maxTilesX - 4 && num5 >= 4 && num5 <= Main.maxTilesY - 4) {
 						if (Main.tile[num4, num5] == null)
@@ -72202,12 +_,14 @@
 				catch {
 					flag = true;
 				}
+				*/
 
-				if (flag)
+				if (!Main.sectionManager.TilesLoaded(num4 - 3, num5 - 3, num4 + 3, num5 + 3))
 					return;
 			}
 
 			UpdateNPC_BuffFlagsReset();
+			NPCLoader.ResetEffects(this);
 			UpdateNPC_BuffSetFlags();
 			UpdateNPC_SoulDrainDebuff();
 			UpdateNPC_BuffClearExpiredBuffs();
@@ -72443,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public IEntitySource GetItemSource_Misc(int itemSourceId) => new EntitySource_ByItemSourceId(this, itemSourceId);
 		public static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => new EntitySource_Parent(Main.player[whoReleasedIt]);
 		public static IEntitySource GetSpawnSource_NPCCatch(int whoCatchedIt) => new EntitySource_Parent(Main.player[whoCatchedIt]);
@@ -72453,6 +_,24 @@
 		public static IEntitySource GetSpawnSourceForTownSpawn() => new EntitySource_SpawnNPC();
 		public IEntitySource GetSpawnSourceForNPCFromNPCAI() => new EntitySource_Parent(this);
 		public IEntitySource GetItemSource_Loot() => new EntitySource_Loot(this);
+		*/
+
+		// Internal redirects:
+		internal static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => Main.player[whoReleasedIt].GetSource_ReleaseEntity();
+		internal static IEntitySource GetSpawnSource_NPCCatch(int whoCaughtIt, Entity caughtEntity) => Main.player[whoCaughtIt].GetSource_CatchEntity(caughtEntity);
+		internal static IEntitySource GetSpawnSourceForNaturalSpawn() => GetSource_NaturalSpawn();
+		internal static IEntitySource GetSpawnSourceForTownSpawn() => GetSource_TownSpawn();
+
+		internal IEntitySource GetItemSource_Misc(int itemSourceId) => GetSource_Misc(context: ItemSourceID.ToContextString(itemSourceId));
+		internal IEntitySource GetSpawnSource_NPCHurt() => new EntitySource_Parent(this);
+		internal IEntitySource GetSpawnSource_ForProjectile() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForProjectileNPC() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForNPCFromNPCAI() => GetSource_FromAI();
+		internal IEntitySource GetItemSource_Loot() => GetSource_Loot();
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   NPC.TML.Sources.cs (if exists);
 
 		private void UpdateNPC_UpdateTrails() {
 			int num = NPCID.Sets.TrailingMode[type];
@@ -73302,6 +_,7 @@
 					num = 5;
 			}
 
+			NPCLoader.UpdateLifeRegen(this, ref num);
 			if (lifeRegen <= -240 && num < 2)
 				num = 2;
 
@@ -73505,6 +_,8 @@
 					else
 						shimmering = true;
 				}
+				
+				BuffLoader.Update(buffType[i], this, ref i); // todo, move?
 			}
 		}
 
@@ -73752,7 +_,12 @@
 				if (acceptableNPCIDs[nPC.type] && nPC.active && !nPC.friendly && nPC.damage > 0) {
 					Rectangle npcRect = nPC.Hitbox;
 					GetMeleeCollisionData(hitbox, num, ref specialHitSetter, ref damageMultiplier, ref npcRect);
+					bool? modCanHit = NPCLoader.CanHitNPC(nPC, this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						continue;
+
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
-					if (hitbox.Intersects(npcRect) && (type != 453 || !NPCID.Sets.Skeletons[nPC.type]) && nPC.type != 624)
+					if (hitbox.Intersects(npcRect) && ((modCanHit == true) || type != 453 || !NPCID.Sets.Skeletons[nPC.type])&& nPC.type != 624)
 						break;
 				}
 
@@ -73768,14 +_,17 @@
 				num = 20;
 
 			int num2 = Main.DamageVar(thatNPC.damage);
-			int num3 = 6;
+			float num3 = 6;
 			int num4 = (!(thatNPC.Center.X > base.Center.X)) ? 1 : (-1);
-			double num5 = StrikeNPCNoInteraction(num2, num3, num4);
+			bool crit = false;
+			NPCLoader.ModifyHitNPC(thatNPC, this, ref num2, ref num3, ref crit);
+			double num5 = StrikeNPCNoInteraction(num2, num3, num4, crit, false, false);
 			if (Main.netMode != 0)
 				NetMessage.SendData(28, -1, -1, null, whoAmI, num2, num3, num4);
 
 			netUpdate = true;
 			immune[255] = num;
+			NPCLoader.OnHitNPC(thatNPC, this, (int)num5, num3, crit);
 			if (dryadWard) {
 				num2 = (int)num5 / 3;
 				num3 = 6;
@@ -74144,6 +_,10 @@
 		}
 
 		private bool Collision_DecideFallThroughPlatforms() {
+			bool? modResult = NPCLoader.CanFallThroughPlatforms(this);
+			if (modResult.HasValue)
+				return modResult.Value;
+
 			bool result = false;
 			if (type == 2 || type == -43 || type == 190 || type == 191 || type == 192 || type == 193 || type == 194 || type == 317 || type == 318 || type == 133)
 				result = true;
@@ -74510,6 +_,10 @@
 			if (IsABestiaryIconDummy)
 				newColor = Color.White;
 
+			Color? modColor = NPCLoader.GetAlpha(this, newColor);
+			if (modColor.HasValue)
+				return modColor.Value;
+
 			float num = (float)(255 - alpha) / 255f;
 			int num2 = (int)((float)(int)newColor.R * num);
 			int num3 = (int)((float)(int)newColor.G * num);
@@ -75169,7 +_,7 @@
 							break;
 					}
 				}
-				else if (Main.player[Main.myPlayer].statLifeMax < 300 || Main.player[Main.myPlayer].statDefense < 10) {
+				else if (Main.player[Main.myPlayer].ConsumedLifeCrystals < 10 || Main.player[Main.myPlayer].statDefense < 10) {
 					switch (Main.rand.Next(4)) {
 						case 0:
 							result = Lang.dialog(85);
@@ -76050,6 +_,7 @@
 				result = ((!HasSpecialEventText("Slime", out specialEventText)) ? Lang.SlimeChat(this) : specialEventText);
 			}
 
+			NPCLoader.GetChat(this, ref result);
 			return result;
 		}
 
