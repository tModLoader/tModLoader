--- src/Terraria/Terraria/NetMessage.cs
+++ src/tModLoader/Terraria/NetMessage.cs
@@ -1,4 +_,5 @@
 using Ionic.Zlib;
+using log4net.Core;
 using Microsoft.Xna.Framework;
 using Microsoft.Xna.Framework.Graphics.PackedVector;
 using System;
@@ -11,6 +_,8 @@
 using Terraria.ID;
 using Terraria.IO;
 using Terraria.Localization;
+using Terraria.ModLoader;
+using Terraria.ModLoader.IO;
 using Terraria.Social;
 
 namespace Terraria
@@ -50,7 +_,7 @@
 		}
 
 		public static MessageBuffer[] buffer = new MessageBuffer[257];
-		private static PlayerDeathReason _currentPlayerDeathReason;
+		public static PlayerDeathReason _currentPlayerDeathReason;
 		private static NetSoundInfo _currentNetSoundInfo;
 		private static CoinLossRevengeSystem.RevengeMarker _currentRevengeMarker;
 
@@ -76,6 +_,9 @@
 			if (Main.netMode == 2 && remoteClient >= 0)
 				num = remoteClient;
 
+			if (ModNet.HijackSendData(num, msgType, remoteClient, ignoreClient, text, number, number2, number3, number4, number5, number6, number7))
+				return;
+
 			lock (buffer[num]) {
 				BinaryWriter writer = buffer[num].writer;
 				if (writer == null) {
@@ -89,12 +_,12 @@
 				writer.Write((byte)msgType);
 				switch (msgType) {
 					case 1:
-						writer.Write("Terraria" + 238);
+						writer.Write(BuildInfo.versionedName);
 						break;
 					case 2:
 						text.Serialize(writer);
 						if (Main.dedServ)
-							Console.WriteLine(Language.GetTextValue("CLI.ClientWasBooted", Netplay.Clients[num].Socket.GetRemoteAddress().ToString(), text));
+							Logging.ServerConsoleLine(Language.GetTextValue("CLI.ClientWasBooted", Netplay.Clients[num].Socket.GetRemoteAddress().ToString(), text));
 						break;
 					case 3:
 						writer.Write((byte)remoteClient);
@@ -157,12 +_,14 @@
 
 							num8 = item5.stack;
 							num9 = item5.netID;
+							//Patch context.
 							if (num8 < 0)
 								num8 = 0;
 
 							writer.Write((short)num8);
 							writer.Write((byte)number3);
 							writer.Write((short)num9);
+							ItemIO.SendModData(item5, writer);
 							break;
 						}
 					case 7: {
@@ -303,12 +_,15 @@
 							writer.Write((short)WorldGen.SavedOreTiers.Mythril);
 							writer.Write((short)WorldGen.SavedOreTiers.Adamantite);
 							writer.Write((sbyte)Main.invasionType);
+
 							if (SocialAPI.Network != null)
 								writer.Write(SocialAPI.Network.GetLobbyId());
 							else
 								writer.Write(0uL);
 
 							writer.Write(Sandstorm.IntendedSeverity);
+							if (!ModNet.AllowVanillaClients)
+								WorldIO.SendModData(writer);
 							break;
 						}
 					case 8:
@@ -510,10 +_,12 @@
 							writer.Write(item7.prefix);
 							writer.Write((byte)number2);
 							short value5 = 0;
+							//Patch context just in case.
 							if (item7.active && item7.stack > 0)
 								value5 = (short)item7.netID;
 
 							writer.Write(value5);
+							ItemIO.SendModData(item7, writer);
 							break;
 						}
 					case 22:
@@ -583,9 +_,10 @@
 								}
 							}
 
-							if (nPC2.type >= 0 && nPC2.type < 668 && Main.npcCatchable[nPC2.type])
+							if (nPC2.type >= 0 && Main.npcCatchable[nPC2.type])
 								writer.Write((byte)nPC2.releaseOwner);
 
+							NPCLoader.SendExtraAI(nPC2, writer);
 							break;
 						}
 					case 24:
@@ -621,12 +_,13 @@
 							if (projectile.knockBack != 0f)
 								bb13[5] = true;
 
-							if (projectile.type > 0 && projectile.type < 956 && ProjectileID.Sets.NeedsUUID[projectile.type])
+							if (projectile.type > 0 && ProjectileID.Sets.NeedsUUID[projectile.type])
 								bb13[7] = true;
 
 							if (projectile.originalDamage != 0)
 								bb13[6] = true;
 
+							byte[] extraAI = ProjectileLoader.SendExtraAI(projectile, ref bb13);
 							writer.Write(bb13);
 							for (int num17 = 0; num17 < Projectile.maxAI; num17++) {
 								if (bb13[num17])
@@ -648,11 +_,19 @@
 							if (bb13[7])
 								writer.Write((short)projectile.projUUID);
 
+							if (bb13[Projectile.maxAI + 1]) {
+								writer.Write((byte)extraAI.Length);
+								writer.Write(extraAI);
+							}
+
 							break;
 						}
 					case 28:
 						writer.Write((short)number);
+						if (ModNet.AllowVanillaClients)
-						writer.Write((short)number2);
+							writer.Write((short)number2);
+						else
+							writer.Write((int)number2);
 						writer.Write(number3);
 						writer.Write((byte)(number4 + 1f));
 						writer.Write((byte)number5);
@@ -680,6 +_,7 @@
 							writer.Write((short)item6.stack);
 							writer.Write(item6.prefix);
 							writer.Write(value2);
+							ItemIO.SendModData(item6, writer);
 							break;
 						}
 					case 33: {
@@ -723,6 +_,8 @@
 						else {
 							writer.Write((short)0);
 						}
+						if (number >= 100)
+							writer.Write((ushort)number6);
 						break;
 					case 35:
 						writer.Write((byte)number);
@@ -735,6 +_,9 @@
 							writer.Write(player3.zone2);
 							writer.Write(player3.zone3);
 							writer.Write(player3.zone4);
+							if (!ModNet.AllowVanillaClients)
+								BiomeLoader.SendCustomBiomes(player3, writer);
+
 							break;
 						}
 					case 38:
@@ -787,7 +_,7 @@
 						}
 					case 50: {
 							writer.Write((byte)number);
-							for (int n = 0; n < 22; n++) {
+							for (int n = 0; n < Player.MaxBuffs; n++) {
 								writer.Write((ushort)Main.player[number].buffType[n]);
 							}
 
@@ -996,7 +_,7 @@
 							bool flag3 = TileEntity.ByID.ContainsKey(number);
 							writer.Write(flag3);
 							if (flag3)
-								TileEntity.Write(writer, TileEntity.ByID[number], networkSend: true);
+								TileEntity.Write(writer, TileEntity.ByID[number], networkSend: true, lightSend: true); //TML: Made lightSend true.
 
 							break;
 						}
@@ -1336,7 +_,10 @@
 
 				int num26 = (int)writer.BaseStream.Position;
 				writer.BaseStream.Position = position;
+				// TODO: Make this int or some other solution. This used to be cast to short. NetMessage.CheckBytes reads ushort though, so changing this is fine. We want to allow for more data primarily because writing tile
+				// chunks can go more than 32767 (and even 65535) bytes. This is because ModTileEntities can have large amounts of data especially when they sync Items and instanced GlobalItem classes are in play.
+				// Complications include AllowVanillaClients, message length byte length negotiation, and MessageBuffer.readBuffer having a fixed size.
-				writer.Write((short)num26);
+				writer.Write((ushort)num26);
 				writer.BaseStream.Position = num26;
 				if (Main.netMode == 1) {
 					if (Netplay.Connection.Socket.IsConnected()) {
@@ -1654,7 +_,7 @@
 							}
 						}
 
-						if (tile2.type == 88 && tile2.frameX % 54 == 0 && tile2.frameY % 36 == 0) {
+						if (TileID.Sets.BasicDresser[tile2.type] && tile2.frameX % 54 == 0 && tile2.frameY % 36 == 0) {
 							short num8 = (short)Chest.FindChest(j, i);
 							if (num8 != -1) {
 								array[num] = num8;
@@ -1674,7 +_,7 @@
 								array2[num2++] = num10;
 						}
 
-						if (tile2.type == 425 && tile2.frameX % 36 == 0 && tile2.frameY % 36 == 0) {
+						if ((tile2.type == 425 || tile2.type >= TileID.Count && Main.tileSign[tile2.type]) && tile2.frameX % 36 == 0 && tile2.frameY % 36 == 0) {
 							short num11 = (short)Sign.ReadSign(j, i);
 							if (num11 != -1)
 								array2[num2++] = num11;
@@ -1839,9 +_,17 @@
 				writer.Write(sign.text);
 			}
 
+			foreach (var item in TileEntity.ByPosition) {
+				Point16 pos = item.Key;
+				if (pos.X >= xStart && pos.X < xStart + width && pos.Y >= yStart && pos.Y < yStart + height) {
+					if (item.Value.type > 2)
+						array3[num3++] = (short)item.Value.ID;
+				}
+			}
+
 			writer.Write(num3);
 			for (int m = 0; m < num3; m++) {
-				TileEntity.Write(writer, TileEntity.ByID[array3[m]]);
+				TileEntity.Write(writer, TileEntity.ByID[array3[m]], networkSend: true); //TML: Made networkSend true, but lightSend should be false.
 			}
 		}
 
@@ -2037,7 +_,7 @@
 
 			num3 = reader.ReadInt16();
 			for (int m = 0; m < num3; m++) {
-				TileEntity tileEntity = TileEntity.Read(reader);
+				TileEntity tileEntity = TileEntity.Read(reader, networkSend: true); //TML: Made networkSend true, but lightSend should be false.
 				TileEntity.ByID[tileEntity.ID] = tileEntity;
 				TileEntity.ByPosition[tileEntity.Position] = tileEntity;
 			}
@@ -2050,10 +_,11 @@
 					buffer[i].totalData += streamLength;
 					buffer[i].checkBytes = true;
 				}
-				catch {
+				catch (Exception e) {
 					if (Main.netMode == 1) {
 						Main.menuMode = 15;
 						Main.statusText = Language.GetTextValue("Error.BadHeaderBufferOverflow");
+						Logging.Terraria.Error(Main.statusText, e);
 						Netplay.Disconnect = true;
 					}
 					else {
@@ -2097,7 +_,7 @@
 				}
 				catch (Exception) {
 					if (Main.dedServ && num < NetMessage.buffer.Length - 100)
-						Console.WriteLine("Error on message " + NetMessage.buffer[num + 2]);
+						Logging.ServerConsoleLine("Error on message " + NetMessage.buffer[num + 2], Level.Warn);
 
 					num2 = 0;
 					num = 0;
@@ -2307,8 +_,10 @@
 			}
 
 			if (!flag) {
-				Console.WriteLine(Language.GetTextValue("Net.ServerAutoShutdown"));
+				Logging.ServerConsoleLine(Language.GetTextValue("Net.ServerAutoShutdown"));
 				WorldFile.SaveWorld();
+				SystemLoader.OnWorldUnload();
+				TileIO.PostExitWorldCleanup();
 				Netplay.Disconnect = true;
 			}
 		}
@@ -2358,11 +_,12 @@
 					SendData(5, toWho, fromWho, null, plr, 94 + m, (int)Main.player[plr].miscDyes[m].prefix);
 				}
 
+				PlayerLoader.SyncPlayer(Main.player[plr], toWho, fromWho, false);
 				if (!Netplay.Clients[plr].IsAnnouncementCompleted) {
 					Netplay.Clients[plr].IsAnnouncementCompleted = true;
 					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.mp[19].Key, Main.player[plr].name), new Color(255, 240, 20), plr);
 					if (Main.dedServ)
-						Console.WriteLine(Lang.mp[19].Format(Main.player[plr].name));
+						Logging.ServerConsoleLine(Lang.mp[19].Format(Main.player[plr].name));
 				}
 
 				return;
@@ -2374,7 +_,7 @@
 				Netplay.Clients[plr].IsAnnouncementCompleted = false;
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.mp[20].Key, Netplay.Clients[plr].Name), new Color(255, 240, 20), plr);
 				if (Main.dedServ)
-					Console.WriteLine(Lang.mp[20].Format(Netplay.Clients[plr].Name));
+					Logging.ServerConsoleLine(Lang.mp[20].Format(Netplay.Clients[plr].Name));
 
 				Netplay.Clients[plr].Name = "Anonymous";
 			}
