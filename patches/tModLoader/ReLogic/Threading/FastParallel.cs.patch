--- src/TerrariaNetCore/ReLogic/Threading/FastParallel.cs
+++ src/tModLoader/ReLogic/Threading/FastParallel.cs
@@ -22,12 +_,25 @@
 			}
 
 			public void Invoke() {
+				/*
 				if (_fromInclusive != _toExclusive)
 					_action(_fromInclusive, _toExclusive, _context);
 
 				_countdown.Signal();
+				*/
+
+				//TML: Included this try finally block to prevent barely debuggable freezes.
+				try {
+					if (_fromInclusive != _toExclusive)
+						_action(_fromInclusive, _toExclusive, _context);
+				}
+				finally {
+					_countdown.Signal();
+				}
 			}
 		}
+		
+		private static bool skipPrioritySetAttempts; // Added by TML.
 
 		public static bool ForceTasksOnCallingThread {
 			get;
@@ -48,7 +_,13 @@
 				num2 = 1;
 
 			ThreadPriority priority = Thread.CurrentThread.Priority;
+			
+			/*
 			Thread.CurrentThread.Priority = ThreadPriority.Highest;
+			*/
+			
+			TrySetThreadPriority(Thread.CurrentThread, ThreadPriority.Highest);
+			
 			int num3 = num / num2;
 			int num4 = num % num2;
 			CountdownEvent countdownEvent = new CountdownEvent(num2);
@@ -68,14 +_,35 @@
 					ThreadPool.QueueUserWorkItem(InvokeTask, rangeTask);
 			}
 
-			while (countdownEvent.CurrentCount != 0) {
+			
+			if (!countdownEvent.Wait(10000)) { // #2659, throw an exception instead of freezing the process forever.
+				ThreadPool.GetAvailableThreads(out int workerThreads, out _);
+				throw new Exception($"Fatal Deadlock in FastParallelFor. pending: {ThreadPool.PendingWorkItemCount}. avail: {workerThreads}");
 			}
 
+			/*
 			Thread.CurrentThread.Priority = priority;
+			*/
+
+			TrySetThreadPriority(Thread.CurrentThread, priority);
 		}
 
 		private static void InvokeTask(object context) {
 			((RangeTask)context).Invoke();
+		}
+		
+		// Added by TML.
+		// A workaround for a (Mac-specific?) issue with thread priority setting throwing 'ThreadStateException: Unable to set thread priority.'.
+		private static void TrySetThreadPriority(Thread thread, ThreadPriority priority) {
+			if (skipPrioritySetAttempts)
+				return;
+
+			try {
+				thread.Priority = priority;
+			}
+			catch {
+				skipPrioritySetAttempts = true;
+			}
 		}
 	}
 }
