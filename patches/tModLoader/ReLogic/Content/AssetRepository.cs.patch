--- src/TerrariaNetCore/ReLogic/Content/AssetRepository.cs
+++ src/tModLoader/ReLogic/Content/AssetRepository.cs
@@ -5,26 +_,41 @@
 
 namespace ReLogic.Content;
 
+// See AssetRepository.TML.cs for most of the code and explanations.
-public class AssetRepository : IAssetRepository, IDisposable
+public partial class AssetRepository : IAssetRepository, IDisposable
 {
+	/*
 	private readonly Dictionary<string, IAsset> _assets = new Dictionary<string, IAsset>();
 	private IEnumerable<IContentSource> _sources = new IContentSource[0];
+	*/
+	protected readonly Dictionary<string, IAsset> _assets = new Dictionary<string, IAsset>();
+	protected IContentSource[] _sources { get; private set; }
+
 	private readonly Dictionary<Type, Action<IAsset, AssetRequestMode>> _typeSpecificReloadActions = new Dictionary<Type, Action<IAsset, AssetRequestMode>>();
+	/*
 	private readonly IAsyncAssetLoader _asyncLoader;
 	private readonly IAssetLoader _loader;
+	*/
 	private readonly object _requestLock = new object();
 	private bool _isDisposed;
 
+	/*
 	public int PendingAssets => _asyncLoader.Remaining;
+	*/
+	public int PendingAssets => _Remaining;
 
 	public int TotalAssets { get; private set; }
 
 	public int LoadedAssets { get; private set; }
 
+	/*
 	public bool IsAsyncLoadingEnabled => _asyncLoader.IsRunning;
+	*/
+	public bool IsAsyncLoadingEnabled => true;
 
 	public FailedToLoadAssetCustomAction AssetLoadFailHandler { get; set; }
 
+	/*
 	public AssetRepository(IAssetLoader syncLoader, IAsyncAssetLoader asyncLoader)
 	{
 		_loader = syncLoader;
@@ -52,13 +_,31 @@
 			ReloadAssetsIfSourceChanged(mode);
 		}
 	}
+	*/
 
+	// New overload to change the default parameter of 'mode' from Immediate to Async for modders, but not the base game.
+	internal Asset<T> Request<T>(string assetName) where T : class
+		=> Request<T>(assetName, AssetRequestMode.ImmediateLoad);
+
+	/*
 	public Asset<T> Request<T>(string assetName, AssetRequestMode mode = AssetRequestMode.ImmediateLoad) where T : class
+	*/
+	public virtual Asset<T> Request<T>(string assetName, AssetRequestMode mode = AssetRequestMode.AsyncLoad) where T : class
 	{
+		// Skip loading assets if this is a dedicated server
+		if (_readers == null)
+			mode = AssetRequestMode.DoNotLoad;
+
 		ThrowIfDisposed();
 		assetName = AssetPathHelper.CleanPath(assetName);
+
+		Asset<T> asset = null;
+
+		// Asset states can't change while this lock is held
 		lock (_requestLock) {
+			/*
 			Asset<T> asset = null;
+			*/
 			if (_assets.TryGetValue(assetName, out var value))
 				asset = value as Asset<T>;
 
@@ -66,20 +_,44 @@
 				asset = new Asset<T>(assetName);
 				_assets[assetName] = asset;
 			}
+			/*
 			else if (asset.State != 0) {
 				return asset;
 			}
+			*/
 
+			// Only load the asset if it's not already loaded.
+			if (asset.State == AssetState.NotLoaded) {
+				EnsureReloadActionExistsForType<T>();
+				LoadAsset(asset, mode);
+			}
+
+			/*
 			LoadAsset(asset, mode);
 			return asset;
+			*/
 		}
+
+		if (mode == AssetRequestMode.ImmediateLoad)
+			asset.Wait();
+
+		return asset;
 	}
 
+	//TODO: Allow partial transfers.
 	public void TransferCompletedAssets()
 	{
 		ThrowIfDisposed();
+		ThrowIfNotMainThread();
+
 		lock (_requestLock) {
+			/*
 			_asyncLoader.TransferCompleted();
+			*/
+
+			while (_assetTransferQueue.TryDequeue(out var action)) {
+				action();
+			}
 		}
 	}
 
@@ -87,10 +_,14 @@
 	{
 		foreach (IAsset item in _assets.Values.Where((IAsset asset) => asset.IsLoaded)) {
 			IContentSource contentSource = FindSourceForAsset(item.Name);
+
 			if (contentSource == null)
 				ForceReloadAsset(item, AssetRequestMode.DoNotLoad);
 			else if (item.Source != contentSource)
+				/*
 				ForceReloadAsset(item, (item.State != 0) ? mode : AssetRequestMode.DoNotLoad);
+				*/
+				ForceReloadAsset(item, mode);
 		}
 	}
 
@@ -99,20 +_,31 @@
 		if (mode == AssetRequestMode.DoNotLoad)
 			return;
 
+		/*
 		EnsureReloadActionExistsForType<T>();
 		TotalAssets++;
 		asset.SetToLoadingState();
+		*/
+
+		var loadTask = LoadAssetWithPotentialAsync(asset, mode);
+
+		asset.Wait = () => SafelyWaitForLoad(asset, loadTask, tracked: true);
+
+		/*
 		try {
 			TryLoadingAsset(asset, mode);
 		}
 		catch (Exception e) {
+			// Extra patch context.
 			if (AssetLoadFailHandler != null)
 				AssetLoadFailHandler(asset.Name, e);
 
 			throw;
 		}
+		*/
 	}
 
+	/*
 	private void TryLoadingAsset<T>(Asset<T> asset, AssetRequestMode mode) where T : class
 	{
 		IContentSource source = FindSourceForAsset(asset.Name);
@@ -162,17 +_,21 @@
 							TryLoadingAsset(asset, mode);
 						}
 					}
+					// Extra patch context.
 				});
 				break;
 			default:
 				throw new ArgumentOutOfRangeException("mode", mode, null);
 		}
 	}
+	*/
 
 	private void ForceReloadAsset(IAsset asset, AssetRequestMode mode)
 	{
+		/*
 		if (mode != 0)
 			LoadedAssets--;
+		*/
 
 		_typeSpecificReloadActions[asset.GetType()](asset, mode);
 	}
@@ -185,11 +_,21 @@
 	private void ForceReloadAsset<T>(IAsset asset, AssetRequestMode mode) where T : class
 	{
 		Asset<T> asset2 = (Asset<T>)asset;
+
+		// Reduce loaded asset count
+		if (asset.IsLoaded)
+			LoadedAssets--;
+
+		// Reduce total active asset count
+		if (asset.State != AssetState.NotLoaded)
+			TotalAssets--;
+
 		asset2.Unload();
 		LoadAsset(asset2, mode);
 	}
 
+	//TML: Made protected instead of private.
-	private IContentSource FindSourceForAsset(string assetName) => _sources.FirstOrDefault((IContentSource source) => source.HasAsset(assetName)) ?? throw AssetLoadException.FromMissingAsset(assetName);
+	protected IContentSource FindSourceForAsset(string assetName) => _sources.FirstOrDefault((IContentSource source) => source.HasAsset(assetName)) ?? throw AssetLoadException.FromMissingAsset(assetName);
 
 	private void ThrowIfDisposed()
 	{
@@ -203,7 +_,10 @@
 			return;
 
 		if (disposing) {
+			/*
 			_asyncLoader.Dispose();
+			*/
+
 			foreach (KeyValuePair<string, IAsset> asset in _assets) {
 				asset.Value.Dispose();
 			}
@@ -214,6 +_,14 @@
 
 	public void Dispose()
 	{
+		if (!IsMainThread) {
+			Invoke(Dispose);
+			return;
+		}
+
+		GC.SuppressFinalize(this);
+
 		Dispose(disposing: true);
 	}
 }
+
