using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Tomlyn;
using Tomlyn.Syntax;

namespace tModLoader.Analyzers.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class BuiltinDataGenerator : IIncrementalGenerator
{
	private sealed record class DataModel(
		in EquatableString Name,
		in EquatableArray<DataContent> Contents
	);

	private readonly record struct DataContent(
		EquatableString MetadataName,
		EquatableString MemberName,
		QuestionableParameter ParameterNameOrIndex,
		EquatableString IdClassMetadataName
	);

	private readonly record struct QuestionableParameter(
		in bool Exists,
		in EquatableString Name,
		in int Index
	);

	public void Initialize(IncrementalGeneratorInitializationContext ctx)
	{
		var files = ctx.AdditionalTextsProvider
			.Select(static (text, token) => {
				string name = Path.GetFileNameWithoutExtension(text.Path);
				string extension = Path.GetExtension(text.Path);

				if (name is not "BuiltinData" || extension is not ".toml")
					return null;

				string contentText = text.GetText(token)?.ToString();
				if (contentText == null)
					return null;

				return GetDataModel(text, contentText, token);
			})
			.Where(static value => value is not null);

		ctx.RegisterSourceOutput(files, static (ctx, source) => {
			ctx.AddSource($"{source.Name}.g.cs", SourceText.From(GenerateSource(source), Encoding.UTF8));
		});

		static string GenerateSource(DataModel source)
		{
			var w = new IndentedStringBuilder();

			w.WriteLine("// <auto-generated/>");

			w.WriteLine("namespace tModLoader.Analyzers.ChangeMagicNumberToID;");

			w.WriteLine("partial class BuiltinData");

			using (w.DoScope()) {
				w.WriteLine("static BuiltinData()");

				using (w.DoScope()) {
					foreach (var content in source.Contents) {
						w.Write("data[new Key(");

						// Constructor parameters for key
						w.Write($"\"{content.MetadataName}\"");
						w.Write($", \"{content.MemberName}\"");

						if (content.ParameterNameOrIndex.Exists) {
							if (content.ParameterNameOrIndex.Name != null) {
								w.Write($", \"{content.ParameterNameOrIndex.Name}\"");
							}
							else {
								w.Write($", {content.ParameterNameOrIndex.Index}");
							}
						}

						w.Write($")] = new Entry(\"{content.IdClassMetadataName}\");");
						w.WriteLine();
					}
				}
			}

			return w.ToString();
		}
	}

	private static DataModel GetDataModel(AdditionalText text, string contents, CancellationToken cancellationToken)
	{
		string name = Path.GetFileNameWithoutExtension(text.Path);

		var document = Toml.Parse(contents, options: TomlParserOptions.ParseOnly);
		var dataContents = new List<DataContent>();

		foreach (var table in document.Tables) {
			cancellationToken.ThrowIfCancellationRequested();

			string tableName = GetTableText(table.Name);

			foreach (var item in table.Items) {
				cancellationToken.ThrowIfCancellationRequested();

				GetItemText(item.Key, out string memberName, out var parameter);

				string itemValueName = GetItemValue(item.Value);

				dataContents.Add(new DataContent(
					MetadataName: tableName,
					MemberName: memberName,
					ParameterNameOrIndex: parameter,
					IdClassMetadataName: itemValueName
					));
			}
		}

		return new DataModel(name, dataContents.ToImmutableArray());
	}

	private static string GetTableText(KeySyntax syntax)
	{
		// 'Foo.Bar'
		if (syntax is { Key: StringValueSyntax stringValueSyntax }) {
			return stringValueSyntax.Value;
		}
		// Foo
		// Foo.Bar
		// Foo.'Bar'
		else if (syntax is { Key: BareKeySyntax bareKeySyntax }) {
			if (syntax.DotKeys.ChildrenCount > 0) {
				var dotNamedKeys = syntax.DotKeys.Select(static syntax => {
					if (syntax.Key is StringValueSyntax stringValueSyntax) {
						return stringValueSyntax.Value;
					}
					else if (syntax.Key is BareKeySyntax bareKeySyntax) {
						return bareKeySyntax.Key.Text;
					}

					throw new NotSupportedException();
				});

				return $"{bareKeySyntax.Key.Text}.{string.Join(".", dotNamedKeys)}";
			}

			return bareKeySyntax.Key.Text;
		}

		throw new NotSupportedException();
	}

	private static void GetItemText(KeySyntax syntax, out string memberName, out QuestionableParameter parameter)
	{
		memberName = default;
		parameter = default;

		if (syntax.DotKeys.ChildrenCount == 1) {
			string parameterPotentialName = ((BareKeySyntax)syntax.DotKeys.GetChild(0).Key).Key.Text;

			if (int.TryParse(parameterPotentialName, out int parameterIndex)) {
				parameter = new(true, default, parameterIndex);
			}
			else {
				parameter = new(true, parameterPotentialName, default);
			}
		}

		if (syntax is { Key: BareKeySyntax bareKeySyntax }) {
			memberName = bareKeySyntax.Key.Text;
			return;
		}
		else if (syntax is { Key: StringValueSyntax stringValueSyntax }) {
			memberName = stringValueSyntax.Value;
			return;
		}

		throw new NotSupportedException();
	}

	private static string GetItemValue(ValueSyntax syntax)
	{
		if (syntax is StringValueSyntax stringValueSyntax) {
			string value = stringValueSyntax.Value
				.Replace('.', '+') // Nested types use '+' instead of '.' in metadata
				;

			if (!value.StartsWith("Terraria")) {
				if (value.StartsWith("EmoteID")) {
					value = "Terraria.GameContent.UI." + value;
				}
				else {
					value = "Terraria.ID." + value;
				}
			}

			return value;
		}

		throw new NotSupportedException();
	}
}
